<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Vectorizable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.backend.standard.operations.linear.internal.operation.matrix</a> &gt; <span class="el_source">Vectorizable.java</span></div><h1>Vectorizable.java</h1><pre class="source lang-java linenums">/*&lt;#LICENSE#&gt;*/
package neureka.backend.standard.operations.linear.internal.operation.matrix;

import neureka.backend.standard.operations.linear.internal.Conf;
import neureka.backend.standard.operations.linear.internal.operation.array.AXPY;
import neureka.backend.standard.operations.linear.internal.operation.array.DOT;
import neureka.devices.host.CPU;

/**
 *  A collection of primitive operations performed on arrays
 *  which are designed so that they can be vectorized by the
 *  JVMs JIT compiler (AVX instructions).
 */
<span class="nc" id="L14">public class Vectorizable {</span>

    @FunctionalInterface
    public interface VectorOperationF32 {
        void invoke(
                float[] product,
                float[] left,
                int complexity,
                float[] right
        );
    }

    @FunctionalInterface
    public interface VectorOperationF64 {
        void invoke(
                double[] product,
                double[] left,
                int complexity,
                double[] right
        );
    }

    public static VectorOperationF32 operationForF32(final long rows, final long columns)
    {
<span class="pc bpc" id="L38" title="1 of 4 branches missed.">        if ( rows &gt; CPU.PARALLELIZATION_THRESHOLD &amp;&amp; columns &gt; CPU.PARALLELIZATION_THRESHOLD) {</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">            return ( Conf.ROW_MAJOR</span>
<span class="fc" id="L40">                    ? Vectorizable::threaded_F32_MxN_RM</span>
<span class="fc" id="L41">                    : Vectorizable::threaded_F32_MxN_CM</span>
                );
        }
<span class="fc bfc" id="L44" title="All 2 branches covered.">        if ( columns == 1 ) {</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">            return ( Conf.ROW_MAJOR</span>
<span class="fc" id="L46">                    ? Vectorizable::full_F32_Mx1_RM</span>
<span class="fc" id="L47">                    : Vectorizable::full_F32_Mx1_CM</span>
                );
        }
<span class="fc bfc" id="L50" title="All 2 branches covered.">        if ( rows == 1 )</span>
<span class="fc" id="L51">            return (</span>
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">                    Conf.ROW_MAJOR</span>
<span class="nc" id="L53">                            ? Vectorizable::full_F32_1xN_RM</span>
<span class="fc" id="L54">                            : Vectorizable::full_F32_1xN_CM</span>
            );
<span class="fc" id="L56">        return (</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">                Conf.ROW_MAJOR</span>
<span class="fc" id="L58">                        ? Vectorizable::full_F32_MxN_RM</span>
<span class="fc" id="L59">                        : Vectorizable::full_F32_MxN_CM</span>
            );
    }

    public static VectorOperationF64 operationForF64(final long rows, final long columns)
    {
<span class="pc bpc" id="L65" title="1 of 4 branches missed.">        if ( rows &gt; CPU.PARALLELIZATION_THRESHOLD &amp;&amp; columns &gt; CPU.PARALLELIZATION_THRESHOLD )</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            return ( Conf.ROW_MAJOR</span>
<span class="fc" id="L67">                ? Vectorizable::threaded_F64_MxN_RM</span>
<span class="fc" id="L68">                : Vectorizable::threaded_F64_MxN_CM</span>
            );

<span class="fc bfc" id="L71" title="All 2 branches covered.">        if ( !Conf.ROW_MAJOR ) { // Supported in column major only!</span>
<span class="fc bfc" id="L72" title="All 4 branches covered.">            if (rows == 5 &amp;&amp; columns == 5) return Vectorizable::full_F64_5x5_CM;</span>
<span class="fc bfc" id="L73" title="All 4 branches covered.">            if (rows == 4 &amp;&amp; columns == 4) return Vectorizable::full_F64_4x4_CM;</span>
<span class="fc bfc" id="L74" title="All 4 branches covered.">            if (rows == 3 &amp;&amp; columns == 3) return Vectorizable::full_F64_3x3_CM;</span>
<span class="fc bfc" id="L75" title="All 4 branches covered.">            if (rows == 2 &amp;&amp; columns == 2) return Vectorizable::full_F64_2x2_CM;</span>
<span class="fc bfc" id="L76" title="All 4 branches covered.">            if (rows == 1 &amp;&amp; columns == 1) return Vectorizable::full_F64_1x1_CM;</span>
        }
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if ( columns == 1 )</span>
<span class="fc" id="L79">            return (</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">                Conf.ROW_MAJOR</span>
<span class="fc" id="L81">                    ? Vectorizable::full_F64_Mx1_RM</span>
<span class="fc" id="L82">                    : Vectorizable::full_F64_Mx1_CM</span>
            );

<span class="fc bfc" id="L85" title="All 2 branches covered.">        if ( !Conf.ROW_MAJOR ) { // Supported in column major only!</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            if ( rows == 10) return Vectorizable::full_F64_0xN_CM;</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            if ( rows == 9 ) return Vectorizable::full_F64_9xN_CM;</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">            if ( rows == 8 ) return Vectorizable::full_F64_8xN_CM;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">            if ( rows == 7 ) return Vectorizable::full_F64_7xN_CM;</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if ( rows == 6 ) return Vectorizable::full_F64_6xN_CM;</span>
        }
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if ( rows == 1 )</span>
<span class="fc" id="L93">            return (</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">                    Conf.ROW_MAJOR</span>
<span class="fc" id="L95">                            ? Vectorizable::full_F64_1xN_RM</span>
<span class="fc" id="L96">                            : Vectorizable::full_F64_1xN_CM</span>
                );

<span class="fc" id="L99">        return (</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">                Conf.ROW_MAJOR</span>
<span class="fc" id="L101">                        ? Vectorizable::full_F64_MxN_RM</span>
<span class="fc" id="L102">                        : Vectorizable::full_F64_MxN_CM</span>
            );
    }

    static void full_F64_Mx1_CM(
            final double[] product,
            final double[] left,
            final int colCount,
            final double[] right
    ) {
<span class="fc" id="L112">        int rowCount = product.length;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        for ( int c = 0; c &lt; colCount; c++ ) {</span>
<span class="fc" id="L114">            AXPY.invoke(</span>
                    product,
                    0,
                    right[c],
                    left,
                    c * rowCount,
                    0,
                    rowCount
            );
        }
<span class="fc" id="L124">    }</span>

    static void full_F64_Mx1_RM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L132">        int colCount = right.length;</span>
<span class="fc" id="L133">        int leftRowCount = left.length / complexity;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (int ri = 0; ri &lt; leftRowCount; ri++) {</span>
<span class="fc" id="L135">            product[ri] =</span>
<span class="fc" id="L136">                 DOT.invoke(</span>
                         left,
                         ri * complexity,
                         right,
                         0,
                         0,
                         colCount
                 );
        }
<span class="fc" id="L145">    }</span>

    static void full_F32_Mx1_CM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L153">        int nbRows = product.length;</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L156">            AXPY.invoke(</span>
                    product,
                    0,
                    right[c],
                    left,
                    c * nbRows,
                    0, nbRows
            );
        }
<span class="fc" id="L165">    }</span>

    static void full_F32_Mx1_RM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L173">            int colCount = right.length;</span>
<span class="fc" id="L174">            int leftRowCount = left.length / complexity;</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            for (int ri = 0; ri &lt; leftRowCount; ri++) {</span>
<span class="fc" id="L176">                product[ri] =</span>
<span class="fc" id="L177">                        DOT.invoke(</span>
                                left,
                                ri * complexity,
                                right,
                                0,
                                0,
                                colCount
                        );
            }
<span class="fc" id="L186">    }</span>

    static void partial_F64_MxN_CM(
            final double[] product,
            final int firstColumn,
            final int columnLimit,
            final double[] left,
            final int commonColumnCount,
            final double[] right
    ) {
<span class="fc" id="L196">        int leftRowCount = left.length / commonColumnCount;</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">        for (int ci = 0; ci &lt; commonColumnCount; ci++) {</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">            for (int j = firstColumn; j &lt; columnLimit; j++) {</span>
<span class="fc" id="L200">                AXPY.invoke(</span>
                        product,
                        j * leftRowCount,
                        right[ci + j * commonColumnCount],
                        left,
                        ci * leftRowCount,
                        0,
                        leftRowCount
                );
            }
        }
<span class="fc" id="L211">    }</span>

    static void partial_F64_MxN_RM(
        final double[] product,
        final int firstRow,
        final int rowLimit,
        final double[] left,
        final int complexity,
        final double[] right
    ) {
<span class="fc" id="L221">        int rightCols = right.length / complexity;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            for (int j = firstRow; j &lt; rowLimit; j++) {</span>
<span class="fc" id="L224">                AXPY.invoke(</span>
                        product,
                        j * rightCols,
                        left[c + j * complexity],
                        right,
                        c * rightCols,
                        0,
                        rightCols
                );
            }
        }
<span class="fc" id="L235">    }</span>

    static void partial_F32_MxN_CM(
            final float[] product,
            final int firstColumn, // right column
            final int columnLimit,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L245">        int nbRows = left.length / complexity;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            for (int j = firstColumn; j &lt; columnLimit; j++) {</span>
<span class="fc" id="L248">                AXPY.invoke(</span>
                        product,
                        j * nbRows,
                        right[c + j * complexity],
                        left,
                        c * nbRows,
                        0,
                        nbRows
                );
            }
        }
<span class="fc" id="L259">    }</span>

    static void partial_F32_MxN_RM(
                                    final float[] product,
                                    final int firstRow, // left row
                                    final int rowLimit,
                                    final float[] left,
                                    final int complexity,
                                    final float[] right
    ) {
<span class="fc" id="L269">        int rightCols = right.length / complexity;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            for (int j = firstRow; j &lt; rowLimit; j++) {</span>
<span class="fc" id="L272">                AXPY.invoke(</span>
                        product,
                        j * rightCols,
                        left[c + j * complexity],
                        right,
                        c * rightCols,
                        0,
                        rightCols
                );
            }
        }
<span class="fc" id="L283">    }</span>


    static void threaded_F64_MxN_CM(final double[] product, final double[] left, final int complexity, final double[] right) {
<span class="fc" id="L287">        CPU.get().divide(</span>
                0,
                right.length / complexity,
<span class="fc" id="L290">                (f, l) -&gt; Vectorizable.partial_F64_MxN_CM(product, f, l, left, complexity, right)</span>
        );
<span class="fc" id="L292">    }</span>

    static void threaded_F32_MxN_CM(final float[] product, final float[] left, final int complexity, final float[] right) {
<span class="fc" id="L295">        CPU.get().divide(</span>
                0,
                right.length / complexity,
<span class="fc" id="L298">                (f, l) -&gt; Vectorizable.partial_F32_MxN_CM(product, f, l, left, complexity, right)</span>
        );
<span class="fc" id="L300">    }</span>

    static void threaded_F32_MxN_RM(final float[] product, final float[] left, final int complexity, final float[] right) {
<span class="fc" id="L303">        CPU.get().divide(</span>
                0,
                left.length / complexity,
<span class="fc" id="L306">                (f, l) -&gt; Vectorizable.partial_F32_MxN_RM(product, f, l, left, complexity, right)</span>
        );
<span class="fc" id="L308">    }</span>

    static void threaded_F64_MxN_RM(final double[] product, final double[] left, final int complexity, final double[] right) {
<span class="fc" id="L311">        CPU.get().divide(</span>
                0,
                left.length / complexity,
<span class="fc" id="L314">                (f, l) -&gt; Vectorizable.partial_F64_MxN_RM(product, f, l, left, complexity, right)</span>
        );
<span class="fc" id="L316">    }</span>

    static void full_F64_0xN_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L320">        int tmpRowDim = 10;</span>
<span class="fc" id="L321">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">        for (int j = 0; j &lt; tmpColDim; j++) {</span>

<span class="fc" id="L325">            double tmp0J = 0.0;</span>
<span class="fc" id="L326">            double tmp1J = 0.0;</span>
<span class="fc" id="L327">            double tmp2J = 0.0;</span>
<span class="fc" id="L328">            double tmp3J = 0.0;</span>
<span class="fc" id="L329">            double tmp4J = 0.0;</span>
<span class="fc" id="L330">            double tmp5J = 0.0;</span>
<span class="fc" id="L331">            double tmp6J = 0.0;</span>
<span class="fc" id="L332">            double tmp7J = 0.0;</span>
<span class="fc" id="L333">            double tmp8J = 0.0;</span>
<span class="fc" id="L334">            double tmp9J = 0.0;</span>

<span class="fc" id="L336">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L338">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L339">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L340">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L341">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L342">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L343">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L344">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L345">                tmp6J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L346">                tmp7J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L347">                tmp8J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L348">                tmp9J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L351">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L352">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L353">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L354">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L355">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L356">            product[++tmpIndex] = tmp5J;</span>
<span class="fc" id="L357">            product[++tmpIndex] = tmp6J;</span>
<span class="fc" id="L358">            product[++tmpIndex] = tmp7J;</span>
<span class="fc" id="L359">            product[++tmpIndex] = tmp8J;</span>
<span class="fc" id="L360">            product[++tmpIndex] = tmp9J;</span>
        }
<span class="fc" id="L362">    }</span>

    static void full_F64_1x1_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L366">        double tmp00 = 0.0;</span>

<span class="fc" id="L368">        int nbRows = left.length / complexity;</span>

<span class="fc bfc" id="L370" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L371">            tmp00 += left[c * nbRows] * right[c];</span>
        }

<span class="fc" id="L374">        product[0] = tmp00;</span>
<span class="fc" id="L375">    }</span>

    static void full_F64_1xN_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc bfc" id="L383" title="All 2 branches covered.">        for (int j = 0, nbCols = product.length; j &lt; nbCols; j++) {</span>
<span class="fc" id="L384">            product[j] = DOT.invoke(left, 0, right, j * complexity, 0, complexity);</span>
        }
<span class="fc" id="L386">    }</span>

    static void full_F64_1xN_RM(
            final double[] product,
            final double[] left,
            final int rowCount,
            final double[] right
    ) {//...
<span class="fc" id="L394">        int colCount = product.length;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        for (int ci = 0; ci &lt; colCount; ci++) {</span>
<span class="fc" id="L396">            AXPY.invoke(</span>
                    product,
                    0,
                    left[ci],
                    right,
                    ci * rowCount,
                    0,
                    rowCount
            );
        }
<span class="fc" id="L406">    }</span>

    static void full_F32_1xN_CM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc bfc" id="L414" title="All 2 branches covered.">        for (int j = 0, nbCols = product.length; j &lt; nbCols; j++) {</span>
<span class="fc" id="L415">            product[j] = DOT.invoke(left, 0, right, j * complexity, 0, complexity);</span>
        }
<span class="fc" id="L417">    }</span>


    static void full_F32_1xN_RM(
            final float[] product,
            final float[] left,
            final int rowCount,
            final float[] right
    ) {//...
<span class="nc" id="L426">        int colCount = product.length;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (int ci = 0; ci &lt; colCount; ci++) {</span>
<span class="nc" id="L428">            AXPY.invoke(</span>
                    product,
                    0,
                    left[ci],
                    right,
                    ci * rowCount,
                    0,
                    rowCount
            );
        }
<span class="nc" id="L438">    }</span>


    static void full_F64_2x2_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L443">        double tmp00 = 0.0;</span>
<span class="fc" id="L444">        double tmp10 = 0.0;</span>
<span class="fc" id="L445">        double tmp01 = 0.0;</span>
<span class="fc" id="L446">        double tmp11 = 0.0;</span>

        int tmpIndex;
<span class="fc bfc" id="L449" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>

<span class="fc" id="L451">            tmpIndex = c * 2;</span>
<span class="fc" id="L452">            double tmpLeft0 = left[tmpIndex];</span>
<span class="fc" id="L453">            tmpIndex++;</span>
<span class="fc" id="L454">            double tmpLeft1 = left[tmpIndex];</span>
<span class="fc" id="L455">            tmpIndex = c;</span>
<span class="fc" id="L456">            double tmpRight0 = right[tmpIndex];</span>
<span class="fc" id="L457">            tmpIndex += complexity;</span>
<span class="fc" id="L458">            double tmpRight1 = right[tmpIndex];</span>

<span class="fc" id="L460">            tmp00 += tmpLeft0 * tmpRight0;</span>
<span class="fc" id="L461">            tmp10 += tmpLeft1 * tmpRight0;</span>
<span class="fc" id="L462">            tmp01 += tmpLeft0 * tmpRight1;</span>
<span class="fc" id="L463">            tmp11 += tmpLeft1 * tmpRight1;</span>
        }

<span class="fc" id="L466">        product[0] = tmp00;</span>
<span class="fc" id="L467">        product[1] = tmp10;</span>
<span class="fc" id="L468">        product[2] = tmp01;</span>
<span class="fc" id="L469">        product[3] = tmp11;</span>
<span class="fc" id="L470">    }</span>

    static void full_F64_3x3_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L474">        double tmp00 = 0.0;</span>
<span class="fc" id="L475">        double tmp10 = 0.0;</span>
<span class="fc" id="L476">        double tmp20 = 0.0;</span>
<span class="fc" id="L477">        double tmp01 = 0.0;</span>
<span class="fc" id="L478">        double tmp11 = 0.0;</span>
<span class="fc" id="L479">        double tmp21 = 0.0;</span>
<span class="fc" id="L480">        double tmp02 = 0.0;</span>
<span class="fc" id="L481">        double tmp12 = 0.0;</span>
<span class="fc" id="L482">        double tmp22 = 0.0;</span>

        int tmpIndex;
<span class="fc bfc" id="L485" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>

<span class="fc" id="L487">            tmpIndex = c * 3;</span>
<span class="fc" id="L488">            double tmpLeft0 = left[tmpIndex];</span>
<span class="fc" id="L489">            tmpIndex++;</span>
<span class="fc" id="L490">            double tmpLeft1 = left[tmpIndex];</span>
<span class="fc" id="L491">            tmpIndex++;</span>
<span class="fc" id="L492">            double tmpLeft2 = left[tmpIndex];</span>
<span class="fc" id="L493">            tmpIndex = c;</span>
<span class="fc" id="L494">            double tmpRight0 = right[tmpIndex];</span>
<span class="fc" id="L495">            tmpIndex += complexity;</span>
<span class="fc" id="L496">            double tmpRight1 = right[tmpIndex];</span>
<span class="fc" id="L497">            tmpIndex += complexity;</span>
<span class="fc" id="L498">            double tmpRight2 = right[tmpIndex];</span>

<span class="fc" id="L500">            tmp00 += tmpLeft0 * tmpRight0;</span>
<span class="fc" id="L501">            tmp10 += tmpLeft1 * tmpRight0;</span>
<span class="fc" id="L502">            tmp20 += tmpLeft2 * tmpRight0;</span>
<span class="fc" id="L503">            tmp01 += tmpLeft0 * tmpRight1;</span>
<span class="fc" id="L504">            tmp11 += tmpLeft1 * tmpRight1;</span>
<span class="fc" id="L505">            tmp21 += tmpLeft2 * tmpRight1;</span>
<span class="fc" id="L506">            tmp02 += tmpLeft0 * tmpRight2;</span>
<span class="fc" id="L507">            tmp12 += tmpLeft1 * tmpRight2;</span>
<span class="fc" id="L508">            tmp22 += tmpLeft2 * tmpRight2;</span>
        }

<span class="fc" id="L511">        product[0] = tmp00;</span>
<span class="fc" id="L512">        product[1] = tmp10;</span>
<span class="fc" id="L513">        product[2] = tmp20;</span>
<span class="fc" id="L514">        product[3] = tmp01;</span>
<span class="fc" id="L515">        product[4] = tmp11;</span>
<span class="fc" id="L516">        product[5] = tmp21;</span>
<span class="fc" id="L517">        product[6] = tmp02;</span>
<span class="fc" id="L518">        product[7] = tmp12;</span>
<span class="fc" id="L519">        product[8] = tmp22;</span>
<span class="fc" id="L520">    }</span>

    static void full_F64_4x4_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L524">        double tmp00 = 0.0;</span>
<span class="fc" id="L525">        double tmp10 = 0.0;</span>
<span class="fc" id="L526">        double tmp20 = 0.0;</span>
<span class="fc" id="L527">        double tmp30 = 0.0;</span>
<span class="fc" id="L528">        double tmp01 = 0.0;</span>
<span class="fc" id="L529">        double tmp11 = 0.0;</span>
<span class="fc" id="L530">        double tmp21 = 0.0;</span>
<span class="fc" id="L531">        double tmp31 = 0.0;</span>
<span class="fc" id="L532">        double tmp02 = 0.0;</span>
<span class="fc" id="L533">        double tmp12 = 0.0;</span>
<span class="fc" id="L534">        double tmp22 = 0.0;</span>
<span class="fc" id="L535">        double tmp32 = 0.0;</span>
<span class="fc" id="L536">        double tmp03 = 0.0;</span>
<span class="fc" id="L537">        double tmp13 = 0.0;</span>
<span class="fc" id="L538">        double tmp23 = 0.0;</span>
<span class="fc" id="L539">        double tmp33 = 0.0;</span>

        int tmpIndex;
<span class="fc bfc" id="L542" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>

<span class="fc" id="L544">            tmpIndex = c * 4;</span>
<span class="fc" id="L545">            double tmpLeft0 = left[tmpIndex];</span>
<span class="fc" id="L546">            tmpIndex++;</span>
<span class="fc" id="L547">            double tmpLeft1 = left[tmpIndex];</span>
<span class="fc" id="L548">            tmpIndex++;</span>
<span class="fc" id="L549">            double tmpLeft2 = left[tmpIndex];</span>
<span class="fc" id="L550">            tmpIndex++;</span>
<span class="fc" id="L551">            double tmpLeft3 = left[tmpIndex];</span>
<span class="fc" id="L552">            tmpIndex = c;</span>
<span class="fc" id="L553">            double tmpRight0 = right[tmpIndex];</span>
<span class="fc" id="L554">            tmpIndex += complexity;</span>
<span class="fc" id="L555">            double tmpRight1 = right[tmpIndex];</span>
<span class="fc" id="L556">            tmpIndex += complexity;</span>
<span class="fc" id="L557">            double tmpRight2 = right[tmpIndex];</span>
<span class="fc" id="L558">            tmpIndex += complexity;</span>
<span class="fc" id="L559">            double tmpRight3 = right[tmpIndex];</span>

<span class="fc" id="L561">            tmp00 += tmpLeft0 * tmpRight0;</span>
<span class="fc" id="L562">            tmp10 += tmpLeft1 * tmpRight0;</span>
<span class="fc" id="L563">            tmp20 += tmpLeft2 * tmpRight0;</span>
<span class="fc" id="L564">            tmp30 += tmpLeft3 * tmpRight0;</span>
<span class="fc" id="L565">            tmp01 += tmpLeft0 * tmpRight1;</span>
<span class="fc" id="L566">            tmp11 += tmpLeft1 * tmpRight1;</span>
<span class="fc" id="L567">            tmp21 += tmpLeft2 * tmpRight1;</span>
<span class="fc" id="L568">            tmp31 += tmpLeft3 * tmpRight1;</span>
<span class="fc" id="L569">            tmp02 += tmpLeft0 * tmpRight2;</span>
<span class="fc" id="L570">            tmp12 += tmpLeft1 * tmpRight2;</span>
<span class="fc" id="L571">            tmp22 += tmpLeft2 * tmpRight2;</span>
<span class="fc" id="L572">            tmp32 += tmpLeft3 * tmpRight2;</span>
<span class="fc" id="L573">            tmp03 += tmpLeft0 * tmpRight3;</span>
<span class="fc" id="L574">            tmp13 += tmpLeft1 * tmpRight3;</span>
<span class="fc" id="L575">            tmp23 += tmpLeft2 * tmpRight3;</span>
<span class="fc" id="L576">            tmp33 += tmpLeft3 * tmpRight3;</span>
        }

<span class="fc" id="L579">        product[0] = tmp00;</span>
<span class="fc" id="L580">        product[1] = tmp10;</span>
<span class="fc" id="L581">        product[2] = tmp20;</span>
<span class="fc" id="L582">        product[3] = tmp30;</span>
<span class="fc" id="L583">        product[4] = tmp01;</span>
<span class="fc" id="L584">        product[5] = tmp11;</span>
<span class="fc" id="L585">        product[6] = tmp21;</span>
<span class="fc" id="L586">        product[7] = tmp31;</span>
<span class="fc" id="L587">        product[8] = tmp02;</span>
<span class="fc" id="L588">        product[9] = tmp12;</span>
<span class="fc" id="L589">        product[10] = tmp22;</span>
<span class="fc" id="L590">        product[11] = tmp32;</span>
<span class="fc" id="L591">        product[12] = tmp03;</span>
<span class="fc" id="L592">        product[13] = tmp13;</span>
<span class="fc" id="L593">        product[14] = tmp23;</span>
<span class="fc" id="L594">        product[15] = tmp33;</span>
<span class="fc" id="L595">    }</span>

    static void full_F64_5x5_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L599">        double tmp00 = 0.0;</span>
<span class="fc" id="L600">        double tmp10 = 0.0;</span>
<span class="fc" id="L601">        double tmp20 = 0.0;</span>
<span class="fc" id="L602">        double tmp30 = 0.0;</span>
<span class="fc" id="L603">        double tmp40 = 0.0;</span>
<span class="fc" id="L604">        double tmp01 = 0.0;</span>
<span class="fc" id="L605">        double tmp11 = 0.0;</span>
<span class="fc" id="L606">        double tmp21 = 0.0;</span>
<span class="fc" id="L607">        double tmp31 = 0.0;</span>
<span class="fc" id="L608">        double tmp41 = 0.0;</span>
<span class="fc" id="L609">        double tmp02 = 0.0;</span>
<span class="fc" id="L610">        double tmp12 = 0.0;</span>
<span class="fc" id="L611">        double tmp22 = 0.0;</span>
<span class="fc" id="L612">        double tmp32 = 0.0;</span>
<span class="fc" id="L613">        double tmp42 = 0.0;</span>
<span class="fc" id="L614">        double tmp03 = 0.0;</span>
<span class="fc" id="L615">        double tmp13 = 0.0;</span>
<span class="fc" id="L616">        double tmp23 = 0.0;</span>
<span class="fc" id="L617">        double tmp33 = 0.0;</span>
<span class="fc" id="L618">        double tmp43 = 0.0;</span>
<span class="fc" id="L619">        double tmp04 = 0.0;</span>
<span class="fc" id="L620">        double tmp14 = 0.0;</span>
<span class="fc" id="L621">        double tmp24 = 0.0;</span>
<span class="fc" id="L622">        double tmp34 = 0.0;</span>
<span class="fc" id="L623">        double tmp44 = 0.0;</span>

        int tmpIndex;
<span class="fc bfc" id="L626" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>

<span class="fc" id="L628">            tmpIndex = c * 5;</span>
<span class="fc" id="L629">            double tmpLeft0 = left[tmpIndex];</span>
<span class="fc" id="L630">            tmpIndex++;</span>
<span class="fc" id="L631">            double tmpLeft1 = left[tmpIndex];</span>
<span class="fc" id="L632">            tmpIndex++;</span>
<span class="fc" id="L633">            double tmpLeft2 = left[tmpIndex];</span>
<span class="fc" id="L634">            tmpIndex++;</span>
<span class="fc" id="L635">            double tmpLeft3 = left[tmpIndex];</span>
<span class="fc" id="L636">            tmpIndex++;</span>
<span class="fc" id="L637">            double tmpLeft4 = left[tmpIndex];</span>
<span class="fc" id="L638">            tmpIndex = c;</span>
<span class="fc" id="L639">            double tmpRight0 = right[tmpIndex];</span>
<span class="fc" id="L640">            tmpIndex += complexity;</span>
<span class="fc" id="L641">            double tmpRight1 = right[tmpIndex];</span>
<span class="fc" id="L642">            tmpIndex += complexity;</span>
<span class="fc" id="L643">            double tmpRight2 = right[tmpIndex];</span>
<span class="fc" id="L644">            tmpIndex += complexity;</span>
<span class="fc" id="L645">            double tmpRight3 = right[tmpIndex];</span>
<span class="fc" id="L646">            tmpIndex += complexity;</span>
<span class="fc" id="L647">            double tmpRight4 = right[tmpIndex];</span>

<span class="fc" id="L649">            tmp00 += tmpLeft0 * tmpRight0;</span>
<span class="fc" id="L650">            tmp10 += tmpLeft1 * tmpRight0;</span>
<span class="fc" id="L651">            tmp20 += tmpLeft2 * tmpRight0;</span>
<span class="fc" id="L652">            tmp30 += tmpLeft3 * tmpRight0;</span>
<span class="fc" id="L653">            tmp40 += tmpLeft4 * tmpRight0;</span>
<span class="fc" id="L654">            tmp01 += tmpLeft0 * tmpRight1;</span>
<span class="fc" id="L655">            tmp11 += tmpLeft1 * tmpRight1;</span>
<span class="fc" id="L656">            tmp21 += tmpLeft2 * tmpRight1;</span>
<span class="fc" id="L657">            tmp31 += tmpLeft3 * tmpRight1;</span>
<span class="fc" id="L658">            tmp41 += tmpLeft4 * tmpRight1;</span>
<span class="fc" id="L659">            tmp02 += tmpLeft0 * tmpRight2;</span>
<span class="fc" id="L660">            tmp12 += tmpLeft1 * tmpRight2;</span>
<span class="fc" id="L661">            tmp22 += tmpLeft2 * tmpRight2;</span>
<span class="fc" id="L662">            tmp32 += tmpLeft3 * tmpRight2;</span>
<span class="fc" id="L663">            tmp42 += tmpLeft4 * tmpRight2;</span>
<span class="fc" id="L664">            tmp03 += tmpLeft0 * tmpRight3;</span>
<span class="fc" id="L665">            tmp13 += tmpLeft1 * tmpRight3;</span>
<span class="fc" id="L666">            tmp23 += tmpLeft2 * tmpRight3;</span>
<span class="fc" id="L667">            tmp33 += tmpLeft3 * tmpRight3;</span>
<span class="fc" id="L668">            tmp43 += tmpLeft4 * tmpRight3;</span>
<span class="fc" id="L669">            tmp04 += tmpLeft0 * tmpRight4;</span>
<span class="fc" id="L670">            tmp14 += tmpLeft1 * tmpRight4;</span>
<span class="fc" id="L671">            tmp24 += tmpLeft2 * tmpRight4;</span>
<span class="fc" id="L672">            tmp34 += tmpLeft3 * tmpRight4;</span>
<span class="fc" id="L673">            tmp44 += tmpLeft4 * tmpRight4;</span>
        }

<span class="fc" id="L676">        product[0] = tmp00;</span>
<span class="fc" id="L677">        product[1] = tmp10;</span>
<span class="fc" id="L678">        product[2] = tmp20;</span>
<span class="fc" id="L679">        product[3] = tmp30;</span>
<span class="fc" id="L680">        product[4] = tmp40;</span>
<span class="fc" id="L681">        product[5] = tmp01;</span>
<span class="fc" id="L682">        product[6] = tmp11;</span>
<span class="fc" id="L683">        product[7] = tmp21;</span>
<span class="fc" id="L684">        product[8] = tmp31;</span>
<span class="fc" id="L685">        product[9] = tmp41;</span>
<span class="fc" id="L686">        product[10] = tmp02;</span>
<span class="fc" id="L687">        product[11] = tmp12;</span>
<span class="fc" id="L688">        product[12] = tmp22;</span>
<span class="fc" id="L689">        product[13] = tmp32;</span>
<span class="fc" id="L690">        product[14] = tmp42;</span>
<span class="fc" id="L691">        product[15] = tmp03;</span>
<span class="fc" id="L692">        product[16] = tmp13;</span>
<span class="fc" id="L693">        product[17] = tmp23;</span>
<span class="fc" id="L694">        product[18] = tmp33;</span>
<span class="fc" id="L695">        product[19] = tmp43;</span>
<span class="fc" id="L696">        product[20] = tmp04;</span>
<span class="fc" id="L697">        product[21] = tmp14;</span>
<span class="fc" id="L698">        product[22] = tmp24;</span>
<span class="fc" id="L699">        product[23] = tmp34;</span>
<span class="fc" id="L700">        product[24] = tmp44;</span>
<span class="fc" id="L701">    }</span>

    static void full_F64_6xN_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L705">        int tmpRowDim = 6;</span>
<span class="fc" id="L706">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L708" title="All 2 branches covered.">        for (int j = 0; j &lt; tmpColDim; j++) {</span>

<span class="fc" id="L710">            double tmp0J = 0.0;</span>
<span class="fc" id="L711">            double tmp1J = 0.0;</span>
<span class="fc" id="L712">            double tmp2J = 0.0;</span>
<span class="fc" id="L713">            double tmp3J = 0.0;</span>
<span class="fc" id="L714">            double tmp4J = 0.0;</span>
<span class="fc" id="L715">            double tmp5J = 0.0;</span>

<span class="fc" id="L717">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L719">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L720">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L721">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L722">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L723">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L724">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L725">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L728">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L729">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L730">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L731">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L732">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L733">            product[++tmpIndex] = tmp5J;</span>
        }
<span class="fc" id="L735">    }</span>

    static void full_F64_7xN_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L739">        int tmpRowDim = 7;</span>
<span class="fc" id="L740">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L742" title="All 2 branches covered.">        for (int j = 0; j &lt; tmpColDim; j++) {</span>

<span class="fc" id="L744">            double tmp0J = 0.0;</span>
<span class="fc" id="L745">            double tmp1J = 0.0;</span>
<span class="fc" id="L746">            double tmp2J = 0.0;</span>
<span class="fc" id="L747">            double tmp3J = 0.0;</span>
<span class="fc" id="L748">            double tmp4J = 0.0;</span>
<span class="fc" id="L749">            double tmp5J = 0.0;</span>
<span class="fc" id="L750">            double tmp6J = 0.0;</span>

<span class="fc" id="L752">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">            for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L754">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L755">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L756">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L757">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L758">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L759">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L760">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L761">                tmp6J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L764">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L765">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L766">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L767">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L768">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L769">            product[++tmpIndex] = tmp5J;</span>
<span class="fc" id="L770">            product[++tmpIndex] = tmp6J;</span>
        }
<span class="fc" id="L772">    }</span>

    static void full_F64_8xN_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L776">        int tmpRowDim = 8;</span>
<span class="fc" id="L777">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L779" title="All 2 branches covered.">        for (int j = 0; j &lt; tmpColDim; j++) {</span>

<span class="fc" id="L781">            double tmp0J = 0.0;</span>
<span class="fc" id="L782">            double tmp1J = 0.0;</span>
<span class="fc" id="L783">            double tmp2J = 0.0;</span>
<span class="fc" id="L784">            double tmp3J = 0.0;</span>
<span class="fc" id="L785">            double tmp4J = 0.0;</span>
<span class="fc" id="L786">            double tmp5J = 0.0;</span>
<span class="fc" id="L787">            double tmp6J = 0.0;</span>
<span class="fc" id="L788">            double tmp7J = 0.0;</span>

<span class="fc" id="L790">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">            for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L792">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L793">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L794">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L795">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L796">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L797">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L798">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L799">                tmp6J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L800">                tmp7J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L803">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L804">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L805">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L806">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L807">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L808">            product[++tmpIndex] = tmp5J;</span>
<span class="fc" id="L809">            product[++tmpIndex] = tmp6J;</span>
<span class="fc" id="L810">            product[++tmpIndex] = tmp7J;</span>
        }
<span class="fc" id="L812">    }</span>

    static void full_F64_9xN_CM(final double[] product, final double[] left, final int complexity, final double[] right) {

<span class="fc" id="L816">        int tmpRowDim = 9;</span>
<span class="fc" id="L817">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L819" title="All 2 branches covered.">        for (int j = 0; j &lt; tmpColDim; j++) {</span>

<span class="fc" id="L821">            double tmp0J = 0.0;</span>
<span class="fc" id="L822">            double tmp1J = 0.0;</span>
<span class="fc" id="L823">            double tmp2J = 0.0;</span>
<span class="fc" id="L824">            double tmp3J = 0.0;</span>
<span class="fc" id="L825">            double tmp4J = 0.0;</span>
<span class="fc" id="L826">            double tmp5J = 0.0;</span>
<span class="fc" id="L827">            double tmp6J = 0.0;</span>
<span class="fc" id="L828">            double tmp7J = 0.0;</span>
<span class="fc" id="L829">            double tmp8J = 0.0;</span>

<span class="fc" id="L831">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">            for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L833">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L834">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L835">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L836">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L837">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L838">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L839">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L840">                tmp6J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L841">                tmp7J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L842">                tmp8J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L845">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L846">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L847">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L848">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L849">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L850">            product[++tmpIndex] = tmp5J;</span>
<span class="fc" id="L851">            product[++tmpIndex] = tmp6J;</span>
<span class="fc" id="L852">            product[++tmpIndex] = tmp7J;</span>
<span class="fc" id="L853">            product[++tmpIndex] = tmp8J;</span>
        }
<span class="fc" id="L855">    }</span>

    static void full_F64_MxN_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L863">        Vectorizable.partial_F64_MxN_CM(product, 0, right.length / complexity, left, complexity, right);</span>
<span class="fc" id="L864">    }</span>

    static void full_F64_MxN_RM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L872">        Vectorizable.partial_F64_MxN_RM(product, 0, left.length / complexity, left, complexity, right);</span>
<span class="fc" id="L873">    }</span>

    static void full_F32_MxN_CM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L881">        Vectorizable.partial_F32_MxN_CM(product, 0, right.length / complexity, left, complexity, right);</span>
<span class="fc" id="L882">    }</span>

    static void full_F32_MxN_RM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L890">        Vectorizable.partial_F32_MxN_RM(product, 0, left.length / complexity, left, complexity, right);</span>
<span class="fc" id="L891">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>