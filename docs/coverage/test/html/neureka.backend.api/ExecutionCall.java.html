<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExecutionCall.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.backend.api</a> &gt; <span class="el_source">ExecutionCall.java</span></div><h1>ExecutionCall.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ______                     _   _              _____      _ _
  |  ____|                   | | (_)            / ____|    | | |
  | |__  __  _____  ___ _   _| |_ _  ___  _ __ | |     __ _| | |
  |  __| \ \/ / _ \/ __| | | | __| |/ _ \| '_ \| |    / _` | | |
  | |____ &gt;  &lt;  __/ (__| |_| | |_| | (_) | | | | |___| (_| | | |
  |______/_/\_\___|\___|\__,_|\__|_|\___/|_| |_|\_____\__,_|_|_|

    A simple class which wraps essential arguments and context data
    used for operation execution on Device instances.


*/

package neureka.backend.api;


import neureka.Tsr;
import neureka.autograd.ADAgent;
import neureka.calculus.Function;
import neureka.calculus.args.Arg;
import neureka.devices.Device;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 *  This class is a simple container holding relevant
 *  arguments needed to execute on a targeted {@link Device} which
 *  is specified by the type parameter below. &lt;br&gt;
 *  &lt;br&gt;
 *  It also holds a context components responsible for storing operation specific variables.
 *  This is Certain operations might require additionally parameters then the ones
 *  defined in this class... &lt;br&gt;
 *
 * @param &lt;D&gt; The Device implementation targeted by an instance of this ExecutionCall!
*/
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">public class ExecutionCall&lt;D extends Device&lt;?&gt;&gt; extends Call&lt;D&gt;</span>
{
    /**
     *  This is the operation type which will be applied to this execution call.
     *  It contains multiple implementations, one of which might be applicable to this call...
     */
    private final Operation _operation;

    /**
     *  This Algorithm variable is the chosen algorithm for a given execution call instance.
     *  The variable is initially null and will be chosen dynamically based on an access request
     *  to the corresponding getter method for this variable.
     *  So it is in essence a lazy load variable.
     *  Choosing an algorithm occurs through the {@link ExecutionCall#_operation} variable,
     *  which is of type {@link Operation} and contains multiple algorithms for different execution call scenarios...
     */
<span class="fc" id="L79">    private Algorithm&lt;?&gt; _algorithm = null;</span>

    private ExecutionCall(
            D device,
            Operation operation,
            Tsr&lt;?&gt;[] tensors,
            Algorithm&lt;?&gt; algorithm,
            List&lt;Arg&gt; arguments
    ) {
<span class="fc" id="L88">        super(tensors, device, arguments);</span>
<span class="fc" id="L89">        this._operation = operation;</span>
<span class="fc" id="L90">        this._tensors = tensors;</span>
<span class="fc" id="L91">        this._algorithm = algorithm;</span>
<span class="fc" id="L92">        int thisArity = _tensors.length;</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if ( thisArity &lt; Math.abs(_operation.getArity()) ) {</span>
<span class="nc" id="L94">            throw new IllegalArgumentException(</span>
<span class="nc" id="L95">                    &quot;Trying to instantiate an &quot;+this.getClass().getSimpleName()+&quot; with an arity &quot; +</span>
                            &quot;of &quot;+thisArity+&quot;, which is not suitable to the targeted operation &quot; +
<span class="nc" id="L97">                            _operation.getClass().getSimpleName()+&quot; with &quot; +</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                            ( _operation.getArity() &lt; 0 ? &quot; a minimum &quot; : &quot; the expected &quot; ) +</span>
<span class="nc" id="L99">                            &quot;arity of &quot;+Math.abs(_operation.getArity())</span>
            );
        }
<span class="fc" id="L102">    }</span>

    public static &lt;D extends Device&lt;?&gt;&gt; Builder&lt;D&gt; of( Tsr&lt;?&gt;... tensors ) {
<span class="fc" id="L105">        return new Builder&lt;D&gt;(tensors);</span>
    }

    /**
     *  Warning: This is the only method on this class which exposes
     *  mutability to parts of the internals of an {@link ExecutionCall}.
     *  Do not use it too extensively in order to keep complexity
     *  to a minimum...
     *
     * @param arg The meta argument which ought to be stored on this {@link ExecutionCall}.
     * @return This very instance to allow for method chaining.
     */
<span class="fc" id="L117">    public ExecutionCall&lt;D&gt; setMetaArg( Arg&lt;?&gt; arg ) { _arguments.set(arg); return this; }</span>
    
    public String toString() {
<span class="nc" id="L120">        return &quot;ExecutionCall(&quot; +</span>
                    &quot;device=&quot; + this._device + &quot;, &quot; +
<span class="nc" id="L122">                    &quot;derivativeIndex=&quot; + this.getValOf( Arg.DerivIdx.class ) + &quot;, &quot; +</span>
                    &quot;operation=&quot; + this._operation + &quot;, &quot; +
                    &quot;tensors=[..&quot;+_tensors.length+&quot;..], &quot; +
<span class="nc" id="L125">                    &quot;j=&quot; + this.getJ() + &quot;, &quot; +</span>
                    &quot;algorithm=?, &quot; +
<span class="nc" id="L127">                    &quot;context=&quot; + _arguments.getAll(Arg.class) +</span>
                &quot;)&quot;;
    }

<span class="fc" id="L131">    public Operation getOperation() { return this._operation; }</span>

<span class="fc" id="L133">    public int getJ() { return this.getValOf( Arg.VarIdx.class ); }</span>

    public ExecutionCall&lt;D&gt; withTensors(Tsr&lt;?&gt;[] tensors ) {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        return this._tensors == tensors</span>
<span class="nc" id="L137">                ? this</span>
<span class="fc" id="L138">                : new ExecutionCall&lt;&gt;(</span>
                        _device, _operation,
<span class="fc" id="L140">                        tensors, _algorithm, _arguments.getAll(Arg.class)</span>
                    );
    }

    public &lt;T extends Device&lt;?&gt;&gt; ExecutionCall&lt;T&gt; forDeviceType( Class&lt;T&gt; type ) {
<span class="pc bpc" id="L145" title="2 of 4 branches missed.">        assert _device.getClass() == type;</span>
<span class="fc" id="L146">        return (ExecutionCall&lt;T&gt;) this;</span>
    }

    public Algorithm&lt;?&gt; getAlgorithm() {
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if ( _algorithm != null ) return _algorithm;</span>
<span class="fc" id="L151">        else _algorithm = _operation.getAlgorithmFor( this );</span>
<span class="fc" id="L152">        return _algorithm;</span>
    }

    public boolean allowsForward() {
<span class="fc" id="L156">        return getAlgorithm().canPerformForwardADFor( this );</span>
    }

    public boolean allowsBackward() {
<span class="fc" id="L160">        return getAlgorithm().canPerformBackwardADFor( this );</span>
    }

    public ADAgent getADAgentFrom(
            Function function,
            ExecutionCall&lt;? extends Device&lt;?&gt;&gt; call,
            boolean forward
    ) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">        for ( Arg&lt;?&gt; arg : _arguments.getAll(Arg.class) ) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            if ( !call._arguments.has(arg.getClass()) )</span>
<span class="fc" id="L170">                call._arguments.set(arg);</span>
            // else: This should not happen.
<span class="fc" id="L172">        }</span>
<span class="fc" id="L173">        return getAlgorithm().supplyADAgentFor( function, call, forward );</span>
    }

    public static class Builder&lt;D extends Device&lt;?&gt;&gt;
    {
        private Operation _operation;
        private Tsr&lt;?&gt;[] _tensors;
        private Algorithm&lt;?&gt; _algorithm;
<span class="fc" id="L181">        private final List&lt;Arg&gt; _arguments = Stream.of(</span>
<span class="fc" id="L182">                                                Arg.DerivIdx.of(-1),</span>
<span class="fc" id="L183">                                                Arg.VarIdx.of(-1)</span>
                                            )
<span class="fc" id="L185">                                            .collect(Collectors.toList());</span>

<span class="fc" id="L187">        private Builder(Tsr&lt;?&gt;[] tensors) { _tensors = tensors; }</span>

        public &lt;V, D extends Device&lt;V&gt;&gt; ExecutionCall&lt;D&gt; on(D device) {
<span class="fc" id="L190">            return new ExecutionCall&lt;&gt;(</span>
                                    device,
                                    _operation,
                                    _tensors,
                                    _algorithm,
                                    _arguments
                            );
        }

        public Builder&lt;D&gt; running(Operation operation) {
<span class="fc" id="L200">            _operation = operation;</span>
<span class="fc" id="L201">            return this;</span>
        }

        public Builder&lt;D&gt; algorithm(Algorithm&lt;?&gt; algorithm) {
<span class="fc" id="L205">            _algorithm = algorithm;</span>
<span class="fc" id="L206">            return this;</span>
        }

        public Builder&lt;D&gt; andArgs( List&lt;Arg&gt; context ) {
<span class="fc" id="L210">            _arguments.addAll(context);</span>
<span class="fc" id="L211">            return this;</span>
        }

        public Builder&lt;D&gt; andArgs( Arg&lt;?&gt;... context ) {
<span class="fc" id="L215">            return andArgs(Arrays.stream(context).collect(Collectors.toList()));</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>