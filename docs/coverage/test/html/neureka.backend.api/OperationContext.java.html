<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OperationContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.backend.api</a> &gt; <span class="el_source">OperationContext.java</span></div><h1>OperationContext.java</h1><pre class="source lang-java linenums">package neureka.backend.api;


import neureka.Component;
import neureka.Neureka;
import neureka.calculus.Cache;
import neureka.calculus.Function;
import neureka.calculus.Functions;
import neureka.ndim.AbstractComponentOwner;
import org.slf4j.Logger;

import java.util.*;
import java.util.function.Supplier;

/**
 *    Instances of this class are execution contexts hosting {@link Operation} instances which receive {@link neureka.Tsr}
 *    instances for execution.
 *    {@link OperationContext}s managed by {@link Neureka}, a (thread-local) Singleton / Multiton.  &lt;br&gt;
 *    Contexts are cloneable for testing purposes and to enable extending the backend dynamically.
 *    A given instance also hosts a reference to a {@link Functions} instance which exposes commonly used
 *    pre-instantiated {@link Function} implementation instances.
 *    &lt;br&gt;&lt;br&gt;
 *    The {@link OperationContext} initializes and stores {@link Operation} instances in various data structures
 *    for fast access and querying (Mostly used by the {@link neureka.calculus.assembly.FunctionParser}).
 *    &lt;br&gt;
 *    {@link Operation}s are stored in simple list and map collections,
 *    namely: &lt;br&gt;
 *    The &quot;_instances&quot; list and the &quot;_lookup&quot; map as declared below.
 *    &lt;br&gt;
 *    &lt;br&gt;
 *    During class initialization concrete classes extending the {@link Operation} class
 *    are being instantiated in the static block below via a {@link ServiceLoader}.
 *    {@link OperationContext} instances expose a useful class called {@link Runner},
 *    which performs temporary context switching between the caller's context and this
 *    context during the execution of provided lambdas.
 *
 */
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">public class OperationContext extends AbstractComponentOwner&lt;OperationContext&gt; implements Cloneable</span>
{
<span class="fc" id="L40">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(OperationContext.class);</span>
    /**
     *  A mapping between OperationType identifiers and their corresponding instances.
     */
    private final Map&lt;String, Operation&gt; _lookup;

    /**
     *  A list of all OperationType instances.
     */
    private final List&lt;Operation&gt; _instances;

    /**
     *  The number of operation instances stored in this context.
     */
    private int _size;

    // Global context and cache:
<span class="fc" id="L57">    private final Cache _functionCache = new Cache();</span>

<span class="fc" id="L59">    private Functions _getAutogradFunction = null;</span>

    /**
     *  This {@link Functions} instance wraps pre-instantiated
     *  {@link Function} instances which are configured to not track their computational history.
     *  This means that no computation graph will be built by these instances.
     *  ( Computation graphs in Neureka are made of instances of the &quot;GraphNode&quot; class... )
     */
<span class="fc" id="L67">    private Functions _getFunction = null;</span>


    /**
     *  A {@link Runner} wraps both the called context as well as the context of the caller in order
     *  to perform temporary context switching during the execution of lambdas passed to the {@link Runner}.
     *  After a given lambda was executed successfully, the original context will be restored in the current
     *  thread local {@link Neureka} instance through the {@link Neureka#setContext(OperationContext)}) method.
     *
     * @return A lambda {@link Runner} which performs temporary context switching between the caller's context and this context.
     */
<span class="fc" id="L78">    public Runner runner() { return new Runner( this, Neureka.get().context() ); }</span>

    /**
     * This method returns an unmodifiable view of the mapping between the {@link Operation#getFunction()} / {@link Operation#getOperator()} properties
     * and the {@link Operation} implementation instances to which they belong.
     * Query operations on the returned map &quot;read through&quot; to the specified map,
     * and attempts to modify the returned map, whether direct or via its collection views,
     * result in an {@link UnsupportedOperationException}.
     *
     * @return An unmodifiable mapping of {@link Operation} properties to the {@link Operation} instances to which they belong.
     */
<span class="fc" id="L89">    public Map&lt;String, Operation&gt; lookup() { return Collections.unmodifiableMap( this._lookup ); }</span>

    /**
     * This method returns an unmodifiable view of the
     * list of {@link Operation} implementation instances managed by this context.
     * Query operations on the returned map &quot;read through&quot; to the specified map,
     * and attempts to modify the returned map, whether direct or via its collection views,
     * result in an {@link UnsupportedOperationException}.
     *
     * @return An unmodifiable view of the list of {@link Operation} implementation instances managed by this context
     */
<span class="fc" id="L100">    public List&lt;Operation&gt; instances() { return Collections.unmodifiableList( this._instances ); }</span>

    /**
     * @return The number of {@link Operation} instances stored on this {@link OperationContext}.
     */
<span class="fc" id="L105">    public int size() { return this._size; }</span>

    /**
     * @return The {@link Function} and {@link neureka.Tsr} cache of this {@link OperationContext}
     */
<span class="fc" id="L110">    public Cache functionCache() { return this._functionCache; }</span>

    /**
     *  This method returns a {@link Functions} instance which wraps pre-instantiated
     *  {@link Function} instances which are configured to not track their computational history.
     *  This means that no computation graph will be built by these instances.
     *  ( Computation graphs in Neureka are made of instances of the {@link neureka.autograd.GraphNode} class... )
     */
    public Functions getFunction() {
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if ( _getFunction == null ) _getFunction = new Functions( false );</span>
<span class="fc" id="L120">        return _getFunction;</span>
    }

    /**
     *  This method returns a {@link Functions} instance which wraps pre-instantiated
     *  {@link Function} instances which are configured to track their computational history.
     *  This means that a computation graph will be built by these instances.
     *  ( Computation graphs in Neureka are made of instances of the {@link neureka.autograd.GraphNode} class... )
     */
    public Functions getAutogradFunction() {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if ( _getAutogradFunction == null ) _getAutogradFunction = new Functions( true );</span>
<span class="fc" id="L131">        return _getAutogradFunction;</span>
    }

    /**
     *  This creates a new context which is completely void of any {@link Operation} implementation instances.
     *  Use this constructor to test, debug, build and populate custom execution contexts.
     */
    public OperationContext()
<span class="fc" id="L139">    {</span>
<span class="fc" id="L140">        _lookup = new HashMap&lt;&gt;();</span>
<span class="fc" id="L141">        _instances = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L142">        _size = 0;</span>
<span class="fc" id="L143">    }</span>

    /**
     *  This method registers {@link Operation} implementation instances in this {@link OperationContext}
     *  which is the thread local execution context receiving and processing {@link neureka.Tsr} instances...         &lt;br&gt;&lt;br&gt;
     *
     * @param operation The {@link Operation} instance which ought to be registered as part of this execution context.
     * @return This very context instance to allow for method chaining.
     */
    public OperationContext addOperation( Operation operation )
    {
<span class="fc" id="L154">        _instances.add( operation );</span>
<span class="fc" id="L155">        String function = operation.getFunction();</span>
<span class="fc" id="L156">        String operator = operation.getOperator();</span>
<span class="pc bpc" id="L157" title="2 of 4 branches missed.">        assert !_lookup.containsKey( operator );</span>
<span class="pc bpc" id="L158" title="2 of 4 branches missed.">        assert !_lookup.containsKey( function );</span>
<span class="fc" id="L159">        _lookup.put( operator, operation );</span>
<span class="fc" id="L160">        _lookup.put( function, operation );</span>
<span class="fc" id="L161">        _lookup.put( operator.toLowerCase(), operation );</span>
<span class="fc" id="L162">        if (</span>
                operator
<span class="fc" id="L164">                        .replace((&quot;&quot;+((char)171)), &quot;&quot;)</span>
<span class="fc" id="L165">                        .replace((&quot;&quot;+((char)187)), &quot;&quot;)</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                        .matches(&quot;[a-z]&quot;)</span>
        ) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">            if ( operator.contains( &quot;&quot;+((char)171) ) )</span>
<span class="fc" id="L169">                this._lookup.put(operator.replace((&quot;&quot;+((char)171)), &quot;&lt;&lt;&quot;), operation);</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">            if ( operator.contains( &quot;&quot;+((char)187) ) )</span>
<span class="fc" id="L172">                this._lookup.put(operator.replace((&quot;&quot;+((char)187)),&quot;&gt;&gt;&quot;), operation);</span>
        }
<span class="fc" id="L174">        _size++;</span>
<span class="fc" id="L175">        return this;</span>
    }

    /**
     * @param operation The {@link Operation} which may or may not be part of this {@link OperationContext}.
     * @return The truth value determining if the provided {@link Operation} is part of this {@link OperationContext}.
     */
    public boolean hasOperation( Operation operation ) {
<span class="fc" id="L183">        return this._lookup.containsKey( operation.getFunction() );</span>
    }


    /**
     *  This method queries the operations in this {@link OperationContext}
     *  by a provided index integer targeting an entry in the list of {@link Operation} implementation instances
     *  sitting in this execution context.
     *
     * @param index The index of the operation.
     * @return The found Operation instance or null.
     */
<span class="fc" id="L195">    public Operation instance( int index ) { return _instances.get( index ); }</span>

    /**
     *  This method queries the operations in this OperationContext
     *  by a provided identifier which has to match the name of
     *  an existing operation.
     *
     * @param identifier The operation identifier, aka: its name.
     * @return The requested Operation or null.
     */
<span class="fc" id="L205">    public Operation instance( String identifier ) { return _lookup.getOrDefault( identifier, null ); }</span>

    /**
     *  This method produces a shallow copy of this {@link OperationContext}.
     *  This is useful for debugging, testing and extending contexts during runtime without side effects!  &lt;br&gt;
     *
     * @return A shallow copy of this operation / execution context.
     */
    @Override
    public OperationContext clone()
    {
<span class="fc" id="L216">        OperationContext clone = new OperationContext();</span>
<span class="fc" id="L217">        clone._size = _size;</span>
<span class="fc" id="L218">        clone._lookup.putAll( _lookup );</span>
<span class="fc" id="L219">        clone._instances.addAll( _instances );</span>
<span class="fc" id="L220">        return clone;</span>
    }

    public String toString() {
<span class="nc" id="L224">        return &quot;OperationContext(_lookup=&quot; + this.lookup() + &quot;, _instances=&quot; + this.instances() + &quot;, _size=&quot; + this.size() + &quot;, _functionCache=&quot; + this.functionCache() + &quot;, _getAutogradFunction=&quot; + this.getAutogradFunction() + &quot;, _getFunction=&quot; + this.getFunction() + &quot;)&quot;;</span>
    }

    @Override
    protected &lt;T extends Component&lt;OperationContext&gt;&gt; T _setOrReject(T newComponent) {
<span class="fc" id="L229">        return newComponent;</span>
    }

    @Override
    protected &lt;T extends Component&lt;OperationContext&gt;&gt; T _removeOrReject(T newComponent) {
<span class="nc" id="L234">        return newComponent;</span>
    }


    /**
     *  This is a very simple class with a single purpose, namely
     *  it exposes methods which receive lambda instances in order to then execute them
     *  in a given {@link OperationContext}, just to then switch back to the original context again.
     *  Switching a context simply means that the {@link OperationContext} which produced this {@link Runner}
     *  will temporarily be set as execution context for the current thread
     *  local {@link Neureka} instance.                                              &lt;br&gt;&lt;br&gt;
     *
     *  A {@link Runner} wraps both the called context as well as the context of the caller in order
     *  to perform this temporary context switching throughout the execution of the lambdas passed to the {@link Runner}.
     *  After a given lambda was executed, the original context will be restored in the current thread
     *  local {@link Neureka} instance through the {@link Neureka#setContext(OperationContext)}) method.
     */
    public static class Runner
    {
        private final OperationContext originalContext;
        private final OperationContext visitedContext;

<span class="fc" id="L256">        private Runner( OperationContext visited, OperationContext originalContext ) {</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            if ( visited == originalContext ) log.warn(&quot;Context runner encountered two identical contexts!&quot;);</span>
<span class="fc" id="L258">            this.originalContext = originalContext;</span>
<span class="fc" id="L259">            this.visitedContext = visited;</span>
<span class="fc" id="L260">        }</span>

        /**
         *  Use this method to supply a lambda which will be executed in the {@link OperationContext}
         *  which produced this very {@link Runner} instance.
         *  After the lambda finished execution successfully the original {@link OperationContext} will
         *  be restored for the current thread local {@link Neureka} instance.
         *
         * @param contextSpecificAction The context specific action which will be execute in the {@link OperationContext} which produced this {@link Runner}.
         * @return This very {@link Runner} instance to enable method chaining.
         */
        public Runner run( Runnable contextSpecificAction ) {
<span class="fc" id="L272">            Neureka.get().setContext( visitedContext );</span>
<span class="fc" id="L273">            contextSpecificAction.run();</span>
<span class="fc" id="L274">            Neureka.get().setContext( originalContext );</span>
<span class="fc" id="L275">            return this;</span>
        }

        /**
         *  Use this method to supply a lambda which will be executed in the {@link OperationContext}
         *  which produced this very {@link Runner} instance.
         *  After the lambda finished execution successfully the original {@link OperationContext} will be restored.
         *  This method distinguishes itself from the {@link #run(Runnable)} method because the
         *  lambda supplied to this method is expected to return something.
         *  What may be returned is up to the user, one might want to return the result
         *  of a tensor operation which might be exclusively available in the used context.
         *
         * @param contextSpecificAction The context specific action which will be execute in the {@link OperationContext} which produced this {@link Runner}.
         * @param &lt;T&gt; The return type of the supplied context action which will also be returned by this method.
         * @return The result of the supplied context action.
         */
        public &lt;T&gt; T runAndGet( Supplier&lt;T&gt; contextSpecificAction ) {
<span class="fc" id="L292">            Neureka.get().setContext( visitedContext );</span>
<span class="fc" id="L293">            T result = contextSpecificAction.get();</span>
<span class="fc" id="L294">            Neureka.get().setContext( originalContext );</span>
<span class="fc" id="L295">            return result;</span>
        }

        /**
         *  Use this method to supply a lambda which will be executed in the {@link OperationContext}
         *  which produced this very {@link Runner} instance.
         *  After the lambda finished execution successfully the original {@link OperationContext} will be restored.
         *  This method distinguishes itself from the {@link #run(Runnable)} method because the
         *  lambda supplied to this method is expected to return something.                            &lt;br&gt;
         *  What may be returned is up to the user, one might want to return the result
         *  of a tensor operation which might be exclusively available in the used context.
         *  This method is doing the exact same thing as the {@link #runAndGet(Supplier)} method,
         *  however its name is shorter and it can even be omitted entirely when using Groovy.          &lt;br&gt;&lt;br&gt;
         *
         * @param contextSpecificAction The context specific action which will be execute in the {@link OperationContext} which produced this {@link Runner}.
         * @param &lt;T&gt; The return type of the supplied context action which will also be returned by this method.
         * @return The result of the supplied context action.
         */
        public &lt;T&gt; T call( Supplier&lt;T&gt; contextSpecificAction ) {
<span class="fc" id="L314">            return runAndGet( contextSpecificAction );</span>
        }

        /**
         *  Use this method to supply a lambda which will be executed in the {@link OperationContext}
         *  which produced this very {@link Runner} instance.
         *  After the lambda finished execution successfully the original {@link OperationContext} will be restored.
         *  This method distinguishes itself from the {@link #run(Runnable)} method because the
         *  lambda supplied to this method is expected to return something.                            &lt;br&gt;
         *  What may be returned is up to the user, one might want to return the result
         *  of a tensor operation which might be exclusively available in the used context.
         *  This method is doing the exact same thing as the {@link #runAndGet(Supplier)} method,
         *  however its name is shorter and it can even be omitted entirely when using Kotlin.          &lt;br&gt;&lt;br&gt;
         *
         * @param contextSpecificAction The context specific action which will be execute in the {@link OperationContext} which produced this {@link Runner}.
         * @param &lt;T&gt; The return type of the supplied context action which will also be returned by this method.
         * @return The result of the supplied context action.
         */
        public &lt;T&gt; T invoke( Supplier&lt;T&gt; contextSpecificAction ) {
<span class="fc" id="L333">            return call( contextSpecificAction );</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>