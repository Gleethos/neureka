<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BackendContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.backend.api</a> &gt; <span class="el_source">BackendContext.java</span></div><h1>BackendContext.java</h1><pre class="source lang-java linenums">package neureka.backend.api;


import neureka.Neureka;
import neureka.calculus.Function;
import neureka.calculus.FunctionCache;
import neureka.calculus.Functions;
import neureka.calculus.assembly.FunctionParser;
import neureka.calculus.assembly.ParseUtil;
import org.slf4j.Logger;

import java.util.*;
import java.util.function.Supplier;

/**
 *    Instances of this class are execution contexts hosting {@link Operation} instances which receive {@link neureka.Tsr}
 *    instances for execution.
 *    {@link BackendContext}s are managed by {@link Neureka}, a (thread-local) Singleton / Multiton library context.&lt;br&gt;
 *    Contexts are cloneable for testing purposes and to enable extending the backend dynamically.
 *    A given instance also hosts a reference to a {@link Functions} instance which exposes commonly used
 *    pre-instantiated {@link Function} implementation instances.
 *    &lt;br&gt;&lt;br&gt;
 *    The {@link BackendContext} initializes and stores {@link Operation} instances in various data structures
 *    for fast access and querying (Mostly used by the {@link ParseUtil} and {@link FunctionParser}).
 *    &lt;br&gt;
 *    {@link Operation}s are stored in simple list and map collections,
 *    namely: &lt;br&gt;
 *    The &quot;_instances&quot; list and the &quot;_lookup&quot; map as declared below.
 *    &lt;br&gt;
 *    &lt;br&gt;
 *    During class initialization concrete classes extending the {@link Operation} class
 *    are being instantiated in the static block below via a {@link ServiceLoader}.
 *    {@link BackendContext} instances expose a useful class called {@link Runner},
 *    which performs temporary context switching between the caller's context and this
 *    context during the execution of provided lambdas.
 *
 */
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">public final class BackendContext implements Cloneable</span>
{
<span class="fc" id="L40">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(BackendContext.class);</span>

<span class="fc" id="L42">    private final Extensions extensions = new Extensions();</span>

    /**
     *  A mapping between OperationType identifiers and their corresponding instances.
     */
    private final Map&lt;String, Operation&gt; _lookup;

    /**
     *  A list of all OperationType instances.
     */
    private final List&lt;Operation&gt; _operations;

    /**
     *  The number of operation instances stored in this context.
     */
    private int _size;

    // Global context and cache:
<span class="fc" id="L60">    private final FunctionCache _functionCache = new FunctionCache();</span>

    private final LazyRef&lt;Functions&gt; _getAutogradFunction;

    /**
     *  This {@link Functions} instance wraps pre-instantiated
     *  {@link Function} instances which are configured to not track their computational history.
     *  This means that no computation graph will be built by these instances.
     *  ( Computation graphs in Neureka are made of instances of the &quot;GraphNode&quot; class... )
     */
    private final LazyRef&lt;Functions&gt; _getFunction;


    /**
     *  A {@link Runner} wraps both the called context as well as the context of the caller in order
     *  to perform temporary context switching during the execution of lambdas passed to the {@link Runner}.
     *  After a given lambda was executed successfully, the original context will be restored in the current
     *  thread local {@link Neureka} instance through the {@link Neureka#setBackend(BackendContext)}) method.
     *
     * @return A lambda {@link Runner} which performs temporary context switching between the caller's context and this context.
     */
<span class="fc" id="L81">    public Runner runner() { return new Runner( this, Neureka.get().backend() ); }</span>

    /**
     * This method returns an unmodifiable view of the mapping between the {@link Operation#getIdentifier()} / {@link Operation#getOperator()} properties
     * and the {@link Operation} implementation instances to which they belong.
     * Query operations on the returned map &quot;read through&quot; to the specified map,
     * and attempts to modify the returned map, whether direct or via its collection views,
     * result in an {@link UnsupportedOperationException}.
     *
     * @return An unmodifiable mapping of {@link Operation} properties to the {@link Operation} instances to which they belong.
     */
<span class="fc" id="L92">    public Map&lt;String, Operation&gt; getOperationLookupMap() { return Collections.unmodifiableMap( _lookup ); }</span>

    /**
     * This method returns an unmodifiable view of the
     * list of {@link Operation} implementation instances managed by this context.
     * Query operations on the returned map &quot;read through&quot; to the specified map,
     * and attempts to modify the returned map, whether direct or via its collection views,
     * result in an {@link UnsupportedOperationException}.
     *
     * @return An unmodifiable view of the list of {@link Operation} implementation instances managed by this context
     */
<span class="fc" id="L103">    public List&lt;Operation&gt; getOperations() { return Collections.unmodifiableList( _operations); }</span>

    /**
     * @return The number of {@link Operation} instances stored on this {@link BackendContext}.
     */
<span class="fc" id="L108">    public int size() { return _size; }</span>

    /**
     * @return The {@link Function} and {@link neureka.Tsr} cache of this {@link BackendContext}
     */
<span class="fc" id="L113">    public FunctionCache getFunctionCache() { return _functionCache; }</span>

    /**
     *  This method returns a {@link Functions} instance which wraps pre-instantiated
     *  {@link Function} instances which are configured to not track their computational history.
     *  This means that no computation graph will be built by these instances.
     *  ( Computation graphs in Neureka are made of instances of the {@link neureka.autograd.GraphNode} class... )
     */
<span class="fc" id="L121">    public Functions getFunction() { return _getFunction.get(); }</span>

    /**
     *  This method returns a {@link Functions} instance which wraps pre-instantiated
     *  {@link Function} instances which are configured to track their computational history.
     *  This means that a computation graph will be built by these instances.
     *  ( Computation graphs in Neureka are made of instances of the {@link neureka.autograd.GraphNode} class... )
     *
     * @return A container object which exposes various types of functions with autograd support.
     */
<span class="fc" id="L131">    public Functions getAutogradFunction() { return _getAutogradFunction.get(); }</span>

    /**
     *  This creates a new context which is completely void of any {@link Operation} implementation instances.
     *  Use this constructor to test, debug, build and populate custom execution contexts.
     */
    public BackendContext()
<span class="fc" id="L138">    {</span>
<span class="fc" id="L139">        _getAutogradFunction = LazyRef.of( () -&gt; new Functions( true ) );</span>
<span class="fc" id="L140">        _getFunction = LazyRef.of( () -&gt; new Functions( false ) );</span>
<span class="fc" id="L141">        _lookup = new HashMap&lt;&gt;();</span>
<span class="fc" id="L142">        _operations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L143">        _size = 0;</span>
<span class="fc" id="L144">    }</span>

    /**
     *  This method registers {@link Operation} implementation instances in this {@link BackendContext}
     *  which is the thread local execution context receiving and processing {@link neureka.Tsr} instances...         &lt;br&gt;&lt;br&gt;
     *
     * @param operation The {@link Operation} instance which ought to be registered as part of this execution context.
     * @return This very context instance to allow for method chaining.
     */
    public BackendContext addOperation(Operation operation )
    {
<span class="fc" id="L155">        _operations.add( operation );</span>
<span class="fc" id="L156">        String function = operation.getIdentifier();</span>
<span class="fc" id="L157">        String operator = operation.getOperator();</span>
<span class="pc bpc" id="L158" title="2 of 4 branches missed.">        assert !_lookup.containsKey( operator );</span>
<span class="pc bpc" id="L159" title="2 of 4 branches missed.">        assert !_lookup.containsKey( function );</span>
<span class="fc" id="L160">        _lookup.put( operator, operation );</span>
<span class="fc" id="L161">        _lookup.put( function, operation );</span>
<span class="fc" id="L162">        _lookup.put( operator.toLowerCase(), operation );</span>
<span class="fc" id="L163">        if (</span>
                operator // TODO: Remove this! Its nonsensical and error prone!!
<span class="fc" id="L165">                        .replace((&quot;&quot;+((char)171)), &quot;&quot;)</span>
<span class="fc" id="L166">                        .replace((&quot;&quot;+((char)187)), &quot;&quot;)</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                        .matches(&quot;[a-z]&quot;)</span>
        ) {
<span class="fc bfc" id="L169" title="All 2 branches covered.">            if ( operator.contains( &quot;&quot;+((char)171) ) )</span>
<span class="fc" id="L170">                _lookup.put(operator.replace((&quot;&quot;+((char)171)), &quot;&lt;&lt;&quot;), operation);</span>

<span class="fc bfc" id="L172" title="All 2 branches covered.">            if ( operator.contains( &quot;&quot;+((char)187) ) )</span>
<span class="fc" id="L173">                _lookup.put(operator.replace((&quot;&quot;+((char)187)),&quot;&gt;&gt;&quot;), operation);</span>
        }
<span class="fc" id="L175">        _size++;</span>
<span class="fc" id="L176">        return this;</span>
    }

    /**
     * @param operation The {@link Operation} which may or may not be part of this {@link BackendContext}.
     * @return The truth value determining if the provided {@link Operation} is part of this {@link BackendContext}.
     */
    public boolean hasOperation( Operation operation ) {
<span class="fc" id="L184">        return _lookup.containsKey( operation.getIdentifier() );</span>
    }

    /**
     * @param operationIdentifier The {@link Operation} identifier which may be the function name or operator if present.
     * @return The truth value determining if the provided {@link Operation} is part of this {@link BackendContext}.
     */
    public boolean hasOperation( String operationIdentifier ) {
<span class="nc" id="L192">        return _lookup.containsKey( operationIdentifier );</span>
    }

    /**
     *  This method queries the operations in this {@link BackendContext}
     *  by a provided index integer targeting an entry in the list of {@link Operation} implementation instances
     *  sitting in this execution context.
     *
     * @param index The index of the operation.
     * @return The found Operation instance or null.
     */
<span class="fc" id="L203">    public Operation getOperation( int index ) { return _operations.get( index ); }</span>

    /**
     *  This method queries the operations in this BackendContext
     *  by a provided identifier which has to match the name of
     *  an existing operation.
     *
     * @param identifier The operation identifier, aka: its name.
     * @return The requested Operation or null.
     */
<span class="fc" id="L213">    public Operation getOperation( String identifier ) { return _lookup.getOrDefault( identifier, null ); }</span>

    /**
     *  This method produces a shallow copy of this {@link BackendContext}.
     *  This is useful for debugging, testing and extending contexts during runtime without side effects!  &lt;br&gt;
     *
     * @return A shallow copy of this operation / execution context.
     */
    @Override
    public BackendContext clone()
    {
<span class="fc" id="L224">        BackendContext clone = new BackendContext();</span>
<span class="fc" id="L225">        clone._size = _size;</span>
<span class="fc" id="L226">        clone._lookup.putAll( _lookup );</span>
<span class="fc" id="L227">        clone._operations.addAll( _operations );</span>
<span class="fc" id="L228">        return clone;</span>
    }

    public String toString() {
<span class="fc" id="L232">        return getClass().getSimpleName()+&quot;[size=&quot; + this.size() + &quot;]&quot;;</span>
    }

    /**
     *  Checks if this context has an instance of the provided {@link BackendExtension} type.
     *
     * @param extensionClass The type class of the extensions whose presents should be checked.
     * @param &lt;E&gt; The type parameter of the provided type class which requires the type to be an extension.
     * @return The truth value determining if the provided type is present.
     */
    public &lt;E extends BackendExtension&gt; boolean has( Class&lt;E&gt; extensionClass ) {
<span class="fc" id="L243">        return extensions.has( extensionClass );</span>
    }

    /**
     *  Returns an instance of the provided {@link BackendExtension} type
     *  or null if no extension of that type was found.
     */
    public &lt;E extends BackendExtension&gt; E get( Class&lt;E&gt; componentClass ) {
<span class="fc" id="L251">        return extensions.get( componentClass );</span>
    }

    /**
     * @return A list of all {@link BackendExtension} instances.
     */
    public List&lt;BackendExtension&gt; getExtensions() {
<span class="fc" id="L258">        return extensions.getAll( BackendExtension.class );</span>
    }

    /**
     *  Registers the provided {@link BackendExtension} instance
     *  which can then be accessed via {@link #get(Class)}.
     *
     * @param extension The backend extension component which ought to be stored by this.
     * @return This very {@link BackendContext} instance to allow for method chaining.
     */
    public BackendContext set( BackendExtension extension ) {
<span class="fc" id="L269">        extensions.set( extension );</span>
<span class="fc" id="L270">        return this;</span>
    }

    /**
     *  This is a very simple class with a single purpose, namely
     *  it exposes methods which receive lambda instances in order to then execute them
     *  in a given {@link BackendContext}, just to then switch back to the original context again.
     *  Switching a context simply means that the {@link BackendContext} which produced this {@link Runner}
     *  will temporarily be set as execution context for the current thread
     *  local {@link Neureka} instance.                                              &lt;br&gt;&lt;br&gt;
     *
     *  A {@link Runner} wraps both the called context as well as the context of the caller in order
     *  to perform this temporary context switching throughout the execution of the lambdas passed to the {@link Runner}.
     *  After a given lambda was executed, the original context will be restored in the current thread
     *  local {@link Neureka} instance through the {@link Neureka#setBackend(BackendContext)}) method.
     */
    public static class Runner
    {
        private final BackendContext originalContext;
        private final BackendContext visitedContext;

<span class="fc" id="L291">        private Runner(BackendContext visited, BackendContext originalContext ) {</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">            if ( visited == originalContext ) log.warn(&quot;Context runner encountered two identical contexts!&quot;);</span>
<span class="fc" id="L293">            this.originalContext = originalContext;</span>
<span class="fc" id="L294">            this.visitedContext = visited;</span>
<span class="fc" id="L295">        }</span>

        /**
         *  Use this method to supply a lambda which will be executed in the {@link BackendContext}
         *  which produced this very {@link Runner} instance.
         *  After the lambda finished execution successfully the original {@link BackendContext} will
         *  be restored for the current thread local {@link Neureka} instance.
         *
         * @param contextSpecificAction The context specific action which will be execute in the {@link BackendContext} which produced this {@link Runner}.
         * @return This very {@link Runner} instance to enable method chaining.
         */
        public Runner run( Runnable contextSpecificAction ) {
<span class="fc" id="L307">            Neureka.get().setBackend( visitedContext );</span>
<span class="fc" id="L308">            contextSpecificAction.run();</span>
<span class="fc" id="L309">            Neureka.get().setBackend( originalContext );</span>
<span class="fc" id="L310">            return this;</span>
        }

        /**
         *  Use this method to supply a lambda which will be executed in the {@link BackendContext}
         *  which produced this very {@link Runner} instance.
         *  After the lambda finished execution successfully the original {@link BackendContext} will be restored.
         *  This method distinguishes itself from the {@link #run(Runnable)} method because the
         *  lambda supplied to this method is expected to return something.
         *  What may be returned is up to the user, one might want to return the result
         *  of a tensor operation which might be exclusively available in the used context.
         *
         * @param contextSpecificAction The context specific action which will be execute in the {@link BackendContext} which produced this {@link Runner}.
         * @param &lt;T&gt; The return type of the supplied context action which will also be returned by this method.
         * @return The result of the supplied context action.
         */
        public &lt;T&gt; T runAndGet( Supplier&lt;T&gt; contextSpecificAction ) {
<span class="fc" id="L327">            Neureka.get().setBackend( visitedContext );</span>
<span class="fc" id="L328">            T result = contextSpecificAction.get();</span>
<span class="fc" id="L329">            Neureka.get().setBackend( originalContext );</span>
<span class="fc" id="L330">            return result;</span>
        }

        /**
         *  Use this method to supply a lambda which will be executed in the {@link BackendContext}
         *  which produced this very {@link Runner} instance.
         *  After the lambda finished execution successfully the original {@link BackendContext} will be restored.
         *  This method distinguishes itself from the {@link #run(Runnable)} method because the
         *  lambda supplied to this method is expected to return something.                            &lt;br&gt;
         *  What may be returned is up to the user, one might want to return the result
         *  of a tensor operation which might be exclusively available in the used context.
         *  This method is doing the exact same thing as the {@link #runAndGet(Supplier)} method,
         *  however its name is shorter and it can even be omitted entirely when using Groovy.          &lt;br&gt;&lt;br&gt;
         *
         * @param contextSpecificAction The context specific action which will be execute in the {@link BackendContext} which produced this {@link Runner}.
         * @param &lt;T&gt; The return type of the supplied context action which will also be returned by this method.
         * @return The result of the supplied context action.
         */
        public &lt;T&gt; T call( Supplier&lt;T&gt; contextSpecificAction ) {
<span class="fc" id="L349">            return runAndGet( contextSpecificAction );</span>
        }

        /**
         *  Use this method to supply a lambda which will be executed in the {@link BackendContext}
         *  which produced this very {@link Runner} instance.
         *  After the lambda finished execution successfully the original {@link BackendContext} will be restored.
         *  This method distinguishes itself from the {@link #run(Runnable)} method because the
         *  lambda supplied to this method is expected to return something.                            &lt;br&gt;
         *  What may be returned is up to the user, one might want to return the result
         *  of a tensor operation which might be exclusively available in the used context.
         *  This method is doing the exact same thing as the {@link #runAndGet(Supplier)} method,
         *  however its name is shorter and it can even be omitted entirely when using Kotlin.          &lt;br&gt;&lt;br&gt;
         *
         * @param contextSpecificAction The context specific action which will be execute in the {@link BackendContext} which produced this {@link Runner}.
         * @param &lt;T&gt; The return type of the supplied context action which will also be returned by this method.
         * @return The result of the supplied context action.
         */
        public &lt;T&gt; T invoke( Supplier&lt;T&gt; contextSpecificAction ) {
<span class="fc" id="L368">            return call( contextSpecificAction );</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>