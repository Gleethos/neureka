<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.function.factory.autograd</a> &gt; <span class="el_source">GraphNode.java</span></div><h1>GraphNode.java</h1><pre class="source lang-java linenums">package neureka.function.factory.autograd;

import neureka.Neureka;
import neureka.Tsr;
import neureka.acceleration.opencl.utility.WeakTensorReference;
import neureka.function.Function;
import neureka.function.factory.assembly.FunctionBuilder;

import java.lang.ref.WeakReference;
import java.util.*;
import java.util.List;
import java.util.function.BiConsumer;

/**
 *
 */
public class GraphNode
{

<span class="fc" id="L20">    private static Function MUL = FunctionBuilder.build(&quot;(I[0]*I[1])&quot;, false);</span>
<span class="fc" id="L21">    private static Function ADD = FunctionBuilder.build(&quot;(I[0]+I[1])&quot;, false);</span>
<span class="fc" id="L22">    private static Function CONV = FunctionBuilder.build(&quot;I[0]&gt;&gt;I[1]&gt;&gt;I[2]&quot;, false);</span>

    /**
     *  This gradient64 node is involved in auto-differentiation.
     * @return boolean
     */
    public boolean usesAD(){
<span class="fc bfc" id="L29" title="All 2 branches covered.">        return (_mode !=0);</span>
    }

    /**
     *  This node propagates forward.
     * @return boolean
     */
    public boolean usesForwardAD(){
<span class="fc bfc" id="L37" title="All 2 branches covered.">        return (_mode &gt;0);</span>
    }

    /**
     * This node propagates _backward.
     * @return boolean
     */
    public boolean usesReverseAD(){
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">        return (_mode &lt;0);</span>
    }

    /**
     *   modes:   |
     *  ----------+----------------------------------+-
     *  _mode == 0 | no Auto-Differentiation         |
     *  ----------+----------------------------------+-
     *  _mode &gt; 0  | forward Auto-Differentiation    |
     *  ----------+----------------------------------+-
     *  _mode &lt; 0  | _backward Auto-Differentiation   |
     *  ----------+----------------------------------+-
     *
     * @var int _mode
     * */
    private int _mode;

    /**
     * Recorded AbstractFunction.
     *
     * @var Function _function
     * */
    private Function _function;

    /**
     * Input tensors. ('Parents' of the tensor of this node)
     * */
    private GraphNode[] _parents;

    /**
     * The value of this graph node!
     * This node belongs to a tensor during creation but may lose
     * it during memory cleanup : _targetedCleanup(Tsr target) ! -&gt; payload might be deleted!
     */
    private Tsr _payload;

    /**
     * Keys are targets and values are gradients with respect to that target
     * Note: values can be null if the recorded function is of type 'reshape'!
     * Why? =&gt; because reshape operation does not need variables for _backward pass!
     * */
    //private TreeMap&lt;Tsr, Tsr&gt; _targets_derivatives;
    private TreeMap&lt;GraphNode, Tsr&gt; _targets_derivatives;

    /**
     * This flag is used merely once. It is a key component
     * of an optimization technique which only applies
     * gradients as soon as they are needed by a tensor (the tensor is used again).
     * If the flag Neureka.settings.ad.RETAIN_PENDING_ERROR_FOR_JITPROP is set to true
     * then errors values will accumulate whenever it makes sense.
     * This technique however uses more memory but will
     * improve performance for some networks substantially.
     */
<span class="fc" id="L98">    private boolean _targets_derivatives_are_deletable = true;</span>

    public  boolean reliesOnJustInTimeProp(){
<span class="fc bfc" id="L101" title="All 2 branches covered.">        return !_targets_derivatives_are_deletable;</span>
    }

    /**
     * &quot;Lock object&quot; for graph identity. (result caching)
     */
    private GraphLock _lock;

    /**
     *  The chain-rule states that the derivative of f(x) = h(g(x)) with respect to x is: g'(x) * h'(g(x))
     *  An example would be:
     *  f(x) = ((x*y)*z)
     *  f'(x) = (1*y) * (1*z) = z*y
     *  The values z,y or z*y must not be deleted as they are needed for back-propagation!
     */
<span class="fc" id="L116">    private boolean _is_used_as_derivative = false;</span>

    /**
     *
     */
    private List&lt;WeakReference&lt;GraphNode&gt;&gt; _children;

    /**
     *
     */
<span class="fc" id="L126">    private long _nid = -1;</span>
    //==================================================================================================================
    /**
     * Unique object which locks the payload to the current computation graph.
     * @return GraphLock
     */
    public GraphLock lock(){
<span class="fc" id="L133">        return _lock;</span>
    }

    /**
     * @param newLock
     */
    public synchronized void obtainLocking(GraphLock newLock){
<span class="fc" id="L140">        _lock = newLock;</span>
<span class="fc" id="L141">    }</span>

    /**
     * @param newChild which references it's input namely the parent (this) has...
     */
    private synchronized void _attachChild(GraphNode newChild){
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if(_children==null)_children = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L148">        WeakTensorReference&lt;GraphNode&gt; ref = new WeakTensorReference&lt;GraphNode&gt;(newChild, null);</span>
<span class="fc" id="L149">        _children.add(ref);</span>
<span class="fc" id="L150">    }</span>

    /**
     * @return the playload of this graph-node.
     */
    public Tsr getPayload(){
<span class="fc" id="L156">        return _payload;</span>
    }

    /**
     *
     * @return long Node-ID (Used for caching to avoid redundant computation within one computation graph)
     */
    public long nid(){
<span class="fc" id="L164">        return _nid;</span>
    }

    /**
     * Some nodes are not cachable! Namely: leave tensors! They are not results of
     * any function operation.
     * @return boolean
     */
    public boolean isCachable(){
<span class="fc bfc" id="L173" title="All 2 branches covered.">        return (this.nid()!=1);</span>
    }

    /**
     * This node (and the corresponding tensor) was not created by a function! (it's a leave tensor)
     * @return boolean
     */
    public boolean isLeave(){
<span class="pc bpc" id="L181" title="1 of 4 branches missed.">        return (_parents ==null &amp;&amp; _function==null);</span>
    }

    public boolean isGraphLeave(){
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if(isLeave()){</span>
<span class="fc" id="L186">            return true;</span>
        }
<span class="fc bfc" id="L188" title="All 2 branches covered.">        for(GraphNode p : _parents){</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if(p.lock()!=this.lock()){</span>
<span class="fc" id="L190">                return true;</span>
            }
        }
<span class="fc" id="L193">        return false;</span>
    }

    /**
     * @return if the tensor to which this graph node is attached has been deleted!
     */
    public boolean isVirtual(){
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        return _payload==null;</span>
    }

    public boolean isUsedAsDerivative(){
<span class="fc" id="L204">        return _is_used_as_derivative;</span>
    }

    /**
     * @param output
     * @param function
     * @param inputs
     * @param lock
     */
    public GraphNode(Tsr output, Function function, Tsr[] inputs, GraphLock lock)
<span class="fc" id="L214">    {</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if(output==null) throw new RuntimeException(&quot;[GraphNode]:(constructor): Payload must no be null!&quot;);</span>
<span class="fc bfc" id="L216" title="All 4 branches covered.">        _mode = (inputs!=null)? _modeOf(inputs, function):(output.rqsGradient())?1:0;</span>
<span class="fc" id="L217">        _function = function;</span>
<span class="fc" id="L218">        _lock = lock;</span>
<span class="fc" id="L219">        _payload = output;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if(inputs!=null){</span>
<span class="fc" id="L221">            _parents = new GraphNode[inputs.length];</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            for(int i=0; i&lt;inputs.length; i++){</span>
<span class="fc" id="L223">                _parents[i] = (GraphNode)inputs[i].find(GraphNode.class);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">                if(_parents[i]==null){</span>
<span class="nc" id="L225">                    throw new IllegalStateException(&quot;[GraphNode]:(constructor): Input tensors of a new graph-node must contain leave graph-nodes!&quot;);</span>
                } else {
<span class="fc" id="L227">                    _parents[i]._attachChild(this);</span>
                }
            }
        }else {
<span class="fc" id="L231">           _parents = null;</span>
        }
<span class="fc" id="L233">        output.add(this);</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if(_nid==-1){</span>
<span class="fc" id="L235">            long nid = 1;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if(_parents !=null){</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">                for(GraphNode n : _parents){</span>
<span class="fc" id="L238">                    nid*=n.getPayload().hashCode();</span>
                }
            }
<span class="fc bfc" id="L241" title="All 2 branches covered.">            if(_function !=null){</span>
<span class="fc" id="L242">                nid+=_function.hashCode();</span>
            }
<span class="fc" id="L244">            _nid = nid;</span>
        }
<span class="fc" id="L246">        _connect(this, output, inputs, function);</span>
<span class="fc" id="L247">    }</span>

    private void _connect(GraphNode node, Tsr output, Tsr[] inputs, Function function)
    {
        /** Returning if the above cannot form an AD computation graph! :
         * */
<span class="pc bpc" id="L253" title="1 of 4 branches missed.">        if(function==null || !function.isFlat()) return; // Leave nodes cannot be connected!!</span>

<span class="fc bfc" id="L255" title="All 4 branches covered.">        for(Tsr t : inputs) if(t.equals(output)) return;</span>
        //--------------------------------------------------------------------------------------
<span class="pc bpc" id="L257" title="1 of 4 branches missed.">        if(node.usesAD() &amp;&amp; function.isFlat())</span>
        {
            /**  Preparing for back propagation:  * */
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if(node.usesForwardAD())</span>
            {
<span class="fc" id="L262">                int i = 0;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">                for(Tsr input : inputs){</span>
<span class="fc" id="L264">                    GraphNode src_node = ((GraphNode) input.find(GraphNode.class));</span>
<span class="fc bfc" id="L265" title="All 4 branches covered.">                    if(src_node.function()!=null &amp;&amp; src_node.function().id()== Function.TYPES.LOOKUP.get(&quot;x&quot;)){</span>
<span class="fc" id="L266">                        Tsr d = function.derive(inputs, i);//TODO: is this ever used? / visited? - yes but why?</span>
<span class="fc" id="L267">                        node.put(src_node, d);// Sources created by x-mul are reverse-mode cases!</span>
<span class="fc" id="L268">                    }else{</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                        if(src_node.usesAD()){</span>
<span class="fc" id="L270">                            Tsr d = function.derive(inputs, i);</span>
<span class="pc bpc" id="L271" title="1 of 4 branches missed.">                            if(src_node.size()==0 &amp;&amp; node.size()==0){</span>
<span class="fc" id="L272">                                node.put((GraphNode) inputs[i].find(GraphNode.class), d);</span>
                            } else {
                            /**  Chain rule (forward) for every _gradient w.r.t. leaves (reverseAD or user leaves):* */
<span class="fc" id="L275">                                src_node.forEach(</span>
                                    (t, g)-&gt;{
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                                        if(node.has(t)){</span>
<span class="nc" id="L278">                                            Tsr dg = node.get(t);</span>
<span class="nc" id="L279">                                            node.put(t, ADD.activate(new Tsr[]{dg, MUL.activate(new Tsr[]{d, g})}));</span>
<span class="nc" id="L280">                                        }else{</span>
<span class="fc" id="L281">                                            node.put(t, MUL.activate(new Tsr[]{d, g}));</span>
                                        }//TODO: flag within src tsrs that grant that the tensor has been created by function constructor!
<span class="fc" id="L283">                                    });</span>
                            }
                        }
                    }
<span class="fc" id="L287">                    i++;</span>
                }
<span class="fc" id="L289">            }</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">            else if(node.usesReverseAD())</span>
            {
<span class="fc" id="L292">                int i = 0;</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">                for(Tsr input : inputs){</span>
<span class="fc" id="L294">                    GraphNode src_node = ((GraphNode) input.find(GraphNode.class));</span>
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">                    if(src_node.mode()!=0 || input.rqsGradient()){</span>
<span class="fc" id="L296">                        Tsr d = function.derive(inputs, i);</span>
<span class="fc" id="L297">                        node.put(src_node, d);// Add gradients with respect to every source tensor!</span>
                    }
<span class="fc" id="L299">                    i++;</span>
                }
            }
        }
        //--------------------------------------------------------------------------------------
<span class="fc" id="L304">    }</span>

    /**
     * Evaluate auto-grad mode:
     * @param inputs
     * @param function
     * @return int
     */
    private static int _modeOf(Tsr[] inputs, Function function)
    {
<span class="fc" id="L314">        int result_mode = 0;</span>
<span class="fc" id="L315">        int[] modes = new int[inputs.length];</span>
<span class="fc" id="L316">        int input_mode = 0;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        for(int Ii = 0; Ii&lt; inputs.length; Ii++){</span>
<span class="fc" id="L318">            GraphNode node = (GraphNode) inputs[Ii].find(GraphNode.class);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            modes[Ii] = (inputs[Ii].rqsGradient())?1:node.mode();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">            input_mode += (modes[Ii]!=0)?1:0;</span>
        }
<span class="fc bfc" id="L322" title="All 4 branches covered.">        if(input_mode==1 &amp;&amp; (&quot;x,&quot;.replace(function.type(), &quot;&quot;)==&quot;x,&quot;)){//Convolution and reshaping prohibit forward AD</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">            for(int Ii = 0; Ii&lt; inputs.length; Ii++){</span>
<span class="fc bfc" id="L324" title="All 4 branches covered.">                result_mode += (modes[Ii]==0)?0:(modes[Ii]&lt;0)?1:modes[Ii]+1;</span>
            }
        }else{
<span class="fc" id="L327">            result_mode = -input_mode;</span>
        }
<span class="fc bfc" id="L329" title="All 2 branches covered.">        result_mode = (&quot;&lt;&gt;&quot;.replace(function.type(), &quot;&quot;)==&quot;&lt;&gt;&quot;)?result_mode:0;</span>
<span class="fc" id="L330">        return result_mode;</span>
    }

    public void redundantGradientCleanup()
    {
<span class="fc bfc" id="L335" title="All 4 branches covered.">        if(_parents==null || mode()==0) return;//Gradient cleanup not needed in this case!</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        for(GraphNode node : _parents){</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            if(!node.isGraphLeave()){</span>
<span class="fc" id="L338">                node._payloadDeletionDive(_mode);</span>
<span class="fc" id="L339">                this.forEach((t, d)-&gt;{</span>
<span class="pc bpc" id="L340" title="1 of 4 branches missed.">                    if( this.mode()&gt;0 || d==node.getPayload() ) node._targetedCleanup(t);</span>
<span class="fc" id="L341">                });</span>
            }
        }
<span class="fc" id="L344">    }</span>

    /**
     * @param target
     * @return void
     */
    private void _targetedCleanup(GraphNode target)
    {// Find and remove redundant gradients sharing the same target: ... remove target payload if it is not used!
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if(target==null) throw new IllegalStateException(&quot;[GraphNode][_targetedCleanup]: target node must not be null!&quot;);</span>
<span class="pc bpc" id="L353" title="2 of 4 branches missed.">        if(_parents==null || mode()==0) return;//Gradient cleanup not needed in this case!</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        boolean cleanForwardAD = (mode()&gt;0);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if(cleanForwardAD)</span>
        {
<span class="fc" id="L357">            TreeMap&lt;Tsr, GraphNode&gt; blacklist = new TreeMap&lt;&gt;((a, b)-&gt;a.hashCode()-b.hashCode());</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            this.forEach((t, d)-&gt;{ if(t==target) blacklist.put(d, t); });</span>
<span class="fc" id="L359">            blacklist.forEach((b, t)-&gt;{</span>
<span class="pc bpc" id="L360" title="2 of 4 branches missed.">                if(!b.has(GraphNode.class) || !((GraphNode)b.find(GraphNode.class)).isLeave()){</span>
<span class="nc" id="L361">                    _targets_derivatives.remove(t);</span>
                    //TODO: get graph node and remove tensor reference! (this creates a virtual graph node (without payload!))
<span class="nc" id="L363">                    ((GraphNode)b.find(GraphNode.class))._payload = null;</span>
<span class="nc" id="L364">                    b.delete();</span>
                }
<span class="fc" id="L366">            });</span>
            // Recursive cleanup: (but only within the current graph!)
<span class="fc bfc" id="L368" title="All 4 branches covered.">            for(GraphNode node : _parents) if(!node.isGraphLeave()) node._targetedCleanup(target);</span>
<span class="fc" id="L369">        }else{</span>
<span class="fc" id="L370">            redundantGradientCleanup();</span>
        }
        /** sources can be deleted because unused graph nodes are already trimmed off the tree (targets remain!)
         * */
        //TODO: query target through inputs... delete forward mode AD node tensors!
        //_parents = null;//This might not be necessary...
<span class="fc" id="L376">    }</span>

    /**
     * The following properties must be true to allow payload deletion:
     * - The node is not a leave node! (Node supplied by user/from outside the locked graph)
     * - The node is not a tip node! (Output node... -&gt;($) )
     * - The node is part of a chain of forward-AD nodes (mode&gt;0)
     * - The mode value of the node is smaller then the largest of another within a chain of forward-AD ($)
     * =&gt;(The largest mode value is owned by 'the most recent derivative w.r.t some leave node')
     *
     * @param child_mode is used to assess if the payload in this node is useful for backpropagation!
     */
    private void _payloadDeletionDive(int child_mode)
    {
<span class="pc bpc" id="L390" title="1 of 4 branches missed.">        if(!this.isLeave() &amp;&amp; _payload!=null){</span>
<span class="fc bfc" id="L391" title="All 4 branches covered.">            if(_mode&gt;0 &amp;&amp; child_mode&gt;_mode){//If _payload==null return maybe?? (because graph already clean?)</span>
<span class="fc" id="L392">                _payload.remove(GraphNode.class);</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">                if(!_is_used_as_derivative) _payload.delete();</span>
<span class="fc" id="L394">                _payload = null;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            } else if(_mode&lt;0){</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">                if(!Neureka.settings.debug.KEEP_DERIVATIVE_TARGET_PAYLOADS){</span>
<span class="fc" id="L397">                    _payload.remove(GraphNode.class);</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">                    if(!_is_used_as_derivative) _payload.delete();</span>
<span class="fc" id="L399">                    _payload = null;</span>
                }
            }
        }
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if(_parents!=null){</span>
<span class="fc bfc" id="L404" title="All 4 branches covered.">            for(GraphNode n : _parents) if(!n.isGraphLeave()) n._payloadDeletionDive(_mode);</span>
        }
<span class="fc" id="L406">    }</span>

    /**
     * This method is called when a tensor is deleted and belongs to a computation graph.
     * All parents of this tensor will be checked if deletions is possible.
     * This is usually the case when the branch lineage is not tied to any other children!
     * @param child
     */
    public void extinguishLineageBy(GraphNode child)
    {
<span class="fc" id="L416">        boolean childrenAreDead = true;</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">        if(child==null){</span>
<span class="nc" id="L418">            throw new IllegalStateException(&quot;[GraphNode][extinguishLineageBy]: Error! Child is null!&quot;);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        } else if(this!=child){</span>
<span class="fc" id="L420">            boolean contains = false;</span>
<span class="fc" id="L421">            int index = 0;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">            for(int i=0; i&lt;_children.size(); i++){</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">                if(_children.get(i)!=null){</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">                    if(_children.get(i).get().equals(child)){</span>
<span class="fc" id="L425">                        contains = true;</span>
<span class="fc" id="L426">                        index = i;</span>
                    }
                }
            }
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">            if(!contains){</span>
<span class="nc" id="L431">                throw new IllegalStateException(&quot;[GraphNode][extinguishLineageBy]: Error! Child is not recognized by parent!&quot;);</span>
            }
<span class="fc" id="L433">            _children.set(index, null);</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">            for(int i=0; i&lt;_children.size(); i++){</span>
<span class="pc bpc" id="L435" title="1 of 4 branches missed.">                childrenAreDead = (_children.get(i)==null) &amp;&amp; childrenAreDead;</span>
            }
        }
<span class="fc bfc" id="L438" title="All 4 branches covered.">        if(childrenAreDead &amp;&amp; !this.isLeave()){</span>
<span class="pc bpc" id="L439" title="1 of 4 branches missed.">            if(_payload!=null &amp;&amp; !_is_used_as_derivative){</span>
<span class="fc" id="L440">                _payload.remove(GraphNode.class);</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">                if(child!=this){</span>
<span class="fc" id="L442">                    _payload.delete();</span>
                }
            }
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">            if(_parents!=null){</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">                for(GraphNode parent : _parents){</span>
<span class="fc" id="L447">                    parent.extinguishLineageBy(this);</span>
                }
            }
<span class="fc" id="L450">            _function = null;</span>
<span class="fc" id="L451">            _lock = null;</span>
<span class="fc" id="L452">            _parents = null;</span>
<span class="fc" id="L453">            _targets_derivatives = null;</span>
<span class="fc" id="L454">            _children = null;</span>
        }
<span class="fc" id="L456">    }</span>

    /**
     *
     * @param error
     */
    public void backward(Tsr error){
<span class="fc" id="L463">        Map&lt;GraphNode, PendingError&gt; pendings = new TreeMap&lt;&gt;((a, b)-&gt;a.hashCode()-b.hashCode());</span>
<span class="fc" id="L464">        _backward(error, pendings, true);</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">        if(!Neureka.settings.ad.RETAIN_PENDING_ERROR_FOR_JITPROP){</span>
<span class="fc" id="L466">            pendings.forEach((n, p)-&gt;{</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">                if(!p.isFullyAccumulated()) throw new IllegalStateException(&quot;[GraphNode][_backward]: Pending error has not received expected accumulation.&quot;);</span>
<span class="fc" id="L468">                n.backward(p.getAccumulatedError());//Continue backprop recursively!</span>
<span class="fc" id="L469">            });</span>
        } else {
<span class="fc" id="L471">            pendings.forEach((n, p)-&gt;{</span>
<span class="fc" id="L472">                n._carryPendingErrorToGradients(pendings);</span>
<span class="fc" id="L473">            });</span>
        }
<span class="fc" id="L475">        _deleteDerivativesRecursively();</span>
<span class="fc" id="L476">    }</span>

    /**
     * This method is called only if JIT-propagation is enabled.
     * It carries pending errors to the tensors requiring gradients which will
     * later on processed them just in time.
     * @param pendings
     */
    private void _carryPendingErrorToGradients(Map&lt;GraphNode, PendingError&gt; pendings){
<span class="fc" id="L485">        _targets_derivatives_are_deletable = false;</span>
<span class="fc" id="L486">        this.forEach((t, d)-&gt;t._carryPendingErrorToGradients(pendings));</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if(this.isLeave()){</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            if(_payload.rqsGradient()){</span>
<span class="fc" id="L489">                JITProp jit = (JITProp) _payload.find(JITProp.class);</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">                if(jit==null){</span>
<span class="fc" id="L491">                    jit = new JITProp(pendings);</span>
                } else {
<span class="nc" id="L493">                    jit.addPending(pendings);</span>
                }
<span class="fc" id="L495">                _payload.add(jit);</span>
            }
        }
<span class="fc" id="L498">        return;</span>
    }

    /**
     * This method traverses the graph and applies errors
     * to gradients.
     *
     * Note: JITProp is enabled when
     * this node is on the path between
     * a pending error and a tensor (rqsGradient==true) waiting
     * to receive it.
     * When _backward is called and JITProp is true then this means
     * the method has been called by a JITProp class (stored at rqsGradient==true tensors...)
     *
     * @param error which is originally supplied by the user but later on is modified by derivatives...
     * @return void
     */
    private void _backward(Tsr error, Map&lt;GraphNode, PendingError&gt; toBeBackpropagated, boolean force)
    {
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if(_payload.isOutsourced()){</span>
<span class="fc" id="L518">            _payload.device().add(error);</span>
        }
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (_payload.rqsGradient()) {</span>
<span class="fc" id="L521">            _payload.addToGradient(error);</span>
        }
<span class="fc bfc" id="L523" title="All 4 branches covered.">        if(!this.reliesOnJustInTimeProp() &amp;&amp; isLeave()){</span>
<span class="fc" id="L524">            JITProp jit = (JITProp) _payload.find(JITProp.class);//Get JIT-Prop node.</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">            if(jit!=null){</span>
<span class="nc" id="L526">                jit.noteFinished(toBeBackpropagated);//note pending errors and store them as 'done'</span>
            }
        }
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">        if(this.usesAD())</span>
        {
<span class="fc bfc" id="L531" title="All 2 branches covered.">            if(!this.reliesOnJustInTimeProp()){//false ==&gt; We are inside a 'Just-In-Time Backprop' process</span>
<span class="fc" id="L532">                int ADPaths = _numberOfADChildren();</span>
<span class="fc bfc" id="L533" title="All 6 branches covered.">                if(!force &amp;&amp; ADPaths&gt;1 &amp;&amp; !this.isLeave()){</span>
<span class="fc" id="L534">                    PendingError pending = toBeBackpropagated.get(this);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">                    if(pending==null){</span>
<span class="fc" id="L536">                        pending = new PendingError(error, ADPaths-1);</span>
<span class="fc" id="L537">                        toBeBackpropagated.put(this, pending);</span>
                    } else {
<span class="fc" id="L539">                        pending.accumulate(error);</span>
                    }
<span class="fc" id="L541">                    return;// NOTE: Multiple AD paths leading to one node in history will be accumulated first! (performance)</span>
                    //This optimization is a light version of JITProp. JITProp build on this!
                }
            }
            //if(_payload==null) throw new RuntimeException();
<span class="fc bfc" id="L546" title="All 2 branches covered.">            if(this.usesForwardAD()){//Using forward-AD derivatives for reverse-mode AD!:</span>
<span class="fc" id="L547">                this.forEach((t, d)-&gt;t._backward(MUL.activate(new Tsr[]{error, d}), toBeBackpropagated, false));</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">            }else if(this.usesReverseAD()){//Standard reverse mode-AD:</span>
<span class="fc" id="L549">                this.forEach((t, d)-&gt;{</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">                    if(_function.id()==Function.TYPES.LOOKUP.get(&quot;x&quot;)){// x operation requires individual operation!</span>
<span class="fc" id="L551">                        t._backward(CONV.activate(new Tsr[]{error, d, new Tsr(t.getPayload().shape(), 0)}), toBeBackpropagated, false);</span>
                    } else {//Normal elementwise backpropagation:
<span class="fc" id="L553">                        t._backward(MUL.activate(new Tsr[]{error, d}), toBeBackpropagated, false);</span>
                    }
<span class="fc" id="L555">                });</span>
            }
        }
<span class="fc" id="L558">    }</span>

    /**
     * This method is called after the backward call has been executed fully.
     * Derivatives are no longer used and will therefore be deleted when possible.
     * Deletion is forbidden if this node is flagged
     * as JITProp job. This means that the node is on the path between gradients
     * and pending error objects.
     * Only if JITProp is enabled (Neureka.settings.ad...) this flag will
     * deviate from its default state, namely: true!
     */
    private void  _deleteDerivativesRecursively(){
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if(!Neureka.settings.ad.RETAIN_GRAPH_DERIVATIVES_AFTER_BACKWARD){</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">            if(_targets_derivatives_are_deletable) _targets_derivatives = null;</span>
<span class="fc" id="L572">            this.forEach((t, d)-&gt;t._deleteDerivativesRecursively());</span>
        }
<span class="fc" id="L574">        return;</span>
    }


    /**
     * Counts how many child nodes will later on provide error values for back-propagation!
     * @return
     */
    private int _numberOfADChildren(){
<span class="fc" id="L583">        int count = 0;</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">        if(_children!=null){</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">            for(WeakReference weak : _children){</span>
<span class="pc bpc" id="L586" title="1 of 4 branches missed.">                if(weak!=null &amp;&amp; weak.get()!=null){</span>
<span class="fc" id="L587">                    GraphNode child = (GraphNode) weak.get();</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">                    if(child.usesAD()){</span>
<span class="fc" id="L589">                        count++;</span>
                    }
                }
<span class="fc" id="L592">            }</span>
        }
<span class="fc" id="L594">        return count;</span>
    }

    /**
     * @return int
     */
    public int mode(){
<span class="fc" id="L601">        return _mode;</span>
    }

    /**
     * @return Function
     */
    public Function function(){
<span class="fc" id="L608">        return _function;</span>
    }

    /**
     * @param target nodes are graph nodes which contain either tensors requiring errors for accumulation and/or more targets.
     * @param derivative tensors are used during back-propagation in order to distribute an error throughout the graph.
     */
    public void put(GraphNode target, Tsr derivative){
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if(_targets_derivatives ==null){</span>
<span class="fc" id="L617">            _targets_derivatives = new TreeMap&lt;&gt;((a, b)-&gt;a.hashCode()-b.hashCode());</span>
        }
<span class="fc" id="L619">        _targets_derivatives.put(target, derivative);</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">        if(derivative.has(GraphNode.class)){</span>
<span class="fc" id="L621">            ((GraphNode)derivative.find(GraphNode.class))._is_used_as_derivative = true;</span>
        }
<span class="fc" id="L623">    }</span>

    /**
     * @param target
     * @return Tsr
     */
    public Tsr get(GraphNode target){
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if(_targets_derivatives ==null) return null;</span>
<span class="nc" id="L631">        return _targets_derivatives.get(target);</span>
    }

    /**
     *
     * @param target
     * @return boolean
     */
    public boolean has(GraphNode target){
<span class="fc bfc" id="L640" title="All 2 branches covered.">        if(_targets_derivatives ==null) return false;</span>
<span class="fc" id="L641">        return _targets_derivatives.containsKey(target);</span>
    }

    /**
     * @return Map&lt;Tsr, Tsr&gt;
     */
    public Map&lt;GraphNode, Tsr&gt; getMap(){
<span class="nc" id="L648">        return _targets_derivatives;</span>
    }

    /**
     * @return int
     */
    public int size(){
<span class="fc bfc" id="L655" title="All 2 branches covered.">        return (_targets_derivatives !=null)?this._targets_derivatives.size():0;</span>
    }

    /**
     * @param action
     * @return void
     */
    public void forEach(BiConsumer&lt;GraphNode, Tsr&gt; action){
<span class="fc bfc" id="L663" title="All 2 branches covered.">        if(_targets_derivatives ==null) return;</span>
<span class="fc" id="L664">        _targets_derivatives.forEach(action);</span>
<span class="fc" id="L665">    }</span>

    public String type(){
<span class="fc" id="L668">        String type = &quot;&quot;;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">        if(this.isLeave()) type+=&quot;LEAVE&quot;;</span>
<span class="fc" id="L670">        else type += &quot;BRANCH&quot;;</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">        if(_payload==null) type = type+&quot; DELETED&quot;;</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">        else if(_payload.rqsGradient()) type += &quot; RQS GRADIENT&quot;;</span>
<span class="fc" id="L673">        return type;</span>
    }

    @Override
    public String toString(){
<span class="nc" id="L678">        return toString(&quot;&quot;);</span>
    }


    public String toString(String m){
<span class="fc bfc" id="L683" title="All 2 branches covered.">        if(m.contains(&quot;g&quot;)){</span>
<span class="fc" id="L684">            return &quot;]&gt; LOCK: &quot;+lock()+&quot; |&gt; GRAPH:\n]\n&quot; +_toString(&quot;]    0&quot;, true) +&quot;\n]\n]|END|&gt;&quot;;</span>
        }
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        if(m.contains(&quot;v&quot;)){</span>
<span class="fc" id="L687">            return &quot;(&quot;+this.type()+&quot;): [NID:&quot;+Long.toHexString(nid())+&quot;]:&lt;(  &quot;</span>
<span class="fc bfc" id="L688" title="All 4 branches covered.">                    +&quot;f&quot;+((_function==null)?&quot;(NONE)&quot;:_function)+&quot; =&gt; &quot;+((_payload==null)?&quot;NULL&quot;:_payload.toString(&quot;cs&quot;))+&quot;  )&gt;&quot;;</span>

        } else {
<span class="nc bnc" id="L691" title="All 2 branches missed.">            return &quot;[NID:&quot;+Long.toHexString(nid())+&quot;]:( &quot;+((_payload==null)?&quot;NULL&quot;:_payload.toString(&quot;cs&quot;))+&quot; )&quot;;</span>
        }

    }

    private String _toString(String deep, boolean isLast){//int depth){
<span class="fc bfc" id="L697" title="All 2 branches covered.">        String delimiter = ((isLast)?(&quot;    &quot;):(&quot;|   &quot;));</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">        String arrow = ((char)187)+&quot;&quot;+((_parents!=null)?(String.valueOf(_parents.length)):&quot;0&quot;)+((char)187);</span>
<span class="fc" id="L699">        String asString = deep+</span>
<span class="fc" id="L700">            arrow+ toString(&quot;v&quot;);</span>
<span class="fc" id="L701">        deep = deep.substring(0, deep.length()-1);</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">        if(_parents!=null){</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">            asString += &quot;\n&quot;+deep+((isLast)?&quot;   \\\n&quot;:&quot;|  \\\n&quot;);</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">            for(int i=0; i&lt;_parents.length; i++){</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">                boolean last = (i==_parents.length-1);</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">                asString += ((i!=0)?deep+delimiter+&quot;|\n&quot;:&quot;&quot;);</span>
<span class="fc" id="L707">                asString+=(_parents[i]._toString(deep+delimiter+i, last)+&quot;\n&quot;);</span>
            }
<span class="fc" id="L709">            asString = asString.substring(0, asString.length()-1);</span>
        }
<span class="fc" id="L711">        return asString;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>