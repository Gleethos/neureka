<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.function.factory.autograd</a> &gt; <span class="el_source">GraphNode.java</span></div><h1>GraphNode.java</h1><pre class="source lang-java linenums">package neureka.function.factory.autograd;

import neureka.Neureka;
import neureka.Tsr;
import neureka.acceleration.opencl.utility.WeakTensorReference;
import neureka.function.Function;
import neureka.function.factory.assembly.FunctionBuilder;

import java.lang.ref.WeakReference;
import java.util.*;
import java.util.List;
import java.util.function.BiConsumer;

/**
 *
 */
public class GraphNode
{

<span class="fc" id="L20">    private static Function MUL = FunctionBuilder.build(&quot;(I[0]*I[1])&quot;, false);</span>
<span class="fc" id="L21">    private static Function ADD = FunctionBuilder.build(&quot;(I[0]+I[1])&quot;, false);</span>
<span class="fc" id="L22">    private static Function CONV = FunctionBuilder.build(&quot;I[0]&gt;&gt;I[1]&gt;&gt;I[2]&quot;, false);</span>

    /**
     *  This gradient64 node is involved in auto-differentiation.
     * @return boolean
     */
    public boolean usesAD(){
<span class="fc bfc" id="L29" title="All 2 branches covered.">        return (_mode !=0);</span>
    }

    /**
     *  This node propagates forward.
     * @return boolean
     */
    public boolean usesForwardAD(){
<span class="fc bfc" id="L37" title="All 2 branches covered.">        return (_mode &gt;0);</span>
    }

    /**
     * This node propagates _backward.
     * @return boolean
     */
    public boolean usesReverseAD(){
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">        return (_mode &lt;0);</span>
    }

    /**
     *   modes:   |
     *  ----------+----------------------------------+-
     *  _mode == 0 | no Auto-Differentiation         |
     *  ----------+----------------------------------+-
     *  _mode &gt; 0  | forward Auto-Differentiation    |
     *  ----------+----------------------------------+-
     *  _mode &lt; 0  | _backward Auto-Differentiation   |
     *  ----------+----------------------------------+-
     *
     * @var int _mode
     * */
    private int _mode;

    /**
     * Recorded AbstractFunction.
     *
     * @var Function _function
     * */
    private Function _function;

    /**
     * Input tensors. ('Parents' of the tensor of this node)
     * */
    private GraphNode[] _parents;

    /**
     * The value of this graph node!
     * This node belongs to a tensor during creation but may lose
     * it during memory cleanup : _targetedCleanup(Tsr target) ! -&gt; payload might be deleted!
     */
    private Tsr _payload;

    /**
     * Keys are targets and values are gradients with respect to that target
     * Note: values can be null if the recorded function is of type 'reshape'!
     * Why? =&gt; because reshape operation does not need variables for _backward pass!
     * */
    //private TreeMap&lt;Tsr, Tsr&gt; _targets_derivatives;
    private TreeMap&lt;GraphNode, Tsr&gt; _targets_derivatives;
    /**
     * &quot;Lock object&quot; for graph identity. (result caching)
     */
    private GraphLock _lock;

    /**
     *  The chain-rule states that the derivative of f(x) = h(g(x)) with respect to x is: g'(x) * h'(g(x))
     *  An example would be:
     *  f(x) = ((x*y)*z)
     *  f'(x) = (1*y) * (1*z) = z*y
     *  The values z,y or z*y must not be deleted as they are needed for back-propagation!
     */
<span class="fc" id="L100">    private boolean _is_used_as_derivative = false;</span>

    /**
     *
     */
    private List&lt;WeakReference&lt;GraphNode&gt;&gt; _children;

    /**
     *
     */
<span class="fc" id="L110">    private long _nid = -1;</span>
    //==================================================================================================================
    /**
     * Unique object which locks the payload to the current computation graph.
     * @return GraphLock
     */
    public GraphLock lock(){
<span class="fc" id="L117">        return _lock;</span>
    }

    /**
     * @param newLock
     */
    public synchronized void obtainLocking(GraphLock newLock){
<span class="fc" id="L124">        _lock = newLock;</span>
<span class="fc" id="L125">    }</span>

    /**
     * @param newChild which references it's input namely the parent (this) has...
     */
    private synchronized void _attachChild(GraphNode newChild){
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if(_children==null)_children = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L132">        WeakTensorReference&lt;GraphNode&gt; ref = new WeakTensorReference&lt;GraphNode&gt;(newChild, null);</span>
<span class="fc" id="L133">        _children.add(ref);</span>
<span class="fc" id="L134">    }</span>

    /**
     * @return the playload of this graph-node.
     */
    public Tsr getPayload(){
<span class="fc" id="L140">        return _payload;</span>
    }

    /**
     *
     * @return long Node-ID (Used for caching to avoid redundant computation within one computation graph)
     */
    public long nid(){
<span class="fc" id="L148">        return _nid;</span>
    }

    /**
     * Some nodes are not cachable! Namely: leave tensors! They are not results of
     * any function operation.
     * @return boolean
     */
    public boolean isCachable(){
<span class="fc bfc" id="L157" title="All 2 branches covered.">        return (this.nid()!=1);</span>
    }

    /**
     * This node (and the corresponding tensor) was not created by a function! (it's a leave tensor)
     * @return boolean
     */
    public boolean isLeave(){
<span class="pc bpc" id="L165" title="1 of 4 branches missed.">        return (_parents ==null &amp;&amp; _function==null);</span>
    }

    public boolean isGraphLeave(){
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if(isLeave()){</span>
<span class="fc" id="L170">            return true;</span>
        }
<span class="fc bfc" id="L172" title="All 2 branches covered.">        for(GraphNode p : _parents){</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            if(p.lock()!=this.lock()){</span>
<span class="fc" id="L174">                return true;</span>
            }
        }
<span class="fc" id="L177">        return false;</span>
    }

    /**
     * @return if the tensor to which this graph node is attached has been deleted!
     */
    public boolean isVirtual(){
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        return _payload==null;</span>
    }

    public boolean isUsedAsDerivative(){
<span class="fc" id="L188">        return _is_used_as_derivative;</span>
    }

    /**
     * @param output
     * @param function
     * @param inputs
     * @param lock
     */
    public GraphNode(Tsr output, Function function, Tsr[] inputs, GraphLock lock)
<span class="fc" id="L198">    {</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if(output==null) throw new RuntimeException(&quot;[GraphNode]:(constructor): Payload must no be null!&quot;);</span>
<span class="fc bfc" id="L200" title="All 4 branches covered.">        _mode = (inputs!=null)? _modeOf(inputs, function):(output.rqsGradient())?1:0;</span>
<span class="fc" id="L201">        _function = function;</span>
<span class="fc" id="L202">        _lock = lock;</span>
<span class="fc" id="L203">        _payload = output;</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if(inputs!=null){</span>
<span class="fc" id="L205">            _parents = new GraphNode[inputs.length];</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            for(int i=0; i&lt;inputs.length; i++){</span>
<span class="fc" id="L207">                _parents[i] = (GraphNode)inputs[i].find(GraphNode.class);</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">                if(_parents[i]==null){</span>
<span class="nc" id="L209">                    throw new IllegalStateException(&quot;[GraphNode]:(constructor): Input tensors of a new graph-node must contain leave graph-nodes!&quot;);</span>
                } else {
<span class="fc" id="L211">                    _parents[i]._attachChild(this);</span>
                }
            }
        }else {
<span class="fc" id="L215">           _parents = null;</span>
        }
<span class="fc" id="L217">        output.add(this);</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if(_nid==-1){</span>
<span class="fc" id="L219">            long nid = 1;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if(_parents !=null){</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">                for(GraphNode n : _parents){</span>
<span class="fc" id="L222">                    nid*=n.getPayload().hashCode();</span>
                }
            }
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if(_function !=null){</span>
<span class="fc" id="L226">                nid+=_function.hashCode();</span>
            }
<span class="fc" id="L228">            _nid = nid;</span>
        }
<span class="fc" id="L230">        _connect(this, output, inputs, function);</span>
<span class="fc" id="L231">    }</span>

    private void _connect(GraphNode node, Tsr output, Tsr[] inputs, Function function)
    {
        /** Returning if the above cannot form an AD computation graph! :
         * */
<span class="pc bpc" id="L237" title="1 of 4 branches missed.">        if(function==null || !function.isFlat()) return; // Leave nodes cannot be connected!!</span>

<span class="fc bfc" id="L239" title="All 4 branches covered.">        for(Tsr t : inputs) if(t.equals(output)) return;</span>
        //--------------------------------------------------------------------------------------
<span class="pc bpc" id="L241" title="1 of 4 branches missed.">        if(node.usesAD() &amp;&amp; function.isFlat())</span>
        {
            /**  Preparing for back propagation:  * */
<span class="fc bfc" id="L244" title="All 2 branches covered.">            if(node.usesForwardAD())</span>
            {
<span class="fc" id="L246">                int i = 0;</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">                for(Tsr input : inputs){</span>
<span class="fc" id="L248">                    GraphNode src_node = ((GraphNode) input.find(GraphNode.class));</span>
<span class="fc bfc" id="L249" title="All 4 branches covered.">                    if(src_node.function()!=null &amp;&amp; src_node.function().id()== Function.TYPES.LOOKUP.get(&quot;x&quot;)){</span>
<span class="fc" id="L250">                        Tsr d = function.derive(inputs, i);//TODO: is this ever used? / visited? - yes but why?</span>
<span class="fc" id="L251">                        node.put(src_node, d);// Sources created by x-mul are reverse-mode cases!</span>
<span class="fc" id="L252">                    }else{</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                        if(src_node.usesAD()){</span>
<span class="fc" id="L254">                            Tsr d = function.derive(inputs, i);</span>
<span class="pc bpc" id="L255" title="1 of 4 branches missed.">                            if(src_node.size()==0 &amp;&amp; node.size()==0){</span>
<span class="fc" id="L256">                                node.put((GraphNode) inputs[i].find(GraphNode.class), d);</span>
                            } else {
                            /**  Chain rule (forward) for every _gradient w.r.t. leaves (reverseAD or user leaves):* */
<span class="fc" id="L259">                                src_node.forEach(</span>
                                    (t, g)-&gt;{
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">                                        if(node.has(t)){</span>
<span class="nc" id="L262">                                            Tsr dg = node.get(t);</span>
<span class="nc" id="L263">                                            node.put(t, ADD.activate(new Tsr[]{dg, MUL.activate(new Tsr[]{d, g})}));</span>
<span class="nc" id="L264">                                        }else{</span>
<span class="fc" id="L265">                                            node.put(t, MUL.activate(new Tsr[]{d, g}));</span>
                                        }//TODO: flag within src tsrs that grant that the tensor has been created by function constructor!
<span class="fc" id="L267">                                    });</span>
                            }
                        }
                    }
<span class="fc" id="L271">                    i++;</span>
                }
<span class="fc" id="L273">            }</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">            else if(node.usesReverseAD())</span>
            {
<span class="fc" id="L276">                int i = 0;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                for(Tsr input : inputs){</span>
<span class="fc" id="L278">                    GraphNode src_node = ((GraphNode) input.find(GraphNode.class));</span>
<span class="pc bpc" id="L279" title="1 of 4 branches missed.">                    if(src_node.mode()!=0 || input.rqsGradient()){</span>
<span class="fc" id="L280">                        Tsr d = function.derive(inputs, i);</span>
<span class="fc" id="L281">                        node.put(src_node, d);// Add gradients with respect to every source tensor!</span>
                    }
<span class="fc" id="L283">                    i++;</span>
                }
            }
        }
        //--------------------------------------------------------------------------------------
<span class="fc" id="L288">    }</span>

    /**
     * Evaluate auto-grad mode:
     * @param inputs
     * @param function
     * @return int
     */
    private static int _modeOf(Tsr[] inputs, Function function)
    {
<span class="fc" id="L298">        int result_mode = 0;</span>
<span class="fc" id="L299">        int[] modes = new int[inputs.length];</span>
<span class="fc" id="L300">        int input_mode = 0;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        for(int Ii = 0; Ii&lt; inputs.length; Ii++){</span>
<span class="fc" id="L302">            GraphNode node = (GraphNode) inputs[Ii].find(GraphNode.class);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            modes[Ii] = (inputs[Ii].rqsGradient())?1:node.mode();</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            input_mode += (modes[Ii]!=0)?1:0;</span>
        }
<span class="fc bfc" id="L306" title="All 4 branches covered.">        if(input_mode==1 &amp;&amp; (&quot;x,&quot;.replace(function.type(), &quot;&quot;)==&quot;x,&quot;)){//Convolution and reshaping prohibit forward AD</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">            for(int Ii = 0; Ii&lt; inputs.length; Ii++){</span>
<span class="fc bfc" id="L308" title="All 4 branches covered.">                result_mode += (modes[Ii]==0)?0:(modes[Ii]&lt;0)?1:modes[Ii]+1;</span>
            }
        }else{
<span class="fc" id="L311">            result_mode = -input_mode;</span>
        }
<span class="fc bfc" id="L313" title="All 2 branches covered.">        result_mode = (&quot;&lt;&gt;&quot;.replace(function.type(), &quot;&quot;)==&quot;&lt;&gt;&quot;)?result_mode:0;</span>
<span class="fc" id="L314">        return result_mode;</span>
    }

    public void redundantGradientCleanup()
    {
<span class="fc bfc" id="L319" title="All 4 branches covered.">        if(_parents==null || mode()==0) return;//Gradient cleanup not needed in this case!</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        for(GraphNode node : _parents){</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">            if(!node.isGraphLeave()){</span>
<span class="fc" id="L322">                node._payloadDeletionDive(_mode);</span>
<span class="fc" id="L323">                this.forEach((t, d)-&gt;{</span>
<span class="pc bpc" id="L324" title="1 of 4 branches missed.">                    if( this.mode()&gt;0 || d==node.getPayload() ) node._targetedCleanup(t);</span>
<span class="fc" id="L325">                });</span>
            }
        }
<span class="fc" id="L328">    }</span>

    /**
     * @param target
     * @return void
     */
    private void _targetedCleanup(GraphNode target)
    {// Find and remove redundant gradients sharing the same target: ... remove target payload if it is not used!
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if(target==null) throw new IllegalStateException(&quot;[GraphNode][_targetedCleanup]: target node must not be null!&quot;);</span>
<span class="pc bpc" id="L337" title="2 of 4 branches missed.">        if(_parents==null || mode()==0) return;//Gradient cleanup not needed in this case!</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        boolean cleanForwardAD = (mode()&gt;0);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">        if(cleanForwardAD)</span>
        {
<span class="fc" id="L341">            TreeMap&lt;Tsr, GraphNode&gt; blacklist = new TreeMap&lt;&gt;((a, b)-&gt;a.hashCode()-b.hashCode());</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            this.forEach((t, d)-&gt;{ if(t==target) blacklist.put(d, t); });</span>
<span class="fc" id="L343">            blacklist.forEach((b, t)-&gt;{</span>
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">                if(!b.has(GraphNode.class) || !((GraphNode)b.find(GraphNode.class)).isLeave()){</span>
<span class="nc" id="L345">                    _targets_derivatives.remove(t);</span>
                    //TODO: get graph node and remove tensor reference! (this creates a virtual graph node (without payload!))
<span class="nc" id="L347">                    ((GraphNode)b.find(GraphNode.class))._payload = null;</span>
<span class="nc" id="L348">                    b.delete();</span>
                }
<span class="fc" id="L350">            });</span>
            // Recursive cleanup: (but only within the current graph!)
<span class="fc bfc" id="L352" title="All 4 branches covered.">            for(GraphNode node : _parents) if(!node.isGraphLeave()) node._targetedCleanup(target);</span>
<span class="fc" id="L353">        }else{</span>
<span class="fc" id="L354">            redundantGradientCleanup();</span>
        }
        /** sources can be deleted because unused graph nodes are already trimmed off the tree (targets remain!)
         * */
        //TODO: query target through inputs... delete forward mode AD node tensors!
        //_parents = null;//This might not be necessary...
<span class="fc" id="L360">    }</span>

    /**
     * The following properties must be true to allow payload deletion:
     * - The node is not a leave node! (Node supplied by user/from outside the locked graph)
     * - The node is not a tip node! (Output node... -&gt;($) )
     * - The node is part of a chain of forward-AD nodes (mode&gt;0)
     * - The mode value of the node is smaller then the largest of another within a chain of forward-AD ($)
     * =&gt;(The largest mode value is owned by 'the most recent derivative w.r.t some leave node')
     *
     * @param child_mode is used to assess if the payload in this node is useful for backpropagation!
     */
    private void _payloadDeletionDive(int child_mode)
    {
<span class="pc bpc" id="L374" title="1 of 4 branches missed.">        if(!this.isLeave() &amp;&amp; _payload!=null){</span>
<span class="fc bfc" id="L375" title="All 4 branches covered.">            if(_mode&gt;0 &amp;&amp; child_mode&gt;_mode){//If _payload==null return maybe?? (because graph already clean?)</span>
<span class="fc" id="L376">                _payload.remove(GraphNode.class);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">                if(!_is_used_as_derivative) _payload.delete();</span>
<span class="fc" id="L378">                _payload = null;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">            } else if(_mode&lt;0){</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">                if(!Neureka.settings.debug.KEEP_DERIVATIVE_TARGET_PAYLOADS){</span>
<span class="fc" id="L381">                    _payload.remove(GraphNode.class);</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">                    if(!_is_used_as_derivative) _payload.delete();</span>
<span class="fc" id="L383">                    _payload = null;</span>
                }
            }
        }
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if(_parents!=null){</span>
<span class="fc bfc" id="L388" title="All 4 branches covered.">            for(GraphNode n : _parents) if(!n.isGraphLeave()) n._payloadDeletionDive(_mode);</span>
        }
<span class="fc" id="L390">    }</span>

    /**
     * This method is called when a tensor is deleted and belongs to a computation graph.
     * All parents of this tensor will be checked if deletions is possible.
     * This is usually the case when the branch lineage is not tied to any other children!
     * @param child
     */
    public void extinguishLineageBy(GraphNode child)
    {
<span class="fc" id="L400">        boolean childrenAreDead = true;</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if(child==null){</span>
<span class="nc" id="L402">            throw new IllegalStateException(&quot;[GraphNode][extinguishLineageBy]: Error! Child is null!&quot;);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">        } else if(this!=child){</span>
<span class="fc" id="L404">            boolean contains = false;</span>
<span class="fc" id="L405">            int index = 0;</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">            for(int i=0; i&lt;_children.size(); i++){</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                if(_children.get(i)!=null){</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                    if(_children.get(i).get().equals(child)){</span>
<span class="fc" id="L409">                        contains = true;</span>
<span class="fc" id="L410">                        index = i;</span>
                    }
                }
            }
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            if(!contains){</span>
<span class="nc" id="L415">                throw new IllegalStateException(&quot;[GraphNode][extinguishLineageBy]: Error! Child is not recognized by parent!&quot;);</span>
            }
<span class="fc" id="L417">            _children.set(index, null);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">            for(int i=0; i&lt;_children.size(); i++){</span>
<span class="pc bpc" id="L419" title="1 of 4 branches missed.">                childrenAreDead = (_children.get(i)==null) &amp;&amp; childrenAreDead;</span>
            }
        }
<span class="fc bfc" id="L422" title="All 4 branches covered.">        if(childrenAreDead &amp;&amp; !this.isLeave()){</span>
<span class="pc bpc" id="L423" title="1 of 4 branches missed.">            if(_payload!=null &amp;&amp; !_is_used_as_derivative){</span>
<span class="fc" id="L424">                _payload.remove(GraphNode.class);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">                if(child!=this){</span>
<span class="fc" id="L426">                    _payload.delete();</span>
                }
            }
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">            if(_parents!=null){</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">                for(GraphNode parent : _parents){</span>
<span class="fc" id="L431">                    parent.extinguishLineageBy(this);</span>
                }
            }
<span class="fc" id="L434">            _function = null;</span>
<span class="fc" id="L435">            _lock = null;</span>
<span class="fc" id="L436">            _parents = null;</span>
<span class="fc" id="L437">            _targets_derivatives = null;</span>
<span class="fc" id="L438">            _children = null;</span>
        }
<span class="fc" id="L440">    }</span>

    /**
     *
     * @param error
     */
    public void backward(Tsr error){
<span class="fc" id="L447">        Map&lt;GraphNode, PendingError&gt; pendings = new TreeMap&lt;&gt;((a, b)-&gt;a.hashCode()-b.hashCode());</span>
<span class="fc" id="L448">        _backward(error, pendings, true);</span>
<span class="fc" id="L449">        pendings.forEach((n, p)-&gt;{</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">            if(!p.isFullyAccumulated()) throw new IllegalStateException(&quot;[GraphNode][_backward]: Pending error has not received expected accumulation.&quot;);</span>
<span class="fc" id="L451">            n.backward(p.getAccumulatedError());//Continue backprop recursively!</span>
<span class="fc" id="L452">        });</span>
<span class="fc" id="L453">    }</span>

    /**
     * @param error
     * @return void
     */
    private void _backward(Tsr error, Map&lt;GraphNode, PendingError&gt; toBeBackpropagated, boolean force)
    {
<span class="fc bfc" id="L461" title="All 2 branches covered.">        if(_payload.isOutsourced()){</span>
<span class="fc" id="L462">            _payload.device().add(error);</span>
        }
<span class="fc bfc" id="L464" title="All 2 branches covered.">        if (_payload.rqsGradient()) {</span>
<span class="fc" id="L465">            _payload.addToGradient(error);</span>
        }
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if(this.usesAD())</span>
        {
<span class="fc" id="L469">            int ADPaths = _numberOfADChildren();</span>
<span class="fc bfc" id="L470" title="All 6 branches covered.">            if(!force &amp;&amp; ADPaths&gt;1 &amp;&amp; !this.isLeave()){</span>
<span class="fc" id="L471">                PendingError pending = toBeBackpropagated.get(this);</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">                if(pending==null){</span>
<span class="fc" id="L473">                    pending = new PendingError(error, ADPaths-1);</span>
<span class="fc" id="L474">                    toBeBackpropagated.put(this, pending);</span>
                } else {
<span class="fc" id="L476">                    pending.accumulate(error);</span>
                }
<span class="fc" id="L478">                return;// NOTE: Multiple AD paths leading to one node in history should be accumulated first! (performance)</span>
            }
            //if(_payload==null) throw new RuntimeException();
<span class="fc bfc" id="L481" title="All 2 branches covered.">            if(this.usesForwardAD()){//Using forward-AD derivatives for reverse-mode AD!:</span>
<span class="fc" id="L482">                this.forEach((t, d)-&gt;t._backward(MUL.activate(new Tsr[]{error, d}), toBeBackpropagated, false));</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">            }else if(this.usesReverseAD()){//Standard reverse mode-AD:</span>
<span class="fc" id="L484">                this.forEach((t, d)-&gt;{</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">                    if(_function.id()==Function.TYPES.LOOKUP.get(&quot;x&quot;)){// x operation requires individual operation!</span>
<span class="fc" id="L486">                        t._backward(CONV.activate(new Tsr[]{error, d, new Tsr(t.getPayload().shape(), 0)}), toBeBackpropagated, false);</span>
                    } else {//Normal elementwise backpropagation:
<span class="fc" id="L488">                        t._backward(MUL.activate(new Tsr[]{error, d}), toBeBackpropagated, false);</span>
                    }
<span class="fc" id="L490">                });</span>
            }
        }
<span class="fc" id="L493">    }</span>

    /**
     * Counts how many child nodes will later on provide error values for backpropagation!
     * @return
     */
    private int _numberOfADChildren(){
<span class="fc" id="L500">        int count = 0;</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">        if(_children!=null){</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            for(WeakReference weak : _children){</span>
<span class="pc bpc" id="L503" title="2 of 4 branches missed.">                if(weak!=null &amp;&amp; weak.get()!=null){</span>
<span class="fc" id="L504">                    GraphNode child = (GraphNode) weak.get();</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">                    if(child.usesAD()){</span>
<span class="fc" id="L506">                        count++;</span>
                    }
                }
<span class="fc" id="L509">            }</span>
        }
<span class="fc" id="L511">        return count;</span>
    }

    /**
     * @return int
     */
    public int mode(){
<span class="fc" id="L518">        return _mode;</span>
    }

    /**
     * @return Function
     */
    public Function function(){
<span class="fc" id="L525">        return _function;</span>
    }

    /**
     * @param target
     * @param derivative
     */
    public void put(GraphNode target, Tsr derivative){
<span class="fc bfc" id="L533" title="All 2 branches covered.">        if(_targets_derivatives ==null){</span>
<span class="fc" id="L534">            _targets_derivatives = new TreeMap&lt;&gt;((a, b)-&gt;a.hashCode()-b.hashCode());</span>
        }
<span class="fc" id="L536">        _targets_derivatives.put(target, derivative);</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if(derivative.has(GraphNode.class)){</span>
<span class="fc" id="L538">            ((GraphNode)derivative.find(GraphNode.class))._is_used_as_derivative = true;</span>
        }
<span class="fc" id="L540">    }</span>

    /**
     * @param key
     * @return Tsr
     */
    public Tsr get(GraphNode key){
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if(_targets_derivatives ==null) return null;</span>
<span class="nc" id="L548">        return _targets_derivatives.get(key);</span>
    }

    /**
     *
     * @param target
     * @return boolean
     */
    public boolean has(GraphNode target){
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if(_targets_derivatives ==null) return false;</span>
<span class="fc" id="L558">        return _targets_derivatives.containsKey(target);</span>
    }

    /**
     * @return Map&lt;Tsr, Tsr&gt;
     */
    public Map&lt;GraphNode, Tsr&gt; getMap(){
<span class="nc" id="L565">        return _targets_derivatives;</span>
    }

    /**
     * @return int
     */
    public int size(){
<span class="fc bfc" id="L572" title="All 2 branches covered.">        return (_targets_derivatives !=null)?this._targets_derivatives.size():0;</span>
    }

    /**
     * @param action
     * @return void
     */
    public void forEach(BiConsumer&lt;GraphNode, Tsr&gt; action){
<span class="fc bfc" id="L580" title="All 2 branches covered.">        if(_targets_derivatives ==null) return;</span>
<span class="fc" id="L581">        _targets_derivatives.forEach(action);</span>
<span class="fc" id="L582">    }</span>

    public String type(){
<span class="fc" id="L585">        String type = &quot;&quot;;</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">        if(this.isLeave()) type+=&quot;LEAVE&quot;;</span>
<span class="fc" id="L587">        else type += &quot;BRANCH&quot;;</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if(_payload==null) type = type+&quot; DELETED&quot;;</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        else if(_payload.rqsGradient()) type += &quot; RQS GRADIENT&quot;;</span>
<span class="fc" id="L590">        return type;</span>
    }

    @Override
    public String toString(){
<span class="nc" id="L595">        return toString(&quot;&quot;);</span>
    }


    public String toString(String m){
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if(m.contains(&quot;g&quot;)){</span>
<span class="fc" id="L601">            return &quot;]&gt; LOCK: &quot;+lock()+&quot; |&gt; GRAPH:\n]\n&quot;</span>
<span class="fc" id="L602">                    +_toString(&quot;]    0&quot;, true)</span>
                    +&quot;\n]\n]|END|&gt;&quot;;
        }
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">        if(m.contains(&quot;v&quot;)){</span>
<span class="fc" id="L606">            return &quot;(&quot;+this.type()+&quot;): [NID:&quot;+Long.toHexString(nid())+&quot;]:&lt;(  &quot;</span>
<span class="fc bfc" id="L607" title="All 4 branches covered.">                    +&quot;f&quot;+((_function==null)?&quot;(NONE)&quot;:_function)+&quot; =&gt; &quot;+((_payload==null)?&quot;NULL&quot;:_payload.toString(&quot;cs&quot;))+&quot;  )&gt;&quot;;</span>

        } else {
<span class="nc bnc" id="L610" title="All 2 branches missed.">            return &quot;[NID:&quot;+Long.toHexString(nid())+&quot;]:( &quot;+((_payload==null)?&quot;NULL&quot;:_payload.toString(&quot;cs&quot;))+&quot; )&quot;;</span>
        }

    }

    private String _toString(String deep, boolean isLast){//int depth){
<span class="fc bfc" id="L616" title="All 2 branches covered.">        String delimiter = ((isLast)?(&quot;    &quot;):(&quot;|   &quot;));</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        String arrow = ((char)187)+&quot;&quot;+((_parents!=null)?(String.valueOf(_parents.length)):&quot;0&quot;)+((char)187);</span>
<span class="fc" id="L618">        String asString = deep+</span>
<span class="fc" id="L619">            arrow+ toString(&quot;v&quot;);</span>
<span class="fc" id="L620">        deep = deep.substring(0, deep.length()-1);</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">        if(_parents!=null){</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">            asString += &quot;\n&quot;+deep+((isLast)?&quot;   \\\n&quot;:&quot;|  \\\n&quot;);</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">            for(int i=0; i&lt;_parents.length; i++){</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">                boolean last = (i==_parents.length-1);</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">                asString += ((i!=0)?deep+delimiter+&quot;|\n&quot;:&quot;&quot;);</span>
<span class="fc" id="L626">                asString+=(_parents[i]._toString(deep+delimiter+i, last)+&quot;\n&quot;);</span>
            }
<span class="fc" id="L628">            asString = asString.substring(0, asString.length()-1);</span>
        }
<span class="fc" id="L630">        return asString;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>