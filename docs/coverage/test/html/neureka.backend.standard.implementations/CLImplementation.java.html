<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CLImplementation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.backend.standard.implementations</a> &gt; <span class="el_source">CLImplementation.java</span></div><h1>CLImplementation.java</h1><pre class="source lang-java linenums">package neureka.backend.standard.implementations;


import neureka.backend.api.ImplementationFor;
import neureka.backend.api.implementations.AbstractImplementationFor;
import neureka.devices.opencl.OpenCLDevice;

import java.util.HashMap;
import java.util.Map;

/**
 * This class is the ExecutorFor &amp;lt; OpenCLDevice &amp;gt; implementation
 * used to properly call an OpenCLDevice instance via the
 * ExecutionOn &amp;lt; OpenCLDevice &amp;gt; lambda implementation
 * receiving an instance of the ExecutionCall class.
*/
public class CLImplementation extends AbstractImplementationFor&lt;OpenCLDevice&gt;
{

<span class="pc" id="L20">    private final java.util.function.Function&lt;String, String&gt; _aliasSwapper =</span>
            s -&gt;
<span class="fc" id="L22">                &quot;//-=&lt;PARSED&gt;=-//\n&quot; +</span>
<span class="fc" id="L23">                    s.replace(&quot;src1&quot;, &quot;src1[_i_of_idx_on_tln(prv_src1_cfg, rank)]&quot;)</span>
<span class="fc" id="L24">                            .replace(&quot;src2&quot;, &quot;src2[_i_of_idx_on_tln(prv_src2_cfg, rank)]&quot;)</span>
<span class="fc" id="L25">                            .replace(&quot;input1&quot;, &quot;src1[_i_of_i(i, prv_src1_cfg, rank)]&quot;)</span>
<span class="fc" id="L26">                            .replace(&quot;input2&quot;, &quot;src2[_i_of_i(i, prv_src2_cfg, rank)]&quot;)</span>
<span class="fc" id="L27">                            .replace(&quot;input&quot;, &quot;src1[_i_of_i(i, prv_src1_cfg, rank)]&quot;)</span>
<span class="fc" id="L28">                            .replace(&quot;output&quot;, &quot;drn[_i_of_i(i, prv_drn_cfg, rank)]&quot;)</span>
<span class="fc" id="L29">                            .replace(&quot;handle&quot;, &quot;src1[_i_of_idx_on_tln(prv_src1_cfg, rank)]&quot;)</span>
<span class="fc" id="L30">                            .replace(&quot;drain&quot;, &quot;src2[_i_of_idx_on_tln(prv_src2_cfg, rank)]&quot;)</span>
<span class="fc" id="L31">                            .replace(&quot;origin&quot;, &quot;drn[di]&quot;)</span>
<span class="fc" id="L32">                            .replace(&quot;target&quot;, &quot;frn[_i_of_idx_on_tln(prv_frn_cfg, rank)]&quot;) +</span>
                    &quot;\n//-=&lt;PARSED&gt;=-//&quot;;

<span class="pc" id="L35">    private final java.util.function.Function&lt;String, String&gt; asAdvanced =</span>
            s -&gt;
<span class="fc" id="L37">            s.replace(&quot;target&quot;, &quot;frn[_i_of_idx_on_tln(prv_frn2_cfg, rank)]&quot;)</span>
<span class="fc" id="L38">                    .replace(&quot;input3&quot;,&quot;frn[_i_of_idx_on_tln(prv_frn2_cfg, rank)]&quot;)</span>
<span class="fc" id="L39">                    .replace(&quot;//-=&lt;ARGUMENT&gt;=-//&quot;, &quot;&quot;)</span>
<span class="fc" id="L40">                    .replace(&quot;//-=&lt;CONFIGURATION&gt;=-//&quot;, &quot;&quot;);</span>

    private String _source;
    private String _name;

    private CLImplementation(
            ImplementationFor&lt;OpenCLDevice&gt; execution,
            int arity,
            String kernelName,
            String kernelSource
    ) {
<span class="nc" id="L51">        super( execution, arity );</span>
<span class="nc" id="L52">        _name = kernelName;</span>
<span class="nc" id="L53">        _source = kernelSource;</span>
<span class="nc" id="L54">    }</span>

    private CLImplementation(
            ImplementationFor&lt;OpenCLDevice&gt; lambda,
            int arity,
            String kernelSource,
            String activationSource,
            String differentiationSource,
            String postfix
    ) {
<span class="fc" id="L64">        super( lambda, arity );</span>
        boolean templateFound;
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        if (kernelSource.contains(&quot;__kernel&quot;)) {</span>
<span class="fc" id="L67">            String[] parts = kernelSource.split(&quot;__kernel&quot;)[ 1 ].split(&quot;\\(&quot;)[ 0 ].split(&quot; &quot;);</span>

<span class="fc" id="L69">            templateFound = parts[parts.length - 1].contains(&quot;template&quot;);</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">            if (!templateFound) {</span>
<span class="nc" id="L71">                throw new IllegalStateException(&quot;Invalid source code passed to AbstractCLExecution!&quot;);</span>
            } else {
<span class="fc" id="L73">                Map&lt;String, String&gt; map = _getParsedKernelsFromTemplate(</span>
                        parts[parts.length - 1],
                        kernelSource,
                        activationSource,
                        differentiationSource,
                        postfix
                );
<span class="fc" id="L80">                _name = map.keySet().toArray(new String[ 0 ])[ 0 ];</span>
<span class="fc" id="L81">                _source = map.values().toArray(new String[ 0 ])[ 0 ];</span>
            }
        }
<span class="fc" id="L84">    }</span>

    public static SourceBuilder fromSource() {
<span class="nc" id="L87">        return new SourceBuilder();</span>
    }

    public static Compiler compiler() {
<span class="fc" id="L91">        return new Compiler();</span>
    }

    public String getSource() {
<span class="fc" id="L95">        return this._source;</span>
    }

    public String getName() {
<span class="fc" id="L99">        return this._name;</span>
    }

    private interface Parser
    {
        void apply(String name, String first, String second);
    }

    private Map&lt;String, String&gt; _getParsedKernelsFromTemplate(
            String templateName,
            String kernelSource,
            String activationSource,
            String differentiationSource,
            String postfix
    ) {
<span class="fc" id="L114">        Map&lt;String, String&gt; code = new HashMap&lt;&gt;();</span>
<span class="fc" id="L115">        String preName = templateName.replace(&quot;template&quot;, &quot;&quot;);</span>
<span class="fc" id="L116">        String source = kernelSource.replace(&quot;template&quot;, &quot;&quot;);</span>
<span class="fc" id="L117">        String[] parts = source.split(&quot;//-=&lt;OPERATION&gt;=-//&quot;);</span>

<span class="fc" id="L119">        Parser parser = ( n, f, s ) -&gt; {</span>
<span class="fc" id="L120">            String convcode =</span>
<span class="fc" id="L121">                    parts[ 0 ].replace(preName, preName + n) +</span>
<span class="fc" id="L122">                            _aliasSwapper.apply(f) +</span>
                            parts[ 2 ] +
<span class="fc" id="L124">                            _aliasSwapper.apply(s) +</span>
                            parts[4];
<span class="pc bpc" id="L126" title="2 of 6 branches missed.">            boolean isAdvanced = s.contains(&quot;target&quot;)&amp;&amp;s.contains(&quot;drain&quot;)&amp;&amp;s.contains(&quot;handle&quot;)</span>
<span class="pc bpc" id="L127" title="1 of 6 branches missed.">                    || s.contains(&quot;input1&quot;)&amp;&amp;s.contains(&quot;input2&quot;)&amp;&amp;s.contains(&quot;input3&quot;);</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            convcode = (isAdvanced) ? asAdvanced.apply(convcode) : convcode;</span>
<span class="fc" id="L129">            code.put(preName + n, convcode);</span>
<span class="fc" id="L130">        };</span>
        //Tsr t0_origin, Tsr t1_handle, Tsr t2_drain ... when d&gt;=0
        //Tsr t0_drain,  Tsr t1_src1,   Tsr t2_src2
        //drn[di], src1[_i_of_idx_on_tln(prv_src1_cfg, rank)], src2[_i_of_idx_on_tln(prv_src2_cfg, rank)]
        //default:  src1 o src2 -&gt; drain
        //inverse:  src1/fdrn &lt;-src2 &lt;- drain
        //===========================================================================
<span class="fc" id="L137">        parser.apply(</span>
                postfix,
                activationSource,
                differentiationSource
        );
<span class="fc" id="L142">        return code;</span>
    }

    /**
     *  This builder builds the most basic type of {@link CLImplementation} which
     *  is in essence merely a wrapper for a lambda and the arity of this implementation.
     */
    public static class SourceBuilder {
        private ImplementationFor&lt;OpenCLDevice&gt; lambda;
        private int arity;
        private String kernelName;
        private String kernelSource;

<span class="nc" id="L155">        SourceBuilder() { }</span>

<span class="nc" id="L157">        public SourceBuilder lambda(ImplementationFor&lt;OpenCLDevice&gt; lambda) { this.lambda = lambda;return this; }</span>
<span class="nc" id="L158">        public SourceBuilder arity(int arity) { this.arity = arity; return this; }</span>
<span class="nc" id="L159">        public SourceBuilder kernelName(String kernelName) { this.kernelName = kernelName;return this; }</span>
<span class="nc" id="L160">        public SourceBuilder kernelSource(String kernelSource) { this.kernelSource = kernelSource;return this; }</span>
<span class="nc" id="L161">        public CLImplementation build() { return new CLImplementation(lambda, arity, kernelName, kernelSource); }</span>
    }

    public static class Compiler {
        private ImplementationFor&lt;OpenCLDevice&gt; lambda;
        private int arity;
        private String kernelSource;
        private String activationSource;
        private String differentiationSource;
        private String type;

<span class="fc" id="L172">        Compiler() { }</span>

<span class="fc" id="L174">        public Compiler execution(ImplementationFor&lt;OpenCLDevice&gt; lambda) { this.lambda = lambda;return this; }</span>
<span class="fc" id="L175">        public Compiler arity(int arity) { this.arity = arity; return this; }</span>
<span class="fc" id="L176">        public Compiler kernelSource(String kernelSource) { this.kernelSource = kernelSource;return this; }</span>
<span class="fc" id="L177">        public Compiler activationSource(String activationSource) { this.activationSource = activationSource;return this; }</span>
<span class="fc" id="L178">        public Compiler differentiationSource(String differentiationSource) { this.differentiationSource = differentiationSource;return this; }</span>
<span class="fc" id="L179">        public Compiler kernelPostfix(String type) { this.type = type;return this; }</span>
        public CLImplementation build() {
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">            if ( lambda == null ) throw new IllegalStateException(</span>
<span class="nc" id="L182">                    CLImplementation.class.getSimpleName()+&quot; builder not satisfied.&quot;</span>
            );
<span class="fc" id="L184">            return new CLImplementation(lambda, arity, kernelSource, activationSource, differentiationSource, type);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>