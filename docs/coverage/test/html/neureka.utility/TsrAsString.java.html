<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TsrAsString.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.utility</a> &gt; <span class="el_source">TsrAsString.java</span></div><h1>TsrAsString.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      _______                   _____ _        _
     |__   __|       /\        / ____| |      (_)
        | |___ _ __ /  \   ___| (___ | |_ _ __ _ _ __   __ _
        | / __| '__/ /\ \ / __|\___ \| __| '__| | '_ \ / _` |
        | \__ \ | / ____ \\__ \____) | |_| |  | | | | | (_| |
        |_|___/_|/_/    \_\___/_____/ \__|_|  |_|_| |_|\__, |
                                                        __/ |
                                                       |___/
        A utility class for tensor stringification !

*/

package neureka.utility;

import neureka.Neureka;
import neureka.Tsr;
import neureka.autograd.GraphNode;
import neureka.framing.NDFrame;
import neureka.ndim.config.NDConfiguration;
import org.jetbrains.annotations.Contract;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.*;
import java.util.function.Function;

/**
 *  This class is in essence a simple wrapper class for a tensor and a StringBuilder
 *  Methods in this class use the builder in order to construct a String representation
 *  for said tensor.
 *  These method adjust this String building based on a set of certain
 *  configurations which are represented by the &quot;Should&quot; enum.
 *
 */
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">public final class TsrAsString</span>
{
<span class="fc" id="L61">    private int _padding = 6;</span>
<span class="fc" id="L62">    private int _shortage = 50;</span>
<span class="fc" id="L63">    private boolean _hasGradient = true;</span>
<span class="fc" id="L64">    private boolean _isCompact = true;</span>
<span class="fc" id="L65">    private boolean _isFormatted = true;</span>
<span class="fc" id="L66">    private boolean _hasValue = true;</span>
<span class="fc" id="L67">    private boolean _hasShape = true;</span>
<span class="fc" id="L68">    private boolean _hasRecursiveGraph = false;</span>
<span class="fc" id="L69">    private boolean _hasDerivatives = false;</span>
<span class="fc" id="L70">    private boolean _isCellBound = false;</span>

    private int[] _shape;
    private Tsr&lt;?&gt; _tensor;
    private StringBuilder _asStr;
<span class="fc" id="L75">    private final boolean _legacy = Neureka.get().settings().view().isUsingLegacyView();</span>

    private Map&lt;Should, Object&gt; _config;

<span class="fc" id="L79">    public enum Should {</span>
<span class="fc" id="L80">        BE_FORMATTED,</span>
<span class="fc" id="L81">        HAVE_PADDING_OF,</span>
<span class="fc" id="L82">        BE_COMPACT,</span>
<span class="fc" id="L83">        HAVE_GRADIENT,</span>
<span class="fc" id="L84">        BE_SHORTENED_BY,</span>
<span class="fc" id="L85">        HAVE_VALUE,</span>
<span class="fc" id="L86">        HAVE_SHAPE,</span>
<span class="fc" id="L87">        HAVE_DERIVATIVES,</span>
<span class="fc" id="L88">        HAVE_RECURSIVE_GRAPH,</span>
<span class="fc" id="L89">        BE_CELL_BOUND</span>
    }

    private interface ValStringifier {
        String stringify( int i );
    }

    public TsrAsString( Tsr&lt;?&gt; tensor, Map&lt; Should, Object &gt; settings )
<span class="fc" id="L97">    {</span>
<span class="fc" id="L98">        Map&lt; Should, Object &gt; copy = Util.configFromCode( &quot;&quot; );</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        for ( Should s : Should.values() )</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">            if ( settings.containsKey( s ) ) copy.put( s, settings.get( s ) );</span>
<span class="fc" id="L101">        _construct( tensor, copy );</span>
<span class="fc" id="L102">    }</span>

    public TsrAsString( Tsr&lt;?&gt; tensor, String modes )
<span class="fc" id="L105">    {</span>
<span class="fc" id="L106">        _construct(</span>
                tensor,
<span class="fc" id="L108">                Util.configFromCode( modes )</span>
        );
<span class="fc" id="L110">    }</span>

    public TsrAsString( Tsr&lt;?&gt; tensor )
<span class="fc" id="L113">    {</span>
<span class="fc" id="L114">        _construct(</span>
                tensor,
<span class="fc" id="L116">                Util.configFromCode( null )</span>
        );
<span class="fc" id="L118">    }</span>

    private void _construct( Tsr&lt;?&gt; tensor, Map&lt; Should, Object &gt; settings )
    {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        if ( tensor.getNDConf() != null ) _shape = tensor.getNDConf().shape();</span>
<span class="fc" id="L123">        _config = settings;</span>
<span class="fc" id="L124">        _tensor = tensor;</span>
        // TODO: Add some asserts!
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.BE_COMPACT ) )</span>
<span class="fc" id="L127">            _isCompact = (boolean) settings.get( Should.BE_COMPACT );</span>

<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.BE_SHORTENED_BY ) )</span>
<span class="fc" id="L130">            _shortage = (int) settings.get( Should.BE_SHORTENED_BY );</span>

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.HAVE_PADDING_OF ) )</span>
<span class="fc" id="L133">            _padding = (int) settings.get( Should.HAVE_PADDING_OF );</span>

<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.HAVE_GRADIENT ) )</span>
<span class="fc" id="L136">            _hasGradient = (boolean) settings.get( Should.HAVE_GRADIENT );</span>

<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.BE_FORMATTED ) )</span>
<span class="fc" id="L139">            _isFormatted = (boolean) settings.get( Should.BE_FORMATTED );</span>

<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.HAVE_VALUE ) )</span>
<span class="fc" id="L142">            _hasValue = (boolean) settings.get( Should.HAVE_VALUE );</span>

<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.HAVE_SHAPE ) )</span>
<span class="fc" id="L145">            _hasShape = (boolean) settings.get( Should.HAVE_SHAPE );</span>

<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.HAVE_RECURSIVE_GRAPH) )</span>
<span class="fc" id="L148">            _hasRecursiveGraph = (boolean) settings.get( Should.HAVE_RECURSIVE_GRAPH);</span>

<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.HAVE_DERIVATIVES) )</span>
<span class="fc" id="L151">            _hasDerivatives = (boolean) settings.get( Should.HAVE_DERIVATIVES);</span>

<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        if ( settings.containsKey( Should.BE_CELL_BOUND ) )</span>
<span class="fc" id="L154">            _isCellBound = (boolean) settings.get( Should.BE_CELL_BOUND );</span>
<span class="fc" id="L155">    }</span>

    /**
     *  This method is a wrapper for the _asStr.append() call.
     *  It thereby greatly reduces boilerplate code which
     *  makes this class substantially more readable,
     *  however one has to keep in mind that &quot;_$&quot; string is
     *  a chained builder method.
     *
     * @param toBeAppended The String which ought to be appended to this builder.
     * @return This very instance in order to enable method-chaining.
     */
    private TsrAsString _$( String toBeAppended ) {
<span class="fc" id="L168">        _asStr.append( toBeAppended );</span>
<span class="fc" id="L169">        return this;</span>
    }

    /**
     *  This method is a wrapper for the _asStr.append() call.
     *  It thereby greatly reduces boilerplate code which
     *  makes this class substantially more readable,
     *  however one has to keep in mind that &quot;_$&quot; string is
     *  a chained builder method.
     *
     * @param toBeAppended The int which ought to be appended to this builder.
     * @return This very instance in order to enable method-chaining.
     */
    private TsrAsString _$( int toBeAppended ) {
<span class="fc" id="L183">        _asStr.append( toBeAppended );</span>
<span class="fc" id="L184">        return this;</span>
    }

    /**
     *  This method takes the data of a tensor and converts it into
     *  a lambda responsible for creating formatted Strings of data entries by
     *  taking the int index of a targeted entry and returning
     *  a properly formatted String representation of said entry. &lt;br&gt;
     *  &lt;br&gt;
     *
     * @param data The data which should be used as a basis for creating an entry stringification lambda.
     * @return A lambda which can convert an array entry targeted by its index to a properly formatted String.
     */
    private ValStringifier _createValStringifierAndFormatter( Object data )
    {
<span class="fc" id="L199">        final ValStringifier function = _createBasicStringifierFor( data, _isCompact );</span>
<span class="fc" id="L200">        int pad = _typeAdjustedPadding();</span>
        final ValStringifier postProcessing;
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if ( pad &gt;= 3 ) postProcessing = i -&gt; {</span>
<span class="fc" id="L203">            String s = function.stringify( i );</span>
<span class="fc" id="L204">            int margin = pad - s.length();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">            int right = ( margin % 2 == 0 ) ? margin / 2 : ( margin-1 ) / 2;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if ( margin &gt; 0 ) s = Util.pad( margin - right, Util.pad( s, right ) );</span>
<span class="fc" id="L207">            return s;</span>
        };
<span class="fc" id="L209">        else postProcessing = function;</span>

        final ValStringifier finalProcessing;
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if ( _isCellBound ) finalProcessing = i -&gt; {</span>
<span class="fc" id="L213">            String s = postProcessing.stringify( i );</span>
<span class="fc" id="L214">            int margin =  s.length() - pad;</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">            if ( margin &gt; 0 ) s = s.substring( 0, pad - 2 ) + &quot;..&quot;;</span>
<span class="fc" id="L216">            return s;</span>
        };
<span class="fc" id="L218">        else finalProcessing = postProcessing;</span>

<span class="fc" id="L220">        return finalProcessing;</span>
    }

    /**
     *  @param data The data array which may be an array of primitives or reference objects.
     *  @param isCompact A flag determining if the array items should be formatted compactly or not.
     *  @return An {@link ValStringifier} which can return {@link String} representations of array items targeted via their index.
     */
    private ValStringifier _createBasicStringifierFor( Object data, boolean isCompact )
    {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if ( data instanceof double[] )</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">            return i -&gt; ( isCompact )</span>
<span class="fc" id="L232">                    ? Util.formatFP( ( (double[]) data )[ i ])</span>
<span class="fc" id="L233">                    : String.valueOf( ( (double[] ) data )[ i ] );</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">        else if ( data instanceof float[] )</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">            return i -&gt; ( isCompact )</span>
<span class="nc" id="L236">                    ? Util.formatFP( ( (float[]) data )[ i ] )</span>
<span class="fc" id="L237">                    : String.valueOf( ( (float[]) data )[ i ] );</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">        else if ( data instanceof short[] )</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">            return i -&gt; ( isCompact )</span>
<span class="nc" id="L240">                    ? Util.formatFP( ( (short[]) data )[ i ] )</span>
<span class="fc" id="L241">                    : String.valueOf( ( (short[]) data )[ i ] );</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">        else if ( data instanceof int[] )</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            return i -&gt; ( isCompact )</span>
<span class="fc" id="L244">                    ? Util.formatFP( ( (int[]) data )[ i ] )</span>
<span class="fc" id="L245">                    : String.valueOf( ( (int[]) data )[ i ] );</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        else if ( data instanceof byte[] )</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">            return i -&gt; ( isCompact )</span>
<span class="nc" id="L248">                    ? Util.formatFP( ( (byte[]) data )[ i ] )</span>
<span class="fc" id="L249">                    : String.valueOf( ( (byte[]) data )[ i ] );</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">        else if ( data == null )</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            return i -&gt; ( isCompact )</span>
<span class="fc" id="L252">                    ? Util.formatFP( _tensor.value64( i ) )</span>
<span class="nc" id="L253">                    : String.valueOf( _tensor.value64( i ) );</span>
        else
<span class="fc" id="L255">            return i -&gt; String.valueOf( ( (Object[]) data )[ i ] );</span>
    }

    /**
     * @return A potentially modified version of the configured padding to better suite certain types.
     */
    private int _typeAdjustedPadding() {
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if ( _tensor.getDataType().getTypeClass() == String.class )</span>
<span class="fc" id="L263">            return  (int)(_padding * 2.5);</span>
        else
<span class="fc" id="L265">            return  _padding;</span>
    }

    public String toString()
    {
<span class="fc" id="L270">        return toString(&quot;&quot;);</span>
    }

    public String toString( String deep )
    {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">        if ( _tensor.isEmpty() ) return &quot;empty&quot;;</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        else if ( _tensor.isUndefined() ) return &quot;undefined&quot;;</span>
<span class="fc" id="L277">        _asStr = new StringBuilder();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        String base = ( deep == null ) ? &quot;&quot; : &quot;\n&quot; + deep;</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        String delimiter = ( deep == null ) ? &quot;&quot; : &quot;    &quot;;</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        String half = ( deep == null ) ? &quot;&quot; : &quot;  &quot;;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        String deeper = ( deep == null ) ? deep : deep + delimiter;</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if ( _hasShape ) _strShape();</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        if ( !_hasValue ) return _asStr.toString();</span>
<span class="fc" id="L284">        _$( &quot;:&quot; );</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if ( _isFormatted ) _recursiveFormatting( new int[ _tensor.rank() ], -1 );</span>
        else {
<span class="fc bfc" id="L287" title="All 2 branches covered.">            _$( (_legacy) ? &quot;(&quot; : &quot;[&quot; );</span>
<span class="fc" id="L288">            _stringifyAllValues();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            _$( (_legacy) ? &quot;)&quot; : &quot;]&quot; );</span>
        }

<span class="fc bfc" id="L292" title="All 6 branches covered.">        if ( _hasGradient &amp;&amp; ( _tensor.rqsGradient() || _tensor.hasGradient() ) ) {</span>
<span class="fc" id="L293">            _$( &quot;:g&quot; );</span>
<span class="fc" id="L294">            Tsr&lt;?&gt; gradient = _tensor.getGradient();</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">            if ( gradient != null )</span>
<span class="fc" id="L296">                _$( gradient.toString( &quot;cv&quot; ) );</span>
            else
<span class="fc bfc" id="L298" title="All 2 branches covered.">                _$( ( ( _legacy ) ? &quot;:(null)&quot; : &quot;:[null]&quot; ) );</span>
        }
<span class="fc bfc" id="L300" title="All 6 branches covered.">        if ( _hasRecursiveGraph &amp;&amp; _tensor.has( GraphNode.class ) &amp;&amp; _tensor.find( GraphNode.class ).size() &gt; 0 ) {</span>
<span class="fc" id="L301">            GraphNode&lt;?&gt; node = _tensor.find( GraphNode.class );</span>
<span class="fc" id="L302">            _$( &quot;; &quot; );</span>
<span class="fc" id="L303">            node.forEachDerivative( ( t, agent ) -&gt; {</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">                if ( agent.derivative() == null ) _$( &quot;-&gt;d(null), &quot; );</span>
                else {
<span class="fc" id="L306">                    _$(</span>
                                    base + &quot;=&gt;d|[ &quot; +
<span class="fc" id="L308">                                    base + delimiter + agent.derivative().toString( _config, deeper ) + &quot; &quot; +</span>
                                    base + half + &quot;]|:t{ &quot; +
                                    base + delimiter + (
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                                    ( t.getPayload() != null ) ? t.getPayload().toString( _config, deeper ) : t.toString(&quot;&quot;)</span>
                            ) + &quot; &quot; + base + half + &quot;}, &quot;
                    );
                }
<span class="fc" id="L315">            });</span>
        }
<span class="fc bfc" id="L317" title="All 6 branches covered.">        if ( _hasDerivatives &amp;&amp; _tensor.has( GraphNode.class ) &amp;&amp; _tensor.find( GraphNode.class ).size() &gt; 0 ) {</span>
<span class="fc" id="L318">            GraphNode&lt;?&gt; node = _tensor.find( GraphNode.class );</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            if ( node.getMode() != 0 ) {</span>
<span class="fc" id="L320">                _$( &quot;; &quot; );</span>
<span class="fc" id="L321">                node.forEachDerivative( ( t, agent ) -&gt; {</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">                    if ( agent.derivative() == null ) _$( &quot;-&gt;d(&quot; )._$( agent.toString() )._$( &quot;), &quot; );</span>
<span class="fc" id="L323">                    else _$( &quot;-&gt;d&quot; )._$( agent.derivative().toString( _config, deeper ) )._$( &quot;, &quot; );</span>
<span class="fc" id="L324">                });</span>
            }
        }
<span class="fc" id="L327">        return _asStr.toString();</span>
    }

    private void _stringifyAllValues()
    {
<span class="fc" id="L332">        int max = _shortage;</span>
<span class="fc" id="L333">        ValStringifier getter = _createValStringifierAndFormatter( _tensor.getData() );</span>
<span class="fc" id="L334">        int size = _tensor.size();</span>
<span class="fc" id="L335">        int trim = ( size - max );</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        size = ( trim &gt; 0 ) ? max : size;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        for ( int i = 0; i &lt; size; i++ ) {</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">            String vStr = getter.stringify( ( _tensor.isVirtual() ) ? 0 : _tensor.indexOfIndex( i ) );</span>
<span class="fc" id="L339">            _$( vStr );</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">            if ( i &lt; size - 1 ) _$( &quot;, &quot; );</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">            else if ( trim &gt; 0 ) _$( &quot;, ... + &quot; )._$( trim )._$( &quot; more&quot; );</span>
        }
<span class="fc" id="L343">    }</span>

    /**
     *  This method builds a single row of stringified and formatted tensor entries.
     *  It will build this row based on incrementing the last tensor dimension. &lt;br&gt;
     *  &lt;br&gt;
     * @param trimStart The row index where the trimming should start (no entries).
     * @param trimEnd The row index where the trimming should end.
     * @param trimSize The size of the row chunk which ought to be skipped.
     * @param indices The current index array defining the current position inside the tensor.
     * @param stringifier A lambda responsible for stringifying a tensor entry ba passing the current index array.
     * @param delimiter The String which ought to separate stringified entries.
     */
    private void _buildRow(
            int trimStart, int trimEnd, int trimSize, int[] indices, Function&lt;int[],String&gt; stringifier, String delimiter
    ) {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        for ( int i = 0; i &lt; _shape[ _shape.length - 1 ]; i++ ) {</span>
<span class="fc bfc" id="L360" title="All 4 branches covered.">            if ( i &lt; trimStart || i &gt;= trimEnd ) {</span>
<span class="fc" id="L361">                _$( stringifier.apply( indices ) );</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">                if ( i &lt; _shape[ _shape.length - 1 ] - 1 ) _$( delimiter );</span>
            }
<span class="fc bfc" id="L364" title="All 2 branches covered.">            else if ( i == trimStart ) _$( &quot;... &quot; )._$( trimSize )._$( &quot; more ..., &quot; );</span>

<span class="fc" id="L366">            NDConfiguration.Utility.increment( indices, _shape );</span>
        }
<span class="fc" id="L368">    }</span>


    /**
     *  This method builds a properly indented and formatted tensor representation.
     *  The depth of the recursion is also tracked by the current dimension which
     *  will be incrementally passed down the recursion. &lt;br&gt;
     *  Besides this dimension there is also the current index array
     *  which will be incremented when tensor elements are being stringified... &lt;br&gt;
     *  &lt;br&gt;
     *
     * @param indices The current index array containing the current index for all dimensions.
     * @param dim The current dimension which is also the &quot;depth&quot; of the recursion.
     */
    private void _recursiveFormatting( int[] indices, int dim )
    {
<span class="fc" id="L384">        int max = ( _shortage * 32 / 50 );</span>
<span class="fc" id="L385">        dim = Math.max( dim, 0 );</span>
<span class="fc" id="L386">        int trimSize = ( _shape[ dim ] - max );</span>
<span class="fc" id="L387">        trimSize = Math.max( trimSize, 0 );</span>
<span class="fc" id="L388">        int trimStart = ( _shape[ dim ] / 2 - trimSize / 2 );</span>
<span class="fc" id="L389">        int trimEnd = ( _shape[ dim ] / 2 + trimSize / 2 );</span>
<span class="pc bpc" id="L390" title="2 of 4 branches missed.">        assert trimEnd - trimStart == trimSize;</span>
<span class="fc" id="L391">        NDFrame&lt;?&gt; alias = _tensor.find( NDFrame.class );</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if ( dim == indices.length - 1 ) {</span>
<span class="pc bpc" id="L393" title="1 of 4 branches missed.">            if (</span>
                    alias != null &amp;&amp;
                            indices[ indices.length - 1 ] == 0 &amp;&amp;
<span class="fc bfc" id="L396" title="All 2 branches covered.">                            indices[ Math.max( indices.length - 2, 0 ) ] == 0</span>
            ) {
<span class="fc" id="L398">                List&lt;Object&gt; aliases = alias.atAxis( indices.length - 1 ).getAllAliases();</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">                if ( aliases != null ) {</span>
<span class="fc" id="L400">                    _$( Util.indent( dim ) );</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                    _$( (_legacy) ? &quot;[ &quot; : &quot;( &quot; ); // The following assert has prevented many String miscarriages!</span>
<span class="pc bpc" id="L402" title="2 of 4 branches missed.">                    assert aliases.size() - _shape[ indices.length - 1 ] == 0; // This is a basic requirement for the label size...</span>
<span class="fc" id="L403">                    ValStringifier getter = _createValStringifierAndFormatter( aliases.toArray() );</span>
<span class="fc" id="L404">                    _buildRow(</span>
                            trimStart, trimEnd, trimSize,
                            new int[ indices.length ],
<span class="fc" id="L407">                            iarr -&gt; getter.stringify( iarr[ iarr.length -1 ] ),</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                            (_legacy) ? &quot;][&quot; : &quot;)(&quot;</span>
                    );
<span class="fc bfc" id="L410" title="All 2 branches covered.">                    _$( (_legacy) ? &quot; ]&quot; : &quot; )&quot; );</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">                    if ( alias.getTensorName() != null )</span>
<span class="fc bfc" id="L412" title="All 4 branches covered.">                        _$( (_legacy) ? &quot;:[ &quot; : &quot;:( &quot; )._$( alias.getTensorName() )._$( (_legacy) ? &quot; ]&quot; : &quot; )&quot; );</span>
<span class="fc" id="L413">                    _$( &quot;\n&quot; );</span>
                }
            }
<span class="fc" id="L416">            _$( Util.indent( dim ) );</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">            _$( (_legacy) ? &quot;( &quot; : &quot;[ &quot; );</span>
<span class="fc" id="L418">            ValStringifier getter = _createValStringifierAndFormatter( _tensor.getData() );</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">            Function&lt;int[], String&gt; fun = ( _tensor.isVirtual() )</span>
<span class="fc" id="L420">                    ? iarr -&gt; getter.stringify( 0 )</span>
<span class="fc" id="L421">                    : iarr -&gt; getter.stringify( _tensor.indexOfIndices( iarr ) );</span>

<span class="fc" id="L423">            _buildRow( trimStart, trimEnd, trimSize, indices, fun, &quot;, &quot; );</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            _$( (_legacy) ? &quot; )&quot; : &quot; ]&quot; );</span>

<span class="fc bfc" id="L426" title="All 2 branches covered.">            if ( alias != null ) _$( &quot;:&quot; )._buildSingleLabel( alias, dim, indices );</span>
<span class="fc" id="L427">        } else {</span>
<span class="fc" id="L428">            _$( Util.indent( dim ) );</span>
<span class="fc bfc" id="L429" title="All 4 branches covered.">            if ( dim &gt; 0 &amp;&amp; alias != null )</span>
<span class="fc" id="L430">                _buildSingleLabel( alias, dim, indices )._$(&quot;:&quot;);</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            _$( (_legacy) ? &quot;(\n&quot; : &quot;[\n&quot; );</span>
<span class="fc" id="L432">            int i = 0;</span>
            do {
<span class="fc bfc" id="L434" title="All 4 branches covered.">                if ( i &lt; trimStart || i &gt;= trimEnd )</span>
<span class="fc" id="L435">                    _recursiveFormatting( indices, dim + 1 );</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">                else if ( i == trimStart )</span>
<span class="fc" id="L437">                    _$( Util.indent( dim + 1 ) )._$( &quot;... &quot; )._$( trimSize )._$( &quot; more ...\n&quot; );</span>
                else
<span class="fc" id="L439">                    indices[ dim ] = trimEnd + 1; // Jumping over trimmed entries!</span>
<span class="fc" id="L440">                i++;</span>
            }
<span class="fc bfc" id="L442" title="All 2 branches covered.">            while ( indices[ dim ] != 0 );</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">            _$( Util.indent( dim ) )._$( (_legacy) ? &quot;)&quot; : &quot;]&quot; );</span>
        }
<span class="fc" id="L445">        int i = dim - 1;</span>
<span class="pc bpc" id="L446" title="1 of 6 branches missed.">        if ( i &gt;= 0 &amp;&amp; i &lt; indices.length &amp;&amp; indices[ i ] != 0 ) _$( &quot;,&quot; );</span>
<span class="fc" id="L447">        _$( &quot;\n&quot; );</span>
<span class="fc" id="L448">    }</span>

    private TsrAsString _buildSingleLabel(NDFrame&lt;?&gt; alias, int dim, int[] indices ) {
<span class="fc" id="L451">        int pos = dim - 1;</span>
<span class="fc" id="L452">        List&lt;Object&gt; key = alias.atAxis( pos ).getAllAliases();</span>
<span class="pc bpc" id="L453" title="2 of 4 branches missed.">        if ( pos &gt;= 0 &amp;&amp; key != null ) {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">            _$( (_legacy) ? &quot;[ &quot; : &quot;( &quot;);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">            int i = ( dim == indices.length - 1 )</span>
<span class="fc" id="L456">                    ? ( _shape[ pos ] + indices[ pos ] - 1 ) % _shape[ pos ]</span>
<span class="fc" id="L457">                    : indices[ pos ];</span>
<span class="fc" id="L458">            _$( key.get( i ).toString() );</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            _$( (_legacy) ? &quot; ]&quot; : &quot; )&quot;);</span>
        }
<span class="fc" id="L461">        return this;</span>
    }

    /**
     *  This method builds a String representation of the
     *  shape of the targeted tensor.
     */
    private void _strShape()
    {
<span class="fc" id="L470">        boolean legacy = Neureka.get().settings().view().isUsingLegacyView();</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        _$( (legacy) ? &quot;[&quot; : &quot;(&quot; );</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">        for ( int i = 0; i &lt; _shape.length; i++ ) {</span>
<span class="fc" id="L473">            _$( _shape[ i ] );</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">            if ( i &lt; _shape.length - 1 ) _$( &quot;x&quot; );</span>
        }
<span class="fc bfc" id="L476" title="All 2 branches covered.">        _$( (legacy) ? &quot;]&quot; : &quot;)&quot; );</span>
<span class="fc" id="L477">    }</span>

    /**
     *  This class is a simple utility class which contains
     *  a collection of static and stateless methods containing
     *  useful functionalities for tensor stringification.
     */
<span class="nc" id="L484">    public static class Util</span>
    {
        @Contract( pure = true )
        public static String indent( int n ){
<span class="fc" id="L488">            return String.join(&quot;&quot;, Collections.nCopies( n, &quot;   &quot; ));</span>
        }

        @Contract( pure = true )
        public static String pad( int left, String s ) {
<span class="fc" id="L493">            return String.join(&quot;&quot;, Collections.nCopies( left, &quot; &quot; )) + s;</span>
        }

        @Contract( pure = true )
        public static String pad( String s, int right ) {
<span class="fc" id="L498">            return s + String.join(&quot;&quot;, Collections.nCopies( right, &quot; &quot; ));</span>
        }

        @Contract( pure = true )
        public static String formatFP( double v )
        {
<span class="fc" id="L504">            DecimalFormatSymbols formatSymbols = new DecimalFormatSymbols( Locale.US );</span>
<span class="fc" id="L505">            DecimalFormat formatter = new DecimalFormat(&quot;##0.0##E0&quot;, formatSymbols);</span>
<span class="fc" id="L506">            String vStr = String.valueOf( v );</span>
<span class="fc" id="L507">            final int offset = 0;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            if ( vStr.length() &gt; ( 7 - offset ) ) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">                if ( vStr.startsWith(&quot;0.&quot;) ) {</span>
<span class="fc" id="L510">                    vStr = vStr.substring( 0, 7-offset )+&quot;E0&quot;;</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">                } else if ( vStr.startsWith( &quot;-0.&quot; ) ) {</span>
<span class="fc" id="L512">                    vStr = vStr.substring( 0, 8-offset )+&quot;E0&quot;;</span>
                } else {
<span class="fc" id="L514">                    vStr = formatter.format( v );</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">                    vStr = (!vStr.contains(&quot;.0E0&quot;))?vStr:vStr.replace(&quot;.0E0&quot;,&quot;.0&quot;);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                    vStr = (vStr.contains(&quot;.&quot;))?vStr:vStr.replace(&quot;E0&quot;,&quot;.0&quot;);</span>
                }
            }
<span class="fc" id="L519">            return vStr;</span>
        }

        @Contract( pure = true )
        public static Map&lt;Should, Object&gt; configFromCode( String modes )
        {
<span class="fc bfc" id="L525" title="All 2 branches covered.">            if ( modes == null )</span>
<span class="fc" id="L526">                return Neureka.get().settings().view().getAsString();</span>
<span class="fc" id="L527">            Map&lt; Should, Object &gt; conf = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">            conf.put( Should.BE_SHORTENED_BY,      (modes.contains( &quot;s&quot;) ) ? 3 : 50                      );</span>
<span class="fc" id="L529">            conf.put( Should.BE_COMPACT,           modes.contains( &quot;c&quot; )                                 );</span>
<span class="fc" id="L530">            conf.put( Should.BE_FORMATTED,         modes.contains( &quot;f&quot; )                                 );</span>
<span class="fc" id="L531">            conf.put( Should.HAVE_GRADIENT,        modes.contains( &quot;g&quot; )                                 );</span>
<span class="fc bfc" id="L532" title="All 4 branches covered.">            conf.put( Should.HAVE_PADDING_OF,     (modes.contains( &quot;p&quot; )) ? 6 : modes.contains( &quot;f&quot; )?2:1 );</span>
<span class="pc bpc" id="L533" title="2 of 4 branches missed.">            conf.put( Should.HAVE_VALUE,          !(modes.contains( &quot;shp&quot; ) || modes.contains(&quot;shape&quot;))   );</span>
<span class="fc" id="L534">            conf.put( Should.HAVE_RECURSIVE_GRAPH, modes.contains( &quot;r&quot; )                                 );</span>
<span class="fc" id="L535">            conf.put( Should.HAVE_DERIVATIVES,     modes.contains( &quot;d&quot; )                                 );</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">            conf.put( Should.HAVE_SHAPE,           !modes.contains( &quot;v&quot; )                                );</span>
<span class="fc" id="L537">            conf.put( Should.BE_CELL_BOUND,        modes.contains(&quot;b&quot;)                                   );</span>
<span class="fc" id="L538">            return conf;</span>
        }
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>