<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.utility</a> &gt; <span class="el_source">DataConverter.java</span></div><h1>DataConverter.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   _____        _         _____                          _
  |  __ \      | |       / ____|                        | |
  | |  | | __ _| |_ __ _| |     ___  _ ____   _____ _ __| |_ ___ _ __
  | |  | |/ _` | __/ _` | |    / _ \| '_ \ \ / / _ \ '__| __/ _ \ '__|
  | |__| | (_| | || (_| | |___| (_) | | | \ V /  __/ |  | ||  __/ |
  |_____/ \__,_|\__\__,_|\_____\___/|_| |_|\_/ \___|_|   \__\___|_|

    A helpful little singleton class used for data conversion.

*/

package neureka.utility;

import neureka.dtype.DataType;
import org.jetbrains.annotations.Contract;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;
import java.util.stream.IntStream;

/**
 *  This class is a singleton.
 *  Its sole job is to simply take in any kind ob object and convert it into
 *  another object of a provided Class type...
 *  In essence the {@link DataConverter} is merely a utility class.
 *  It also contains a nested static class named &quot;Utility&quot; which
 *  provides useful methods to handle primitive data types and arrays
 *  of said types.
 */
public class DataConverter
{
<span class="fc" id="L59">    private final static Logger _LOG = LoggerFactory.getLogger(DataConverter.class);</span>
    /**
     *  This interface declares a simple lambda which represents type conversion implementations...
     *  These conversion lambdas are then stored within a nested Map that can be extended easily.
     *  The structure of this interface is not different to the java.util.function.Function&lt;T,R&gt;
     *  interface, however for the sake of descriptiveness and completeness the interface is
     *  still redefined and named accordingly!
     *
     * @param &lt;FromType&gt; The type that is being passed to the lambda.
     * @param &lt;ToType&gt; The target type that is returned.
     */
    private interface Conversion&lt;FromType, ToType&gt; { ToType go(FromType thing); }

    /**
     *  This nested Map field manages Converter lambda instances!
     *  Besides Converter lambdas there are also Class objects used as keys.
     *  The keys of the outer Map represent &quot;from types&quot;, whereas inner keys
     *  represent &quot;to types&quot;.
     *  This allows for fast Converter access for a given type pair!
     */
<span class="fc" id="L79">    private static Map&lt;Class&lt;?&gt;, Map&lt;Class, Conversion&gt;&gt; _converters = new HashMap&lt;&gt;();</span>

    /**
     *  This class is a singleton.
     *  Therefore it stores the following static &quot;_instance&quot; variable.
     */
<span class="fc" id="L85">    private static DataConverter _instance = new DataConverter();</span>

    /**
     *  This method returns the singleton.
     *
     * @return The singleton instance of this class.
     */
    public static DataConverter instance() {
<span class="fc" id="L93">        return _instance;</span>
    }

    /**
     *  This constructor is private because the DataConverter class is a singleton.
     *  Within the constructor the Converter lambdas are being set for a given
     *  &quot;from&quot;- and &quot;to&quot;- Class pair.
     */
    private DataConverter()
<span class="fc" id="L102">    {</span>
<span class="fc" id="L103">        _set( byte[].class, float[].class, Utility::byteToFloat );</span>
<span class="fc" id="L104">        _set( byte[].class, double[].class, Utility::byteToDouble );</span>
<span class="fc" id="L105">        _set( byte[].class, short[].class, Utility::byteToShort );</span>
<span class="fc" id="L106">        _set( byte[].class, int[].class, Utility::byteToInt );</span>
<span class="fc" id="L107">        _set( byte[].class, long[].class, Utility::byteToLong );</span>
<span class="fc" id="L108">        _set( byte[].class, BigInteger[].class, Utility::byteToBigInteger );</span>

<span class="fc" id="L110">        _set( float[].class, double[].class, Utility::floatToDouble );</span>
<span class="fc" id="L111">        _set( float[].class, int[].class,    Utility::floatToInt );</span>
<span class="fc" id="L112">        _set( float[].class, short[].class, Utility::floatToShort );</span>
<span class="fc" id="L113">        _set( float[].class, byte[].class, Utility::floatToByte );</span>
<span class="fc" id="L114">        _set( float[].class, long[].class, Utility::floatToLong );</span>
<span class="fc" id="L115">        _set( float[].class, BigInteger[].class, Utility::floatToBigInteger );</span>

<span class="fc" id="L117">        _set( int[].class, float[].class,    Utility::intToFloat );</span>
<span class="fc" id="L118">        _set( int[].class, double[].class,   Utility::intToDouble );</span>
<span class="fc" id="L119">        _set( int[].class, long[].class, Utility::intToLong );</span>
<span class="fc" id="L120">        _set( int[].class, short[].class, Utility::intToShort );</span>
<span class="fc" id="L121">        _set( int[].class, BigInteger[].class, Utility::intToBigInteger );</span>
<span class="fc" id="L122">        _set( int[].class, byte[].class, Utility::intToByte );</span>

<span class="fc" id="L124">        _set( long[].class, byte[].class, Utility::longToByte );</span>
<span class="fc" id="L125">        _set( long[].class, short[].class, Utility::longToShort );</span>
<span class="fc" id="L126">        _set( long[].class, int[].class, Utility::longToInt );</span>
<span class="fc" id="L127">        _set( long[].class, float[].class, Utility::longToFloat );</span>
<span class="fc" id="L128">        _set( long[].class, double[].class, Utility::longToDouble );</span>
<span class="fc" id="L129">        _set( long[].class, BigInteger[].class, Utility::longToBigInteger );</span>

<span class="fc" id="L131">        _set( short[].class, long[].class, Utility::shortToLong );</span>
<span class="fc" id="L132">        _set( short[].class, double[].class, Utility::shortToDouble );</span>
<span class="fc" id="L133">        _set( short[].class, float[].class, Utility::shortToFloat );</span>
<span class="fc" id="L134">        _set( short[].class, int[].class, Utility::shortToInt );</span>
<span class="fc" id="L135">        _set( short[].class, byte[].class, Utility::shortToByte );</span>
<span class="fc" id="L136">        _set( short[].class, BigInteger[].class, Utility::shortToBigInteger );</span>

<span class="fc" id="L138">        _set( double[].class, byte[].class,  Utility::doubleToByte );</span>
<span class="fc" id="L139">        _set( double[].class, short[].class, Utility::doubleToShort );</span>
<span class="fc" id="L140">        _set( double[].class, int[].class, Utility::doubleToInt );</span>
<span class="fc" id="L141">        _set( double[].class, BigInteger[].class, Utility::doubleToBigInteger );</span>
<span class="fc" id="L142">        _set( double[].class, long[].class, Utility::doubleToLong );</span>
<span class="fc" id="L143">        _set( double[].class, float[].class, Utility::doubleToFloat );</span>

<span class="pc" id="L145">        _set( List.class, int[].class, thing -&gt; thing.stream().mapToInt( i -&gt; (int) i ).toArray() );</span>
<span class="pc" id="L146">        _set( List.class, double[].class, thing -&gt; thing.stream().mapToDouble( i -&gt; (double) i ).toArray() );</span>
<span class="pc" id="L147">        _set( List.class, long[].class, thing -&gt; thing.stream().mapToLong( i -&gt; (long) i ).toArray() );</span>
<span class="fc" id="L148">        _set( BigInteger.class, Double.class, BigInteger::doubleValue );</span>
<span class="fc" id="L149">        _set( BigDecimal.class, Double.class, BigDecimal::doubleValue );</span>
<span class="fc" id="L150">        _set( Integer.class, Double.class, Integer::doubleValue );</span>
<span class="fc" id="L151">        _set( Integer.class, Float.class, Integer::floatValue );</span>
<span class="fc" id="L152">        _set( Integer.class, Short.class, Integer::shortValue );</span>
<span class="fc" id="L153">        _set( Integer.class, Byte.class, Integer::byteValue );</span>

<span class="fc" id="L155">        _set( Float[].class, float[].class,   Utility::objFloatsToPrimFloats );</span>
<span class="fc" id="L156">        _set( Integer[].class, int[].class,   Utility::objIntsToPrimInts );</span>
<span class="fc" id="L157">        _set( Long[].class, long[].class,     Utility::objLongsToPrimLongs );</span>
<span class="fc" id="L158">        _set( Double[].class, double[].class, Utility::objDoublesToPrimDoubles );</span>
<span class="fc" id="L159">        _set( Short[].class, short[].class,   Utility::objShortsToPrimShorts );</span>
<span class="fc" id="L160">        _set( Byte[].class, byte[].class,     Utility::objBytesToPrimBytes );</span>
<span class="fc" id="L161">    }</span>

    /**
     *  This method fills the previously defined nested Map field of this class
     *  with Converter instances using the provided Class objects as keys.
     *
     * @param from The Class of the type that is being put into the given converter.
     * @param to The Class of the type that is being returned by the given converter.
     * @param conversion The Converter lambda instance, namely : the conversion for the provided types.
     * @param &lt;F&gt; The &quot;from&quot; type argument.
     * @param &lt;T&gt; The &quot;to&quot; type argument.
     */
    private &lt;F,T&gt; void _set(
            Class&lt;F&gt; from, Class&lt;T&gt; to,
            Conversion&lt;F,T&gt; conversion
    ) {
<span class="fc" id="L177">        Map&lt;Class, Conversion&gt; fromMap = _converters.get(from);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if ( fromMap == null )</span>
        {
<span class="fc" id="L180">            fromMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L181">            fromMap.put(to, conversion);</span>
<span class="fc" id="L182">            fromMap.put(DataType.of(to).getTypeClass(), conversion);</span>
<span class="fc" id="L183">            _converters.put( from, fromMap );</span>
        } else {
<span class="fc" id="L185">            Conversion found = fromMap.get(to);</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">            if ( found != null ) throw new IllegalStateException(</span>
<span class="nc" id="L187">                    &quot;Conversion already present! From class '&quot;+from.getName()+&quot;'. To clas '&quot;+to.getName()+&quot;'.&quot;</span>
                    );
<span class="fc" id="L189">            else fromMap.put(to, conversion);</span>
        }
<span class="fc" id="L191">    }</span>

    /**
     *  This method embodies the purpose of this class.
     *  It receives objects for type conversion and queries the request
     *  through the nested &quot;_converters&quot; Map instance.
     *
     * @param from The object which ought to be converted.
     * @param to The target type for the provided object.
     * @param &lt;T&gt; The type parameter of the &quot;to&quot; Class.
     * @return The target object created by a Converter lambda.
     */
    public &lt;T&gt; T convert( Object from, Class&lt;T&gt; to ) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if ( from == null ) return null;</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if ( from.getClass() == to ) return (T) from;</span>
<span class="fc" id="L206">        Map&lt;Class, Conversion&gt; fromSpecific = _converters.get( from.getClass() );</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if ( fromSpecific == null ) {</span>
<span class="nc" id="L208">            String fromName = from.getClass().getSimpleName();</span>
<span class="nc" id="L209">            String toName = to.getSimpleName();</span>
<span class="nc" id="L210">            String message =</span>
                    &quot;Conversion from '&quot;+fromName+&quot;' to '&quot;+toName+&quot;' could not be performed.\n&quot; +
                            &quot;No converter lambdas were found for type '&quot;+fromName+&quot;'!&quot;;
<span class="nc" id="L213">            _LOG.error( message );</span>
<span class="nc" id="L214">            throw new IllegalArgumentException( message );</span>
        }
<span class="fc" id="L216">        Map&lt;Class, Conversion&gt; tos = _converters.get(from.getClass());</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if ( tos == null ) {</span>
<span class="nc" id="L218">            String message = &quot;Conversion from type '&quot;+from.getClass()+&quot;' to '&quot;+to+&quot;' failed: No converters found for '&quot;+from.getClass()+&quot;'.&quot;;</span>
<span class="nc" id="L219">            _LOG.error(message);</span>
<span class="nc" id="L220">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L222">        Conversion&lt;Object, Object&gt; conversion = tos.get(to);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if ( conversion == null ) {</span>
<span class="nc" id="L224">            String message = &quot;No converter found from type '&quot;+from.getClass()+&quot;' to '&quot;+to+&quot;'.&quot;;</span>
<span class="nc" id="L225">            _LOG.error(message);</span>
<span class="nc" id="L226">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L228">        return (T) conversion.go(from);</span>
    }



    public &lt;F extends Number, T&gt; T convert( F[] from, Class&lt;T&gt; to, int size ) {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if ( from.length == size )</span>
<span class="fc" id="L235">            return convert( from, to );</span>
        else {
<span class="fc" id="L237">            Iterator&lt;F&gt; stream = IntStream.iterate(0, i -&gt; i + 1).limit(size).mapToObj(i -&gt; from[i % from.length] ).iterator();</span>
<span class="fc" id="L238">            int index = 0;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            if ( from instanceof Integer[] ) {</span>
<span class="fc" id="L240">                Integer[] array = new Integer[size];</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                for ( Iterator&lt;F&gt; it = stream; it.hasNext(); ) { array[ index ] = (Integer) it.next(); index++; }</span>
<span class="fc" id="L242">                return convert( array, to );</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            } else if ( from instanceof Double[] ) {</span>
<span class="fc" id="L244">                Double[] array = new Double[size];</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                for ( Iterator&lt;F&gt; it = stream; it.hasNext(); ) { array[ index ] = (Double) it.next(); index++; }</span>
<span class="fc" id="L246">                return convert( array, to );</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            } else if ( from instanceof Float[] ) {</span>
<span class="fc" id="L248">                Float[] array = new Float[size];</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                for ( Iterator&lt;F&gt; it = stream; it.hasNext(); ) { array[ index ] = (Float) it.next(); index++; }</span>
<span class="fc" id="L250">                return convert( array, to );</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            } else if ( from instanceof Short[] ) {</span>
<span class="fc" id="L252">                Short[] array = new Short[size];</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                for ( Iterator&lt;F&gt; it = stream; it.hasNext(); ) { array[ index ] = (Short) it.next(); index++; }</span>
<span class="fc" id="L254">                return convert( array, to );</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            } else if ( from instanceof Long[] ) {</span>
<span class="fc" id="L256">                Long[] array = new Long[size];</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">                for ( Iterator&lt;F&gt; it = stream; it.hasNext(); ) { array[ index ] = (Long) it.next(); index++; }</span>
<span class="fc" id="L258">                return convert( array, to );</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">            } else if ( from instanceof Byte[] ) {</span>
<span class="fc" id="L260">                Byte[] array = new Byte[size];</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">                for ( Iterator&lt;F&gt; it = stream; it.hasNext(); ) { array[ index ] = (Byte) it.next(); index++; }</span>
<span class="fc" id="L262">                return convert( array, to );</span>
            }
<span class="nc" id="L264">            Object[] array = new Object[ size ];</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            for ( Iterator&lt;F&gt; it = stream; it.hasNext(); ) { array[ index ] = it.next(); index++; }</span>
<span class="nc" id="L266">            return convert( array, to );</span>
        }
    }

    /**
     *  This is a static utility class containing the actual conversion logic
     *  which is usually referenced by the Converter lambdas via method signatures...
     *  Besides that it also provides the ability to create seeded arrays of data.
     */
<span class="nc" id="L275">    public static class Utility</span>
    {
        public static float[] objFloatsToPrimFloats( Float[] objects ) {
<span class="fc" id="L278">            float[] array = new float[objects.length];</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">            for ( int i = 0; i &lt; array.length; i++ ) {</span>
<span class="fc" id="L280">                array[i] = objects[i];</span>
            }
<span class="fc" id="L282">            return array;</span>
        }

        public static double[] objDoublesToPrimDoubles( Double[] objects ) {
<span class="fc" id="L286">            double[] array = new double[objects.length];</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">            for ( int i = 0; i &lt; array.length; i++ ) {</span>
<span class="fc" id="L288">                array[i] = objects[i];</span>
            }
<span class="fc" id="L290">            return array;</span>
        }

        public static int[] objIntsToPrimInts( Integer[] objects ) {
<span class="fc" id="L294">            int[] array = new int[objects.length];</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">            for ( int i = 0; i &lt; array.length; i++ ) {</span>
<span class="fc" id="L296">                array[i] = objects[i];</span>
            }
<span class="fc" id="L298">            return array;</span>
        }

        public static long[] objLongsToPrimLongs( Long[] objects ) {
<span class="fc" id="L302">            long[] array = new long[objects.length];</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            for ( int i = 0; i &lt; array.length; i++ ) {</span>
<span class="fc" id="L304">                array[i] = objects[i];</span>
            }
<span class="fc" id="L306">            return array;</span>
        }

        public static short[] objShortsToPrimShorts( Short[] objects ) {
<span class="fc" id="L310">            short[] array = new short[objects.length];</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">            for ( int i = 0; i &lt; array.length; i++ ) {</span>
<span class="fc" id="L312">                array[i] = objects[i];</span>
            }
<span class="fc" id="L314">            return array;</span>
        }

        public static byte[] objBytesToPrimBytes( Byte[] objects ) {
<span class="fc" id="L318">            byte[] array = new byte[objects.length];</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            for ( int i = 0; i &lt; array.length; i++ ) {</span>
<span class="fc" id="L320">                array[i] = objects[i];</span>
            }
<span class="fc" id="L322">            return array;</span>
        }

        public static double[] newSeededDoubleArray(String seed, int size) {
<span class="fc" id="L326">            return newSeededDoubleArray(_longStringHash(seed), size);</span>
        }

        public static double[] newSeededDoubleArray(long seed, int size) {
<span class="fc" id="L330">            return seededDoubleArray(new double[size], seed);</span>
        }

        public static double[] seededDoubleArray(double[] array, String seed) {
<span class="fc" id="L334">            return seededDoubleArray(array, _longStringHash(seed));</span>
        }

        public static double[] seededDoubleArray(double[] array, long seed) {
<span class="fc" id="L338">            Random dice = new Random();</span>
<span class="fc" id="L339">            dice.setSeed(seed);</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">            for( int i=0; i&lt;array.length; i++ ) array[ i ] = dice.nextGaussian();</span>
<span class="fc" id="L341">            return array;</span>
        }

        public static float[] newSeededFloatArray(String seed, int size) {
<span class="fc" id="L345">            return newSeededFloatArray(_longStringHash(seed), size);</span>
        }

        public static float[] newSeededFloatArray(long seed, int size) {
<span class="fc" id="L349">            return seededFloatArray(new float[size], seed);</span>
        }

        public static float[] seededFloatArray(float[] array, String seed) {
<span class="fc" id="L353">            return seededFloatArray(array, _longStringHash(seed));</span>
        }

        public static float[] seededFloatArray(float[] array, long seed) {
<span class="fc" id="L357">            Random dice = new Random();</span>
<span class="fc" id="L358">            dice.setSeed(seed);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">            for(int i=0; i&lt;array.length; i++) array[ i ] = (float)dice.nextGaussian();</span>
<span class="fc" id="L360">            return array;</span>
        }

        private static long _longStringHash(String string)
        {
<span class="fc" id="L365">            long h = 1125899906842597L; // prime</span>
<span class="fc" id="L366">            int len = string.length();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            for ( int i = 0; i &lt; len; i++ ) h = 31*h + string.charAt( i );</span>
<span class="fc" id="L368">            return h;</span>
        }


        public static short[] byteToShort( byte[] data ) {
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L374">            short[] newData = new short[data.length];</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L376">            return newData;</span>
        }

        public static BigInteger[] byteToBigInteger( byte[] data ) {
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L381">            BigInteger[] newData = new BigInteger[data.length];</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = BigInteger.valueOf( data[ i ] );</span>
<span class="fc" id="L383">            return newData;</span>
        }

        public static float[] doubleToFloat( double[] data ) {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L388">            float[] newData = new float[data.length];</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (float) data[ i ];</span>
<span class="fc" id="L390">            return newData;</span>
        }

        public static byte[] doubleToByte( double[] data ) {
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L395">            byte[] newData = new byte[data.length];</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (byte) data[ i ];</span>
<span class="fc" id="L397">            return newData;</span>
        }

        public static short[] doubleToShort( double[] data ) {
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L402">            short[] newData = new short[ data.length ];</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (short) data[ i ];</span>
<span class="fc" id="L404">            return newData;</span>
        }

        public static long[] doubleToLong( double[] data ) {
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L409">            long[] newData = new long[ data.length ];</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (long) data[ i ];</span>
<span class="fc" id="L411">            return newData;</span>
        }

        public static double[] floatToDouble(float[] data) {
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L416">            double[] newData = new double[data.length];</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (double)data[ i ];</span>
<span class="fc" id="L418">            return newData;</span>
        }

        public static byte[] floatToByte( float[] data ) {
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L423">            byte[] newData = new byte[data.length];</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (byte) data[ i ];</span>
<span class="fc" id="L425">            return newData;</span>
        }

        public static short[] floatToShort( float[] data ) {
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L430">            short[] newData = new short[data.length];</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (short) data[ i ];</span>
<span class="fc" id="L432">            return newData;</span>
        }

        public static long[] floatToLong( float[] data ) {
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L437">            long[] newData = new long[data.length];</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (long) data[ i ];</span>
<span class="fc" id="L439">            return newData;</span>
        }

        public static double[] shortToDouble(short[] data) {
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L444">            double[] newData = new double[data.length];</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L446">            return newData;</span>
        }

        public static double[] byteToDouble(byte[] data) {
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L451">            double[] newData = new double[data.length];</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L453">            return newData;</span>
        }

        public static float[] byteToFloat(byte[] data) {
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L458">            float[] newData = new float[data.length];</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L460">            return newData;</span>
        }

        public static float[] shortToFloat(short[] data) {
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L465">            float[] newData = new float[data.length];</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L467">            return newData;</span>
        }

        public static int[] byteToInt(byte[] data) {
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L472">            int[] newData = new int[data.length];</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L474">            return newData;</span>
        }

        public static int[] shortToInt(short[] data) {
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L479">            int[] newData = new int[data.length];</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L481">            return newData;</span>
        }

        public static byte[] shortToByte(short[] data) {
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L486">            byte[] newData = new byte[data.length];</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (byte) data[ i ];</span>
<span class="fc" id="L488">            return newData;</span>
        }

        public static long[] byteToLong(byte[] data) {
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L493">            long[] newData = new long[data.length];</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L495">            return newData;</span>
        }

        public static long[] shortToLong(short[] data) {
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L500">            long[] newData = new long[data.length];</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L502">            return newData;</span>
        }

        public static BigInteger[] shortToBigInteger(short[] data) {
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L507">            BigInteger[] newData = new BigInteger[data.length];</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = BigInteger.valueOf( data[ i ] );</span>
<span class="fc" id="L509">            return newData;</span>
        }

        public static float[] intToFloat(int[] data) {
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L514">            float[] newData = new float[data.length];</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (float) data[ i ];</span>
<span class="fc" id="L516">            return newData;</span>
        }

        public static int[] floatToInt(float[] data) {
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L521">            int[] newData = new int[data.length];</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (int) data[ i ];</span>
<span class="fc" id="L523">            return newData;</span>
        }

        public static BigInteger[] floatToBigInteger( float[] data ) {
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L528">            BigInteger[] newData = new BigInteger[ data.length ];</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">            for ( int i = 0; i &lt; data.length; i++ ) newData[ i ] = BigInteger.valueOf( (int) data[i] );</span>
<span class="fc" id="L530">            return newData;</span>
        }

        public static int[] doubleToInt(double[] data) {
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L535">            int[] newData = new int[data.length];</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (int) data[ i ];</span>
<span class="fc" id="L537">            return newData;</span>
        }

        public static BigInteger[] doubleToBigInteger( double[] data ) {
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L542">            BigInteger[] newData = new BigInteger[ data.length ];</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">            for ( int i = 0; i &lt; data.length; i++ ) newData[ i ] = BigInteger.valueOf( (long) data[i] );</span>
<span class="fc" id="L544">            return newData;</span>
        }

        public static double[] intToDouble(int[] data) {
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L549">            double[] newData = new double[data.length];</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L551">            return newData;</span>
        }

        public static long[] intToLong( int[] data ) {
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L556">            long[] newData = new long[data.length];</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = data[ i ];</span>
<span class="fc" id="L558">            return newData;</span>
        }

        public static short[] intToShort( int[] data ) {
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L563">            short[] newData = new short[data.length];</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (short) data[ i ];</span>
<span class="fc" id="L565">            return newData;</span>
        }

        public static byte[] intToByte( int[] data ) {
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L570">            byte[] newData = new byte[data.length];</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (byte) data[ i ];</span>
<span class="fc" id="L572">            return newData;</span>
        }

        public static BigInteger[] intToBigInteger( int[] data ) {
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">            if ( data == null ) return null;</span>
<span class="fc" id="L577">            BigInteger[] newData = new BigInteger[ data.length ];</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">            for ( int i = 0; i &lt; data.length; i++ ) newData[ i ] = BigInteger.valueOf( data[i] );</span>
<span class="fc" id="L579">            return newData;</span>
        }

        public static byte[] longToByte(long[] data) {
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L584">            byte[] newData = new byte[data.length];</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (byte) data[ i ];</span>
<span class="fc" id="L586">            return newData;</span>
        }

        public static short[] longToShort(long[] data) {
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L591">            short[] newData = new short[data.length];</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (short) data[ i ];</span>
<span class="fc" id="L593">            return newData;</span>
        }

        public static int[] longToInt(long[] data) {
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L598">            int[] newData = new int[data.length];</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (int) data[ i ];</span>
<span class="fc" id="L600">            return newData;</span>
        }

        public static float[] longToFloat(long[] data) {
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L605">            float[] newData = new float[data.length];</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (float) data[ i ];</span>
<span class="fc" id="L607">            return newData;</span>
        }

        @Contract( pure = true )
        public static double[] longToDouble(long[] data) {
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L613">            double[] newData = new double[data.length];</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = (double) data[ i ];</span>
<span class="fc" id="L615">            return newData;</span>
        }

        @Contract( pure = true )
        public static BigInteger[] longToBigInteger( long[] data ) {
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">            if (data==null) return null;</span>
<span class="fc" id="L621">            BigInteger[] newData = new BigInteger[data.length];</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">            for(int i=0; i&lt;data.length; i++) newData[ i ] = BigInteger.valueOf( data[ i ] );</span>
<span class="fc" id="L623">            return newData;</span>
        }

        //---

        @Contract( pure = true )
        public static double[] objectsToDoubles( Object[] objects, int targetSize ) {
<span class="fc" id="L630">            double[] data = new double[ targetSize ];</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">            for ( int i = 0; i &lt; data.length; i++ ) {</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">                if ( objects[ i % objects.length ] instanceof BigDecimal )</span>
<span class="fc" id="L633">                    data[ i ] = ( (BigDecimal) objects[ i % objects.length ] ).doubleValue();</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">                else if ( objects[ i % objects.length ] instanceof Integer )</span>
<span class="fc" id="L635">                    data[ i ] = (Integer) objects[ i % objects.length ];</span>
            }
<span class="fc" id="L637">            return data;</span>
        }

        @Contract( pure = true )
        public static float[] objectsToFloats( Object[] objects, int targetSize ) {
<span class="nc" id="L642">            float[] data = new float[ targetSize ];</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            for ( int i = 0; i &lt; data.length; i++ ) {</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                if ( objects[ i % objects.length ] instanceof BigDecimal )</span>
<span class="nc" id="L645">                    data[ i ] = ( (BigDecimal) objects[ i % objects.length ] ).floatValue();</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">                else if ( objects[ i % objects.length ] instanceof Integer )</span>
<span class="nc" id="L647">                    data[ i ] = (Integer) objects[ i % objects.length ];</span>
            }
<span class="nc" id="L649">            return data;</span>
        }

        @Contract( pure = true )
        public static short[] objectsToShorts( Object[] objects, int targetSize ) {
<span class="nc" id="L654">            short[] data = new short[ targetSize ];</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">            for ( int i = 0; i &lt; data.length; i++ ) {</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if ( objects[ i % objects.length ] instanceof BigDecimal )</span>
<span class="nc" id="L657">                    data[ i ] = ( (BigDecimal) objects[ i % objects.length ] ).shortValue();</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">                else if ( objects[ i % objects.length ] instanceof Integer )</span>
<span class="nc" id="L659">                    data[ i ] = ( (Integer) objects[ i % objects.length ] ).shortValue();</span>
            }
<span class="nc" id="L661">            return data;</span>
        }

        @Contract( pure = true )
        public static byte[] objectsToBytes( Object[] objects, int targetSize ) {
<span class="nc" id="L666">            byte[] data = new byte[ targetSize ];</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">            for ( int i = 0; i &lt; data.length; i++ ) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                if ( objects[ i % objects.length ] instanceof BigDecimal )</span>
<span class="nc" id="L669">                    data[ i ] = ( (BigDecimal) objects[ i % objects.length ] ).byteValue();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">                else if ( objects[ i % objects.length ] instanceof Integer )</span>
<span class="nc" id="L671">                    data[ i ] = ( (Integer) objects[ i % objects.length ] ).byteValue();</span>
            }
<span class="nc" id="L673">            return data;</span>
        }

        @Contract( pure = true )
        public static long[] objectsToLongs( Object[] objects, int targetSize ) {
<span class="nc" id="L678">            long[] data = new long[ targetSize ];</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">            for ( int i = 0; i &lt; data.length; i++ ) {</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                if ( objects[ i % objects.length ] instanceof BigDecimal )</span>
<span class="nc" id="L681">                    data[ i ] = ( (BigDecimal) objects[ i % objects.length ] ).longValue();</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                else if ( objects[ i % objects.length ] instanceof Integer )</span>
<span class="nc" id="L683">                    data[ i ] = ( (Integer) objects[ i % objects.length ] ).longValue();</span>
            }
<span class="nc" id="L685">            return data;</span>
        }

        @Contract( pure = true )
        public static int[] objectsToInts( Object[] objects, int targetSize ) {
<span class="nc" id="L690">            int[] data = new int[ targetSize ];</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            for ( int i = 0; i &lt; data.length; i++ ) {</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                if ( objects[ i % objects.length ] instanceof BigDecimal )</span>
<span class="nc" id="L693">                    data[ i ] = ( (BigDecimal) objects[ i % objects.length ] ).shortValueExact();</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                else if ( objects[ i % objects.length ] instanceof Integer )</span>
<span class="nc" id="L695">                    data[ i ] = ( (Integer) objects[ i % objects.length ] );</span>
            }
<span class="nc" id="L697">            return data;</span>
        }
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>