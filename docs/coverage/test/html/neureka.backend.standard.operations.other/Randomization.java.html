<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Randomization.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.backend.standard.operations.other</a> &gt; <span class="el_source">Randomization.java</span></div><h1>Randomization.java</h1><pre class="source lang-java linenums">package neureka.backend.standard.operations.other;

import neureka.Tsr;
import neureka.backend.api.ExecutionCall;
import neureka.backend.api.operations.AbstractOperation;
import neureka.backend.api.operations.OperationBuilder;
import neureka.backend.standard.algorithms.Activation;
import neureka.backend.standard.implementations.CPUImplementation;
import neureka.calculus.Function;
import neureka.calculus.args.Arg;
import neureka.calculus.internal.CalcUtil;
import neureka.devices.host.CPU;
import neureka.devices.opencl.OpenCLDevice;
import neureka.ndim.iterator.NDIterator;

import java.util.Arrays;

/**
 *  This {@link neureka.backend.api.Operation} takes an optional user seed,
 *  the shape of its input tensor, and
 *  the indices of individual elements within said tensor to generate
 *  floats or doubles with a gaussian distribution where the mean
 *  is 0 and the standard deviation is 1.
 *  This operation is very fast because it generates numbers in parallel unlike
 *  the JDKs random number generator class {@link java.util.Random}.
 */
public class Randomization extends AbstractOperation
{
    private static final long   MULTIPLIER = 0x5DEECE66DL;
    private static final long   ADDEND = 0xBL;
    private static final long   MASK = (1L &lt;&lt; 48) - 1;
    private static final double DOUBLE_UNIT = 0x1.0p-53; // 1.0 / (1L &lt;&lt; 53)

    public Randomization()
    {
<span class="fc" id="L36">        super(</span>
            new OperationBuilder()
<span class="fc" id="L38">                .setIdentifier(       &quot;random&quot;   )</span>
<span class="fc" id="L39">                .setOperator(         &quot;rand&quot;     )</span>
<span class="fc" id="L40">                .setArity(            1          )</span>
<span class="fc" id="L41">                .setIsOperator(       true       )</span>
<span class="fc" id="L42">                .setIsIndexer(        false      )</span>
<span class="fc" id="L43">                .setIsDifferentiable( false      )</span>
<span class="fc" id="L44">                .setIsInline(         true       )</span>
        );

<span class="fc" id="L47">        setAlgorithm(</span>
            new Activation()
<span class="fc" id="L49">                .setCanPerformBackwardADFor( call -&gt; false )</span>
<span class="fc" id="L50">                .setCanPerformForwardADFor( call -&gt; false )</span>
<span class="fc" id="L51">                .setSupplyADAgentFor( getDefaultAlgorithm() )</span>
<span class="fc" id="L52">                .setExecutionDispatcher( CalcUtil::defaultRecursiveExecution )</span>
<span class="fc" id="L53">                .setCallPreparation( call -&gt;</span>
                {
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">                    if ( call.input( 0 ) == null )</span>
<span class="fc" id="L56">                        call.setInput( 0, call.input( 1 ) );</span>

<span class="fc" id="L58">                    call.input( 0 ).getUnsafe().incrementVersion(call);</span>

<span class="fc" id="L60">                    int hash = Arrays.hashCode( call.input( 0 ).getNDConf().shape() );</span>
<span class="fc" id="L61">                    Arg.Seed seed = call.get(Arg.Seed.class);</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">                    if ( seed != null ) seed = Arg.Seed.of( initialScramble(seed.get() + hash) );</span>
<span class="fc" id="L63">                    else seed = Arg.Seed.of( initialScramble(hash) );</span>

<span class="fc" id="L65">                    return call.withArgs(seed);</span>
                })
<span class="fc" id="L67">                .buildFunAlgorithm()</span>
<span class="fc" id="L68">                .setImplementationFor(</span>
                    CPU.class,
                    CPUImplementation
<span class="fc" id="L71">                        .withArity(1)</span>
<span class="fc" id="L72">                        .andImplementation(</span>
                            call -&gt;
                                call
<span class="fc" id="L75">                                .getDevice()</span>
<span class="fc" id="L76">                                .getExecutor()</span>
<span class="fc" id="L77">                                .threaded(</span>
<span class="fc" id="L78">                                    call.input( Number.class, 0 ).size(),</span>
<span class="fc" id="L79">                                    _newWorkloadFor( call )</span>
                                )
                        )
                )
<span class="fc" id="L83">                .setImplementationFor(</span>
                    OpenCLDevice.class,
                    call -&gt; {
<span class="nc" id="L86">                        throw new IllegalStateException(&quot;Not yet implemented&quot;);</span>
                    }
                )
        );

<span class="fc" id="L91">    }</span>

    private static CPU.RangeWorkload _newWorkloadFor( ExecutionCall&lt;?&gt; call )
    {
<span class="fc" id="L95">        Tsr&lt;?&gt; tensor = call.input( 0 );</span>
<span class="fc" id="L96">        tensor.setIsVirtual(false);</span>
<span class="fc" id="L97">        Class&lt;?&gt; type = tensor.getValueClass();</span>
<span class="fc" id="L98">        boolean isSimple = tensor.getNDConf().isSimple();</span>
<span class="fc" id="L99">        long seed = call.getValOf(Arg.Seed.class);</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">        if ( type == Double.class ) {</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">            if ( isSimple )</span>
<span class="fc" id="L103">                return (i, end) -&gt; {</span>
<span class="fc" id="L104">                    double[] t0_value = tensor.getUnsafe().getDataForWriting(double[].class);</span>
<span class="fc" id="L105">                    double[] gaussian = {0, 0};</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">                    if ( i % 2 == 1 ) {</span>
<span class="fc" id="L107">                        gaussianFrom(seed + i - 1, gaussian);</span>
<span class="fc" id="L108">                        t0_value[i] = gaussian[1];</span>
<span class="fc" id="L109">                        i++;</span>
                    }
<span class="fc bfc" id="L111" title="All 2 branches covered.">                    for ( ; i &lt; end; i += 2 ) // increment on drain accordingly:</span>
                    {
<span class="fc" id="L113">                        gaussianFrom(seed + i, gaussian);</span>
<span class="fc" id="L114">                        t0_value[i + 0] = gaussian[0];</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                        if ( i + 1 &lt; end ) t0_value[i + 1] = gaussian[1];</span>
                    }
<span class="fc" id="L117">                };</span>
            else
<span class="fc" id="L119">                return (i, end) -&gt; {</span>
<span class="fc" id="L120">                    NDIterator t0Idx = NDIterator.of(tensor);</span>
<span class="fc" id="L121">                    t0Idx.set(tensor.indicesOfIndex(i));</span>
<span class="fc" id="L122">                    double[] t0_value = tensor.getUnsafe().getDataForWriting(double[].class);</span>
<span class="fc" id="L123">                    double[] gaussian = {0, 0};</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">                    if ( i % 2 == 1 ) {</span>
<span class="fc" id="L125">                        gaussianFrom(seed + i - 1, gaussian);</span>
<span class="fc" id="L126">                        t0_value[t0Idx.getIndexAndIncrement()] = gaussian[1];</span>
<span class="fc" id="L127">                        i++;</span>
                    }
<span class="fc bfc" id="L129" title="All 2 branches covered.">                    for ( ; i &lt; end; i += 2 ) // increment on drain accordingly:</span>
                    {
<span class="fc" id="L131">                        gaussianFrom(seed + i, gaussian);</span>
<span class="fc" id="L132">                        t0_value[t0Idx.getIndexAndIncrement()] = gaussian[0];</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">                        if ( i + 1 &lt; end ) t0_value[t0Idx.getIndexAndIncrement()] = gaussian[1];</span>
                    }
<span class="fc" id="L135">                };</span>
        } else {
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if ( isSimple )</span>
<span class="fc" id="L138">                return (i, end) -&gt; {</span>
<span class="fc" id="L139">                    float[] t0_value = tensor.getUnsafe().getDataForWriting(float[].class);</span>
<span class="fc" id="L140">                    double[] gaussian = {0, 0};</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">                    if ( i % 2 == 1 ) {</span>
<span class="fc" id="L142">                        gaussianFrom(seed + i - 1, gaussian);</span>
<span class="fc" id="L143">                        t0_value[i] = (float) gaussian[1];</span>
<span class="fc" id="L144">                        i++;</span>
                    }
<span class="fc bfc" id="L146" title="All 2 branches covered.">                    for ( ; i &lt; end; i += 2 ) // increment on drain accordingly:</span>
                    {
<span class="fc" id="L148">                        gaussianFrom(seed + i, gaussian);</span>
<span class="fc" id="L149">                        t0_value[i + 0] = (float) gaussian[0];</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">                        if ( i + 1 &lt; end ) t0_value[i + 1] = (float) gaussian[1];</span>
                    }
<span class="fc" id="L152">                };</span>
            else
<span class="fc" id="L154">                return (i, end) -&gt; {</span>
<span class="fc" id="L155">                    NDIterator t0Idx = NDIterator.of(tensor);</span>
<span class="fc" id="L156">                    t0Idx.set(tensor.indicesOfIndex(i));</span>
<span class="fc" id="L157">                    float[] t0_value = tensor.getUnsafe().getDataForWriting(float[].class);</span>
<span class="fc" id="L158">                    double[] gaussian = {0, 0};</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">                    if ( i % 2 == 1 ) {</span>
<span class="fc" id="L160">                        gaussianFrom(seed + i - 1, gaussian);</span>
<span class="fc" id="L161">                        t0_value[t0Idx.getIndexAndIncrement()] = (float) gaussian[1];</span>
<span class="fc" id="L162">                        i++;</span>
                    }
<span class="fc bfc" id="L164" title="All 2 branches covered.">                    for ( ; i &lt; end; i += 2 ) // increment on drain accordingly:</span>
                    {
<span class="fc" id="L166">                        gaussianFrom(seed + i, gaussian);</span>
<span class="fc" id="L167">                        t0_value[t0Idx.getIndexAndIncrement()] = (float) gaussian[0];</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">                        if ( i + 1 &lt; end ) t0_value[t0Idx.getIndexAndIncrement()] = (float) gaussian[1];</span>
                    }
<span class="fc" id="L170">                };</span>
        }
    }

    @Override
    public String stringify( String[] children ) {
<span class="fc" id="L176">        String expression = String.join( &quot;, &quot;, children );</span>
<span class="pc bpc" id="L177" title="3 of 4 branches missed.">        if ( expression.charAt( 0 ) == '(' &amp;&amp; expression.charAt( expression.length() - 1 ) == ')' ) {</span>
<span class="nc" id="L178">            return &quot;rand&quot; + expression;</span>
        }
<span class="fc" id="L180">        return &quot;rand&quot; + &quot;(&quot; + expression + &quot;)&quot;;</span>
    }

    @Override
    public String asDerivative( Function[] children, int derivationIndex) {
<span class="nc" id="L185">        throw new IllegalStateException(&quot;Operation does not support dynamic derivation!&quot;);</span>
    }

    @Override
    public double calculate( double[] inputs, int j, int d, Function[] src ) {
<span class="nc" id="L190">        return src[ 0 ].call( inputs, j );</span>
    }

    public static long initialScramble(long seed) {
<span class="fc" id="L194">        return (seed ^ MULTIPLIER) &amp; MASK;</span>
    }

    public static void gaussianFrom( long seed, double[] out ) {

        // See Knuth, ACP, Section 3.4.1 Algorithm C.
        double v1, v2, s;
        do {
<span class="fc" id="L202">            long seed1 = _next(seed );</span>
<span class="fc" id="L203">            long seed2 = _next(seed1);</span>
<span class="fc" id="L204">            long seed3 = _next(seed2);</span>
<span class="fc" id="L205">            long seed4 = _next(seed3);</span>
<span class="fc" id="L206">            v1 = 2 * _doubleFrom( seed1, seed2 ) - 1; // between -1 and 1</span>
<span class="fc" id="L207">            v2 = 2 * _doubleFrom( seed3, seed4 ) - 1; // between -1 and 1</span>
<span class="fc" id="L208">            s = v1 * v1 + v2 * v2;</span>
<span class="fc" id="L209">            seed = seed4;</span>
        }
<span class="pc bpc" id="L211" title="1 of 4 branches missed.">        while ( s &gt;= 1 || s == 0 );</span>

<span class="fc" id="L213">        double multiplier = StrictMath.sqrt( -2 * StrictMath.log(s) / s );</span>

<span class="fc" id="L215">        out[0] = v1 * multiplier;</span>
<span class="fc" id="L216">        out[1] = v2 * multiplier;</span>
<span class="fc" id="L217">    }</span>

    private static long _next( long currentSeed ) {
        long oldseed, nextseed;
        do {
<span class="fc" id="L222">            oldseed = currentSeed;</span>
<span class="fc" id="L223">            nextseed = (oldseed * MULTIPLIER + ADDEND) &amp; MASK;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        } while ( oldseed == (currentSeed = nextseed) );</span>
<span class="fc" id="L225">        return nextseed;</span>
    }

    private static double _doubleFrom( long seed1, long seed2 ) {
<span class="fc" id="L229">        return (((long)(_intFrom(26, seed1)) &lt;&lt; 27) + _intFrom(27, seed2)) * DOUBLE_UNIT;</span>
    }

    private static int _intFrom( int bits, long seed ) {
<span class="fc" id="L233">        return (int)(seed &gt;&gt;&gt; (48 - bits));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>