<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractNDArray.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.ndim</a> &gt; <span class="el_source">AbstractNDArray.java</span></div><h1>AbstractNDArray.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            _         _                  _   _   _ _____
      /\   | |       | |                | | | \ | |  __ \   /\
     /  \  | |__  ___| |_ _ __ __ _  ___| |_|  \| | |  | | /  \   _ __ _ __ __ _ _   _
    / /\ \ | '_ \/ __| __| '__/ _` |/ __| __| . ` | |  | |/ /\ \ | '__| '__/ _` | | | |
   / ____ \| |_) \__ \ |_| | | (_| | (__| |_| |\  | |__| / ____ \| |  | | | (_| | |_| |
  /_/    \_\_.__/|___/\__|_|  \__,_|\___|\__|_| \_|_____/_/    \_\_|  |_|  \__,_|\__, |
                                                                                  __/ |
                                                                                |___/


*/

package neureka.ndim;

import lombok.Getter;
import lombok.experimental.Accessors;
import neureka.Neureka;
import neureka.Tsr;
import neureka.dtype.DataType;
import neureka.dtype.NumericType;
import neureka.ndim.config.NDConfiguration;
import neureka.utility.DataConverter;
import org.jetbrains.annotations.Contract;
import org.slf4j.Logger;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.*;
import java.util.function.Consumer;


/**
 *  This is the precursor class to the final Tsr class from which
 *  tensor instances can be created.
 *  The inheritance model of a tensor is structured as follows:
 *  Tsr inherits from AbstractNDArray which inherits from AbstractComponentOwner
 *  The inheritance model is linear, meaning that all classes involved
 *  are not extended more than once.
 *
 */
@Accessors( prefix = {&quot;_&quot;} )
<span class="fc" id="L66">public abstract class AbstractNDArray&lt;InstanceType, ValueType&gt; extends AbstractComponentOwner&lt;InstanceType&gt; implements Iterable&lt;ValueType&gt;</span>
{

    /**
     *  An interface provided by sl4j which enables a modular logging backend!
     */
    protected static Logger _LOG; // Why is this not final ? : For unit testing!

<span class="fc" id="L74">    @Getter</span>
    protected NDConfiguration _NDConf;

<span class="fc" id="L77">    @Getter</span>
<span class="fc" id="L78">    private DataType&lt;?&gt; _dataType = DataType.of( Neureka.instance().settings().dtype().getDefaultDataTypeClass() );</span>

<span class="fc" id="L80">    @Getter</span>
    private Object _data;

    public Class&lt;?&gt; getValueClass()
    {
<span class="fc" id="L85">        DataType&lt;?&gt; dt = _dataType;</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        if ( dt != null ) return dt.getTypeClass();</span>
<span class="nc" id="L87">        else return null;</span>
    }

    public InstanceType setDataType( DataType&lt;?&gt; dataType )
    {
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if ( _data != null ) {</span>
<span class="nc" id="L93">            String message = &quot;Data type of tensor can only be set when data attribute is null!\n&quot; +</span>
                    &quot;This is due to construction-consistency reasons.\n&quot;;
<span class="nc" id="L95">            throw new IllegalStateException( message );</span>
        }
<span class="fc" id="L97">        _dataType = dataType;</span>
<span class="fc" id="L98">        return (InstanceType) this;</span>
    }

    protected void _setData( Object data )
    {
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if ( _dataType == null ) {</span>
<span class="nc" id="L104">            String message = &quot;Trying to set data in a tensor which does not have a DataTyp instance.&quot;;</span>
<span class="nc" id="L105">            _LOG.error( message );</span>
<span class="nc" id="L106">            throw new IllegalStateException( message );</span>
        }
<span class="fc bfc" id="L108" title="All 4 branches covered.">        if ( data != null &amp;&amp; _dataType.typeClassImplements( NumericType.class ) ) {</span>
<span class="fc" id="L109">            NumericType numericType = (NumericType) _dataType.getTypeClassInstance();</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            if ( numericType.targetArrayType() != data.getClass() ) {</span>
<span class="nc" id="L111">                String message = &quot;Cannot set data whose type does not match what is defined by the DataType instance.\n&quot; +</span>
<span class="nc" id="L112">                        &quot;Current type '&quot;+numericType.targetArrayType().getSimpleName()+&quot;' does not match '&quot;+ data.getClass().getSimpleName()+&quot;'.\n&quot;;</span>
<span class="nc" id="L113">                _LOG.error( message );</span>
<span class="nc" id="L114">                throw new IllegalStateException( message );</span>
            }
        }
<span class="fc" id="L117">        _data = data;</span>
<span class="fc" id="L118">    }</span>

    protected void _allocate( int size )
    {
<span class="fc" id="L122">        _data = _dataType.allocate( size );</span>
<span class="fc" id="L123">    }</span>

    protected void _virtualize()
    {
<span class="fc" id="L127">        _data = _dataType.virtualize(_data);</span>
<span class="fc" id="L128">    }</span>

    protected void _actualize()
    {
<span class="fc" id="L132">        _data = _dataType.actualize(_data, this.size() );</span>
<span class="fc" id="L133">    }</span>

    protected Object _convertedDataOfType( Class&lt;?&gt; typeClass )
    {
<span class="fc" id="L137">        DataType newDT = DataType.of( typeClass );</span>
<span class="fc" id="L138">        if (</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">                newDT.typeClassImplements( NumericType.class ) &amp;&amp;</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">                        getDataType().typeClassImplements( NumericType.class )</span>
        ) {
<span class="fc" id="L142">            NumericType&lt;?,Object, ?, Object&gt; targetType  = (NumericType&lt;?, Object,?, Object&gt;) newDT.getTypeClassInstance();</span>
<span class="fc" id="L143">            return targetType.readForeignDataFrom( iterator(), this.size() );</span>
        }
        else
<span class="nc" id="L146">            return DataConverter.instance().convert( getData(), newDT.getTypeClass() );</span>
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    @Override
    public void forEach( Consumer&lt;? super ValueType&gt; action ) {
<span class="fc bfc" id="L153" title="All 2 branches covered.">        for ( ValueType v : this ) action.accept( v );</span>
<span class="fc" id="L154">    }</span>

    @Override
    public Spliterator&lt;ValueType&gt; spliterator()
    {
<span class="nc" id="L159">        return new Spliterator&lt;ValueType&gt;()</span>
<span class="nc" id="L160">        {</span>
            @Override
            public boolean tryAdvance( Consumer&lt;? super ValueType&gt; action ) {
<span class="nc" id="L163">                return false;</span>
            }

            @Override
            public Spliterator&lt;ValueType&gt; trySplit() {
<span class="nc" id="L168">                return null;</span>
            }

            @Override
            public long estimateSize() {
<span class="nc" id="L173">                return 0;</span>
            }

            @Override
            public int characteristics() {
<span class="nc" id="L178">                return 0;</span>
            }
        };
    }

    public abstract Object getValueAt( int i );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    public boolean is( Class&lt;?&gt; typeClass ) {
<span class="nc" id="L188">        DataType&lt;?&gt; type = DataType.of( typeClass );</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        return type == _dataType;</span>
    }

    public boolean is64() {
<span class="fc" id="L193">        return _data instanceof double[];</span>
    }

    public boolean is32() {
<span class="fc" id="L197">        return _data instanceof float[];</span>
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    public int i_of_i( int i ) {
<span class="fc" id="L203">        return _NDConf.i_of_i( i );</span>
    }

    public int[] idx_of_i( int i ) {
<span class="fc" id="L207">        return _NDConf.idx_of_i( i );</span>
    }

    public int i_of_idx( int[] idx ) {
<span class="fc" id="L211">        return _NDConf.i_of_idx(idx);</span>
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    public InstanceType setNDConf( NDConfiguration ndConfiguration ) {
<span class="fc" id="L218">        _NDConf = ndConfiguration;</span>
<span class="fc" id="L219">        return (InstanceType) this;</span>
    }


    //---

    public int rank() {
<span class="fc" id="L226">        return _NDConf.shape().length;</span>
    }

    public List&lt;Integer&gt; shape() {
<span class="fc" id="L230">        return _asList(_NDConf.shape());</span>
    }

    public int shape( int i ) {
<span class="fc" id="L234">        return _NDConf.shape()[ i ];</span>
    }

    public List&lt;Integer&gt; idxmap() {
<span class="fc" id="L238">        return _asList(_NDConf.idxmap());</span>
    }

    public List&lt;Integer&gt; translation() {
<span class="fc" id="L242">        return _asList(_NDConf.translation());</span>
    }

    public List&lt;Integer&gt; spread() {
<span class="fc" id="L246">        return _asList(_NDConf.spread());</span>
    }

    public List&lt;Integer&gt; offset() {
<span class="fc" id="L250">        return _asList(_NDConf.offset());</span>
    }

    public int size() {
<span class="fc" id="L254">        return NDConfiguration.Utility.szeOfShp(_NDConf.shape());</span>
    }

    protected static List&lt;Integer&gt; _asList( int[] array ) {
<span class="fc" id="L258">        List&lt;Integer&gt; intList = new ArrayList&lt;&gt;( array.length );</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        for ( int i : array ) intList.add( i );</span>
<span class="fc" id="L260">        return intList;</span>
    }



    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    /**
     *  Static methods.
     */
<span class="nc" id="L271">    public static class Utility</span>
    {
<span class="nc" id="L273">        public static class Stringify</span>
        {
            @Contract( pure = true )
            public static String strConf( int[] conf ) {
<span class="fc" id="L277">                StringBuilder str = new StringBuilder();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">                for ( int i = 0; i &lt; conf.length; i++ )</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">                    str.append(conf[ i ]).append((i != conf.length - 1) ? &quot;, &quot; : &quot;&quot;);</span>
<span class="fc" id="L280">                return &quot;[&quot; + str + &quot;]&quot;;</span>
            }
        }

        /**
         * Indexing methods.
         */
<span class="nc" id="L287">        public static class Indexing</span>
        {
            @Contract(pure = true)
            public static int[] shpCheck( int[] newShp, Tsr t ) {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">                if ( NDConfiguration.Utility.szeOfShp(newShp) != t.size() ) {</span>
<span class="nc" id="L292">                    throw new IllegalArgumentException(</span>
                            &quot;New shape does not match tensor size!&quot; +
<span class="nc bnc" id="L294" title="All 2 branches missed.">                                    &quot; (&quot; + Utility.Stringify.strConf(newShp) + ((NDConfiguration.Utility.szeOfShp(newShp) &lt; t.size()) ? &quot;&lt;&quot; : &quot;&gt;&quot;) + Utility.Stringify.strConf(t._NDConf.shape()) + &quot;)&quot;);</span>
                }
<span class="fc" id="L296">                return newShp;</span>
            }

            @Contract(pure = true)
            public static int[][] makeFit( int[] sA, int[] sB ) {
<span class="fc" id="L301">                int lastIndexOfA = 0;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">                for ( int i = sA.length-1; i &gt;= 0; i-- ) {</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">                    if (sA[ i ]!=1) {</span>
<span class="fc" id="L304">                        lastIndexOfA = i;</span>
<span class="fc" id="L305">                        break;</span>
                    }
                }
<span class="fc" id="L308">                int firstIndexOfB = 0;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                for ( int i=0; i&lt;sB.length; i++ ) {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">                    if (sB[ i ]!=1) {</span>
<span class="fc" id="L311">                        firstIndexOfB = i;</span>
<span class="fc" id="L312">                        break;</span>
                    }
                }
<span class="fc" id="L315">                int newSize = lastIndexOfA + sB.length - firstIndexOfB;</span>
<span class="fc" id="L316">                int[] rsA = new int[newSize];</span>
<span class="fc" id="L317">                int[] rsB = new int[newSize];</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                for(int i=0; i&lt;newSize; i++ ) {</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">                    if (i&lt;=lastIndexOfA) rsA[ i ] = i; else rsA[ i ] = -1;</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">                    if (i&gt;=lastIndexOfA) rsB[ i ] = i-lastIndexOfA+firstIndexOfB; else rsB[ i ] = -1;</span>
                }
<span class="fc" id="L322">                return new int[][]{rsA, rsB};</span>
            }

            @Contract(pure = true)
            public static int[] shpOfCon(int[] shp1, int[] shp2) {
<span class="fc" id="L327">                int[] shape = new int[(shp1.length + shp2.length) / 2];</span>
<span class="pc bpc" id="L328" title="1 of 4 branches missed.">                for ( int i = 0; i &lt; shp1.length &amp;&amp; i &lt; shp2.length; i++) shape[ i ] = Math.abs(shp1[ i ] - shp2[ i ]) + 1;</span>
<span class="fc" id="L329">                return shape;</span>
            }

            @Contract(pure = true)
            public static int[] shpOfBrc(int[] shp1, int[] shp2) {
<span class="fc" id="L334">                int[] shape = new int[(shp1.length + shp2.length) / 2];</span>
<span class="pc bpc" id="L335" title="1 of 4 branches missed.">                for ( int i = 0; i &lt; shp1.length &amp;&amp; i &lt; shp2.length; i++ ) {</span>
<span class="fc" id="L336">                    shape[ i ] = Math.max(shp1[ i ], shp2[ i ]);</span>
<span class="pc bpc" id="L337" title="3 of 4 branches missed.">                    if (Math.min(shp1[ i ], shp2[ i ])!=1&amp;&amp;Math.max(shp1[ i ], shp2[ i ])!=shape[ i ]) {</span>
<span class="nc" id="L338">                        throw new IllegalStateException(&quot;Broadcast not possible. Shapes do not match!&quot;);</span>
                    }
                }
<span class="fc" id="L341">                return shape;</span>
            }


        }

    }




}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>