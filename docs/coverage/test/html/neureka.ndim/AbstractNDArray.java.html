<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractNDArray.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.ndim</a> &gt; <span class="el_source">AbstractNDArray.java</span></div><h1>AbstractNDArray.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            _         _                  _   _   _ _____
      /\   | |       | |                | | | \ | |  __ \   /\
     /  \  | |__  ___| |_ _ __ __ _  ___| |_|  \| | |  | | /  \   _ __ _ __ __ _ _   _
    / /\ \ | '_ \/ __| __| '__/ _` |/ __| __| . ` | |  | |/ /\ \ | '__| '__/ _` | | | |
   / ____ \| |_) \__ \ |_| | | (_| | (__| |_| |\  | |__| / ____ \| |  | | | (_| | |_| |
  /_/    \_\_.__/|___/\__|_|  \__,_|\___|\__|_| \_|_____/_/    \_\_|  |_|  \__,_|\__, |
                                                                                  __/ |
                                                                                |___/


*/

package neureka.ndim;

import neureka.Neureka;
import neureka.Tsr;
import neureka.backend.api.ExecutionCall;
import neureka.common.composition.AbstractComponentOwner;
import neureka.common.utility.DataConverter;
import neureka.devices.Device;
import neureka.devices.host.CPU;
import neureka.dtype.DataType;
import neureka.dtype.NumericType;
import neureka.ndim.config.NDConfiguration;
import neureka.ndim.config.types.ColumnMajorNDConfiguration;
import org.jetbrains.annotations.Contract;
import org.slf4j.Logger;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


/**
 *  This is the precursor class to the final {@link Tsr} class from which
 *  tensor instances can be created. &lt;br&gt;
 *  The inheritance model of a tensor is structured as follows: &lt;br&gt;
 *  {@link Tsr} inherits from {@link AbstractNDArray} which inherits from {@link AbstractComponentOwner}
 *  The inheritance model is linear, meaning that all classes involved
 *  are not extended more than once.
 *
 * @param &lt;C&gt; The type of the concrete class extending this abstract class (currently the {@link Tsr} class).
 * @param &lt;V&gt; The value type of the individual items stored within this nd-array.
 */
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">public abstract class AbstractNDArray&lt;C, V&gt; extends AbstractComponentOwner&lt;C&gt; implements Iterable&lt;V&gt;</span>
{
    /**
     *  An interface provided by sl4j which enables a modular logging backend!
     */
    public static Logger _LOG; // Why is this not final ? -&gt; For unit testing!

    /**
     *  An instance of an implementation of the {@link NDConfiguration} interface defining
     *  the dimensionality of this {@link AbstractNDArray} in terms of certain index properties
     *  which imply individual access patterns for the underlying {@link #_data}.
     */
    private NDConfiguration _NDConf;

<span class="fc" id="L83">    private DataType&lt;?&gt; _dataType = DataType.of( Neureka.get().settings().dtype().getDefaultDataTypeClass() );</span>

    private Object _data;

    /**
     * @return The truth value determining if the {@link Tsr#delete()} method has been called oin this instance.
     */
    public abstract boolean isDeleted();

<span class="fc" id="L92">    protected void _guardGet( String varName ) { _guard(&quot;Trying to access the &quot;+varName+&quot; of an already deleted tensor.&quot; ); }</span>
<span class="fc" id="L93">    protected void _guardSet( String varName ) { _guard(&quot;Trying to set the &quot;+varName+&quot; of an already deleted tensor.&quot; ); }</span>
<span class="fc" id="L94">    protected void _guardMod( String varName ) { _guard(&quot;Trying to modify the &quot;+varName+&quot; of an already deleted tensor.&quot; ); }</span>

    /**
     *  This method will guard the state of deleted tensors by throwing an {@link IllegalAccessError}
     *  if this {@link Tsr} has already been deleted and whose state should no longer be exposed to
     *  anything but the garbage collector...
     *
     * @param message The message explaining to the outside which kind of access violation just occurred.
     */
    private void _guard( String message ) {
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if ( this.isDeleted() ) {</span>
<span class="fc" id="L105">            _LOG.error( message );</span>
<span class="fc" id="L106">            throw new IllegalAccessError( message );</span>
        }
<span class="fc" id="L108">    }</span>

    /**
     * @return The {@link NDConfiguration} implementation instance of this {@link Tsr} storing dimensionality information.
     */
<span class="fc" id="L113">    public NDConfiguration getNDConf() { _guardGet(&quot;ND-Configuration&quot;); return _NDConf; }</span>

    /**
     *  This method returns the {@link DataType} instance of this {@link Tsr}, which is
     *  a wrapper object for the actual type class representing the value items stored inside
     *  the underlying data array of this tensor.
     *
     * @return The {@link DataType} instance of this {@link Tsr} storing important type information.
     */
<span class="fc" id="L122">    public DataType&lt;?&gt; getDataType() { _guardGet(&quot;data type&quot;); return _dataType; }</span>

    /**
     *  This returns the underlying raw data object of this tensor.
     *  Contrary to the {@link Tsr#getValue()} ()} method, this one will
     *  return an unbiased view on the data of this tensor.
     *
     * @return The raw data object underlying this tensor.
     */
<span class="fc" id="L131">    public Object getData() { _guardGet(&quot;data object&quot;); return _data; }</span>

    /**
     * @return The type class of individual value items within this {@link Tsr} instance.
     */
    public Class&lt;?&gt; getValueClass() {
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        _guardGet(&quot;data type class&quot;); return ( _dataType != null ? _dataType.getJVMTypeClass() : null );</span>
    }

    /**
     *  The {@link Class} returned by this method is the representative {@link Class} of the
     *  value items of a concrete {@link AbstractNDArray} but not necessarily the actual {@link Class} of
     *  a given value item, this is especially true for numeric types, which are represented by
     *  implementations of the {@link NumericType} interface.                                        &lt;br&gt;
     *  For example in the case of a tensor of type {@link Double}, this method would
     *  return {@link neureka.dtype.custom.F64} which is the representative class of {@link Double}. &lt;br&gt;
     *  Calling the {@link #getValueClass()} method instead of this method would return the actual value
     *  type class, namely: {@link Double}.
     *
     * @return The representative type class of individual value items within this concrete {@link AbstractNDArray}
     *         extension instance which might also be sub-classes of the {@link NumericType} interface
     *         to model unsigned types or other JVM foreign numeric concepts.
     */
    public Class&lt;?&gt; getRepresentativeValueClass() {
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        _guardGet(&quot;representative data type class&quot;); return ( _dataType != null ? _dataType.getTypeClass() : null );</span>
    }

    /**
     *  This method enables modifying the data-type configuration of this {@link AbstractNDArray}.
     *  Warning! The method should not be used unless absolutely necessary.
     *  This is because it can cause unpredictable inconsistencies between the
     *  underlying {@link DataType} instance of this {@link AbstractNDArray} and the actual type of the actual
     *  data it is wrapping (or it is referencing on a {@link neureka.devices.Device}).&lt;br&gt;
     *  &lt;br&gt;
     * @param dataType The new {@link DataType} which ought to be set.
     * @return The final instance type of this class which enables method chaining.
     */
    protected C _setDataType(DataType&lt;?&gt; dataType )
    {
<span class="fc" id="L170">        _guardSet(&quot;data type&quot;);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if ( _data != null ) {</span>
<span class="nc" id="L172">            String message = &quot;Data type of tensor can only be set when data attribute is null!\n&quot; +</span>
                             &quot;This is due to construction-consistency reasons.\n&quot;;
<span class="nc" id="L174">            throw new IllegalStateException( message );</span>
        }
<span class="fc" id="L176">        _dataType = dataType;</span>
<span class="fc" id="L177">        return (C) this;</span>
    }

    protected void _setData( Object data )
    {
<span class="fc" id="L182">        _guardSet(&quot;data object&quot;);</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if ( _dataType == null ) {</span>
<span class="nc" id="L184">            String message = &quot;Trying to set data in a tensor which does not have a DataTyp instance.&quot;;</span>
<span class="nc" id="L185">            _LOG.error( message );</span>
<span class="nc" id="L186">            throw new IllegalStateException( message );</span>
        }
<span class="fc bfc" id="L188" title="All 4 branches covered.">        if ( data != null &amp;&amp; _dataType.typeClassImplements( NumericType.class ) ) {</span>
<span class="fc" id="L189">            NumericType&lt;?,?,?,?&gt; numericType = (NumericType&lt;?,?,?,?&gt;) _dataType.getTypeClassInstance();</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">            if ( numericType.targetArrayType() != data.getClass() ) {</span>
<span class="nc" id="L191">                String message = &quot;Cannot set data whose type does not match what is defined by the DataType instance.\n&quot; +</span>
<span class="nc" id="L192">                        &quot;Current type '&quot;+numericType.targetArrayType().getSimpleName()+&quot;' does not match '&quot;+ data.getClass().getSimpleName()+&quot;'.\n&quot;;</span>
<span class="nc" id="L193">                _LOG.error( message );</span>
<span class="nc" id="L194">                throw new IllegalStateException( message );</span>
            }
        }
<span class="fc" id="L197">        _data = data;</span>
<span class="fc" id="L198">    }</span>

    protected &lt;T&gt; void _initData( Initializer&lt;T&gt; initializer )
    {
<span class="fc" id="L202">        CPU.JVMExecutor executor = CPU.get().getExecutor();</span>
<span class="fc" id="L203">        Object data = getData();</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if ( data instanceof double[] )</span>
<span class="fc" id="L205">            executor.threaded( ( (double[]) data ).length, (start, end) -&gt; {</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">                for (int i = start; i &lt; end; i++)</span>
<span class="fc" id="L207">                    ((double[]) data)[i] = (double) initializer.init(i, _NDConf.indicesOfIndex(i));</span>
<span class="fc" id="L208">            });</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        else if ( data instanceof float[] )</span>
<span class="fc" id="L210">            executor.threaded( ( (float[]) data ).length, (start, end) -&gt; {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">                for (int i = start; i &lt; end; i++)</span>
<span class="fc" id="L212">                    ( (float[]) data )[ i ] = (float) initializer.init( i, _NDConf.indicesOfIndex( i )  );</span>
<span class="fc" id="L213">            });</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        else if ( data instanceof int[] )</span>
<span class="fc" id="L215">            executor.threaded( ( (int[]) data ).length, (start, end) -&gt; {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                for (int i = start; i &lt; end; i++)</span>
<span class="fc" id="L217">                    ( (int[]) data )[ i ] = (int) initializer.init( i, _NDConf.indicesOfIndex( i )  );</span>
<span class="fc" id="L218">            });</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        else if ( data instanceof short[] )</span>
<span class="fc" id="L220">            executor.threaded( ( (short[]) data ).length, (start, end) -&gt; {</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">                for (int i = start; i &lt; end; i++)</span>
<span class="fc" id="L222">                    ( (short[]) data )[ i ] = (short) initializer.init( i, _NDConf.indicesOfIndex( i )  );</span>
<span class="fc" id="L223">            });</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">        else if ( data instanceof byte[] )</span>
<span class="fc" id="L225">            executor.threaded( ( (byte[]) data ).length, (start, end) -&gt; {</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">                for (int i = start; i &lt; end; i++)</span>
<span class="fc" id="L227">                    ( (byte[]) data )[ i ] = (byte) initializer.init( i, _NDConf.indicesOfIndex( i )  );</span>
<span class="fc" id="L228">            });</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        else if ( data instanceof long[] )</span>
<span class="fc" id="L230">            executor.threaded( ( (long[]) data ).length, (start, end) -&gt; {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">                for (int i = start; i &lt; end; i++)</span>
<span class="fc" id="L232">                    ( (long[]) data )[ i ] = (long) initializer.init( i, _NDConf.indicesOfIndex( i )  );</span>
<span class="fc" id="L233">            });</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">        else if ( data instanceof boolean[] )</span>
<span class="fc" id="L235">            executor.threaded( ( (boolean[]) data ).length, (start, end) -&gt; {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">                for (int i = start; i &lt; end; i++)</span>
<span class="fc" id="L237">                    ( (boolean[]) data )[ i ] = (boolean) initializer.init( i, _NDConf.indicesOfIndex( i )  );</span>
<span class="fc" id="L238">            });</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        else if ( data instanceof char[] )</span>
<span class="fc" id="L240">            executor.threaded( ( (char[]) data ).length, (start, end) -&gt; {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                for (int i = start; i &lt; end; i++)</span>
<span class="fc" id="L242">                    ( (char[]) data )[ i ] = (char) initializer.init( i, _NDConf.indicesOfIndex( i )  );</span>
<span class="fc" id="L243">            });</span>
        else
<span class="fc" id="L245">            executor.threaded( ( (Object[]) data ).length, (start, end) -&gt; {</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">                for (int i = start; i &lt; end; i++)</span>
<span class="fc" id="L247">                    ( (Object[]) data )[ i ] = initializer.init( i, _NDConf.indicesOfIndex( i )  );</span>
<span class="fc" id="L248">            });</span>
<span class="fc" id="L249">    }</span>

    /**
     *  This method is responsible for allocating the data of this nd-array.
     *  It is protected and located in this abstract class so that a high degree of encapsulation
     *  is ensured for such crucial procedures like the allocation of the right data. &lt;br&gt;
     *  The actual allocation takes place inside an instance of the DataType class.
     *  This is because the data type has to be known in order to correctly perform an allocation.&lt;br&gt;
     *  &lt;br&gt;
     *
     * @param size The size of the data array which ought to be allocated.
     */
<span class="fc" id="L261">    protected void _allocate( int size ) { _data = _dataType.allocate( size ); }</span>

    /**
     *  WARNING! Virtualizing is the process of compacting the underlying data array
     *  down to an array holding a single value.
     *  This only makes sense for homogeneously populated tensors.
     *  Passing {@code false} to this method will &quot;actualize&quot; a &quot;virtual&quot; tensor.
     *  Meaning the underlying data array will at least become as large as the size of the tensor
     *  as is defined by {@link #size()}.
     *
     * @param isVirtual The truth value determining if this tensor should be &quot;virtual&quot; or &quot;actual&quot;.
     * @return This concrete instance, to allow for method chaining.
     */
    public abstract C setIsVirtual( boolean isVirtual );

    /**
     *  A Virtual tensor is a tensor whose underlying data array is of size 1, holding only a single value. &lt;br&gt;
     *  This only makes sense for homogeneously populated tensors.
     *  An example of such a tensor would be: &lt;br&gt;
     *  {@code Tsr.ofInts().withShape(x,y).all(n)}                           &lt;br&gt;&lt;br&gt;
     *
     *  Use {@link #setIsVirtual(boolean)} to &quot;actualize&quot; a &quot;virtual&quot; tensor, and vise versa.
     *
     * @return The truth value determining if this tensor is &quot;virtual&quot; or &quot;actual&quot;.
     */
    public abstract boolean isVirtual();

    /**
     *  The internal implementation handling {@link #setIsVirtual(boolean)}.
     */
    protected abstract void _setIsVirtual(boolean isVirtual);

    /**
     *  The {@link AbstractNDArray} is in essence a precursor class to the {@link Tsr} which encapsulates
     *  and protects most of its state...
     *  This is especially important during constructing where a wider range of unexpected user input
     *  might lead to a wider variety of exceptions.
     *  The API returned by this method simplifies this greatly.
     *
     * @return An {@link NDAConstructor} exposing a simple API for configuring a new {@link Tsr} instance.
     */
    protected NDAConstructor createConstructionAPI()
    {
<span class="fc" id="L304">        AbstractNDArray&lt;C, ?&gt; nda = this;</span>
<span class="fc" id="L305">        return new NDAConstructor(</span>
<span class="fc" id="L306">                    new NDAConstructor.API() {</span>
<span class="fc" id="L307">                        @Override public void setType( DataType&lt;?&gt; type        ) { nda.getMutate().setDataType( type ); }</span>
<span class="fc" id="L308">                        @Override public void setConf( NDConfiguration conf    ) { nda.getMutate().setNDConf(   conf ); }</span>
<span class="fc" id="L309">                        @Override public void setData( Object o                ) { nda._setData(      o  ); }</span>
<span class="fc" id="L310">                        @Override public void allocate( int size               ) { nda._allocate(   size ); }</span>
<span class="fc" id="L311">                        @Override public Object getData()                        { return nda.getData();    }</span>
<span class="fc" id="L312">                        @Override public void setIsVirtual(  boolean isVirtual ) { nda._setIsVirtual( isVirtual ); }</span>
                    }
                );
    }

    /**
     *  A virtual NDArray (tensor) is the opposite to an actual one. &lt;br&gt;
     *  Virtual means that the size of the underlying data does not match the real size of the NDArray.
     *  This is the case when the NDArray is filled with one element homogeneously.
     *  An example would be an all zeros array.&lt;br&gt;
     *  The reasoning behind this feature is memory efficiency.
     *  It would be unreasonable to allocate an arrays filled entirely with one and the same value item!
     *  &lt;br&gt;
     */
<span class="fc" id="L326">    protected void _virtualize() { _data = _dataType.virtualize(_data); }</span>

    /**
     *  An actual NDArray (tensor) is the opposite to a virtual one. &lt;br&gt;
     *  Virtual means that the size of the underlying data does not match the real size of the NDArray.
     *  This is the case when the NDArray is filled with one element homogeneously.
     *  An example would be an all zeros array. The reasoning behind this feature is memory efficiency.
     *  It would be unreasonable to allocate an array filled entirely with one and the same value item!&lt;br&gt;
     *  &lt;br&gt;
     *  This method turns the data of a virtual NDArray into a newly allocated data array matching the
     *  size of the nd-array type... &lt;br&gt;
     */
<span class="fc" id="L338">    protected void _actualize() { _data = _dataType.actualize(_data, this.size() ); }</span>

    protected Object _convertedDataOfType( Class&lt;?&gt; typeClass )
    {
<span class="fc" id="L342">        DataType&lt;?&gt; newDT = DataType.of( typeClass );</span>
<span class="fc" id="L343">        if (</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">                newDT.typeClassImplements( NumericType.class ) &amp;&amp;</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">                        getDataType().typeClassImplements( NumericType.class )</span>
        ) {
<span class="fc" id="L347">            NumericType&lt;?,Object, ?, Object&gt; targetType  = (NumericType&lt;?, Object,?, Object&gt;) newDT.getTypeClassInstance();</span>
<span class="fc" id="L348">            return targetType.readForeignDataFrom( iterator(), this.size() );</span>
        }
        else
<span class="nc" id="L351">            return DataConverter.instance().convert( getData(), newDT.getTypeClass() );</span>
    }

    /**
     *  An NDArray implementation ought to have some way to access its underlying data array.
     *  This method simple returns an element within this data array sitting at position &quot;i&quot;.
     * @param i The position of the targeted item within the raw data array of an NDArray implementation.
     * @return The found object sitting at the specified index position.
     */
    public abstract Object getDataAt( int i );

    /**
     *  An NDArray implementation ought to have some way to selectively modify its underlying data array.
     *  This method simply overrides an element within this data array sitting at position &quot;i&quot;.
     * @param i The index of the data array entry which ought to be addressed.
     * @param o The object which ought to be placed at the requested position.
     * @return This very tensor in order to enable method chaining.
     */
    public abstract C setDataAt( int i, V o );

    /**
     *  An NDArray implementation ought to have some way to selectively modify its underlying value.
     *  This method simply overrides an element within this data array sitting at position &quot;i&quot;.
     * @param i The index of the value array entry which ought to be addressed.
     * @param o The object which ought to be placed at the requested position.
     * @return This very tensor in order to enable method chaining.
     */
    public abstract C setValueAt( int i, V o );

    /**
     *  This method compares the passed class with the underlying data-type of this NDArray.
     *  If the data-type of this NDArray is equivalent to the passed class then the returned
     *  boolean will be true, otherwise the method returns false.
     *
     * @param typeClass The class which ought to be compared to the underlying data-type of this NDArray.
     * @return The truth value of the question: Does this NDArray implementation hold the data of the passed type?
     */
    public boolean is( Class&lt;?&gt; typeClass ) {
<span class="fc" id="L389">        DataType&lt;?&gt; type = DataType.of( typeClass );</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        return type == _dataType;</span>
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     *  This is a convenience method identical to {@code tensor.getNDConf().indexOfIndex(i)}.
     *  Use this to calculate the true index for an element in the data array (data array index)
     *  based on a provided &quot;virtual index&quot;, or &quot;value array index&quot;.
     *  This virtual index may be different from the true index depending on the type of nd-array,
     *  like for example if the nd-array is
     *  a slice of another larger nd-array, or if it is in fact a reshaped version of another nd-array.
     *  The basis for performing this translation is expressed by individual implementations of
     *  this {@link NDConfiguration} interface, which contain everything
     *  needed to treat a given block of data as a nd-array!
     *
     * @param index The virtual index of the tensor having this configuration.
     * @return The true index which targets the actual data within the underlying data array of an nd-array / tensor.
     */
<span class="fc" id="L409">    public int indexOfIndex( int index ) { return _NDConf.indexOfIndex( index ); }</span>

    /**
     *  This is a convenience method identical to {@code tensor.getNDConf().IndicesOfIndex(i)}.
     *  Use this to calculates the axis indices for an element in the nd-array array
     *  based on a provided &quot;virtual index&quot;.
     *  The resulting index defines the position of the element for every axis.
     *
     * @param index The virtual index of the tensor having this configuration.
     * @return The position of the (virtually) targeted element represented as an array of axis indices.
     */
<span class="fc" id="L420">    public int[] IndicesOfIndex( int index ) { return _NDConf.indicesOfIndex( index ); }</span>

    /**
     *  This is a convenience method identical to {@code tensor.getNDConf().indexOfIndices(indices)}.
     *  Use this to calculates the true index for an element in the data array
     *  based on a provided index array.
     *
     * @param indices The indices for every axis of a given nd-array.
     * @return The true index targeting the underlying data array of a given nd-array.
     */
<span class="fc" id="L430">    public int indexOfIndices( int[] indices ) { return _NDConf.indexOfIndices(indices); }</span>

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     *  This method sets the NDConfiguration of this NDArray.
     *  Therefore, it should not be used lightly as it can cause major internal inconsistencies.
     *
     * @param ndConfiguration The new NDConfiguration instance which ought to be set.
     * @return The final instance type of this class which enables method chaining.
     */
    protected C _setNDConf(NDConfiguration ndConfiguration )
    {
<span class="fc" id="L443">        _guardSet( &quot;ND-Configuration&quot; );</span>
<span class="fc bfc" id="L444" title="All 4 branches covered.">        if ( _NDConf != null &amp;&amp; ndConfiguration != null ) {</span>
<span class="fc" id="L445">            int s1 = Arrays.stream( _NDConf.shape() ).map( Math::abs ).reduce( 1, ( a, b ) -&gt; a*b );</span>
<span class="fc" id="L446">            int s2 = Arrays.stream( ndConfiguration.shape() ).map( Math::abs ).reduce( 1, ( a, b ) -&gt; a*b );</span>
<span class="pc bpc" id="L447" title="2 of 4 branches missed.">            assert s1 == s2;</span>
        }
<span class="fc" id="L449">        _NDConf = ndConfiguration;</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">        if ( this.has( Device.class ) ) {</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">            if ( ndConfiguration instanceof ColumnMajorNDConfiguration )</span>
<span class="nc" id="L452">                throw new IllegalStateException(&quot;Column major data layout not yet supported on the GPU!&quot;);</span>
            else
<span class="fc" id="L454">                this.get(Device.class).updateNDConf((Tsr) this);</span>
        }
<span class="fc" id="L456">        return (C) this;</span>
    }

    //---

    /**
     * @return The number of dimensions of this tensor / nd-array.
     */
<span class="fc" id="L464">    public int rank() { return _NDConf.rank(); }</span>

    /**
     * @return A list of the dimensions of this tensor / array.
     */
<span class="fc" id="L469">    public List&lt;Integer&gt; shape() { return _asList(_NDConf.shape()); }</span>

<span class="fc" id="L471">    public int shape( int i ) { return _NDConf.shape()[ i ]; }</span>

<span class="fc" id="L473">    public List&lt;Integer&gt; indicesMap() { return _asList(_NDConf.indicesMap()); }</span>

<span class="fc" id="L475">    public List&lt;Integer&gt; translation() { return _asList(_NDConf.translation()); }</span>

<span class="fc" id="L477">    public List&lt;Integer&gt; spread() { return _asList(_NDConf.spread()); }</span>

<span class="fc" id="L479">    public List&lt;Integer&gt; offset() { return _asList(_NDConf.offset()); }</span>

<span class="fc" id="L481">    public int size() { return NDConfiguration.Utility.szeOfShp(_NDConf.shape()); }</span>

    private static List&lt;Integer&gt; _asList( int[] array ) {
<span class="fc" id="L484">        List&lt;Integer&gt; intList = new ArrayList&lt;&gt;( array.length );</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        for ( int i : array ) intList.add( i );</span>
<span class="fc" id="L486">        return intList;</span>
    }

    /**
     *  Static utility methods for the NDArray.
     */
<span class="nc" id="L492">    public static class Utility</span>
    {
<span class="nc" id="L494">        public static class Stringify</span>
        {
            @Contract( pure = true )
            public static String strConf( int[] conf ) {
<span class="fc" id="L498">                StringBuilder str = new StringBuilder();</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">                for ( int i = 0; i &lt; conf.length; i++ )</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">                    str.append(conf[ i ]).append((i != conf.length - 1) ? &quot;, &quot; : &quot;&quot;);</span>
<span class="fc" id="L501">                return &quot;[&quot; + str + &quot;]&quot;;</span>
            }
        }

        /**
         * Indexing methods.
         */
<span class="nc" id="L508">        public static class Indexing</span>
        {
            @Contract(pure = true)
            public static void shpCheck( int[] newShp, Tsr&lt;?&gt; t ) {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">                if ( NDConfiguration.Utility.szeOfShp(newShp) != t.size() ) {</span>
<span class="nc" id="L513">                    throw new IllegalArgumentException(</span>
                            &quot;New shape does not match tensor size!&quot; +
                                    &quot; (&quot; +
<span class="nc" id="L516">                                        Utility.Stringify.strConf(newShp) +</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                                        ((NDConfiguration.Utility.szeOfShp(newShp) &lt; t.size()) ? &quot;&lt;&quot; : &quot;&gt;&quot;) +</span>
<span class="nc" id="L518">                                        Utility.Stringify.strConf(t.getNDConf().shape()) + &quot;&quot; +</span>
                                    &quot;)&quot;
                    );
                }
<span class="fc" id="L522">            }</span>

            @Contract(pure = true)
            public static int[][] makeFit( int[] sA, int[] sB ) {
<span class="fc" id="L526">                int lastIndexOfA = 0;</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                for ( int i = sA.length-1; i &gt;= 0; i-- ) {</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">                    if ( sA[ i ] != 1 ) {</span>
<span class="fc" id="L529">                        lastIndexOfA = i;</span>
<span class="fc" id="L530">                        break;</span>
                    }
                }
<span class="fc" id="L533">                int firstIndexOfB = 0;</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">                for ( int i = 0; i &lt; sB.length; i++ ) {</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">                    if ( sB[ i ] != 1 ) {</span>
<span class="fc" id="L536">                        firstIndexOfB = i;</span>
<span class="fc" id="L537">                        break;</span>
                    }
                }
<span class="fc" id="L540">                int newSize = lastIndexOfA + sB.length - firstIndexOfB;</span>
<span class="fc" id="L541">                int[] rsA = new int[ newSize ];</span>
<span class="fc" id="L542">                int[] rsB = new int[ newSize ];</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">                for( int i = 0; i &lt;newSize; i++ ) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">                    if (i&lt;=lastIndexOfA) rsA[ i ] = i; else rsA[ i ] = -1;</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">                    if (i&gt;=lastIndexOfA) rsB[ i ] = i-lastIndexOfA+firstIndexOfB; else rsB[ i ] = -1;</span>
                }
<span class="fc" id="L547">                return new int[][]{ rsA, rsB };</span>
            }

            @Contract(pure = true)
            public static int[] shpOfCon( int[] shp1, int[] shp2 ) {
<span class="fc" id="L552">                int[] shape = new int[(shp1.length + shp2.length) / 2];</span>
<span class="pc bpc" id="L553" title="1 of 4 branches missed.">                for ( int i = 0; i &lt; shp1.length &amp;&amp; i &lt; shp2.length; i++) shape[ i ] = Math.abs(shp1[ i ] - shp2[ i ]) + 1;</span>
<span class="fc" id="L554">                return shape;</span>
            }

            @Contract(pure = true)
            public static int[] shpOfBrc( int[] shp1, int[] shp2 ) {
<span class="fc" id="L559">                int[] shape = new int[(shp1.length + shp2.length) / 2];</span>
<span class="pc bpc" id="L560" title="1 of 4 branches missed.">                for ( int i = 0; i &lt; shp1.length &amp;&amp; i &lt; shp2.length; i++ ) {</span>
<span class="fc" id="L561">                    shape[ i ] = Math.max(shp1[ i ], shp2[ i ]);</span>
<span class="pc bpc" id="L562" title="3 of 4 branches missed.">                    if (Math.min(shp1[ i ], shp2[ i ])!=1&amp;&amp;Math.max(shp1[ i ], shp2[ i ])!=shape[ i ]) {</span>
<span class="nc" id="L563">                        throw new IllegalStateException(&quot;Broadcast not possible. Shapes do not match!&quot;);</span>
                    }
                }
<span class="fc" id="L566">                return shape;</span>
            }
        }

    }

    /**
     *  This method exposes an API for mutating the state of this tensor.
     *  The usage of methods exposed by this API is generally discouraged
     *  because the exposed state can easily lead to broken tensors and exceptions...&lt;br&gt;
     *  &lt;br&gt;&lt;b&gt;
     *
     *  Only use this if you know what you are doing and
     *  performance is critical! &lt;br&gt;
     *  &lt;/b&gt;
     *  (Like custom backend extensions for example)
     *
     *  &lt;br&gt;&lt;br&gt;
     */
    public abstract Mutate getMutate();

    /**
     *  Tensors should be considered immutable, however sometimes it
     *  is important to mutate their state for performance reasons.
     *  This interface exposes several methods for mutating the state of this tensor.
     *  The usage of methods exposed by this API is generally discouraged
     *  because the exposed state can easily lead to broken tensors and exceptions...&lt;br&gt;
     *  &lt;br&gt;
     */
    public interface Mutate {
        /**
         *  This method sets the NDConfiguration of this NDArray.
         *  Therefore, it should not be used lightly as it can cause major internal inconsistencies.
         *
         * @param configuration The new NDConfiguration instance which ought to be set.
         * @return The final instance type of this class which enables method chaining.
         */
        Mutate setNDConf( NDConfiguration configuration );
        /**
         *  This method is an inline operation which changes the underlying data of this tensor.
         *  It converts the data types of the elements of this tensor to the specified type!&lt;br&gt;
         *  &lt;br&gt;
         *  &lt;b&gt;WARNING : The usage of this method is discouraged for the following reasons: &lt;/b&gt;&lt;br&gt;
         *  &lt;br&gt;
         *  1. Inline operations are inherently error-prone for most use cases. &lt;br&gt;
         *  2. This inline operation in particular has no safety net,
         *     meaning that there is no implementation of version mismatch detection
         *     like there is for those operations present in the standard operation backend...
         *     No exceptions will be thrown during backpropagation! &lt;br&gt;
         *  3. This method has not yet been implemented to also handle instances which
         *     are slices of parent tensors!
         *     Therefore, there might be unexpected performance penalties or side effects
         *     associated with this method.&lt;br&gt;
         *     &lt;br&gt;
         *
         * @param typeClass The target type class for elements of this tensor.
         * @param &lt;V&gt; The type parameter for the returned tensor.
         * @return The same tensor instance whose data has been converted to hold a different type.
         */
        &lt;V&gt; Tsr&lt;V&gt; toType( Class&lt;V&gt; typeClass );

        /**
         *  This method enables modifying the data-type configuration of this {@link AbstractNDArray}.
         *  Warning! The method should not be used unless absolutely necessary.
         *  This is because it can cause unpredictable inconsistencies between the
         *  underlying {@link DataType} instance of this {@link AbstractNDArray} and the actual type of the actual
         *  data it is wrapping (or it is referencing on a {@link neureka.devices.Device}).&lt;br&gt;
         *  &lt;br&gt;
         * @param dataType The new {@link DataType} which ought to be set.
         * @return The tensor with the new data type set.
         */
        &lt;V&gt; Tsr&lt;V&gt; setDataType( DataType&lt;V&gt; dataType );

        /**
         *  This method allows you to modify the data-layout of this {@link AbstractNDArray}.
         *  Warning! The method should not be used unless absolutely necessary.
         *  This is because it can cause unpredictable side effects especially for certain
         *  operations expecting a particular data layout (like for example matrix multiplication).
         *  &lt;br&gt;
         *
         * @param layout The layout of the data array (row or column major).
         * @return The final instance type of this class which enables method chaining.
         */
        Mutate toLayout( NDConfiguration.Layout layout );

        /**
         *  This method is responsible for incrementing
         *  the &quot;_version&quot; field variable which represents the version of the data of this tensor.
         *  Meaning :
         *  Every time the underlying data (_value) changes this version ought to increment alongside.
         *  The method is called during the execution procedure.
         *
         * @param call The context object containing all relevant information that defines a call for tensor execution.
         * @return This very tensor instance. (factory pattern)
         */
        Mutate incrementVersion( ExecutionCall&lt;?&gt; call );

    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>