<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TensorAPI.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.ndim</a> &gt; <span class="el_source">TensorAPI.java</span></div><h1>TensorAPI.java</h1><pre class="source lang-java linenums">package neureka.ndim;

import neureka.Tsr;

import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 *  This interface is part of the {@link Tsr} API, and it defines
 *  how data can be read from and written to a tensor.
 *  In essence, this interface exists to expand
 *  the tensor API through default methods without littering the
 *  already large {@link Tsr} and {@link AbstractTensor} classes.
 *
 * @param &lt;V&gt; The value type parameter of the tensor.
 */
public interface TensorAPI&lt;V&gt; extends NDimensional, Iterable&lt;V&gt; {

    /**
     * @return The type class of individual value items within this {@link Tsr} instance.
     */
    Class&lt;V&gt; getValueClass();

    /**
     * @return The type class of individual value items within this {@link Tsr} instance.
     */
<span class="nc" id="L28">    default Class&lt;V&gt; valueClass() { return getValueClass(); }</span>

    /**
     *  The following method enables access to specific scalar elements within the tensor.
     *  The method name also translates to the subscript operator in Groovy.
     *
     * @param indices The index array of the element which should be returned.
     * @return An element located at the provided index.
     */
    Tsr&lt;V&gt; getAt( int... indices );

    /**
     *  This getter method creates and returns a slice of the original tensor.
     *  The returned slice is a scalar tensor wrapping a single value element which
     *  is being targeted by the provided integer index.
     *
     * @param i The index of the value item which should be returned as a tensor instance.
     * @return A tensor holding a single value element which is internally still residing in the original tensor.
     */
    default Tsr&lt;V&gt; getAt( Number i ) {
<span class="fc" id="L48">        return getAt( Collections.singletonList( getNDConf().indicesOfIndex( (i).intValue() ) ).toArray() );</span>
    }

    /**
     *  The following method enables access to specific scalar elements within the tensor.
     *  The method name also translates to the subscript operator in Groovy.
     *
     * @param indices The index array of the element which should be returned.
     * @return An element located at the provided index.
     */
<span class="fc" id="L58">    default Tsr&lt;V&gt; get( int... indices ) { return getAt( indices ); }</span>

    /**
     *  The following method enables the creation of tensor slices which access
     *  the same underlying data (possibly from a different view).
     *  The method name also translates to the subscript operator in Groovy.
     *
     * @param args An arbitrary number of arguments which can be used for slicing.
     * @return A slice tensor created based on the passed keys.
     */
    Tsr&lt;V&gt; getAt( Object... args );

    /**
     *  The following method enables the creation of tensor slices which access
     *  the same underlying data (possibly from a different view).
     *  The method name also translates to the subscript operator in Groovy.
     *
     * @param args An arbitrary number of arguments which can be used for slicing.
     * @return A slice tensor created based on the passed keys.
     */
    default Tsr&lt;V&gt; get( Object... args ) {
<span class="fc" id="L79">        return getAt( args );</span>
    }

    /**
     *  This getter method creates and returns a slice of the original tensor.
     *  The returned slice is a scalar tensor wrapping a single value element which
     *  is being targeted by the provided integer index.
     *
     * @param i The index of the value item which should be returned as a tensor instance.
     * @return A tensor holding a single value element which is internally still residing in the original tensor.
     */
<span class="fc" id="L90">    default Tsr&lt;V&gt; getAt( int i ) { return getAt( indicesOfIndex(i) ); }</span>

    /**
     *  This getter method creates and returns a slice of the original tensor.
     *  The returned slice is a scalar tensor wrapping a single value element which
     *  is being targeted by the provided integer index.
     *
     * @param i The index of the value item which should be returned as a tensor instance.
     * @return A tensor holding a single value element which is internally still residing in the original tensor.
     */
<span class="fc" id="L100">    default Tsr&lt;V&gt; get( int i ) { return getAt( i ); }</span>

    /**
     *  This getter method creates and returns a slice of the original tensor.
     *  The returned slice is a scalar tensor wrapping a single value element which
     *  is being targeted by the provided integer index.
     *
     * @param i The index of the value item which should be returned as a tensor instance.
     * @return A tensor holding a single value element which is internally still residing in the original tensor.
     */
<span class="nc" id="L110">    default Tsr&lt;V&gt; get( Number i ) { return getAt( i ); }</span>

    /**
     *  This method is most useful when used in Groovy
     *  where defining maps is done through square brackets,
     *  making it possible to slice tensors like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      var b = a[[[0..0]:1, [0..0]:1, [0..3]:2]]
     *  }&lt;/pre&gt;
     *  Here a single argument with the format '[i..j]:k' is equivalent
     *  to Pythons 'i:j:k' syntax for indexing! (numpy)                            &lt;br&gt;
     *  i... start indexAlias.                                                      &lt;br&gt;
     *  j... end indexAlias. (inclusive!)                                           &lt;br&gt;
     *  k... step size.
     *
     * @param rangToStrides A map where the keys define where axes should be sliced and values which define the strides for the specific axis.
     * @return A tensor slice with an offset based on the provided map keys and
     *         strides based on the provided map values.
     */
    Tsr&lt;V&gt; getAt( Map&lt;?,Integer&gt; rangToStrides );

    /**
     *  This method enables tensor slicing!
     *  It takes a key of various types and configures a slice
     *  tensor which shares the same underlying data as the original tensor.
     *
     * @param key This object might be a wide range of objects including maps, lists or arrays...
     * @return A slice tensor or scalar value.
     */
    Tsr&lt;V&gt; getAt( Object key );

    /**
     *  This method enables tensor slicing!
     *  It takes a key of various types and configures a slice
     *  tensor which shares the same underlying data as the original tensor.
     *
     * @param key This object might be a wide range of objects including maps, lists or arrays...
     * @return A slice tensor or scalar value.
     */
<span class="nc" id="L149">    default Tsr&lt;V&gt; get( Object key ) { return getAt( key ); }</span>

    /**
     *  This method enables assigning a provided tensor to be a subset of this tensor!
     *  It takes a key which is used to configure a slice
     *  sharing the same underlying data as the original tensor.
     *  This slice is then used to assign the second argument {@code value} to it.
     *  The usage of this method is especially powerful when used in Groovy. &lt;br&gt;
     *  The following code illustrates this very well:
     *  &lt;pre&gt;{@code
     *      a[[[0..0]:1, [0..0]:1, [0..3]:2]] = b
     *  }&lt;/pre&gt;
     *  Here a single argument with the format '[i..j]:k' is equivalent
     *  to pythons 'i:j:k' syntax for indexing! (numpy)                            &lt;br&gt;
     *  i... start indexAlias.                                                      &lt;br&gt;
     *  j... end indexAlias. (inclusive!)                                           &lt;br&gt;
     *  k... step size.                                                             &lt;br&gt;
     *
     * @param key This object is a map defining a stride and a targeted index or range of indices...
     * @param value The tensor which ought to be assigned into a slice of this tensor.
     * @return A slice tensor or scalar value.
     */
    Tsr&lt;V&gt; putAt( Map&lt;?,Integer&gt; key, Tsr&lt;V&gt; value );


    Tsr&lt;V&gt; putAt( int[] indices, V value );


    default Tsr&lt;V&gt; set( int[] indices, V value ) {
<span class="fc" id="L178">        return putAt( indices, value );</span>
    }


    /**
     *  Individual entries for value items in this tensor can be set
     *  via this method.
     *
     * @param index The scalar index targeting a specific value position within this tensor
     *          which ought to be replaced by the one provided by the second parameter
     *          of this method.
     *
     * @param value The item which ought to be placed at the targeted position.
     * @return This very tensor in order to enable method chaining...
     */
    default Tsr&lt;V&gt; putAt( int index, V value ) {
<span class="fc" id="L194">        return putAt( indicesOfIndex(index), value );</span>
    }


    /**
     *  Individual entries for value items in this tensor can be set
     *  via this method.
     *
     * @param index The scalar index targeting a specific value position within this tensor
     *          which ought to be replaced by the one provided by the second parameter
     *          of this method.
     *
     * @param value The item which ought to be placed at the targeted position.
     * @return This very tensor in order to enable method chaining...
     */
<span class="fc" id="L209">    default Tsr&lt;V&gt; set( int index, V value ) { return putAt( index, value ); }</span>

    /**
     *  This method enables injecting slices of tensor to be assigned into this tensor!
     *  It takes a key of various types which is used to configure a slice
     *  tensor sharing the same underlying data as the original tensor.
     *  This slice is then used to assign the second argument to it, namely
     *  the &quot;value&quot; argument.
     *
     * @param key This object is a list defining a targeted index or range of indices...
     * @param value the tensor which ought to be assigned to a slice of this tensor.
     * @return A slice tensor or scalar value.
     */
    Tsr&lt;V&gt; putAt( List&lt;?&gt; key, Tsr&lt;V&gt; value );

    default Tsr&lt;V&gt; putAt( List&lt;?&gt; indices, V value ) {
<span class="nc" id="L225">        return this.putAt( indices, Tsr.of( this.getValueClass(), shape(), value ) );</span>
    }

    /**
     *  An NDArray implementation ought to have some way to access its underlying data array.
     *  This method simple returns an element within this data array sitting at position &quot;i&quot;.
     * @param i The position of the targeted item within the raw data array of an NDArray implementation.
     * @return The found object sitting at the specified index position.
     */
    V getDataAt( int i );

    /**
     *  An NDArray implementation ought to have some way to selectively modify its underlying data array.
     *  This method simply overrides an element within this data array sitting at position &quot;i&quot;.
     * @param i The index of the data array entry which ought to be addressed.
     * @param o The object which ought to be placed at the requested position.
     * @return This very tensor in order to enable method chaining.
     */
    Tsr&lt;V&gt; setDataAt( int i, V o );

    /**
     *  An NDArray implementation ought to have some way to selectively modify its underlying value.
     *  This method simply overrides an element within this data array sitting at position &quot;i&quot;.
     * @param i The index of the value array entry which ought to be addressed.
     * @param o The object which ought to be placed at the requested position.
     * @return This very tensor in order to enable method chaining.
     */
    Tsr&lt;V&gt; setValueAt( int i, V o );

    /**
     *  The following method returns a raw value item within this tensor
     *  targeted by a scalar index.
     *
     * @param i The scalar index of the value item which should be returned by the method.
     * @return The value item found at the targeted index.
     */
<span class="fc" id="L261">    default V getValueAt( int i ) { return getDataAt( indexOfIndex( i ) ); }</span>

    /**
     *  This method returns a raw value item within this tensor
     *  targeted by an index array which is expect to hold an index for
     *  every dimension of the shape of this tensor.
     *  So the provided array must have the same length as the
     *  rank of this tensor!
     *
     * @param indices The index array which targets a single value item within this tensor.
     * @return The found raw value item targeted by the provided index array.
     */
<span class="fc" id="L273">    default V getValueAt( int... indices ) { return getDataAt( getNDConf().indexOfIndices( indices ) ); }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>