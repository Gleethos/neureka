<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OpenCLDevice.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.devices.opencl</a> &gt; <span class="el_source">OpenCLDevice.java</span></div><h1>OpenCLDevice.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ____                    _____ _      _____             _
  / __ \                  / ____| |    |  __ \           (_)
 | |  | |_ __   ___ _ __ | |    | |    | |  | | _____   ___  ___ ___
 | |  | | '_ \ / _ \ '_ \| |    | |    | |  | |/ _ \ \ / / |/ __/ _ \
 | |__| | |_) |  __/ | | | |____| |____| |__| |  __/\ V /| | (_|  __/
  \____/| .__/ \___|_| |_|\_____|______|_____/ \___| \_/ |_|\___\___|
        | |
        |_|

------------------------------------------------------------------------------------------------------------------------

   'Any fool can write code that a computer can understand.
    Good programmers write code that humans can understand.'
    – Martin Fowler

    Use the following as search keys :)

    $(1) : FIELD VARIABLES
    $(2) : CONSTRUCTION
    $(3) : OPENCL PROPERTIES
    $(4) : NESTED CLASSES

*/

package neureka.devices.opencl;

import neureka.Data;
import neureka.Neureka;
import neureka.Tsr;
import neureka.backend.api.*;
import neureka.backend.main.implementations.CLImplementation;
import neureka.backend.ocl.CLBackend;
import neureka.common.composition.Component;
import neureka.common.utility.DataConverter;
import neureka.common.utility.LogUtil;
import neureka.devices.*;
import neureka.devices.opencl.utility.CLFunctionCompiler;
import neureka.dtype.DataType;
import neureka.dtype.NumericType;
import neureka.dtype.custom.F32;
import neureka.framing.Relation;
import neureka.math.Function;
import neureka.ndim.config.NDConfiguration;
import org.jocl.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.WeakHashMap;
import java.util.function.Supplier;

import static org.jocl.CL.*;

/**
 * This class models OpenCL supporting accelerator hardware like GPUs or FPGAs
 * for storing tensors and executing operations on them.
 */
public class OpenCLDevice extends AbstractDevice&lt;Number&gt;
{
<span class="fc" id="L88">    private static final Logger _LOG = LoggerFactory.getLogger(OpenCLDevice.class);</span>

    static OpenCLDevice of( OpenCLPlatform platform, cl_device_id did ) {
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (!platform.has(did)) platform.put(did, new OpenCLDevice(platform, did));</span>
<span class="fc" id="L92">        return platform.get(did);</span>
    }

<span class="fc" id="L95">    public enum Type {</span>
<span class="fc" id="L96">        CPU, GPU, ACCELERATOR, DEFAULT, CUSTOM, ALL, UNKNOWN</span>
    }

<span class="fc" id="L99">    enum cl_dtype { F32, F64, I64, I32, I16, I8, U32, U16, U8 }</span>

    /*==================================================================================================================
    |
    |       §(1) : FIELD VARIABLES
    |   ---------------------------
    */

<span class="fc" id="L107">    private final KernelCache _kernelCache = new KernelCache();</span>

    private final cl_device_id _deviceId;

    /**
     * The OpenCLPlatform :
     * This method is a simple getter for the OpenCLPlatform instance hosting this current device.
     * A platform would for example be vendor specific like Intel, AMD, Nvidia...
     */
    private final OpenCLPlatform _platform;

    /**
     * The OpenCL command queue
     */
    private final cl_command_queue _queue;


<span class="fc" id="L124">    private final Map&lt;NDConfiguration, cl_config&gt; _configs = new WeakHashMap&lt;&gt;();</span>

    /*==================================================================================================================
    |
    |       §(2) : CONSTRUCTION
    |   ---------------------------
    */

    /**
     * @param platform The platform containing this device.
     * @param deviceId The underlying OpenCL id of this device.
     */
    private OpenCLDevice( OpenCLPlatform platform, cl_device_id deviceId ) {
<span class="fc" id="L137">        super();</span>
<span class="fc" id="L138">        _deviceId = deviceId;</span>
<span class="fc" id="L139">        _platform = platform;</span>
<span class="fc" id="L140">        _queue = clCreateCommandQueueWithProperties(// Create a command-queue for the selected device</span>
<span class="fc" id="L141">                        platform.getContext(), deviceId,</span>
                        null,
                        null
                    );
<span class="pc" id="L145">        _cleaning(this, () -&gt; clReleaseCommandQueue(_queue));</span>
<span class="fc" id="L146">    }</span>

    public final String toString() {
<span class="fc" id="L149">        return &quot;OpenCLDevice[id=0x&quot; + Long.toHexString(_deviceId.getNativePointer()) + &quot;,platform=0x&quot; + Long.toHexString(_platform.getId()) + &quot;]&quot;;</span>
    }

<span class="nc" id="L152">    public final cl_device_id getId() { return _deviceId; }</span>

<span class="fc" id="L154">    public final OpenCLPlatform getPlatform() { return _platform; }</span>

    /**
     * @param name The name of the kernel whose presents should be checked.
     * @return True if the kernel is present in the cache, false otherwise.
     */
<span class="fc" id="L160">    public boolean hasAdHocKernel( String name ) { return _kernelCache.has(name); }</span>

    /**
     * @param name The name of the kernel which should be retrieved.
     * @return The kernel with the given name if it is present in the cache, throws an exception otherwise.
     */
    public KernelCaller getAdHocKernel( String name ) {
<span class="fc" id="L167">        cl_ad_hoc adHoc = _kernelCache.get(name);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (adHoc != null) return new KernelCaller(adHoc.kernel, _queue);</span>
<span class="nc" id="L169">        else throw new IllegalArgumentException(&quot;No ad hoc kernel with name '&quot; + name + &quot;' found!&quot;);</span>
    }

    /**
     * @param name The name of the kernel which should be retrieved.
     * @return An {@link Optional} containing the kernel with the given name if it is present in the cache, an empty optional otherwise.
     */
    public Optional&lt;KernelCaller&gt; findAdHocKernel( String name ) {
<span class="fc" id="L177">        cl_ad_hoc adHoc = _kernelCache.get(name);</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (adHoc != null) return Optional.of(new KernelCaller(adHoc.kernel, _queue));</span>
<span class="nc" id="L179">        else return Optional.empty();</span>
    }

    /**
     * @param name The name of the kernel which should be retrieved.
     * @param source The source code of the kernel which should be compiled if it is not present in the cache.
     * @return The kernel caller for the kernel of the requested name, either from cache,
     *          or compiled from the given source code if it was not present in the cache.
     */
    public KernelCaller findOrCompileAdHocKernel( String name, Supplier&lt;String&gt; source ) {
<span class="fc" id="L189">        cl_ad_hoc adHoc = _kernelCache.get(name);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if ( adHoc != null ) return new KernelCaller(adHoc.kernel, _queue);</span>
<span class="fc" id="L191">        else return compileAndGetAdHocKernel(name, source.get());</span>
    }

    /**
     * This method compiles and returns the {@link KernelCaller} for a so called &quot;ad hoc&quot; kernel.
     * Ad hoc is a Latin phrase meaning literally 'to this'.
     * In English, it generally signifies a solution designed for a specific problem or task,
     * non-generalizable, and not intended to be adapted to other purposes.
     * This leads to the purpose of ad hoc kernel compilation, namely to be able to compile
     * unique kernels with a specific purpose created on the fly during runtime by operations.
     * This might be useful for high performance operations on tensors with specific dimensions and
     * or possibly other variables / properties which might be taken into account...
     *
     * @param name   The name of the kernel which ought to be compiled.
     * @param source The source of the kernel which ought to be compiled.
     * @return The {@link KernelCaller} for the compiled kernel.
     */
    public synchronized KernelCaller compileAndGetAdHocKernel( String name, String source ) {
<span class="fc" id="L209">        return compileAdHocKernel( name, source )</span>
<span class="fc" id="L210">                .findAdHocKernel( name )</span>
<span class="pc" id="L211">                .orElseThrow(() -&gt; new RuntimeException(&quot;Failed to compile kernel: &quot; + name));</span>
    }

    /**
     * This method compiles so called &quot;ad hoc&quot; kernel.
     * Ad hoc is a Latin phrase meaning literally 'to this'.
     * In English, it generally signifies a solution designed for a specific problem or task,
     * non-generalizable, and not intended to be adapted to other purposes.
     * This leads to the purpose of ad hoc kernel compilation, namely to be able to compile
     * unique kernels with a specific purpose created on the fly during runtime by operations.
     * This might be useful for high performance operations on tensors with specific dimensions and
     * or possibly other variables / properties which might be taken into account...
     *
     * @param name   The name of the kernel which ought to be compiled.
     * @param source The source of the kernel which ought to be compiled.
     * @return This very instance in order to enable the factory pattern.
     */
    public synchronized OpenCLDevice compileAdHocKernel( String name, String source ) {
<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (this.hasAdHocKernel(name)) {</span>
<span class="fc" id="L230">            cl_ad_hoc adHoc = _kernelCache.get(name);</span>
<span class="fc" id="L231">            String message =</span>
                &quot;Cannot compile kernel source for name '&quot; + name + &quot;' because the name is already taken.\n&quot; +
                &quot;Use another name or find out why this kernel already exists.\n&quot; +
                (
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">                        adHoc.source.equals(source)</span>
<span class="pc" id="L236">                                ? &quot;Besides the name, the source code of the existing kernel is also identical.\n&quot; : &quot;&quot;</span>
                );
<span class="fc" id="L238">            _log.error(message);</span>
<span class="fc" id="L239">            throw new IllegalArgumentException(message);</span>
        }

        // Create the program for the kernel
<span class="fc" id="L243">        cl_program cpProgram = clCreateProgramWithSource(</span>
<span class="fc" id="L244">                getPlatform().getContext(),</span>
                1,
                new String[]{source},
                null,
                null
        );

        // Build the program
<span class="fc" id="L252">        int err = clBuildProgram(</span>
                        cpProgram,
                        1,
                        new cl_device_id[]{_deviceId},
                        &quot;-cl-mad-enable&quot;,
                        null,
                        null
                );

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if ( err != CL_SUCCESS )</span>
<span class="nc" id="L262">            _log.error(&quot;Error when trying to compile 'ad hoc kernel' named '&quot;+name+&quot;'! Error code: &quot;+err);</span>

        //TODO: check compilation errors!
        cl_kernel kernel;
        try {
            // Create the kernel
<span class="fc" id="L268">            kernel = clCreateKernel(cpProgram, name, null);</span>
<span class="fc" id="L269">        } catch (Exception e) {</span>
<span class="pc bpc" id="L270" title="2 of 4 branches missed.">            if (e.getMessage().equals(&quot;CL_INVALID_KERNEL_NAME&quot;) &amp;&amp; !source.contains(&quot;__kernel void &quot; + name)) {</span>
<span class="fc" id="L271">                String message = &quot;Method 'clCreateKernel' failed! The name of the '__kernel' method declared inside \n&quot; +</span>
                                 &quot;the source String does not match the provided name needed for kernel creation.&quot;;
<span class="fc" id="L273">                _log.error(message, e);</span>
<span class="fc" id="L274">                throw new IllegalArgumentException(message);</span>
            }
<span class="nc" id="L276">            _log.error(&quot;Method call 'clCreateKernel(.., name=\&quot;&quot; + name + &quot;\&quot;, ..)' failed!&quot;, e);</span>
<span class="nc" id="L277">            throw e;</span>
<span class="fc" id="L278">        }</span>
<span class="fc" id="L279">        cl_ad_hoc adHoc = new cl_ad_hoc(source, kernel, cpProgram);</span>

        // Storing the ad hoc object in a weak hash map for fast access by operations :
<span class="fc" id="L282">        _kernelCache.put( name, adHoc );</span>

<span class="fc" id="L284">        _cleaning(adHoc, () -&gt; {</span>
<span class="nc" id="L285">            clReleaseKernel(kernel);</span>
<span class="nc" id="L286">            clReleaseProgram(cpProgram);</span>
<span class="nc" id="L287">        });</span>
<span class="fc" id="L288">        return this;</span>
    }

    @Override
    public Operation optimizedOperationOf( Function function, String name ) {
<span class="fc" id="L293">        return new CLFunctionCompiler( this, function, name ).optimize();</span>
    }

    /**
     * This method tells the to restore all tensors stored on it and release all resources.
     */
    @Override
    public void dispose() {
<span class="fc" id="L301">        _numberOfTensors = 0;</span>
<span class="fc" id="L302">        clFinish( _queue );</span>
<span class="fc" id="L303">        clReleaseCommandQueue( _queue );</span>
<span class="fc" id="L304">    }</span>

    /**
     * This method assumes that the passed tensor is stored on this device instance.
     * If the tensor is stored on the device then the method loads the outsourced
     * data of the tensor back into primitive JVM arrays and restores the tensor
     * freshly in RAM.
     *
     * @param tensor The tensor whose data ought to be restored (loaded to RAM).
     * @return This device, which enables method chaining.
     */
    @Override
    public Device&lt;Number&gt; restore( Tsr&lt;Number&gt; tensor ) {
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if ( !this.has( tensor ) ) {</span>
<span class="fc" id="L318">            String message = &quot;The passed tensor cannot be restored from this OpenCL device &quot; +</span>
                                &quot;because the tensor is not stored on the device.\n&quot;;
<span class="fc" id="L320">            _log.error(message);</span>
<span class="fc" id="L321">            throw new IllegalArgumentException(message);</span>
        }

<span class="fc bfc" id="L324" title="All 2 branches covered.">        Object value  = _read(JVMData.of(tensor.itemType(), tensor.isVirtual() ? 1 : tensor.size()), tensor, 0).getArray();</span>

<span class="fc" id="L326">        Class&lt;?&gt; arrayType = Objects.requireNonNull(tensor.getDataType().getTypeClassInstance(NumericType.class)).holderArrayType();</span>

<span class="fc" id="L328">        value = DataConverter.get().convert( value, arrayType );</span>

<span class="fc" id="L330">        this.free( tensor );</span>
<span class="fc" id="L331">        tensor.find( Tsr.class ).ifPresent( this::restore );</span>
<span class="fc" id="L332">        tensor.getMut().setItems( value );</span>
<span class="fc" id="L333">        return this;</span>
    }


    /**
     * Implementations of this method ought to store the value
     * of the given tensor and the &quot;parent&quot; tensor in whatever
     * formant suites the underlying implementation and or final type.
     * {@link Device} implementations are also tensor storages
     * which may also have to store tensors which are slices of bigger tensors.   &lt;br&gt;&lt;br&gt;
     *
     * @param tensor The tensor whose data ought to be stored.
     */
    private &lt;T extends Number&gt; void _store( Tsr&lt;T&gt; tensor, Tsr&lt;T&gt; parent ) {
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (!parent.isOutsourced()) throw new IllegalStateException(&quot;Data parent is not outsourced!&quot;);</span>
<span class="fc" id="L348">        _add(</span>
<span class="fc" id="L349">            tensor.getMut().upcast(Number.class),</span>
<span class="fc" id="L350">            parent.getMut().getData(),</span>
<span class="nc" id="L351">            () -&gt; tensor.set((Component) this)</span>
        );
<span class="fc" id="L353">    }</span>

    private &lt;T extends Number&gt; void _add(
        Tsr&lt;Number&gt; tensor,
        Data&lt;T&gt; parentData,
        Runnable migration // Causes the device to be a component of the tensor!
    ) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if ( this.has( tensor ) ) {</span>
<span class="fc" id="L361">            _LOG.debug(&quot;Trying to add a tensor to a device which already reports hosting it.&quot;);</span>
<span class="fc" id="L362">            return;</span>
        }

<span class="fc" id="L365">        boolean convertToFloat = Neureka.get()</span>
<span class="fc" id="L366">                                    .backend()</span>
<span class="fc" id="L367">                                    .find(CLBackend.class)</span>
<span class="fc" id="L368">                                    .map( it -&gt; it.getSettings().isAutoConvertToFloat() )</span>
<span class="fc" id="L369">                                    .orElse(false);</span>

        Data&lt;Number&gt; data;
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">        if ( parentData == null ) {</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">            if ( tensor.getMut().getData().owner() == this ) {</span>
<span class="nc" id="L374">                migration.run();</span>
<span class="nc" id="L375">                return;</span>
            }
<span class="fc" id="L377">            JVMData jvmData = null;</span>
<span class="fc" id="L378">            jvmData = JVMData.of( tensor.getMut().getData().getOrNull(), convertToFloat );</span>
            cl_tsr&lt;Number, Number&gt; newClt;
<span class="fc" id="L380">            newClt = _storeNew( jvmData );</span>
<span class="pc bpc" id="L381" title="1 of 4 branches missed.">            if ( tensor.rqsGradient() &amp;&amp; tensor.hasGradient() )</span>
<span class="nc" id="L382">                this.store(tensor.gradient().orElseThrow(()-&gt;new IllegalStateException(&quot;Gradient missing!&quot;)));</span>

<span class="fc" id="L384">            cl_mem[] memos = new cl_mem[]{newClt.value.data};</span>
<span class="fc" id="L385">            clEnqueueMigrateMemObjects(</span>
                    _queue, memos.length, memos,
                    CL_MIGRATE_MEM_OBJECT_HOST,
                    0,
                    null,
                    null
                );

<span class="fc" id="L393">            data = _dataArrayOf(newClt, (DataType&lt;Number&gt;) _dataTypeOf(newClt));</span>
<span class="fc" id="L394">        }</span>
        else
<span class="nc" id="L396">            data = (Data&lt;Number&gt;) parentData;</span>

<span class="fc" id="L398">        tensor.getMut().setData( data );</span>
<span class="fc" id="L399">        migration.run();</span>

        // When tensors get stored on this device,
        // they can be implicitly converted to a float tensor:
<span class="fc bfc" id="L403" title="All 2 branches covered.">        if ( convertToFloat )</span>
<span class="fc" id="L404">            tensor.getMut().toType(F32.class);</span>
<span class="fc" id="L405">    }</span>

    private cl_tsr&lt;Number, Number&gt; _storeNew( JVMData jvmData ) {
<span class="fc" id="L408">        return _storeNew( jvmData, false );</span>
    }

    private cl_tsr&lt;Number, Number&gt; _storeNew( JVMData jvmData, boolean allocateTargetSize ) {
<span class="fc bfc" id="L412" title="All 2 branches covered.">        cl_tsr.cl_value newVal = new cl_tsr.cl_value((int) (allocateTargetSize ? jvmData.getTargetLength() : jvmData.getLength()));</span>
<span class="fc" id="L413">        cl_tsr&lt;Number, Number&gt; newClt = new cl_tsr&lt;&gt;(newVal, jvmData.getType());</span>
<span class="fc" id="L414">        _store( jvmData, newClt, allocateTargetSize );</span>
<span class="fc" id="L415">        return newClt;</span>
    }

    public cl_config clConfigOf(Tsr&lt;?&gt; t ) {
<span class="fc" id="L419">        return clConfigOf( t.getNDConf() );</span>
    }

    public cl_config clConfigOf(NDConfiguration ndc ) {
<span class="fc" id="L423">        cl_config config = _configs.get(ndc);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">        if ( config == null ) {</span>
<span class="fc" id="L425">            config = _writeNewNDConfig( ndc );</span>
<span class="fc" id="L426">            _configs.put(ndc, config);</span>
        }
<span class="fc" id="L428">        return config;</span>
    }

    private cl_config _writeNewNDConfig(NDConfiguration ndc ) {

<span class="fc" id="L433">        cl_config clf = new cl_config();</span>

        //Config format: &lt;[ shape | strides | indicesMap | indices | scale ]&gt;
<span class="fc" id="L436">        int[] config = ndc.asInlineArray();</span>

        //shape/strides/map/offset/spread
<span class="fc" id="L439">        clf.data = clCreateBuffer(</span>
<span class="fc" id="L440">                    _platform.getContext(),</span>
                    CL_MEM_READ_WRITE,
                    (long) config.length * Sizeof.cl_int,
                    null, null
                );

<span class="fc" id="L446">        clEnqueueWriteBuffer(</span>
                _queue, clf.data, CL_TRUE, 0,
                (long) config.length * Sizeof.cl_int,
<span class="fc" id="L449">                Pointer.to(config),</span>
                0,
                null, null
            );
<span class="fc" id="L453">        final cl_mem clConfMem = clf.data;</span>
<span class="fc" id="L454">        _cleaning( clf, () -&gt; clReleaseMemObject(clConfMem) );</span>
<span class="fc" id="L455">        return clf;</span>
    }

    private void _store(
       JVMData jvmData,
       cl_tsr&lt;?, ?&gt; newClTsr,
       boolean allocateTarget
    ) {
<span class="fc bfc" id="L463" title="All 2 branches covered.">        long bufferLength = allocateTarget ? jvmData.getTargetLength() : jvmData.getLength();</span>

<span class="fc" id="L465">        cl_mem mem = clCreateBuffer(</span>
<span class="fc" id="L466">                        _platform.getContext(),</span>
                        CL_MEM_READ_WRITE,
<span class="fc" id="L468">                        (long) jvmData.getItemSize() * bufferLength,</span>
                        null,
                        null
                    );

<span class="fc" id="L473">        newClTsr.value.data = mem;</span>

        // Virtual means that there is only a single value in the JVM array.
        // So we don't have to write the whole array to the device!
        // Instead, we can just fill the device memory with the single value.
<span class="fc" id="L478">        boolean isASingleValue = jvmData.isVirtual();</span>

<span class="fc bfc" id="L480" title="All 2 branches covered.">        if ( isASingleValue )</span>
<span class="fc" id="L481">            clEnqueueFillBuffer(</span>
<span class="fc" id="L482">                    _queue, mem, jvmData.getPointer(), // pattern</span>
<span class="fc" id="L483">                    jvmData.getItemSize(), 0,</span>
<span class="fc" id="L484">                    (long) jvmData.getItemSize() * bufferLength,</span>
                    0, null, null
                );
        else
<span class="fc" id="L488">            clEnqueueWriteBuffer(</span>
                    _queue, mem,
                    CL_TRUE, 0,
<span class="fc" id="L491">                    (long) jvmData.getItemSize() * bufferLength,</span>
<span class="fc" id="L492">                    jvmData.getPointer(), 0, null, null</span>
                );
<span class="fc" id="L494">    }</span>

    @Override
    public final &lt;T extends Number&gt; Device&lt;Number&gt; free( Tsr&lt;T&gt; tensor ) {
<span class="fc" id="L498">        cl_tsr&lt;?, ?&gt; clt = tensor.getMut().getData().as( cl_tsr.class);</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        if ( clt == null ) return this;</span>
<span class="fc" id="L500">        tensor.getMut().setData(null);</span>
<span class="fc" id="L501">        tensor.find(Device.class).ifPresent(</span>
            device -&gt; {
<span class="fc" id="L503">                tensor.remove( Device.class );</span>
<span class="fc" id="L504">                tensor.find(Tsr.class).ifPresent(</span>
                    gradient -&gt;
<span class="fc" id="L506">                        ( (Tsr&lt;Number&gt;) gradient ).find(Device.class).ifPresent(</span>
                            gradDevice -&gt; {
                                try {
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">                                    if ( this.has( gradient ) ) gradDevice.restore( gradient );</span>
                                }
<span class="nc" id="L511">                                catch ( Exception exception ) {</span>
<span class="nc" id="L512">                                    _LOG.error(</span>
                                        &quot;Gradient could not be restored from device component when trying to migrate it back to RAM.&quot;,
                                        exception
                                    );
<span class="nc" id="L516">                                    throw exception;</span>
<span class="fc" id="L517">                                }</span>
<span class="fc" id="L518">                                gradient.remove( Device.class );</span>
<span class="fc" id="L519">                            })</span>
                );
<span class="fc" id="L521">            }</span>
        );
<span class="fc" id="L523">        return this;</span>
    }

    @Override
    protected final &lt;T extends Number&gt; T _readItem( Tsr&lt;T&gt; tensor, int index ) {
<span class="fc" id="L528">        return (T) _read(JVMData.of(tensor.itemType(), 1), tensor.getMut().upcast(Number.class), index).getElementAt(0);</span>
    }

    @Override
    protected final &lt;T extends Number, A&gt; A _readArray( Tsr&lt;T&gt; tensor, Class&lt;A&gt; arrayType, int start, int size ) {
<span class="fc" id="L533">        return (A) _read(JVMData.of(tensor.itemType(), size), tensor.getMut().upcast(Number.class), start).getArray();</span>
    }

    @Override
    protected final &lt;T extends Number&gt; void _writeItem( Tsr&lt;T&gt; tensor, T item, int start, int size ) {
<span class="fc" id="L538">        _overwrite( tensor, start, JVMData.of(item, size, 0) );</span>
<span class="fc" id="L539">    }</span>

    @Override
    protected final &lt;T extends Number&gt; void _writeArray( Tsr&lt;T&gt; tensor, Object array, int offset, int start, int size ) {
<span class="fc" id="L543">        _overwrite( tensor, start, JVMData.of(array, size, offset) );</span>
<span class="fc" id="L544">    }</span>

    @Override
    public &lt;T extends Number&gt; Data&lt;T&gt; allocate( DataType&lt;T&gt; dataType, NDConfiguration ndc ) {
<span class="nc" id="L548">        JVMData jvmData = JVMData.of( dataType.getItemTypeClass(), ndc.size() );</span>
<span class="nc" id="L549">        cl_tsr&lt;Number, Number&gt; clt = _storeNew(jvmData );</span>
<span class="nc" id="L550">        return (Data&lt;T&gt;) _dataArrayOf(clt, (DataType&lt;Number&gt;) _dataTypeOf(clt));</span>
    }

    @Override
    public &lt;T extends Number&gt; Data&lt;T&gt; allocateFromOne( DataType&lt;T&gt; dataType, NDConfiguration ndc, T initialValue ) {
<span class="fc" id="L555">        JVMData jvmData = JVMData.of( initialValue, ndc.size(), false, true );</span>
<span class="fc" id="L556">        cl_tsr&lt;Number, Number&gt; clt = _storeNew(jvmData );</span>
<span class="fc" id="L557">        return (Data&lt;T&gt;) _dataArrayOf(clt, (DataType&lt;Number&gt;) _dataTypeOf(clt));</span>
    }

    @Override
    public &lt;T extends Number&gt; Data&lt;T&gt; allocateFromAll( DataType&lt;T&gt; dataType, NDConfiguration ndc, Object data ) {
<span class="nc" id="L562">        JVMData jvmData = JVMData.of( data );</span>
<span class="nc" id="L563">        cl_tsr&lt;Number, Number&gt; clt = _storeNew(jvmData );</span>
<span class="nc" id="L564">        return (Data&lt;T&gt;) _dataArrayOf(clt, (DataType&lt;Number&gt;) _dataTypeOf(clt));</span>
    }

    @Override
    protected Data&lt;Number&gt; _actualize( Tsr&lt;?&gt; tensor ) {
<span class="fc" id="L569">        NDConfiguration ndc = tensor.getNDConf();</span>
<span class="fc" id="L570">        Object initialValue = tensor.item();</span>
<span class="fc" id="L571">        cl_tsr&lt;?, ?&gt; clt = tensor.getMut().getData().as( cl_tsr.class);</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        if ( clt == null ) throw new IllegalStateException(&quot;The tensor has no device component!&quot;);</span>
<span class="fc" id="L573">        JVMData jvmData = JVMData.of( initialValue, ndc.size(), false, true );</span>
<span class="fc" id="L574">        clt = _storeNew( jvmData, true );</span>
<span class="fc" id="L575">        return _dataArrayOf(clt, (DataType&lt;Number&gt;) _dataTypeOf(clt));</span>
    }

    @Override
    protected Data&lt;Number&gt; _virtualize( Tsr&lt;?&gt; tensor ) {
<span class="fc" id="L580">        NDConfiguration ndc = tensor.getNDConf();</span>
<span class="fc" id="L581">        Object initialValue = tensor.item();</span>
<span class="fc" id="L582">        cl_tsr&lt;?, ?&gt; clt = tensor.getMut().getData().as( cl_tsr.class);</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if ( clt == null ) throw new IllegalStateException(&quot;The tensor has no device component!&quot;);</span>
<span class="fc" id="L584">        JVMData jvmData = JVMData.of( initialValue, ndc.size(), false, true );</span>
<span class="fc" id="L585">        clt = _storeNew( jvmData, false );</span>
<span class="fc" id="L586">        return _dataArrayOf(clt, (DataType&lt;Number&gt;) _dataTypeOf(clt));</span>
    }

    @Override
    protected final DataType&lt;?&gt; _dataTypeOf( Object rawData ) {
<span class="fc" id="L591">        LogUtil.nullArgCheck( rawData, &quot;rawData&quot;, Object.class );</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">        if ( rawData instanceof cl_tsr ) {</span>
<span class="fc" id="L593">            cl_dtype type = ((cl_tsr) rawData).dtype;</span>
<span class="pc bpc" id="L594" title="1 of 7 branches missed.">            switch ( type ) {</span>
<span class="fc" id="L595">                case F32: return DataType.of( Float.class );</span>
<span class="fc" id="L596">                case F64: return DataType.of( Double.class );</span>
                case I32: case U32:
<span class="fc" id="L598">                    return DataType.of( Integer.class );</span>
<span class="fc" id="L599">                case I64: return DataType.of( Long.class );</span>
                case I16: case U16:
<span class="fc" id="L601">                    return DataType.of( Short.class );</span>
                case I8: case U8:
<span class="fc" id="L603">                    return DataType.of( Byte.class );</span>
<span class="nc" id="L604">                default: throw new IllegalStateException(&quot;Unknown OpenCL data type!&quot;);</span>
            }
        }
<span class="nc" id="L607">        throw new IllegalStateException(&quot;Unknown data type &quot;+rawData.getClass()+&quot;!&quot;);</span>
    }

    private void _overwrite(
            Tsr&lt;?&gt; tensor, long offset, JVMData jvmData
    ) {
<span class="fc bfc" id="L613" title="All 2 branches covered.">        if ( jvmData.getLength() == 0 ) return;</span>
<span class="fc" id="L614">        cl_tsr&lt;?, ?&gt; clt = tensor.getMut().getData().as( cl_tsr.class);</span>

<span class="fc bfc" id="L616" title="All 2 branches covered.">        if ( clt.value.event != null ) clWaitForEvents(1, new cl_event[]{clt.value.event});</span>
<span class="fc" id="L617">        clt.value.event = new cl_event();</span>
<span class="fc" id="L618">        long start = offset * jvmData.getItemSize();</span>
<span class="fc" id="L619">        long size  = jvmData.getItemSize() * jvmData.getLength();</span>
<span class="fc" id="L620">        clEnqueueWriteBuffer(</span>
                _queue, clt.value.data, CL_TRUE,
                start, size,
<span class="fc" id="L623">                jvmData.getPointer(), 0, null,</span>
                clt.value.event
            );
<span class="fc" id="L626">    }</span>

    @Override
    protected final &lt;T extends Number&gt; void _swap(Tsr&lt;T&gt; former, Tsr&lt;T&gt; replacement) {
<span class="nc" id="L630">        cl_tsr&lt;Number, T&gt; clTsr = former.getMut().getData().as( cl_tsr.class);</span>
<span class="nc" id="L631">        former.getMut().setData(null);</span>
<span class="nc" id="L632">        replacement.getMut().setData( _dataArrayOf(clTsr, (DataType&lt;T&gt;) _dataTypeOf(clTsr)) );</span>
<span class="nc" id="L633">    }</span>

    @Override
    public boolean update( OwnerChangeRequest&lt;Tsr&lt;Number&gt;&gt; changeRequest ) {
<span class="fc" id="L637">        super.update(changeRequest);</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        if (changeRequest.type() == IsBeing.ADDED) {</span>
<span class="fc" id="L639">            Tsr&lt;Number&gt; newOwner = changeRequest.getNewOwner();</span>
<span class="fc" id="L640">            _updateInternal(newOwner, changeRequest::executeChange);</span>
<span class="fc" id="L641">        } else</span>
<span class="fc" id="L642">            changeRequest.executeChange(); // This can be an 'add', 'remove' or 'transfer' of this component!</span>
<span class="fc" id="L643">        return true;</span>
    }

    @Override
<span class="fc" id="L647">    protected &lt;T extends Number&gt; int _sizeOccupiedBy( Tsr&lt;T&gt; tensor ) { return tensor.getMut().getData().as( cl_tsr.class).value.size; }</span>

    @Override
    protected &lt;T extends Number&gt; Object _readAll( Tsr&lt;T&gt; tensor, boolean clone ) {
<span class="fc" id="L651">        cl_tsr&lt;?, ?&gt; clt = tensor.getMut().getData().as( cl_tsr.class);</span>
<span class="fc" id="L652">        return _readArray( tensor, tensor.getDataType().dataArrayType(), 0, clt.value.size );</span>
    }

    private void _updateInternal(Tsr&lt;Number&gt; newOwner, Runnable migration) {
<span class="fc" id="L656">        Tsr&lt;Number&gt; root = _findRoot( newOwner );</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">        if (root != null) _store(newOwner, root);</span>
<span class="fc" id="L658">        else _add( newOwner, null, migration );</span>
<span class="fc" id="L659">    }</span>

    private Tsr&lt;Number&gt; _findRoot( Tsr&lt;Number&gt; newOwner ) {
<span class="fc" id="L662">        Tsr&lt;Number&gt; root = null;</span>
<span class="fc" id="L663">        Relation&lt;Number&gt; relation = newOwner.get(Relation.class);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        if ( relation != null )</span>
<span class="fc" id="L665">            root = ((Relation&lt;Number&gt;) newOwner.get(Relation.class)).findRootTensor().orElse(null);</span>

<span class="fc" id="L667">        return root;</span>
    }

    private JVMData _read( JVMData jvmData, Tsr&lt;Number&gt; tensor, int offset ) {
<span class="fc" id="L671">        cl_tsr&lt;?, ?&gt; clt = tensor.getMut().getData().as( cl_tsr.class);</span>
<span class="fc" id="L672">        clEnqueueReadBuffer(</span>
                _queue,
                clt.value.data,
                CL_TRUE,
<span class="fc" id="L676">                (long) offset * jvmData.getItemSize(), // one double == eight byte</span>
<span class="fc" id="L677">                (long) jvmData.getItemSize() * jvmData.getLength(),</span>
<span class="fc" id="L678">                jvmData.getPointer(),</span>
                0,
                null,
                null
        );
<span class="fc" id="L683">        return jvmData;</span>
    }

    /**
     * @param call The {@link ExecutionCall} which will be queried for a {@link CLImplementation} holding the kernel.
     * @return The kernel call which uses the builder pattern to receive kernel arguments.
     */
    public KernelCaller getKernel( ExecutionCall&lt;OpenCLDevice&gt; call ) {
        String chosen;
<span class="fc" id="L692">        Algorithm algorithm = call.getAlgorithm();</span>
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        DeviceAlgorithm&lt;?&gt; deviceAlgorithm = ( algorithm instanceof DeviceAlgorithm ? ((DeviceAlgorithm&lt;?&gt;) algorithm) : null );</span>
        // We create the kernel name from the chosen algorithm:
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">        ImplementationFor&lt;OpenCLDevice&gt; impl = ( deviceAlgorithm == null ? null : deviceAlgorithm.getImplementationFor(OpenCLDevice.class) );</span>
<span class="pc bpc" id="L696" title="2 of 4 branches missed.">        if ( impl instanceof CLImplementation &amp;&amp; _platform.hasKernel(((CLImplementation) impl).getKernelFor(call).getName()) ) {</span>
<span class="fc" id="L697">            chosen = ((CLImplementation) impl).getKernelFor( call ).getName();</span>
        }
        else
<span class="nc" id="L700">            chosen = call.getAlgorithm().getName() + &quot;_&quot; + call.getOperation().getIdentifier();</span>

<span class="fc" id="L702">        cl_kernel kernel = _platform.getKernel( chosen );</span>
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">        if ( kernel == null )</span>
<span class="nc" id="L704">            throw new IllegalStateException(</span>
<span class="nc" id="L705">                    &quot;No kernel found for signature '&quot; + chosen + &quot;' for operation '&quot; +  call.getOperation().getIdentifier() + &quot;'.&quot;</span>
                );

<span class="fc" id="L708">        return new KernelCaller(kernel, _queue);</span>
    }

    /**
     * @param name The name of the kernel for which a {@link KernelCaller} should be returned.
     * @return A {@link KernelCaller} for calling the requested kernel.
     */
    public KernelCaller getKernel( String name ) {
<span class="fc" id="L716">        cl_kernel kernel = _platform.getKernel( name );</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">        if ( kernel == null )</span>
<span class="nc" id="L718">            throw new IllegalStateException(&quot;No kernel found with name '&quot; + name + &quot;'.&quot;);</span>
<span class="fc" id="L719">        return new KernelCaller(kernel, _queue);</span>
    }

    @Override
<span class="fc" id="L723">    protected boolean _approveExecutionOf( Tsr&lt;?&gt;[] tensors, int d, Operation type ) { return true; }</span>


    /*==================================================================================================================
    |
    |       §(3) : OPENCL PROPERTIES
    |   ---------------------------
    */

<span class="fc" id="L732">    public String name() { return Query.getString( _deviceId, CL_DEVICE_NAME ); }</span>

<span class="fc" id="L734">    public String vendor() { return Query.getString(_deviceId, CL_DEVICE_VENDOR); }</span>

<span class="fc" id="L736">    public String version() { return Query.getString(_deviceId, CL_DRIVER_VERSION); }</span>

    public Type type() {
<span class="fc" id="L739">        long deviceType = Query.getLong(_deviceId, CL_DEVICE_TYPE);</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_CPU         ) != 0 ) return Type.CPU;</span>
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_GPU         ) != 0 ) return Type.GPU;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_ACCELERATOR ) != 0 ) return Type.ACCELERATOR;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_DEFAULT     ) != 0 ) return Type.DEFAULT;</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_CUSTOM      ) != 0 ) return Type.CUSTOM;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_ALL         ) != 0 ) return Type.ALL;</span>
<span class="nc" id="L746">        return Type.UNKNOWN;</span>
    }

<span class="nc" id="L749">    public int maxComputeUnits() { return Query.getInt(_deviceId, CL_DEVICE_MAX_COMPUTE_UNITS); }</span>

<span class="nc" id="L751">    public long maxWorkItemSimensions() { return Query.getLong(_deviceId, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS); }</span>

<span class="nc" id="L753">    public long[] maxWorkItemSizes() { return Query.getSizes(_deviceId, CL_DEVICE_MAX_WORK_ITEM_SIZES, 3); }</span>

<span class="fc" id="L755">    public long maxWorkGroupSize() { return Query.getSize(_deviceId, CL_DEVICE_MAX_WORK_GROUP_SIZE); }</span>

<span class="fc" id="L757">    public long maxClockFrequenzy() { return Query.getLong(_deviceId, CL_DEVICE_MAX_CLOCK_FREQUENCY); }</span>

<span class="nc" id="L759">    public int maxAddressBits() { return Query.getInt(_deviceId, CL_DEVICE_ADDRESS_BITS); }</span>

<span class="nc" id="L761">    public long maxMemAllocSize() { return Query.getLong(_deviceId, CL_DEVICE_MAX_MEM_ALLOC_SIZE); }</span>

<span class="fc" id="L763">    public long globalMemSize() { return Query.getLong(_deviceId, CL_DEVICE_GLOBAL_MEM_SIZE); }</span>

<span class="nc" id="L765">    public int errorCorrectionSupport() { return Query.getInt(_deviceId, CL_DEVICE_ERROR_CORRECTION_SUPPORT); }</span>

<span class="nc" id="L767">    public int localMemType() { return Query.getInt(_deviceId, CL_DEVICE_LOCAL_MEM_TYPE); }</span>

<span class="nc" id="L769">    public long localMemSize() { return Query.getLong(_deviceId, CL_DEVICE_LOCAL_MEM_SIZE); }</span>

<span class="fc" id="L771">    public long maxConstantBufferSize() { return Query.getLong(_deviceId, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE); }</span>

<span class="nc" id="L773">    public long maxConstantBufferSizeKB() { return (int) (Query.getLong(_deviceId, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE) / 1024); }</span>

<span class="nc" id="L775">    public int imageSupport() { return Query.getInt(_deviceId, CL_DEVICE_IMAGE_SUPPORT); }</span>

<span class="nc" id="L777">    public int maxReadImageArgs() { return Query.getInt(_deviceId, CL_DEVICE_MAX_READ_IMAGE_ARGS); }</span>

<span class="fc" id="L779">    public int maxWriteImageArgs() { return Query.getInt(_deviceId, CL_DEVICE_MAX_WRITE_IMAGE_ARGS); }</span>

<span class="nc" id="L781">    public long singleFPConfig() { return Query.getLong(_deviceId, CL_DEVICE_SINGLE_FP_CONFIG); }</span>

<span class="fc" id="L783">    public long image2DMaxWidth() { return Query.getSize(_deviceId, CL_DEVICE_IMAGE2D_MAX_WIDTH); }</span>

<span class="fc" id="L785">    public long image2DMaxHeight() { return Query.getSize(_deviceId, CL_DEVICE_IMAGE2D_MAX_HEIGHT); }</span>

<span class="fc" id="L787">    public long image3DMaxWidth() { return Query.getSize(_deviceId, CL_DEVICE_IMAGE3D_MAX_WIDTH); }</span>

<span class="fc" id="L789">    public long image3DMaxHeight() { return Query.getSize(_deviceId, CL_DEVICE_IMAGE3D_MAX_HEIGHT); }</span>

<span class="fc" id="L791">    public long image3DMaxDepth() { return Query.getSize(_deviceId, CL_DEVICE_IMAGE3D_MAX_DEPTH); }</span>

<span class="fc" id="L793">    public int prefVecWidthChar() { return Query.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR); }</span>

<span class="fc" id="L795">    public int prefVecWidthShort() { return Query.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT); }</span>

<span class="fc" id="L797">    public int prefVecWidthInt() { return Query.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT); }</span>

<span class="fc" id="L799">    public int prefVecWidthLong() { return Query.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG); }</span>

<span class="fc" id="L801">    public int prefVecWidthFloat() { return Query.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT); }</span>

<span class="fc" id="L803">    public int prefVecWidthDouble() { return Query.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE); }</span>

<span class="nc" id="L805">    public static class Query {</span>
        /**
         * Returns the value of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @return The value
         */
        public static int getInt(cl_device_id device, int paramName) {
<span class="fc" id="L814">            return getInts(device, paramName, 1)[0];</span>
        }

        /**
         * Returns the values of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @param numValues The number of values
         * @return The value
         */
        public static int[] getInts(cl_device_id device, int paramName, int numValues) {
<span class="fc" id="L826">            int[] values = new int[numValues];</span>
<span class="fc" id="L827">            clGetDeviceInfo(device, paramName, (long) Sizeof.cl_int * numValues, Pointer.to(values), null);</span>
<span class="fc" id="L828">            return values;</span>
        }

        /**
         * Returns the value of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @return The value
         */
        public static long getLong(cl_device_id device, int paramName) {
<span class="fc" id="L839">            return getLongs(device, paramName, 1)[0];</span>
        }

        /**
         * Returns the values of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @param numValues The number of values
         * @return The value
         */
        public static long[] getLongs(cl_device_id device, int paramName, int numValues) {
<span class="fc" id="L851">            long[] values = new long[numValues];</span>
<span class="fc" id="L852">            clGetDeviceInfo(device, paramName, (long) Sizeof.cl_long * numValues, Pointer.to(values), null);</span>
<span class="fc" id="L853">            return values;</span>
        }

        /**
         * Returns the value of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @return The value
         */
        public static String getString(cl_device_id device, int paramName) {
            // Obtain the length of the string that will be queried
<span class="fc" id="L865">            long[] size = new long[1];</span>
<span class="fc" id="L866">            clGetDeviceInfo(device, paramName, 0, null, size);</span>

            // Create a buffer of the appropriate size and fill it with the info
<span class="fc" id="L869">            byte[] buffer = new byte[(int) size[0]];</span>
<span class="fc" id="L870">            clGetDeviceInfo(device, paramName, buffer.length, Pointer.to(buffer), null);</span>

            // Create a string from the buffer (excluding the trailing \0 byte)
<span class="fc" id="L873">            return new String(buffer, 0, buffer.length - 1);</span>
        }

        /**
         * Returns the value of the platform info parameter with the given name
         *
         * @param platform  The platform
         * @param paramName The parameter name
         * @return The value
         */
        public static String getString(cl_platform_id platform, int paramName) {
            // Obtain the length of the string that will be queried
<span class="nc" id="L885">            long[] size = new long[1];</span>
<span class="nc" id="L886">            clGetPlatformInfo(platform, paramName, 0, null, size);</span>

            // Create a buffer of the appropriate size and fill it with the info
<span class="nc" id="L889">            byte[] buffer = new byte[(int) size[0]];</span>
<span class="nc" id="L890">            clGetPlatformInfo(platform, paramName, buffer.length, Pointer.to(buffer), null);</span>

            // Create a string from the buffer (excluding the trailing \0 byte)
<span class="nc" id="L893">            return new String(buffer, 0, buffer.length - 1);</span>
        }

        /**
         * Returns the value of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @return The value64
         */
        public static long getSize(cl_device_id device, int paramName) {
<span class="fc" id="L904">            return getSizes(device, paramName, 1)[0];</span>
        }

        /**
         * Returns the values of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @param numValues The number of values
         * @return The value64
         */
        public static long[] getSizes(cl_device_id device, int paramName, int numValues) {
            // The size of the returned data has to depend on
            // the size of a size_t, which is handled here
<span class="fc" id="L918">            ByteBuffer buffer = ByteBuffer.allocate(numValues * Sizeof.size_t).order(ByteOrder.nativeOrder());</span>
<span class="fc" id="L919">            clGetDeviceInfo(</span>
                    device,
                    paramName,
                    (long) Sizeof.size_t * numValues,
<span class="fc" id="L923">                    Pointer.to(buffer),</span>
                    null
            );
<span class="fc" id="L926">            long[] values = new long[numValues];</span>
<span class="fc" id="L927">            return getLongs(numValues, buffer, values);</span>
        }

        public static long[] getLongs(int numValues, ByteBuffer buffer, long[] values) {
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">            if (Sizeof.size_t == 4)</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">                for (int i = 0; i &lt; numValues; i++)</span>
<span class="nc" id="L933">                    values[i] = buffer.getInt(i * Sizeof.size_t);</span>
            else
<span class="fc bfc" id="L935" title="All 2 branches covered.">                for ( int i = 0; i &lt; numValues; i++ )</span>
<span class="fc" id="L936">                    values[i] = buffer.getLong(i * Sizeof.size_t);</span>

<span class="fc" id="L938">            return values;</span>
        }

    }


    private &lt;T extends Number&gt; Data&lt;T&gt; _dataArrayOf( Object data, DataType&lt;T&gt; dataType ) {
<span class="fc" id="L945">        return (Data&lt;T&gt;) new CLData(this, data, (DataType&lt;Number&gt;) dataType);</span>
    }

<span class="fc" id="L948">    private static class CLData extends AbstractDeviceData&lt;Number&gt; {</span>

        public CLData( AbstractBaseDevice&lt;Number&gt; owner, Object dataRef, DataType&lt;Number&gt; dataType ) {
<span class="fc" id="L951">            super(owner, dataRef, dataType, ()-&gt;{</span>
                // In this lambda we free the memory, because the data is no longer needed!
<span class="fc" id="L953">                cl_tsr&lt;?,?&gt; clTsr = (cl_tsr&lt;?,?&gt;) dataRef;</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">                if ( clTsr.value.event != null ) clWaitForEvents(1, new cl_event[]{clTsr.value.event});</span>
<span class="fc" id="L955">                clReleaseMemObject(clTsr.value.data); // Removing data from the device!</span>
<span class="fc" id="L956">            });</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">            assert !(dataRef instanceof Data);</span>
<span class="fc" id="L958">        }</span>

    }

    /*==================================================================================================================
    |
    |       §(4) : NESTED CLASSES
    |   ---------------------------
    */

    /**
     * This class is an OpenCL-Device specific tensor component used to store
     * the floating point size ( 1:float, 2:double, ...),
     * a reference to a wrapper containing a pointer to the tensor's configuration (cl_config),
     * and
     * a reference to a wrapper containing a pointer to the tensor's data (cl_data)
     * The latter two lend their identity for garbage collection!
     */
    static class cl_tsr&lt;V, T extends V&gt; {

<span class="fc" id="L978">        cl_tsr(cl_tsr.cl_value value, cl_dtype  dtype) {</span>
<span class="fc" id="L979">            this.value = value;</span>
<span class="fc" id="L980">            this.dtype = dtype;</span>
<span class="fc" id="L981">        }</span>

        /**
         * This class is responsible for representing the
         * data of a tensor stored on the device.
         * Instances of this class lend their identity to utilize garbage collection
         * of the data that they reference via their &quot;cl_mem&quot; field.
         * Meaning this inner memory object &quot;cl_mem&quot; will
         * be freed via a call hook stored inside a Cleaner instance...
         */
        static class cl_value
        {
<span class="fc" id="L993">            cl_value( int size ) { this.size = size; }</span>

            public final int size;
            public cl_mem    data;
            public cl_event  event;
        }

        public final cl_dtype  dtype;
        public final cl_value  value;

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">            if ( !(obj instanceof cl_tsr) ) return false;</span>
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">            return ((cl_tsr) obj).value == this.value;</span>
        }
    }

    /**
     * This class manages a reference to a so called &quot;ad hoc&quot; program &amp; kernel.
     * Ad hoc is a Latin phrase meaning literally 'to this'.
     * In English, it generally signifies a solution designed for a specific problem or task,
     * non-generalizable, and not intended to be adapted to other purposes.
     * This leads to the purpose of this class, namely to hold the context to a unique kernel with
     * a uniquely associated purpose which has been created by an operation possibly for specific
     * tensor dimensions or possibly other properties...
     */
    static final class cl_ad_hoc
    {
        public final String source;
        public final cl_kernel kernel;
        public final cl_program program;

        public cl_ad_hoc(
                String source, cl_kernel kernel, cl_program program
<span class="fc" id="L1027">        ) {</span>
<span class="fc" id="L1028">            this.source = source;</span>
<span class="fc" id="L1029">            this.kernel = kernel;</span>
<span class="fc" id="L1030">            this.program = program;</span>
<span class="fc" id="L1031">        }</span>
    }

    /**
     * This is the class responsible for representing NDConfiguration data.
     * Instances of this class lend their identity to utilize garbage collection
     * of the data that they reference via their &quot;cl_mem&quot; field.
     * Meaning this inner memory object &quot;cl_mem&quot; will
     * be freed via a call hook stored inside a Cleaner instance...
     */
<span class="fc" id="L1041">    static final class cl_config {</span>
        public cl_mem data;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>