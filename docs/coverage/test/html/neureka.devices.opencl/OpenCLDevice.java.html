<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OpenCLDevice.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.devices.opencl</a> &gt; <span class="el_source">OpenCLDevice.java</span></div><h1>OpenCLDevice.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ____                    _____ _      _____             _
  / __ \                  / ____| |    |  __ \           (_)
 | |  | |_ __   ___ _ __ | |    | |    | |  | | _____   ___  ___ ___
 | |  | | '_ \ / _ \ '_ \| |    | |    | |  | |/ _ \ \ / / |/ __/ _ \
 | |__| | |_) |  __/ | | | |____| |____| |__| |  __/\ V /| | (_|  __/
  \____/| .__/ \___|_| |_|\_____|______|_____/ \___| \_/ |_|\___\___|
        | |
        |_|

------------------------------------------------------------------------------------------------------------------------

   'Any fool can write code that a computer can understand.
    Good programmers write code that humans can understand.'
    â€“ Martin Fowler

    Use the following as search keys :)

    $(1) : NESTED CLASSES
    $(2) : FIELD VARIABLES
    $(3) : CONSTRUCTION
    $(4) : OPENCL PROPERTIES

*/

package neureka.devices.opencl;

import static org.jocl.CL.*;

import java.nio.*;
import java.util.*;

import lombok.Getter;
import lombok.ToString;
import lombok.experimental.Accessors;
import neureka.Component;
import neureka.Tsr;
import neureka.devices.AbstractDevice;
import neureka.devices.Device;
import neureka.devices.opencl.execution.CLExecutor;
import neureka.backend.api.ExecutionCall;
import neureka.backend.api.operations.OperationType;
import neureka.dtype.custom.F32;
import neureka.framing.Relation;
import neureka.utility.DataConverter;
import org.jocl.*;

/**
 *  This class is a concrete implementation of the Device interface by extending the AbstractDevice class.
 *  Instances of this class internally utilize the OpenCL API in order to use supported
 *  accelerator hardware like GPUs or FPGAs for storing tensors and executing operations on them.
 */
@Accessors( prefix = {&quot;_&quot;} )
<span class="fc" id="L77">@ToString</span>
public class OpenCLDevice extends AbstractDevice&lt;Number&gt;
{
    public static OpenCLDevice newInstanceOf( OpenCLPlatform platform, cl_device_id did )
    {
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if( !platform.has( did ) ) platform.put( did,  new OpenCLDevice( platform, did ) );</span>
<span class="fc" id="L83">        return platform.get( did );</span>
    }

    /*==================================================================================================================
    |
    |       Â§(1) : NESTED CLASSES
    |   ---------------------------
    */

    /**
     * This class is an OpenCL-Device specific tensor component used to store
     * the floating point size ( 1:float, 2:double, ...),
     * a reference to a wrapper containing a pointer to the tensors configuration (cl_config),
     * and
     * a reference to a wrapper containing a pointer to the tensors data (cl_data)
     * The latter two lend their identity for garbage collection!
     */
<span class="fc" id="L100">    static class cl_tsr implements Component&lt;Tsr&lt;Number&gt;&gt;</span>
    {

        /**
         * This class is responsible for representing the
         * data of a tensor stored on the device.
         * Instances of this class lend their identity to utilize garbage collection
         * of the data that they reference via their &quot;cl_mem&quot; field.
         * Meaning this inner memory object &quot;cl_mem&quot; will
         * be freed via a call hook stored inside a Cleaner instance...
         */
<span class="fc" id="L111">        public static class cl_value</span>
        {
<span class="fc" id="L113">            public int size = 0;</span>
            public cl_mem data;
            public cl_event event;
        }

        /**
         * This is the class responsible for representing NDConfiguration data.
         * Instances of this class lend their identity to utilize garbage collection
         * of the data that they reference via their &quot;cl_mem&quot; field.
         * Meaning this inner memory object &quot;cl_mem&quot; will
         * be freed via a call hook stored inside a Cleaner instance...
         */
<span class="fc" id="L125">        public static class cl_config</span>
        {
            public cl_mem data;
        }

<span class="fc" id="L130">        public int fp = 1;</span>
<span class="fc" id="L131">        public cl_config config = new cl_config();// Tensor configurations are always unique!</span>
        public cl_value value;

        @Override
        public void update( Tsr&lt;Number&gt; oldOwner, Tsr&lt;Number&gt; newOwner ) {
            // Update not needed....
<span class="fc" id="L137">        }</span>
    }

    /**
     *  This class manages reference to a so called &quot;ad hoc&quot; program &amp; kernel.
     *  Ad hoc is a Latin phrase meaning literally 'to this'.
     *  In English, it generally signifies a solution designed for a specific problem or task,
     *  non-generalizable, and not intended to be adapted to other purposes.
     *  This leads to the purpose of instances of this class, namely to hold the context to a unique kernel with
     *  a uniquely associated purpose which has been created by an operation possibly for specific
     *  tensor dimensions or possibly other properties...
     */
    private static class cl_ad_hoc
    {
        public String source;
        public cl_kernel kernel;
        public cl_program program;
    }

    /*==================================================================================================================
    |
    |       Â§(2) : FIELD VARIABLES
    |   ---------------------------
    */

<span class="fc" id="L162">    private final Map&lt;String, cl_ad_hoc&gt; _adhocKernels = new WeakHashMap&lt;&gt;();</span>
<span class="fc" id="L163">    private final cl_ad_hoc[] _adhocKernelRingBuffer = new cl_ad_hoc[ 128 ];</span>
<span class="fc" id="L164">    private int _ringIndex = 0;</span>

<span class="fc" id="L166">    private final Set&lt;Tsr&lt;Number&gt;&gt; _tensors = Collections.newSetFromMap( new WeakHashMap&lt;Tsr&lt;Number&gt;, Boolean&gt;() );</span>

<span class="fc" id="L168">    @Getter</span>
    private final cl_device_id _deviceId;

    /**
     *  The OpenCLPlatform :
     *  This method is a simple getter for the OpenCLPlatform instance hosting this current device.
     *  A platform would for example be vendor specific like Intel, AMD, Nvidia...
     *
     * @return The OpenCLPlatform instance representing the platform (amd, intel, nvidia) to which this device belongs.
     */
<span class="fc" id="L178">    @Getter</span>
    private final OpenCLPlatform _platform;

    /**
     * The OpenCL command queue
     */
    private final cl_command_queue _queue;


    /*==================================================================================================================
    |
    |       Â§(3) : CONSTRUCTION
    |   ---------------------------
    */

    /**
     * @param platform
     * @param deviceId
     */
    private OpenCLDevice( OpenCLPlatform platform, cl_device_id deviceId )
    {
<span class="fc" id="L199">        super();</span>
<span class="fc" id="L200">        _deviceId = deviceId;</span>
<span class="fc" id="L201">        _platform = platform;</span>
<span class="fc" id="L202">        _queue = clCreateCommandQueueWithProperties(// Create a command-queue for the selected device</span>
<span class="fc" id="L203">                platform.getContext(), deviceId,</span>
                null,
                null
        );
<span class="pc" id="L207">        _cleaning( this, () -&gt; clReleaseCommandQueue( _queue ) );</span>
        //Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {
        //    _mapping.forEach((k, v) -&gt; {
        //        if(v.value.event!=null) clWaitForEvents(1, new cl_event[]{v.value.event});
        //        clReleaseMemObject(v.config);
        //        clReleaseMemObject(v.value.data);
        //    });
        //    clReleaseCommandQueue(_queue);
        //    clReleaseContext(_context);
        //}));
<span class="fc" id="L217">    }</span>

    public boolean hasAdHocKernel( String name ) {
<span class="fc" id="L220">        return _adhocKernels.containsKey( name );</span>
    }

    public KernelCaller getAdHocKernel( String name ) {
<span class="fc" id="L224">        cl_ad_hoc adHoc = _adhocKernels.get( name );</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if ( adHoc != null ) return new KernelCaller( adHoc.kernel, _queue );</span>
<span class="nc" id="L226">        else return null;</span>
    }

    /**
     *  This method compiles so called &quot;ad hoc&quot; kernel.
     *  Ad hoc is a Latin phrase meaning literally 'to this'.
     *  In English, it generally signifies a solution designed for a specific problem or task,
     *  non-generalizable, and not intended to be adapted to other purposes.
     *  This leads to the purpose of ad hoc kernel compilation, namely to be able to compile
     *  unique kernels with a specific purpose created on the fly during runtime by operations.
     *  This might be useful for high performance operations on tensors with specific dimensions and
     *  or possibly other variables / properties which might be taken into account...
     *
     * @param name The name of the kernel which ought to be compiled.
     * @param source The source of the kernel which ought to be compiled.
     * @return This very instance in order to enable the factory pattern.
     */
    public synchronized OpenCLDevice compileAdHocKernel( String name, String source )
    {
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if ( this.hasAdHocKernel( name ) ) {</span>
<span class="fc" id="L246">            cl_ad_hoc adHoc = _adhocKernels.get( name );</span>
<span class="fc" id="L247">            String message = &quot;Cannot compile kernel source for name '&quot;+name+&quot;' because the name is already taken.\n&quot; +</span>
                    &quot;Use another name or find out why this kernel already exists.\n&quot; +
                    (
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">                            ( adHoc.source.equals( source ) )</span>
<span class="pc" id="L251">                                    ? &quot;Besides the name, the source code of the existing kernel is also identical.\n&quot; : &quot;&quot;</span>
                    );
<span class="fc" id="L253">            _log.error( message );</span>
<span class="fc" id="L254">            throw new IllegalArgumentException( message );</span>
        }

        // Create the program for the kernel
<span class="fc" id="L258">        cl_program cpProgram = clCreateProgramWithSource(</span>
<span class="fc" id="L259">                getPlatform().getContext(),</span>
                1,
                new String[]{source},
                null,
                null
        );

        // Build the program
<span class="fc" id="L267">        int err = clBuildProgram(</span>
                cpProgram,
                1,
                new cl_device_id[]{ _deviceId },
                &quot;-cl-mad-enable&quot;,
                null,
                null
        );
        //TODO: check compilation errors!
        cl_kernel kernel;
        try {
            // Create the kernel
<span class="fc" id="L279">            kernel = clCreateKernel(cpProgram, name, null);</span>
<span class="fc" id="L280">        } catch ( Exception e ) {</span>
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">            if ( e.getMessage().equals(&quot;CL_INVALID_KERNEL_NAME&quot;) &amp;&amp; !source.contains( &quot;__kernel void &quot; + name ) ) {</span>
<span class="fc" id="L282">                String message = &quot;Method 'clCreateKernel' failed! The name of the '__kernel' method declared inside \n&quot; +</span>
                        &quot;the source String does not match the provided name needed for kernel creation.&quot;;
<span class="fc" id="L284">                _log.error( message, e );</span>
<span class="fc" id="L285">                throw new IllegalArgumentException( message );</span>
            }
<span class="nc" id="L287">            _log.error( &quot;Method call 'clCreateKernel(.., name=\&quot;&quot;+name+&quot;\&quot;, ..)' failed!&quot;, e );</span>
<span class="nc" id="L288">            throw e;</span>
<span class="fc" id="L289">        }</span>
<span class="fc" id="L290">        cl_ad_hoc adHoc = new cl_ad_hoc();</span>
<span class="fc" id="L291">        adHoc.source = source;</span>
<span class="fc" id="L292">        adHoc.kernel = kernel;</span>
<span class="fc" id="L293">        adHoc.program = cpProgram;</span>
        // Storing the ad hoc object in a weak hash map for fast access by operations :
<span class="fc" id="L295">        _adhocKernels.put( name, adHoc );</span>
        // Storing the ad hoc object in a ring buffer to avoid immediate garbage collection :
<span class="fc" id="L297">        _ringIndex = ( _ringIndex + 1 ) % _adhocKernelRingBuffer.length;</span>

<span class="fc" id="L299">        _cleaning( adHoc, () -&gt; {</span>
<span class="fc" id="L300">            clReleaseKernel( kernel );</span>
<span class="fc" id="L301">            clReleaseProgram( cpProgram );</span>
<span class="fc" id="L302">        } );</span>
<span class="fc" id="L303">        return this;</span>
    }


    /**
     *  This method returns all the tensors stored on this
     *  OpenCLDevice instance as a Collection.
     *
     * @return A collection of all tensors currently stored on the device.
     */
    @Override
    public synchronized Collection&lt;Tsr&lt;Number&gt;&gt; getTensors() {
<span class="fc" id="L315">        Collection&lt;Collection&lt;Tsr&lt;Number&gt;&gt;&gt; collection = Collections.singleton( _tensors );</span>
<span class="fc" id="L316">        Collection&lt;Tsr&lt;Number&gt;&gt; extracted = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        collection.forEach( c -&gt; c.forEach( t -&gt; { if ( t != null ) extracted.add( t ); }));</span>
<span class="fc" id="L318">        return extracted;</span>
    }

    /**
     *  This method tells the to restore all tensors stored on it and release all resources.
     */
    @Override
    public void dispose() {
<span class="nc" id="L326">        _tensors.forEach( this::restore );</span>
<span class="nc" id="L327">        clFinish( _queue );</span>
<span class="nc" id="L328">    }</span>

    /**
     *  This method assumes that the passed tensor is stored on this device instance.
     *  If the tensor is stored on the device then the method loads the outsourced
     *  data of the tensor back into primitive JVM arrays and restores the tensor
     *  freshly in RAM.
     *
     * @param tensor The tensor whose data ought to be restored (loaded to RAM).
     * @return This device, which enables method chaining.
     */
    @Override
    public Device&lt;Number&gt; restore( Tsr&lt;Number&gt; tensor )
    {
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if ( !this.has( tensor ) ) {</span>
<span class="fc" id="L343">            String message = &quot;The passed tensor cannot be restored from this OpenCL device &quot; +</span>
                    &quot;because the tensor is not stored on the device.\n&quot;;
<span class="fc" id="L345">            _log.error( message );</span>
<span class="fc" id="L346">            throw new IllegalArgumentException( message );</span>
        }
<span class="fc bfc" id="L348" title="All 2 branches covered.">        double[] value = ( tensor.isVirtual() )</span>
<span class="fc" id="L349">                ? _value64f( tensor.find( cl_tsr.class ), 1, 0 )</span>
<span class="fc" id="L350">                : value64f( tensor );</span>
<span class="fc" id="L351">        free( tensor );</span>
<span class="fc" id="L352">        tensor.forComponent( Tsr.class, this::restore);</span>
<span class="fc" id="L353">        tensor.setValue( value );</span>
<span class="fc" id="L354">        return this;</span>
    }

    @Override
    public Device&lt;Number&gt; store( Tsr&lt;Number&gt; tensor ) {
<span class="fc" id="L359">        Tsr&lt;Number&gt; root = null;</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if ( tensor.has( Relation.class ) ) root = tensor.find( Relation.class ).findRootTensor();</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if ( root != null ) store( tensor, root );</span>
<span class="fc" id="L362">        else _add( tensor, null );</span>
<span class="fc" id="L363">        return this;</span>
    }

    @Override
    public Device&lt;Number&gt; store( Tsr&lt;Number&gt; tensor, Tsr&lt;Number&gt; parent ) {
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if ( !parent.isOutsourced() ) throw new IllegalStateException( &quot;Data parent is not outsourced!&quot; );</span>
<span class="fc" id="L369">        _add( tensor, parent.find( cl_tsr.class ) );</span>
<span class="fc" id="L370">        _tensors.add( tensor );</span>
<span class="fc" id="L371">        tensor.set( this );</span>
<span class="fc" id="L372">        return this;</span>
    }

    private void _add( Tsr&lt;Number&gt; tensor, cl_tsr parent )
    {
<span class="fc" id="L377">        cl_tsr newClt = new cl_tsr();</span>
        {
<span class="fc" id="L379">            final cl_mem clConfMem = newClt.config.data;</span>
<span class="pc" id="L380">            _cleaning( newClt.config, () -&gt; clReleaseMemObject( clConfMem ) );</span>
        }
        //VALUE TRANSFER:
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if ( parent == null ) {</span>
<span class="fc" id="L384">            newClt.value = new cl_tsr.cl_value();</span>
<span class="fc" id="L385">            _store( tensor, newClt, 1 );</span>
<span class="pc bpc" id="L386" title="1 of 4 branches missed.">            if ( tensor.rqsGradient() &amp;&amp; tensor.has( Tsr.class ) ) this.store( tensor.find( Tsr.class ) );</span>
            {
<span class="fc" id="L388">                final cl_mem clValMem = newClt.value.data;</span>
<span class="fc" id="L389">                cl_event clValEvent = newClt.value.event;</span>
<span class="fc" id="L390">                _cleaning( newClt.value, () -&gt; {</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                    if( clValEvent != null ) clWaitForEvents( 1, new cl_event[]{ clValEvent } );</span>
<span class="fc" id="L392">                    clReleaseMemObject( clValMem );//Removing value.. from device!</span>
<span class="fc" id="L393">                });</span>
<span class="fc" id="L394">            }</span>
        } else { // Tensor is a subset tensor of parent:
<span class="fc" id="L396">            newClt.fp = parent.fp;</span>
<span class="fc" id="L397">            newClt.value = parent.value;</span>
        }
        //CONFIG TRANSFER: &lt;[ shape | translation | idxmap | idx | scale ]&gt;
<span class="fc" id="L400">        int[] config = tensor.getNDConf().asInlineArray();</span>

        //SHAPE/TRANSLATION/IDXMAP/OFFSET/SPREAD TRANSFER:
<span class="fc" id="L403">        newClt.config.data = clCreateBuffer(</span>
<span class="fc" id="L404">                _platform.getContext(),</span>
                CL_MEM_READ_WRITE,
                config.length * Sizeof.cl_int,
                null, null
        );
<span class="fc" id="L409">        clEnqueueWriteBuffer(</span>
                _queue,
                newClt.config.data,
                CL_TRUE,
                0,
                config.length * Sizeof.cl_int,
<span class="fc" id="L415">                Pointer.to(config),</span>
                0,
                null,
                null
        );
        cl_mem[] memos;
<span class="fc" id="L421">        memos = new cl_mem[]{ newClt.value.data, newClt.config.data };</span>

<span class="fc" id="L423">        clEnqueueMigrateMemObjects(</span>
                _queue,
                memos.length,
                memos,
                CL_MIGRATE_MEM_OBJECT_HOST,
                0,
                null,
                null
        );

<span class="fc" id="L433">        _tensors.add( tensor );</span>

<span class="fc" id="L435">        tensor.set( newClt );</span>
<span class="fc" id="L436">        tensor.set( this );</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">        if ( tensor.isVirtual() ) {</span>
<span class="fc" id="L439">            double value = tensor.value64( 0 );</span>
<span class="fc" id="L440">            tensor.setIsOutsourced( true );</span>
<span class="fc" id="L441">            execute(</span>
                new ExecutionCall(
                        this,
<span class="fc" id="L444">                        new Tsr[]{ tensor, (Tsr) new Tsr( value ).set( this )},</span>
                        -1,
<span class="fc" id="L446">                        OperationType.instance( &quot;&lt;&quot; )</span>
                )
            );
<span class="fc" id="L449">        }</span>
<span class="fc" id="L450">        else tensor.setIsOutsourced( true );</span>

<span class="fc" id="L452">        tensor.toType( F32.class );</span>
<span class="fc" id="L453">    }</span>

    /**
     * This method checks if the passed tensor
     * is stored on this very OpenCLDevice instance.
     * &quot;Stored&quot; means that the data of the tensor is represented as
     * cl_mem objects which are referenced inside tensors as components...
     *
     * @param tensor The tensor in question.
     * @return The truth value of the fact that the provided tensor is on this device.
     */
    @Override
    public boolean has( Tsr&lt;Number&gt; tensor ) {
<span class="fc" id="L466">        return _tensors.contains( tensor );</span>
    }


    private void _store( Tsr&lt;Number&gt; tensor, cl_tsr newClTsr, int fp ) {
        Pointer p;
        int size;
        //if ( !tensor.isVirtual() ) {
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            if ( fp == 1 ) {</span>
<span class="fc" id="L475">                float[] data = tensor.value32();</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">                data = ( data == null ) ? new float[ tensor.size() ] : data;</span>
<span class="fc" id="L477">                p = Pointer.to(data);</span>
<span class="fc" id="L478">                size = data.length;</span>
<span class="fc" id="L479">            } else {</span>
<span class="nc" id="L480">                double[] data = tensor.value64();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">                data = ( data == null ) ? new double[ tensor.size() ] : data;</span>
<span class="nc" id="L482">                p = Pointer.to(data);</span>
<span class="nc" id="L483">                size = data.length;</span>
            }
        //}
<span class="fc" id="L486">        newClTsr.value.size = size;</span>
        //VALUE TRANSFER:
<span class="fc" id="L488">        cl_mem mem = clCreateBuffer(</span>
<span class="fc" id="L489">                _platform.getContext(),</span>
                CL_MEM_READ_WRITE,
                size * (long) Sizeof.cl_float * fp,
                null,
                null
        );
<span class="fc" id="L495">        newClTsr.value.data = mem;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if ( !tensor.isVirtual() ) {</span>
<span class="fc" id="L497">            clEnqueueWriteBuffer(</span>
                    _queue,
                    mem,
                    CL_TRUE,
                    0,
                    size * (long) Sizeof.cl_float * fp,
                    p,
                    0,
                    null,
                    null
            );
        }
<span class="fc" id="L509">    }</span>


    @Override
    public Device&lt;Number&gt; free( Tsr&lt;Number&gt; tensor ) {
<span class="fc" id="L514">        cl_tsr clt = tensor.find( cl_tsr.class );</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">        if ( clt == null ) return this;</span>
<span class="fc" id="L516">        _tensors.remove( tensor );</span>
<span class="fc" id="L517">        tensor.setIsOutsourced( false );</span>
<span class="fc" id="L518">        tensor.remove( cl_tsr.class );</span>
<span class="fc" id="L519">        return this;</span>
    }


    @Override
    public Device&lt;Number&gt; overwrite64( Tsr&lt;Number&gt; tensor, double[] value )
    {
<span class="fc" id="L526">        cl_tsr clt = tensor.find(cl_tsr.class);</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">        if ( clt.fp == 1 ) overwrite32( tensor, DataConverter.Utility.doubleToFloat( value ) );</span>
        else {
<span class="nc bnc" id="L529" title="All 2 branches missed.">            if( clt.value.event != null ) clWaitForEvents( 1, new cl_event[]{ clt.value.event } );</span>
<span class="nc" id="L530">            clt.value.event = new cl_event();</span>
<span class="nc" id="L531">            clEnqueueWriteBuffer(</span>
                    _queue,
                    clt.value.data,
                    CL_FALSE,
                    0,
                    Sizeof.cl_double * value.length,
<span class="nc" id="L537">                    Pointer.to( value ),</span>
                    0,
                    null,
                    clt.value.event
            );
        }
<span class="fc" id="L543">        return this;</span>
    }


    @Override
    public Device overwrite32( Tsr&lt;Number&gt; tensor, float[] value) {
<span class="fc" id="L549">        cl_tsr clt = tensor.find( cl_tsr.class );</span>
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">        if ( clt.fp == 1 ) {</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">            if ( clt.value.event != null ) clWaitForEvents( 1, new cl_event[]{ clt.value.event } );</span>
<span class="fc" id="L552">            clt.value.event = new cl_event();</span>
<span class="fc" id="L553">            clEnqueueWriteBuffer(</span>
                    _queue,
                    clt.value.data,
                    CL_TRUE,
                    0,
                    Sizeof.cl_float * value.length,
<span class="fc" id="L559">                    Pointer.to(value),</span>
                    0,
                    null,
                    clt.value.event
            );
        }
<span class="nc" id="L565">        else overwrite64( tensor, DataConverter.Utility.floatToDouble( value ) );</span>

<span class="fc" id="L567">        return this;</span>
    }

    @Override
    public Device swap(Tsr&lt;Number&gt; former, Tsr&lt;Number&gt; replacement)
    {
<span class="fc" id="L573">        cl_tsr clTsr = former.find( cl_tsr.class );</span>
<span class="fc" id="L574">        former.remove( cl_tsr.class );</span>
<span class="fc" id="L575">        replacement.set( clTsr );</span>
<span class="fc" id="L576">        _tensors.remove( former );</span>
<span class="fc" id="L577">        _tensors.add( replacement );</span>
<span class="fc" id="L578">        return this;</span>
    }

    @Override
    public double[] value64f( Tsr&lt;Number&gt; tensor ) {
<span class="fc" id="L583">        cl_tsr clt = tensor.find( cl_tsr.class );</span>
<span class="fc" id="L584">        return _value64f( clt, clt.value.size, 0 );</span>
    }

    private double[] _value64f( cl_tsr clt , int size, int offset )
    {
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if ( clt.fp == 1 ) return DataConverter.Utility.floatToDouble( _value32f( clt, size, offset ) );</span>
        else {
<span class="nc" id="L591">            double[] data = new double[ size ];</span>
<span class="nc" id="L592">            clEnqueueReadBuffer(</span>
                    _queue,
                    clt.value.data,
                    CL_TRUE,
                    offset * 8, // one double == eight byte
                    Sizeof.cl_double * data.length,
<span class="nc" id="L598">                    Pointer.to( data ),</span>
                    0,
                    null,
                    null
            );
<span class="nc" id="L603">            return data;</span>
        }
    }

    @Override
    public float[] value32f( Tsr&lt;Number&gt; tensor ) {
<span class="fc" id="L609">        cl_tsr clt = tensor.find( cl_tsr.class );</span>
<span class="fc" id="L610">        return _value32f( clt, clt.value.size, 0 );</span>
    }

    private float[] _value32f( cl_tsr clt, int size, int offset ) {
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">        if ( clt.fp == 1 ) {</span>
<span class="fc" id="L615">            float[] data = new float[ size ];</span>
<span class="fc" id="L616">            clEnqueueReadBuffer(</span>
                    _queue,
                    clt.value.data,
                    CL_TRUE,
                    offset * 4, // one float == four bytes !
                    (long) Sizeof.cl_float * data.length,
<span class="fc" id="L622">                    Pointer.to( data ),</span>
                    0,
                    null,
                    null
            );
<span class="fc" id="L627">            return data;</span>
        }
<span class="nc" id="L629">        else return DataConverter.Utility.doubleToFloat( _value64f( clt, size, offset ) );</span>
    }

    @Override
    public double value64f( Tsr&lt;Number&gt; tensor, int index ) {
<span class="fc" id="L634">        cl_tsr clt = tensor.find( cl_tsr.class );</span>
<span class="fc" id="L635">        return _value64f( clt, 1, index )[ 0 ];</span>
    }

    @Override
    public float value32f( Tsr&lt;Number&gt; tensor, int index ) {
<span class="fc" id="L640">        cl_tsr clt = tensor.find( cl_tsr.class );</span>
<span class="fc" id="L641">        return _value32f( clt, 1, index )[ 0 ];</span>
    }

    public KernelCaller getKernel( ExecutionCall call ) {
<span class="fc" id="L645">        String chosen = call.getImplementation().getName() + &quot;_&quot; + call.getOperation().getFunction();</span>
<span class="fc" id="L646">        cl_kernel kernel = _platform.getKernels().get( chosen );</span>
<span class="fc" id="L647">        return new KernelCaller( kernel, _queue );</span>
    }

    @Override
    protected void _execute( Tsr[] tensors, int d, OperationType type )
    {
<span class="fc" id="L653">        ExecutionCall&lt;OpenCLDevice&gt; call =</span>
                new ExecutionCall&lt;OpenCLDevice&gt;(
                        this,
                        tensors,
                        d,
                        type
                );
<span class="fc" id="L660">        tensors[ 0 ].setIsVirtual( false );</span>
<span class="fc" id="L661">        call.getImplementation().getExecutor( CLExecutor.class ).getExecution().run( call );</span>
<span class="fc" id="L662">    }</span>

    /*
    // The following are two potentially important methods for future features.

    private void _releaseEvents(Tsr[] tsrs) {
        for(Tsr&lt;Number&gt; t : tsrs) {
            if( t.find(cl_tsr.class).value.event != null ) {
                clReleaseEvent(t.find(cl_tsr.class).value.event);
                t.find(cl_tsr.class).value.event = null;
            }
        }
    }

    private cl_event[] _getWaitList(Tsr[] tsrs) {
        List&lt;cl_event&gt; list = new ArrayList&lt;&gt;();
        for (Tsr&lt;Number&gt; t : tsrs) {
            cl_event event = t.find(cl_tsr.class).value.event;
            if (event != null &amp;&amp; !list.contains(event)) {
                list.add(event);
            }
        }
        return list.toArray(new cl_event[ 0 ]);
    }
    */


    /*==================================================================================================================
    |
    |       Â§(4) : OPENCL PROPERTIES
    |   ---------------------------
    */

    public String name() {
<span class="fc" id="L696">        return DeviceQuery.getString( _deviceId, CL_DEVICE_NAME );</span>
    }

    public String vendor() {
<span class="fc" id="L700">        return DeviceQuery.getString( _deviceId, CL_DEVICE_VENDOR );</span>
    }

    public String version() {
<span class="fc" id="L704">        return DeviceQuery.getString( _deviceId, CL_DRIVER_VERSION );</span>
    }

    public String type() {
<span class="fc" id="L708">        long deviceType = DeviceQuery.getLong( _deviceId, CL_DEVICE_TYPE );</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_CPU) != 0 )</span>
<span class="nc" id="L710">            return &quot;CPU&quot;;</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_GPU) != 0 )</span>
<span class="fc" id="L712">            return &quot;GPU&quot;;</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_ACCELERATOR) != 0 )</span>
<span class="nc" id="L714">            return &quot;ACCELERATOR&quot;;</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">        if ( (deviceType &amp; CL_DEVICE_TYPE_DEFAULT) != 0 )</span>
<span class="nc" id="L716">            return &quot;DEFAULT&quot;;</span>
<span class="nc" id="L717">        return &quot;UNKNOWN&quot;;</span>
    }

    public int maxComputeUnits() {
<span class="nc" id="L721">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_MAX_COMPUTE_UNITS);</span>
    }

    public long maxWorkItemSimensions() {
<span class="nc" id="L725">        return DeviceQuery.getLong(_deviceId, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS);</span>
    }

    public long[] maxWorkItemSizes() {
<span class="nc" id="L729">        return DeviceQuery.getSizes(_deviceId, CL_DEVICE_MAX_WORK_ITEM_SIZES, 3);</span>
    }

    public long maxWorkGroupSize() {
<span class="fc" id="L733">        return DeviceQuery.getSize(_deviceId, CL_DEVICE_MAX_WORK_GROUP_SIZE);</span>
    }

    public long maxClockFrequenzy() {
<span class="fc" id="L737">        return DeviceQuery.getLong(_deviceId, CL_DEVICE_MAX_CLOCK_FREQUENCY);</span>
    }

    public int maxAddressBits() {
<span class="nc" id="L741">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_ADDRESS_BITS);</span>
    }

    public long maxMemAllocSize() {
<span class="nc" id="L745">        return DeviceQuery.getLong(_deviceId, CL_DEVICE_MAX_MEM_ALLOC_SIZE);</span>
    }

    public long globalMemSize() {
<span class="fc" id="L749">        return DeviceQuery.getLong(_deviceId, CL_DEVICE_GLOBAL_MEM_SIZE);</span>
    }

    public int errorCorrectionSupport() {
<span class="nc" id="L753">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_ERROR_CORRECTION_SUPPORT);</span>
    }

    public int localMemType() {
<span class="nc" id="L757">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_LOCAL_MEM_TYPE);</span>
    }

    public long localMemSize() {
<span class="nc" id="L761">        return DeviceQuery.getLong(_deviceId, CL_DEVICE_LOCAL_MEM_SIZE);</span>
    }

    public long maxConstantBufferSize() {
<span class="fc" id="L765">        return DeviceQuery.getLong(_deviceId, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE);</span>
    }

    public long maxConstantBufferSizeKB() {
<span class="nc" id="L769">        return (int) (DeviceQuery.getLong(_deviceId, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE) / 1024);</span>
    }
    /*
    public boolean queueExecIsOrdered() {
        long queueProperties = DeviceQuery.getLong(_did, CL_DEVICE_QUEUE_PROPERTIES);//Deprecation!
        return ((queueProperties &amp; CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE) != 0);
    }

    public boolean queueProfilingIsEnabled() {
        long queueProperties = DeviceQuery.getLong(_did, CL_DEVICE_QUEUE_PROPERTIES);
        return ((queueProperties &amp; CL_QUEUE_PROFILING_ENABLE) != 0);
    }
    */
    public int imageSupport() {
<span class="nc" id="L783">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_IMAGE_SUPPORT);</span>
    }

    public int maxReadImageArgs() {
<span class="nc" id="L787">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_MAX_READ_IMAGE_ARGS);</span>
    }

    public int maxWriteImageArgs() {
<span class="fc" id="L791">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_MAX_WRITE_IMAGE_ARGS);</span>
    }

    public long singleFPConfig() {
<span class="nc" id="L795">        return DeviceQuery.getLong(_deviceId, CL_DEVICE_SINGLE_FP_CONFIG);</span>
    }

    public long image2DMaxWidth() {
<span class="fc" id="L799">        return DeviceQuery.getSize(_deviceId, CL_DEVICE_IMAGE2D_MAX_WIDTH);</span>
    }

    public long image2DMaxHeight() {
<span class="fc" id="L803">        return DeviceQuery.getSize(_deviceId, CL_DEVICE_IMAGE2D_MAX_HEIGHT);</span>
    }

    public long image3DMaxWidth() {
<span class="fc" id="L807">        return DeviceQuery.getSize(_deviceId, CL_DEVICE_IMAGE3D_MAX_WIDTH);</span>
    }

    public long image3DMaxHeight() {
<span class="fc" id="L811">        return DeviceQuery.getSize(_deviceId, CL_DEVICE_IMAGE3D_MAX_HEIGHT);</span>
    }

    public long image3DMaxDepth() {
<span class="fc" id="L815">        return DeviceQuery.getSize(_deviceId, CL_DEVICE_IMAGE3D_MAX_DEPTH);</span>
    }

    public int prefVecWidthChar() {
<span class="fc" id="L819">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR);</span>
    }

    public int prefVecWidthShort() {
<span class="fc" id="L823">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT);</span>
    }

    public int prefVecWidthInt() {
<span class="fc" id="L827">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT);</span>
    }

    public int prefVecWidthLong() {
<span class="fc" id="L831">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG);</span>
    }

    public int prefVecWidthFloat() {
<span class="fc" id="L835">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT);</span>
    }

    public int prefVecWidthDouble() {
<span class="fc" id="L839">        return DeviceQuery.getInt(_deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE);</span>
    }

<span class="nc" id="L842">    public static class DeviceQuery</span>
    {
        /**
         *  Returns the value of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @return The value
         */
        public static int getInt(cl_device_id device, int paramName) {
<span class="fc" id="L852">            return getInts(device, paramName, 1)[ 0 ];</span>
        }

        /**
         *  Returns the values of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @param numValues The number of values
         * @return The value
         */
        public static int[] getInts(cl_device_id device, int paramName, int numValues) {
<span class="fc" id="L864">            int[] values = new int[numValues];</span>
<span class="fc" id="L865">            clGetDeviceInfo(device, paramName, (long)Sizeof.cl_int * numValues, Pointer.to(values), null);</span>
<span class="fc" id="L866">            return values;</span>
        }

        /**
         *  Returns the value of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @return The value
         */
        public static long getLong(cl_device_id device, int paramName) {
<span class="fc" id="L877">            return getLongs(device, paramName, 1)[ 0 ];</span>
        }

        /**
         *  Returns the values of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @param numValues The number of values
         * @return The value
         */
        public static long[] getLongs(cl_device_id device, int paramName, int numValues) {
<span class="fc" id="L889">            long[] values = new long[numValues];</span>
<span class="fc" id="L890">            clGetDeviceInfo(device, paramName, (long)Sizeof.cl_long * numValues, Pointer.to(values), null);</span>
<span class="fc" id="L891">            return values;</span>
        }

        /**
         *  Returns the value of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @return The value
         */
        public static String getString(cl_device_id device, int paramName) {
            // Obtain the length of the string that will be queried
<span class="fc" id="L903">            long[] size = new long[ 1 ];</span>
<span class="fc" id="L904">            clGetDeviceInfo(device, paramName, 0, null, size);</span>

            // Create a buffer of the appropriate size and fill it with the info
<span class="fc" id="L907">            byte[] buffer = new byte[(int) size[ 0 ]];</span>
<span class="fc" id="L908">            clGetDeviceInfo(device, paramName, buffer.length, Pointer.to(buffer), null);</span>

            // Create a string from the buffer (excluding the trailing \0 byte)
<span class="fc" id="L911">            return new String(buffer, 0, buffer.length - 1);</span>
        }

        /**
         *  Returns the value of the platform info parameter with the given name
         *
         * @param platform  The platform
         * @param paramName The parameter name
         * @return The value
         */
        public static String getString( cl_platform_id platform, int paramName ) {
            // Obtain the length of the string that will be queried
<span class="nc" id="L923">            long[] size = new long[ 1 ];</span>
<span class="nc" id="L924">            clGetPlatformInfo(platform, paramName, 0, null, size);</span>

            // Create a buffer of the appropriate size and fill it with the info
<span class="nc" id="L927">            byte[] buffer = new byte[ (int) size[ 0 ] ];</span>
<span class="nc" id="L928">            clGetPlatformInfo( platform, paramName, buffer.length, Pointer.to(buffer), null );</span>

            // Create a string from the buffer (excluding the trailing \0 byte)
<span class="nc" id="L931">            return new String( buffer, 0, buffer.length - 1 );</span>
        }

        /**
         *  Returns the value of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @return The value64
         */
        public static long getSize( cl_device_id device, int paramName ) {
<span class="fc" id="L942">            return getSizes( device, paramName, 1 )[ 0 ];</span>
        }

        /**
         *  Returns the values of the device info parameter with the given name
         *
         * @param device    The device
         * @param paramName The parameter name
         * @param numValues The number of values
         * @return The value64
         */
        public static long[] getSizes(cl_device_id device, int paramName, int numValues) {
            // The size of the returned data has to depend on
            // the size of a size_t, which is handled here
<span class="fc" id="L956">            ByteBuffer buffer = ByteBuffer.allocate( numValues * Sizeof.size_t ).order( ByteOrder.nativeOrder() );</span>
<span class="fc" id="L957">            clGetDeviceInfo(</span>
                    device,
                    paramName,
                    (long) Sizeof.size_t * numValues,
<span class="fc" id="L961">                    Pointer.to(buffer),</span>
                    null
            );
<span class="fc" id="L964">            long[] values = new long[ numValues ];</span>
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">            if ( Sizeof.size_t == 4 ) {</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                for ( int i = 0; i &lt; numValues; i++ ) {</span>
<span class="nc" id="L967">                    values[ i ] = buffer.getInt( i * Sizeof.size_t );</span>
                }
            } else {
<span class="fc bfc" id="L970" title="All 2 branches covered.">                for ( int i = 0; i &lt; numValues; i++ ) {</span>
<span class="fc" id="L971">                    values[ i ] = buffer.getLong( i * Sizeof.size_t );</span>
                }
            }
<span class="fc" id="L974">            return values;</span>
        }

    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>