<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DispatchUtility.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.devices.opencl.utility</a> &gt; <span class="el_source">DispatchUtility.java</span></div><h1>DispatchUtility.java</h1><pre class="source lang-java linenums">package neureka.devices.opencl.utility;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

<span class="pc bpc" id="L7" title="1 of 2 branches missed.">public final class DispatchUtility {</span>

    private DispatchUtility() {/* This is a utility class! */}

    private static void _revert( int[] array ) {
<span class="fc bfc" id="L12" title="All 2 branches covered.">        for( int i = 0; i &lt; array.length / 2; i++ )</span>
        {
<span class="fc" id="L14">            int temp = array[ i ];</span>
<span class="fc" id="L15">            array[ i ] = array[ array.length - i - 1 ];</span>
<span class="fc" id="L16">            array[ array.length - i - 1 ] = temp;</span>
        }
<span class="fc" id="L18">    }</span>

    private static int _productOf( int[] array ) {
<span class="fc" id="L21">        int product = 1;</span>
<span class="fc bfc" id="L22" title="All 2 branches covered.">        for ( int i : array ) product *= i;</span>
<span class="fc" id="L23">        return product;</span>
    }

    public static int[] parseTile( int size, int[] shape )
    {
<span class="fc" id="L28">        double root = Math.pow(size, 1/(double)shape.length);</span>
<span class="fc" id="L29">        int center = (int) root;</span>
<span class="fc" id="L30">        int[] current = new int[ shape.length ];</span>
<span class="fc" id="L31">        Arrays.fill( current, center );</span>
<span class="fc bfc" id="L32" title="All 2 branches covered.">        for ( int i = 0; i &lt; shape.length; i++ )</span>
<span class="pc bpc" id="L33" title="1 of 2 branches missed.">            if ( current[ i ] &gt; shape[ i ] ) current[ i ] = shape[ i ];</span>
<span class="fc" id="L34">        int[][] factors = new int[shape.length][];</span>
<span class="fc bfc" id="L35" title="All 2 branches covered.">        for ( int si = 0; si &lt; shape.length; si++ ) factors[si] = _primeFactors(shape[si]);</span>
<span class="fc" id="L36">        int[] indices = new int[ shape.length ];</span>
<span class="fc bfc" id="L37" title="All 2 branches covered.">        for ( int si = 0; si &lt; shape.length; si++ ) {</span>
<span class="fc" id="L38">            int fi = -1;</span>
<span class="fc" id="L39">            int product = 1;</span>
            do {
<span class="fc" id="L41">                fi++;</span>
<span class="fc" id="L42">                int previousDelta = Math.abs( current[ si ] - product );</span>
<span class="fc" id="L43">                product *= factors[ si ][ fi ];</span>
<span class="fc" id="L44">                int newDelta = Math.abs( current[ si ] - product );</span>
<span class="pc bpc" id="L45" title="1 of 4 branches missed.">                if ( product &gt; shape[ si ] || previousDelta &lt;= newDelta ) {</span>
<span class="fc" id="L46">                    product /= factors[ si ][ fi ];</span>
<span class="fc" id="L47">                    break;</span>
                }
            }
<span class="fc bfc" id="L50" title="All 2 branches covered.">            while( product &lt; current[ si ] );</span>

<span class="fc" id="L52">            int intermediateProduct = product;</span>
<span class="fc" id="L53">            int intermediateIndex = fi;</span>

            // Now the same in reverse :

<span class="fc" id="L57">            fi = factors[ si ].length;</span>
<span class="fc" id="L58">            product = 1;</span>
            do {
<span class="fc" id="L60">                fi--;</span>
<span class="fc" id="L61">                int previousDelta = Math.abs(current[ si ]-product);</span>
<span class="fc" id="L62">                product *= factors[ si ][ fi ];</span>
<span class="fc" id="L63">                int newDelta = Math.abs(current[ si ]-product);</span>
<span class="pc bpc" id="L64" title="1 of 4 branches missed.">                if ( product &gt; shape[ si ] || previousDelta &lt;= newDelta ) {</span>
<span class="fc" id="L65">                    product /= factors[ si ][ fi ];</span>
<span class="fc" id="L66">                    _revert( factors[ si ] );</span>
<span class="fc" id="L67">                    fi = factors[ si ].length - 1 - fi;</span>
<span class="fc" id="L68">                    break;</span>
                }
            }
<span class="fc bfc" id="L71" title="All 2 branches covered.">            while( product &lt; current[ si ] );</span>

<span class="fc" id="L73">            boolean firstWasBetter = (</span>
<span class="fc" id="L74">                    Math.abs(current[ si ]-intermediateProduct)</span>
                            &lt;
<span class="fc bfc" id="L76" title="All 2 branches covered.">                    Math.abs(Math.abs(current[ si ]-product))</span>
            );
<span class="fc bfc" id="L78" title="All 2 branches covered.">            current[ si ] = (firstWasBetter) ? intermediateProduct : product;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">            indices[ si ] = (firstWasBetter) ? intermediateIndex : fi;</span>
        }

        /*
           Setup done, we've got a basic set of tile dimensions
           which is close to a quadratic / cubic / ... dimensionality !
           Now let's try to find a product that fits our desired size better :
        */
<span class="fc" id="L87">        int totalProduct = _productOf( current );</span>
<span class="fc" id="L88">        int productDelta = Math.abs( size - totalProduct );</span>
        do {
<span class="fc" id="L90">            int bestIndex = -1;</span>
<span class="fc" id="L91">            int lowest = Integer.MAX_VALUE;</span>
<span class="fc" id="L92">            double bestRatio = 1.0;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">            for ( int i = 0; i &lt; shape.length; i++ )</span>
            {
<span class="fc bfc" id="L95" title="All 2 branches covered.">                int found = ( factors[ i ].length &gt; indices[ i ] + 1 )</span>
<span class="fc" id="L96">                                ? factors[ i ][ indices[ i ]+1 ]</span>
<span class="fc" id="L97">                                : Integer.MAX_VALUE ;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">                double ratio = (found == Integer.MAX_VALUE)</span>
<span class="fc" id="L99">                                    ? 1.0</span>
<span class="fc" id="L100">                                    : (double)current[ i ] / (double)shape[ i ];</span>
<span class="pc bpc" id="L101" title="1 of 8 branches missed.">                if (</span>
                        lowest == -1 ||
                        found &lt; lowest ||
                        found &lt;= lowest &amp;&amp; ratio &lt; bestRatio
                ) {
<span class="fc" id="L106">                    lowest = found;</span>
<span class="fc" id="L107">                    bestIndex = i;</span>
<span class="fc" id="L108">                    bestRatio = ratio;</span>
<span class="pc bpc" id="L109" title="2 of 4 branches missed.">                    assert indices[bestIndex] &gt; -1;</span>
                }
            }
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if ( bestIndex == -1 ) break; // nothing found :/</span>

<span class="fc" id="L114">            int newTotalProduct = _productOfNewDimension(</span>
                    current,
                    bestIndex,
                    lowest,
                    size
            );
<span class="fc" id="L120">            int newProductDelta = Math.abs(size-newTotalProduct);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if ( productDelta &gt; newProductDelta ) {</span>
<span class="fc" id="L122">                productDelta = newProductDelta;</span>
<span class="fc" id="L123">                current[bestIndex] *= factors[ bestIndex ][ indices[bestIndex]+1 ];</span>
            }
            else break;

<span class="fc" id="L127">        } while ( true );</span>

        // Maybe we went about some dimensions the wrong way...
        // Let's check if maybe could reverse product relations and get better configurations :

<span class="fc" id="L132">        totalProduct = _productOf( current );</span>
<span class="fc" id="L133">        productDelta = Math.abs(size-totalProduct);</span>
        do {
<span class="fc" id="L135">            int bestIndex = -1;</span>
<span class="fc" id="L136">            int bestInversionDelta = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            for ( int i=0; i&lt;shape.length; i++)</span>
            {
<span class="fc" id="L139">                int inversionDelta = _inversionProductOfNewDimension(</span>
                        shape, current, i, size
                );
<span class="fc bfc" id="L142" title="All 2 branches covered.">                if ( inversionDelta &lt; productDelta ) {</span>
<span class="fc" id="L143">                    bestIndex = i;</span>
<span class="fc" id="L144">                    bestInversionDelta = inversionDelta;</span>
                }
            }
<span class="fc bfc" id="L147" title="All 2 branches covered.">            if (bestIndex == -1 ) break; // nothing found :/</span>

<span class="fc" id="L149">            productDelta = bestInversionDelta;</span>
<span class="fc" id="L150">            current[bestIndex] = shape[bestIndex] / current[bestIndex];</span>

<span class="fc" id="L152">        } while ( true );</span>

<span class="fc" id="L154">        return current;</span>
    }


    private static int _productOfNewDimension(
            int[] current,
            int index,
            int alteration,
            int size
    ) {
<span class="fc" id="L164">        int[] copy = Arrays.copyOf(current, current.length);</span>
<span class="fc" id="L165">        copy[index] *= alteration;</span>
<span class="fc" id="L166">        int product = _productOf( copy );</span>
<span class="fc" id="L167">        return Math.abs(size-product);</span>
    }

    private static int _inversionProductOfNewDimension(
            int[] shape,
            int[] current,
            int index,
            int size
    ) {
<span class="fc" id="L176">        int[] copy = Arrays.copyOf(current, current.length);</span>
<span class="fc" id="L177">        copy[index] = shape[index] / copy[index];</span>
<span class="fc" id="L178">        int product = _productOf( copy );</span>
<span class="fc" id="L179">        return Math.abs(size-product);</span>
    }

    private static int[] _primeFactors(int n )
    {
<span class="fc" id="L184">        List&lt;Integer&gt; factors = new ArrayList&lt;&gt;();</span>

        // Print the number of 2s that divide n
<span class="fc bfc" id="L187" title="All 2 branches covered.">        while ( n % 2 == 0 ) {</span>
<span class="fc" id="L188">            factors.add( 2 );</span>
<span class="fc" id="L189">            n /= 2;</span>
        }

        // n must be odd at this point.  So we can
        // skip one element (Note i = i +2)
<span class="fc bfc" id="L194" title="All 2 branches covered.">        for ( int i = 3; i &lt;= Math.sqrt(n); i += 2 ) {</span>
            // While i divides n, print i and divide n
<span class="fc bfc" id="L196" title="All 2 branches covered.">            while ( n % i == 0 ) {</span>
<span class="fc" id="L197">                factors.add( i );</span>
<span class="fc" id="L198">                n /= i;</span>
            }
        }

        // This condition is to handle the case when
        // n is a prime number greater than 2
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if ( n &gt; 2 ) factors.add( n );</span>
<span class="fc" id="L205">        return factors.stream().mapToInt( p -&gt; p ).toArray();</span>
    }


    public static int[] findBestParams (
            int local_size,
            int reg_size,
            int com, int row, int col

    ) {
        // We know the global size :
        //[] global = new long[]{com, col};
        //=================
        // GOALS :
<span class="fc" id="L219">        int[] row_com_col = bestMatMulMatch(local_size, row, col, com);</span>
<span class="fc" id="L220">        int max_ts_row = row_com_col[ 0 ];//   = 128, // ts := tile size</span>
<span class="fc" id="L221">        int max_ts_col = row_com_col[ 2 ];//   = 128,</span>
<span class="fc" id="L222">        int max_ts_com = row_com_col[ 1 ];//   = 16,</span>

<span class="fc" id="L224">        int[] wpt_row_col = parseTile(reg_size, new int[]{max_ts_row, max_ts_col});</span>
<span class="fc" id="L225">        int max_wpt_row = wpt_row_col[ 0 ];//  = 8,   // wpt := work per thread</span>
<span class="fc" id="L226">        int max_wpt_col = wpt_row_col[ 1 ]; // = 8,</span>
        //---

<span class="fc" id="L229">        return new int[]{max_ts_row, max_ts_col, max_ts_com, max_wpt_row, max_wpt_col};</span>
    }


    public static int[] bestMatMulMatch(int size, int row, int col, int com)
    {
<span class="fc" id="L235">        int[] row_com = DispatchUtility.parseTile(size, new int[]{row, com});</span>
<span class="fc" id="L236">        int[] col_com = DispatchUtility.parseTile(size, new int[]{col, com});</span>

<span class="fc" id="L238">        int delta1 = Math.abs((row_com[ 0 ] * row_com[ 1 ] + row_com[ 0 ] * col_com[ 0 ])-size);</span>
<span class="fc" id="L239">        int delta2 = Math.abs((col_com[ 0 ] * col_com[ 1 ] + col_com[ 0 ] * row_com[ 0 ])-size);</span>

<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if ( delta1 &gt; delta2 ) return new int[]{ row_com[ 0 ], col_com[ 1 ], col_com[ 0 ] };</span>
<span class="fc" id="L242">        else return new int[]{ row_com[ 0 ], row_com[ 1 ], col_com[ 0 ] };</span>
    }



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>