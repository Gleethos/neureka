<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CLFunctionCompiler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.devices.opencl.utility</a> &gt; <span class="el_source">CLFunctionCompiler.java</span></div><h1>CLFunctionCompiler.java</h1><pre class="source lang-java linenums">package neureka.devices.opencl.utility;

import neureka.Neureka;
import neureka.Tsr;
import neureka.autograd.DefaultADAgent;
import neureka.backend.api.ExecutionCall;
import neureka.backend.api.Operation;
import neureka.backend.api.operations.OperationBuilder;
import neureka.backend.standard.algorithms.GenericAlgorithm;
import neureka.calculus.Function;
import neureka.calculus.assembly.FunctionBuilder;
import neureka.calculus.implementations.FunctionInput;
import neureka.calculus.implementations.FunctionVariable;
import neureka.devices.Device;
import neureka.devices.opencl.KernelCaller;
import neureka.devices.opencl.OpenCLDevice;
import neureka.dtype.DataType;
import neureka.dtype.NumericType;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class CLFunctionCompiler {

    private final OpenCLDevice _device;
    private final Function _functionToBeOptimized;
    private final String _functionName;
    private final int[] _argPointer;

<span class="fc" id="L32">    public CLFunctionCompiler( OpenCLDevice device, Function toBeOptimized, String functionName ) {</span>
<span class="fc" id="L33">        _device = device;</span>
<span class="fc" id="L34">        _functionToBeOptimized = toBeOptimized;</span>
<span class="fc" id="L35">        _functionName = functionName;</span>
<span class="fc" id="L36">        _argPointer = toBeOptimized.getAllFunctions()</span>
<span class="fc" id="L37">                                    .stream()</span>
<span class="fc" id="L38">                                    .filter( fun -&gt; fun instanceof FunctionInput )</span>
<span class="fc" id="L39">                                    .mapToInt( fun -&gt; ( (FunctionInput) fun ).index() )</span>
<span class="fc" id="L40">                                    .distinct()</span>
<span class="fc" id="L41">                                    .toArray();</span>
<span class="fc" id="L42">    }</span>


    public Operation optimize() {
<span class="fc" id="L46">        int numberOfArgs = _functionToBeOptimized.numberOfArgs();</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">        if ( _functionToBeOptimized.getSubFunctions().stream().anyMatch(fun -&gt; fun instanceof FunctionVariable ) )</span>
<span class="nc" id="L48">            numberOfArgs = -1; // The function is an indexer which means that it can have any number of arguments...</span>
<span class="fc" id="L49">        return new OperationBuilder()</span>
<span class="fc" id="L50">                .setFunction( _functionName )</span>
<span class="fc" id="L51">                .setOperator( _functionName )</span>
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">                .setArity( numberOfArgs )</span>
<span class="fc" id="L53">                .setIsIndexer( numberOfArgs &lt; 0 )</span>
<span class="fc" id="L54">                .setIsOperator( false )</span>
<span class="fc" id="L55">                .setIsDifferentiable( true )</span>
<span class="fc" id="L56">                .setIsInline( false )</span>
<span class="fc" id="L57">                .setStringifier(</span>
                        children -&gt; {
<span class="fc" id="L59">                            String expression = String.join( &quot;, &quot;, children );</span>
<span class="pc bpc" id="L60" title="3 of 4 branches missed.">                            if (expression.charAt(0) == '(' &amp;&amp; expression.charAt(expression.length() - 1) == ')') {</span>
<span class="nc" id="L61">                                return _functionName + expression;</span>
                            }
<span class="fc" id="L63">                            return _functionName + &quot;(&quot; + expression + &quot;)&quot;;</span>
                        }
                )
<span class="fc" id="L66">                .build()</span>
<span class="fc" id="L67">                .setAlgorithm(</span>
                        new GenericAlgorithm( &quot;generic_algorithm_for_&quot;+ _functionName)
<span class="fc" id="L69">                                .setIsSuitableFor( call -&gt; 1.0f )</span>
<span class="fc" id="L70">                                .setCanPerformBackwardADFor( call -&gt; true )</span>
<span class="fc" id="L71">                                .setCanPerformForwardADFor( call -&gt; false )</span>
<span class="fc" id="L72">                                .setSupplyADAgentFor(</span>
                                        (Function f, ExecutionCall&lt;? extends Device&lt;?&gt;&gt; call, boolean forward) -&gt; {
                                            // TODO: calculate derivative and supply agent!
<span class="nc" id="L75">                                            return new DefaultADAgent(null)</span>
<span class="nc" id="L76">                                                    .setForward((t, derivative) -&gt; new FunctionBuilder(Neureka.get().context()).build(f.toString(), false).derive(new Tsr[]{derivative}, 0))</span>
<span class="nc" id="L77">                                                    .setBackward((t, error) -&gt; new FunctionBuilder(Neureka.get().context()).build(f.toString(), false).derive(new Tsr[]{error}, 0));</span>
                                        }
                                )
<span class="fc" id="L80">                                .setHandleInsteadOfDevice( (caller, call) -&gt; null )</span>
<span class="fc" id="L81">                                .setHandleRecursivelyAccordingToArity( (call, goDeeperWith) -&gt; null )</span>
<span class="fc" id="L82">                                .setInstantiateNewTensorsForExecutionIn(</span>
                                        call -&gt; {
<span class="fc" id="L84">                                            Tsr&lt;?&gt;[] args = call.getTensors();</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">                                            if ( args[0] == null ) // Creating a new tensor:</span>
                                            {
<span class="fc" id="L87">                                                Tsr&lt;Double&gt; output = Tsr.of(args[1].getNDConf().shape(), 0.0);</span>
<span class="fc" id="L88">                                                output.setIsVirtual( false );</span>
<span class="fc" id="L89">                                                call.getDeviceFor(Double.class).store(output);</span>
<span class="fc" id="L90">                                                args[0] = output;</span>
                                            }
<span class="fc" id="L92">                                            return call;</span>
                                        }
                                )
<span class="fc" id="L95">                                .setImplementationFor(</span>
                                        OpenCLDevice.class,
                                        this::_adHocKernelFor
                                )
                );
    }


    private void _adHocKernelFor( ExecutionCall&lt;?&gt; call ) {

<span class="fc" id="L105">        List&lt;Tsr&lt;Number&gt;&gt; args = Arrays.stream( _argPointer )</span>
<span class="fc" id="L106">                                    .mapToObj( p -&gt; (Tsr&lt;Number&gt;) call.getTensors()[p+1] )</span>
<span class="fc" id="L107">                                    .collect(Collectors.toList());</span>

<span class="fc" id="L109">        args.add(0, call.getTsrOfType(Number.class, 0));</span>

<span class="fc" id="L111">        List&lt;String&gt; types = args.stream()</span>
<span class="fc" id="L112">                                    .map( CLFunctionCompiler::_clTypeOf )</span>
<span class="fc" id="L113">                                    .collect(Collectors.toList());</span>

<span class="fc" id="L115">        String kernelSignature =</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">                                _functionName + ( call.getDerivativeIndex() &gt;= 0 ? &quot;_derivative&quot; : &quot;&quot; ) +</span>
                                &quot;_&quot; +
<span class="fc" id="L118">                                        args.stream()</span>
<span class="fc" id="L119">                                                .map( arg -&gt;</span>
<span class="fc" id="L120">                                                        arg.getDataType().getTypeClass().getSimpleName() +</span>
                                                        &quot;$&quot; +
                                                        (
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">                                                            arg.getNDConf().isSimple()</span>
<span class="fc" id="L124">                                                            ? Arrays.stream( arg.getNDConf().shape() )</span>
<span class="pc" id="L125">                                                            : Arrays.stream( arg.getNDConf().asInlineArray() )</span>
                                                        )
<span class="fc" id="L127">                                                        .mapToObj( String::valueOf )</span>
<span class="fc" id="L128">                                                        .collect( Collectors.joining(&quot;x&quot;) )</span>
                                                )
<span class="fc" id="L130">                                    .collect(Collectors.joining(&quot;_&quot;));</span>

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if ( this._device.hasAdHocKernel( kernelSignature ) ) {</span>
<span class="nc" id="L133">            KernelCaller caller = _device.getAdHocKernel( kernelSignature );</span>
<span class="nc" id="L134">            args.forEach( caller::pass );</span>
<span class="nc" id="L135">            caller.call( args.get(0).size() );</span>
<span class="nc" id="L136">            return;</span>
        }
        // So no kernel with this signature was found...
        // Therefore we compile a new kernel specific to the provided call contents (shapes and types)!

<span class="fc" id="L141">        int rank = args.get(0).rank();</span>

<span class="fc" id="L143">        List&lt;List&lt;String&gt;&gt; configs = args.stream()</span>
<span class="fc" id="L144">                                            .map( arg -&gt; arg.getNDConf().asInlineArray() )</span>
<span class="fc" id="L145">                                            .map(</span>
                                                    array -&gt;
<span class="fc" id="L147">                                                            Arrays.stream(array)</span>
<span class="fc" id="L148">                                                                    .mapToObj( String::valueOf )</span>
<span class="fc" id="L149">                                                                    .collect(Collectors.toList())</span>
                                            )
<span class="fc" id="L151">                                            .collect(Collectors.toList());</span>

<span class="fc" id="L153">        String argString = IntStream.range( 0, args.size() )</span>
<span class="fc" id="L154">                                    .mapToObj( i -&gt; &quot;__global &quot;+types.get(i)+&quot;* arg&quot; + i )</span>
<span class="fc" id="L155">                                    .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        Function toBeCompiled = call.getDerivativeIndex() &lt; 0</span>
<span class="fc" id="L158">                                    ? _functionToBeOptimized</span>
<span class="pc" id="L159">                                    : _functionToBeOptimized.getDerivative( call.getDerivativeIndex() );</span>

<span class="fc" id="L161">        String compilableFun = IntStream.range( 0, _argPointer.length )</span>
<span class="fc" id="L162">                                        .mapToObj( String::valueOf )</span>
<span class="fc" id="L163">                                        .reduce(</span>
<span class="fc" id="L164">                                            toBeCompiled.toString(),</span>
                                             (source, index) -&gt;
<span class="fc" id="L166">                                                     source.replace(</span>
<span class="fc" id="L167">                                                             &quot;I[&quot;+_argPointer[Integer.parseInt(index)]+&quot;]&quot;,</span>
<span class="fc" id="L168">                                                             &quot;v&quot; + (Integer.parseInt(index) + 1)</span>
                                                     )
                                        );

<span class="fc" id="L172">        String kernelCode =</span>
                &quot;\n&quot; +
<span class="fc" id="L174">                    _readAndGetIndexMapper() +</span>
                &quot;\n&quot; +
                &quot;    __kernel void &quot; + kernelSignature + &quot;(\n&quot; +
                &quot;        &quot; + argString + &quot;\n&quot; +
                &quot;    ) {                                                                                     \n&quot; +
                &quot;        &quot; + IntStream
<span class="fc" id="L180">                                .range(0, configs.size())</span>
<span class="fc" id="L181">                                .mapToObj(</span>
<span class="fc" id="L182">                                    i -&gt; &quot;int cfg&quot;+i+&quot;[] = {&quot; + String.join( &quot;,&quot;, configs.get(i) ) + &quot;};&quot;</span>
                                )
<span class="fc" id="L184">                                .collect(Collectors.joining(&quot;\n        &quot;)) +</span>
                &quot;                                                                                          \n&quot; +
                &quot;        unsigned int i = get_global_id( 0 );                                              \n&quot; +
                &quot;        &quot; + IntStream
<span class="fc" id="L188">                                .range(1, args.size()) // We start at 1 because 0 is the output!</span>
<span class="fc" id="L189">                                .mapToObj(</span>
<span class="fc" id="L190">                                        i -&gt; types.get(i) + &quot; v&quot; + i + &quot; = arg&quot; + i + &quot;[_i_of_i(i, cfg&quot;+i+&quot;, &quot;+rank+&quot;)];&quot;</span>
                                )
<span class="fc" id="L192">                                .collect(Collectors.joining(&quot;\n        &quot;)) +</span>
                &quot;                                                                                          \n&quot; +
                &quot;        arg0[_i_of_i(i, cfg0, &quot;+rank+&quot;)] = &quot; + compilableFun + &quot;;                         \n&quot; +
                &quot;    }                                                                                     \n\n&quot;;

<span class="fc" id="L197">        _device.compileAdHocKernel( kernelSignature, kernelCode );</span>
<span class="fc" id="L198">        KernelCaller caller = _device.getAdHocKernel( kernelSignature );</span>
<span class="fc" id="L199">        args.forEach( caller::passRaw );</span>
<span class="fc" id="L200">        caller.call( args.get(0).size() );</span>
<span class="fc" id="L201">    }</span>

    private static String _clTypeOf( Tsr&lt;?&gt; tensor ) {
<span class="fc" id="L204">        DataType&lt;?&gt; dtype = tensor.getDataType();</span>
<span class="fc" id="L205">        java.util.function.Function&lt;Class&lt;?&gt;, String&gt; formatter = type -&gt; type.getSimpleName()</span>
<span class="fc" id="L206">                                                                                 .toLowerCase()</span>
<span class="fc" id="L207">                                                                                 .replace(&quot;integer&quot;, &quot;int&quot;);</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (dtype.typeClassImplements(NumericType.class) ) {</span>
<span class="fc" id="L209">            NumericType&lt;?,?,?,?&gt; instance = (NumericType&lt;?,?,?,?&gt;) dtype.getTypeClassInstance();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">            if ( instance.holderType() == instance.targetType() )</span>
<span class="fc" id="L211">                return formatter.apply(instance.holderType()); // Float, Double, Long, Short...</span>
            else // Unsigned types:
<span class="nc" id="L213">                return &quot;u&quot; + formatter.apply(instance.holderType());</span>
        }
<span class="nc" id="L215">        return formatter.apply(dtype.getTypeClass());</span>
    }

    /**
     *  This method simply reads the &quot;utility.cl&quot; resource to extract and
     *  return the &quot;_i_of_i&quot; method in the form of a simple {@link String}.
     *
     * @return The &quot;_i_of_i&quot; method from the &quot;utility.cl&quot; file.
     */
    private static String _readAndGetIndexMapper() {
<span class="fc" id="L225">        String resource = Neureka.get()</span>
<span class="fc" id="L226">                                    .utility()</span>
<span class="fc" id="L227">                                    .readResource(&quot;kernels/utility.cl&quot;);</span>
<span class="fc" id="L228">        return</span>
                &quot;    int _i_of_idx_on_tln&quot; +
                        resource
<span class="fc" id="L231">                                .split(&quot;int _i_of_idx_on_tln&quot;)[1]</span>
<span class="fc" id="L232">                                .split(&quot;// _i_of_idx_on_tln end!&quot;)[0] +</span>
               &quot;\n&quot; +
               &quot;    int _i_of_i&quot; +
                        resource
<span class="fc" id="L236">                                .split(&quot;int _i_of_i&quot;)[1]</span>
<span class="fc" id="L237">                                .split(&quot;// _i_of_i end!&quot;)[0];</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>