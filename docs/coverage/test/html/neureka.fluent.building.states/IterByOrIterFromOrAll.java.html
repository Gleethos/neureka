<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IterByOrIterFromOrAll.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.fluent.building.states</a> &gt; <span class="el_source">IterByOrIterFromOrAll.java</span></div><h1>IterByOrIterFromOrAll.java</h1><pre class="source lang-java linenums">package neureka.fluent.building.states;

import neureka.Tsr;
import neureka.ndim.Filler;

import java.util.Arrays;
import java.util.List;

public interface IterByOrIterFromOrAll&lt;V&gt;
{
    /**
     *  Provide an array of values which will be used to fill
     *  the {@link Tsr} instance returned by this last fluent builder method.
     *  If the configured tensor is larger than the number of provided
     *  elements, then they will simply be read multiple times until
     *  the result has been sufficiently populated.
     *
     * @param values The values which will be used to populate the {@link Tsr} instance returned by this method.
     * @return The final result of the fluent tensor builder API having a tensor filled with custom values.
     */
    Tsr&lt;V&gt; andFill( V... values );

    /**
     *  Provide a list of values which will be used to fill
     *  the {@link Tsr} instance returned by this last fluent builder method.
     *  If the configured tensor is larger than the number of provided
     *  elements, then they will simply be read multiple times until
     *  the result has been sufficiently populated.
     *
     * @param values The values which will be used to populate the {@link Tsr} instance returned by this method.
     * @return The final result of the fluent tensor builder API having a tensor filled with custom values.
     */
    default Tsr&lt;V&gt; andFill( List&lt;V&gt; values ) {
<span class="fc" id="L34">        return this.andFill((V[])values.toArray());</span>
    }


    /**
     *  Pass a lambda to this method which will be used to populate the {@link Tsr}
     *  built by this fluent builder API based on the indices of the tensor.
     *  The lambda will receive the absolute index ranging from 0 to {@link Tsr#size()}
     *  as well as an array of shape based nd-indices which can be used to
     *  initialize the underlying data of the {@link Tsr} more selectively.
     *
     * @param filler A data element provider lambda mapping the indices to custom values.
     * @return The resulting {@link Tsr} instance populated by the provided {@link Filler}.
     */
    Tsr&lt;V&gt; andWhere( Filler&lt;V&gt; filler );

    /**
     *  This part of the builder API allows for specifying a range which starts from the
     *  provided value and will end at the value specified in the next
     *  builder step returned by this method.
     *  If the number in the created range is not sufficiently large enough to
     *  fully populate the final {@link Tsr} instance built by this API, then the resulting
     *  range will fill the underlying data array of the tensor recurrently.
     *
     * @param index The start of the range which ought to supply the {@link Tsr} instance built by this API.
     * @return The next step in the builder method chain which expects to receive the end point of the range.
     */
    To&lt;V&gt; andFillFrom( V index );

    /**
     *  This method creates and return a {@link Tsr} instance which
     *  will be homogeneously filled by the the provided value irrespective
     *  of the previously defined shape.
     *
     * @param value The value which ought to populate the entire {@link Tsr}.
     * @return The homogeneously populated {@link Tsr} instance.
     */
    Tsr&lt;V&gt; all( V value );

    /**
     *  This method creates and return a {@link Tsr} instance which
     *  will be filled based on the provided seed object.
     *  The seed can be any object whose hash will serve as a basis for
     *  supplying the tensor with random data...
     *
     * @param seed The seed based on which the value for populating the entire {@link Tsr} will be generated.
     * @return The pseudo randomly populated {@link Tsr} instance.
     */
    Tsr&lt;V&gt; andSeed( Object seed );

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>