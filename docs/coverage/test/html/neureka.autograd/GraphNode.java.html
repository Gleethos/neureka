<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.autograd</a> &gt; <span class="el_source">GraphNode.java</span></div><h1>GraphNode.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    _____                 _     _   _           _
   / ____|               | |   | \ | |         | |
  | |  __ _ __ __ _ _ __ | |__ |  \| | ___   __| | ___
  | | |_ | '__/ _` | '_ \| '_ \| . ` |/ _ \ / _` |/ _ \
  | |__| | | | (_| | |_) | | | | |\  | (_) | (_| |  __/
   \_____|_|  \__,_| .__/|_| |_|_| \_|\___/ \__,_|\___|
                   | |
                   |_|

    This class defines the nodes which form the computation graph used to track operations performed on tensors,
    or more precisely :
    instances of the 'Tsr' class!

*/

package neureka.autograd;

import lombok.Getter;
import lombok.experimental.Accessors;
import neureka.Component;
import neureka.Neureka;
import neureka.Tsr;
import neureka.devices.Device;
import neureka.devices.opencl.utility.WeakTensorReference;
import neureka.calculus.Function;
import neureka.backend.api.ExecutionCall;

import java.lang.ref.WeakReference;
import java.util.*;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 *  Instances of this class are components of tensors.
 *  GraphNodes form a computation graph during runtime which is traversed during backpropagation.
 *  Both parent and child references are use for traversal.
 *  Parents are the GraphNodes of the tensors from which the tensor of the current node was formed,
 *  whereas children are the nodes (also) produced by said current node.
 *  Children are weakly referenced so that abandoned / detached
 *  graph branches (child nodes) can be garbage collected...
 *  ...whereas parents are strongly referenced in order to grant successful traversal.
 */
@Accessors( prefix = {&quot;_&quot;} )
public class GraphNode&lt;ValueType&gt; implements Component&lt;Tsr&lt;ValueType&gt;&gt;
{

    /**
     * mode state meaning:
     * -----------+----------------------------------+-
     * _mode == 0 |  no Auto-Differentiation         |
     * -----------+----------------------------------+-
     * _mode &gt; 0  |  forward Auto-Differentiation    |
     * -----------+----------------------------------+-
     * _mode &lt; 0  |  backward Auto-Differentiation   |
     * -----------+----------------------------------+-
     */
<span class="fc" id="L83">    @Getter</span>
    private int _mode;

    /**
     * This gradient node is involved in auto-differentiation.
     *
     * @return boolean
     */
    public boolean usesAD() {
<span class="fc bfc" id="L92" title="All 2 branches covered.">        return ( _mode != 0 );</span>
    }

    /**
     * This node propagates forward.
     *
     * @return boolean
     */
    public boolean usesForwardAD() {
<span class="fc bfc" id="L101" title="All 2 branches covered.">        return ( _mode &gt; 0 );</span>
    }

    /**
     * This node propagates _backward.
     *
     * @return boolean
     */
    public boolean usesReverseAD() {
<span class="fc bfc" id="L110" title="All 2 branches covered.">        return ( _mode &lt; 0 );</span>
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     *  This flag records the support evaluation of the forward-AD availability analysis
     *  done in the corresponding OperationTypeImplementation method
     *  for a given ExecutionCall instance.
     *
     *  The difference between this flag and the &quot;usesForwardAD()&quot; truth value
     *  is that the latter one can be false while the prior is true!
     *  ( However the reverse is not possible! )
     *  The reason is as follows:
     *  If a GraphNode has multiple parent nodes which require auto-differentiation,
     *  then said node will not be able to perform forward-AD even though it might very well
     *  be possible given an ExecutionCall whose state allows for such...
     */
    private boolean _allows_forward;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     *  This flag records the support evaluation of the backward-AD availability analysis
     *  done in the corresponding OperationTypeImplementation method
     *  for a given ExecutionCall instance.
     *
     *  The difference between this flag and the &quot;usesBackwardAD()&quot; truth value
     *  is that the latter one can be false while the prior is true!
     *  ( However the reverse is not possible! )
     *  The reason is as follows:
     *  If for example a GraphNode has only one parent node which require auto-differentiation,
     *  then said node will most likely perform backward-AD even though it might very well
     *  be possible given an ExecutionCall whose state allows for such...
     */
    private boolean _allows_backward;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * This flag is used for a performance optimization feature namely 'Just In Time Propagation'.
     * This feature accumulates errors and continues propagation
     * as soon as they are needed. (At the end of 'backward()' or when the tensor is used again).
     * If the flag Neureka.instance().settings().AutoDiff()._retainPendingErrorForJITProp is set to true
     * then error values will accumulate whenever it makes sense.
     * This technique however uses more memory but will
     * improve performance for some networks substantially.
     * &lt;p&gt;
     * All nodes between a Pending-Error and those requiring gradients will
     * be marked with '_relies_on_JIPProp=true'!
     */
<span class="fc" id="L161">    @Getter</span>
    private boolean _reliesOnJustInTimeProp = false;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * This method is called by the JITProp component.
     * A pending should only ever be retrieved from a GraphNode once because
     * afterwards the accumulated error is about to be backpropagated.
     * Therefore this method nulls the reference when returning the PendingError instance.
     * @return Returns an instance of the PendingError class containing a error accumulation.
     */
    public PendingError getAndRemovePendingError() {
<span class="fc" id="L174">        PendingError pe = _pendingError;</span>
<span class="fc" id="L175">        _pendingError = null;</span>
<span class="fc" id="L176">        return pe;</span>
    }

    /**
     * Used by the Just-In-Time back-prop component.
     */
<span class="pc" id="L182">    @Getter</span>
    private PendingError _pendingError = null;


    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * The chain-rule states that the derivative of f(x) = h(g(x)) with respect to x is: g'(x) * h'(g(x))
     * An example would be:
     * f(x) = ((x*y)*z)
     * f'(x) = (1*y) * (1*z) = z*y
     * The values z,y or z*y must not be deleted as they are needed for back-propagation!
     */
<span class="fc" id="L195">    @Getter</span>
    private boolean _isUsedAsDerivative = false;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * Recorded Function which produced this GrphNode.
     */
<span class="fc" id="L203">    @Getter</span>
    private Function _function;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * The GraphNodes of the input tensors. ('Parents' of the tensor of this node)
     * These are always the GraphNodes of the tensors from which the tensor payload of this
     * GraphNode has been formed.
     */
<span class="fc" id="L213">    @Getter</span>
    private GraphNode[] _parents;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * This is the tensor owning this GraphNode component.
     * It is referenced weakly because it might not be needed anymore (Not referenced inside AD-Agent for example)
     * and can therefore be garbage collected.
     */
    private WeakReference&lt;Tsr&lt;ValueType&gt;&gt; _payload;

    /**
     * The value of this graph node!
     * This node belongs to a tensor during creation.
     * The payload is referenced weakly and might be garbage collected.
     * When the tensor becomes phantom reachable the lambda defined
     * in this method will be executed.
     * It is stored inside the Cleaner within the device of the payload.
     * Cleaning means to null the targets_derivatives map.
     * Leaning however only occurs if the payload reference is still null.
     * If it is not null then this means that the payload
     * changed (happens during injection)
     *
     * @return the payload of this graph-node.
     */
    public Tsr&lt;ValueType&gt; getPayload() {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        return ( _payload == null ) ? null : _payload.get();</span>
    }

    private void _setPayload( Tsr&lt;ValueType&gt; p ) {
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if ( p == null ) _payload = null;</span>
        else {
<span class="fc" id="L246">            _payload = new WeakReference&lt;&gt;( p );</span>
<span class="fc" id="L247">            p.device().cleaning( p, () -&gt; {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                if (this.getPayload() == null) {</span>
<span class="fc" id="L249">                    boolean allChildrenUseForwardAD = true;</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">                    if ( _children != null ) {</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">                        for ( WeakReference&lt;GraphNode&gt; childRef : _children ) {</span>
<span class="fc" id="L252">                            GraphNode childNode = childRef.get();</span>
<span class="pc bpc" id="L253" title="1 of 4 branches missed.">                            if ( childNode != null &amp;&amp; childNode.usesReverseAD() ) allChildrenUseForwardAD = false;</span>
<span class="fc" id="L254">                        }</span>
                    }
<span class="fc bfc" id="L256" title="All 2 branches covered.">                    if ( allChildrenUseForwardAD ) _targets_derivatives = null;</span>
                }
<span class="fc" id="L258">            });</span>
        }
<span class="fc" id="L260">    }</span>

    @Override
    public void update( Tsr&lt;ValueType&gt; oldOwner, Tsr&lt;ValueType&gt; newOwner ) {
<span class="fc" id="L264">        _setPayload( newOwner );</span>
<span class="fc" id="L265">    }</span>

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     *  This variable holds a copy of the version of the payload tensor
     *  recorded when this GraphNode instance is instantiated.
     *  It must be treated as final and should never be modified.
     *  However it can be read freely in order to
     *  check that the version of the payload hasn't changed.
     */
<span class="fc" id="L276">    @Getter</span>
    private int _payloadReferenceVersion = -1;


    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * Keys are targets and values are gradients with respect to that target
     * Note: values can be null if the recorded function is of type 'reshape'!
     * Why? =&gt; because reshape operation does not need variables for _backward pass!
     */
    private TreeMap&lt;GraphNode&lt;ValueType&gt;, List&lt;ADAgent&gt;&gt; _targets_derivatives;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * &quot;Lock object&quot; for graph identity. (result caching)
     * Unique object which locks the payload to the current computation graph.
     *
     * @return GraphLock
     */
<span class="fc" id="L297">    @Getter</span>
    private GraphLock _lock;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     *  The children are GraphNode instances which represent computations
     *  performed on at least the payload of this very node.
     */
<span class="fc" id="L306">    @Getter</span>
    private List&lt;WeakReference&lt;GraphNode&gt;&gt; _children;

    /**
     * @param newChild which references it's input namely the parent (this) has...
     */
    private synchronized void _attachChild( GraphNode newChild ) {
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if ( _children == null ) _children = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L314">        WeakReference&lt;GraphNode&gt; ref = new WeakTensorReference&lt;&gt;( newChild, null );</span>
<span class="fc" id="L315">        _children.add( ref );</span>
<span class="fc" id="L316">    }</span>

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * @return long AbstractSurfaceNode-ID (Used for caching to avoid redundant computation within one computation graph)
     */
<span class="fc" id="L323">    @Getter</span>
    private long _nodeID = -1;

    /**
     * Some nodes are not cachable! Namely: leave tensors! They are not results of
     * any function operation.
     *
     * @return boolean
     */
    public boolean isCachable() {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        return ( this.getNodeID() != 1 );</span>
    }

    //==================================================================================================================

    /**
     * @param newLock The new lock of this GraphNode.
     */
    public synchronized void obtainLocking( GraphLock newLock ) {
<span class="fc" id="L342">        _lock = newLock;</span>
<span class="fc" id="L343">    }</span>

    /**
     * This node (and the corresponding tensor) was not created by a function! (it's a leave tensor)
     *
     * @return boolean
     */
    public boolean isLeave() {
<span class="pc bpc" id="L351" title="1 of 4 branches missed.">        return ( _parents == null &amp;&amp; _function == null );</span>
    }

    public boolean isGraphLeave() {
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if ( this.isLeave() ) return true;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">        for ( GraphNode p : _parents ) {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">            if ( p.getLock() != this.getLock() ) return true;</span>
        }
<span class="fc" id="L359">        return false;</span>
    }

    /**
     * @return if the tensor to which this graph node is attached has been deleted!
     */
    public boolean isVirtual() {
<span class="nc bnc" id="L366" title="All 2 branches missed.">        return getPayload() == null;</span>
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * @param function        Is the function that lead to the creation of this node.
     * @param context         Can be either an array of tensors or a new lock (for leave node or fresh function locking)
     * @param payloadSupplier Provides the payload of this node.
     */
    public GraphNode( Function function, Object context, Supplier&lt;Tsr&lt;ValueType&gt;&gt; payloadSupplier )
<span class="fc" id="L377">    {</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if ( function == null )</span>
<span class="fc" id="L379">            throw new IllegalArgumentException(</span>
                    &quot;Passed constructor argument of type Function must not be null!&quot;
            );
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if ( context instanceof GraphLock ) // Note function always null in this case:</span>
<span class="fc" id="L383">            _construct( payloadSupplier.get(), function, null, (GraphLock) context );</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        else if ( context instanceof ExecutionCall ) {</span>
<span class="fc" id="L385">            ExecutionCall call = (ExecutionCall) context;</span>
<span class="fc" id="L386">            Tsr&lt;ValueType&gt;[] inputs = call.getTensors();</span>
            /* Applying JITProp and gradients */
<span class="fc" id="L388">            Neureka.Settings.AutoGrad adSetting = Neureka.instance().settings().autograd();</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">            if ( adSetting.isApplyingGradientWhenTensorIsUsed() ) {</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">                for ( Tsr&lt;ValueType&gt; t : inputs ) {</span>
<span class="fc bfc" id="L391" title="All 4 branches covered.">                    if ( !adSetting.isApplyingGradientWhenRequested() || t.gradientApplyRqd() ) {</span>
<span class="fc" id="L392">                        t.applyGradient(); // activates JITProp if present and removes it...</span>
<span class="fc" id="L393">                        t.setGradientApplyRqd( false );</span>
                    }
                }
            }
<span class="fc" id="L397">            GraphLock foundLock = null;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L399">                GraphNode child = inputs[ i ].find( GraphNode.class );</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">                if ( child == null ) throw new IllegalStateException(</span>
                        &quot;Input tensor at index '&quot; + i + &quot;' did not return a GraphNode instance.&quot; +
                                &quot;Input tensors of a new GraphNode must be part of the computation graph!&quot;
                );
<span class="fc bfc" id="L404" title="All 2 branches covered.">                if ( foundLock == null ) foundLock = child.getLock();</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">                if ( foundLock != child.getLock() ) {</span>
<span class="fc" id="L406">                    throw new IllegalStateException(</span>
                            &quot;GraphNode instances found in input tensors do not share the same GraphLock instance.\n&quot; +
                                    &quot;The given input tensors of a new node must be part of the same locked computation graph!&quot;
                    );
                }
<span class="fc bfc" id="L411" title="All 4 branches covered.">                if ( !function.getOperation().isDifferentiable() &amp;&amp; child.usesAD() ) { // &amp;&amp; Math.abs(child.mode())&gt;1</span>
<span class="fc" id="L412">                    throw new IllegalStateException(</span>
<span class="fc" id="L413">                            &quot;Trying to apply inline operation '&quot; + function.getOperation().getFunction() + &quot;'\n&quot; +</span>
                            &quot;on active autograd computation graph in non detached function.\n&quot; +
<span class="fc" id="L415">                            &quot;Please use detached functions instead! ( 'Function.create(\&quot;&quot; + function.getOperation().getFunction() + &quot;(...)\&quot;, false)' )\n&quot;</span>
                    );
                }
            }
<span class="fc" id="L419">            _construct( payloadSupplier.get(), function, call, inputs[ 0 ].find( GraphNode.class ).getLock() );</span>
<span class="fc" id="L420">        } else {</span>
<span class="fc" id="L421">            throw new IllegalArgumentException(</span>
<span class="fc" id="L422">                    &quot;The passed context object for the GraphNode constructor is of type '&quot; + context.getClass().getName() + &quot;'.\n&quot; +</span>
                            &quot;A given context must either be a GraphLock instance or an ExecutionCall.&quot;
            );
        }
<span class="fc" id="L426">    }</span>

    /**
     * This method handles the construction of a GraphNode instance.
     *
     * @param output
     * @param function
     * @param call
     * @param lock
     */
    private void _construct(  Tsr&lt;ValueType&gt; output, Function function, ExecutionCall&lt;Device&gt; call, GraphLock lock )
    {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        Tsr&lt;Object&gt;[] inputs = ( call == null ) ? null : call.getTensors();</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">        if ( output == null ) throw new NullPointerException( &quot;The supplied payload Tsr must no be null!&quot; );</span>
<span class="fc" id="L440">        _payloadReferenceVersion = output.getVersion();</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">        if ( !function.isDoingAD() ) return; // Only functions with AutoDiff enabled create computation graph!</span>
<span class="fc" id="L442">        _lock = lock;</span>
<span class="fc" id="L443">        _setPayload( output );</span>
<span class="fc" id="L444">        output.set( this );</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if ( inputs == null ) {</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">            _mode = ( output.rqsGradient() ) ? 1 : 0;</span>
<span class="fc" id="L447">            _function = null;</span>
<span class="fc" id="L448">            _parents = null;</span>
        } else {
<span class="fc" id="L450">            _mode = _modeOf( call, function );</span>
<span class="fc" id="L451">            _function = function;</span>
<span class="fc" id="L452">            _parents = new GraphNode[inputs.length];</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">            for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L454">                _parents[ i ] = inputs[ i ].find( GraphNode.class );</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                if ( _parents[ i ] == null ) {</span>
<span class="nc" id="L456">                    throw new IllegalStateException(</span>
                            &quot;Input tensors of a new graph-node must contain leave graph-nodes!&quot;
                    );
<span class="fc" id="L459">                } else _parents[ i ]._attachChild(this);</span>
            }
        }
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        if ( _nodeID == -1 ) {</span>
<span class="fc" id="L463">            long nid = 1;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">            if ( _parents != null ) {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">                for ( GraphNode&lt;ValueType&gt; n : _parents )</span>
<span class="fc" id="L466">                    nid *= n.getPayload().hashCode(); //payload might be 0! Why? -&gt; garbage collected!</span>
            }
<span class="fc bfc" id="L468" title="All 2 branches covered.">            if ( _function != null ) nid += _function.hashCode();</span>
<span class="fc" id="L469">            _nodeID = nid;</span>
        }
        /* Returning if the above cannot form an AutoDiff computation graph! : */
<span class="fc bfc" id="L472" title="All 4 branches covered.">        if ( inputs == null || !function.isFlat() ) return; // Leave nodes have!</span>
<span class="fc bfc" id="L473" title="All 4 branches covered.">        for ( Tsr&lt;Object&gt; t : inputs ) if ( t.equals(output) ) return; // Output must be a unique tensor for AD!</span>

<span class="pc bpc" id="L475" title="1 of 4 branches missed.">        if ( this.usesAD() &amp;&amp; function.isFlat() ) {</span>
            /* Preparing for back propagation: */
<span class="fc bfc" id="L477" title="All 2 branches covered.">            if ( this.usesForwardAD() ) {</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">                for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L479">                    GraphNode&lt;ValueType&gt; srcNode = inputs[ i ].find( GraphNode.class );</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                    if ( srcNode.usesAD() ) {</span>
<span class="fc" id="L481">                        if (</span>
<span class="pc bpc" id="L482" title="1 of 4 branches missed.">                                srcNode.size() == 0 &amp;&amp; this.size() == 0</span>
                                    ||// Sources created by for example dot/mm or x-mul are reverse-mode cases!
<span class="pc bpc" id="L484" title="1 of 4 branches missed.">                                !srcNode.isLeave() &amp;&amp; !srcNode._allows_forward</span>
                        ) {
<span class="fc" id="L486">                            this.put(</span>
                                    srcNode,
<span class="fc" id="L488">                                    call.getADAgentFrom(</span>
                                            function,
                                            new ExecutionCall&lt;&gt;(
<span class="fc" id="L491">                                                    call.getDevice(),</span>
<span class="fc" id="L492">                                                    call.getTensors(),</span>
                                                    i,
<span class="fc" id="L494">                                                    call.getJ(),</span>
<span class="fc" id="L495">                                                    call.getOperation()</span>
                                            ),
                                            true
                                    )
                            );
                        } else {
                            /*  Chain rule (forward) for every derivative w.r.t. leaves (reverseAD or user leaves): */
<span class="fc" id="L502">                            int finalI = i;</span>
<span class="fc" id="L503">                            Tsr&lt;ValueType&gt; localDerivative = (Tsr&lt;ValueType&gt;) function.derive( inputs, i );</span>
<span class="fc" id="L504">                            srcNode.forEachTargetAgentPair(</span>
                                ( targetNode, localAgent ) -&gt;
                                {
                                    // The agent multiplies the local derivative with its stored partial derivative...
<span class="fc" id="L508">                                    Tsr&lt;?&gt; targetDerivative = localAgent.forward( this, localDerivative );</span>
                                    // ...this is now the new partial derivative with respect to the target node!
<span class="fc" id="L510">                                    this.put(</span>
                                            targetNode,
<span class="fc" id="L512">                                            call.getADAgentFrom(</span>
                                                    function,
                                                    new ExecutionCall&lt;&gt;(
<span class="fc" id="L515">                                                            call.getDevice(),</span>
<span class="fc" id="L516">                                                            call.getTensors(),</span>
                                                            finalI,
<span class="fc" id="L518">                                                            call.getJ(),</span>
<span class="fc" id="L519">                                                            call.getOperation()</span>
                                                    )
<span class="fc" id="L521">                                                    .putAt( &quot;derivative&quot;,targetDerivative ),</span>
                                                    true
                                            )
                                    );
                                    // TODO: flag within src Tsr&lt;ValueType&gt;s that grant that the tensor
                                    // has been created by function constructor!
<span class="fc" id="L527">                                }</span>
                            );
                        }
                    }
                }
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">            } else if ( this.usesReverseAD() ) {</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">                for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L534">                    GraphNode&lt;ValueType&gt; srcNode = inputs[ i ].find( GraphNode.class );</span>
<span class="pc bpc" id="L535" title="1 of 4 branches missed.">                    if ( srcNode.usesAD() || inputs[ i ].rqsGradient() ) {</span>
<span class="fc" id="L536">                        this.put(</span>
                                srcNode,
<span class="fc" id="L538">                                call.getADAgentFrom(</span>
                                        function,
                                        new ExecutionCall&lt;&gt;(
<span class="fc" id="L541">                                                call.getDevice(),</span>
<span class="fc" id="L542">                                                call.getTensors(),</span>
                                                i,
<span class="fc" id="L544">                                                call.getJ(),</span>
<span class="fc" id="L545">                                                call.getOperation()</span>
                                        ),
                                        false
                                )
                        );
                    }
                }
            }
        }
<span class="fc" id="L554">    }</span>

    /**
     * Evaluate auto-grad/auto-differentiation mode:
     * A positive value means that the AD-procedure will be forward mode AD,
     * whereas a negative value is backward mode AD.
     * If the resulting mode equals 0 then this means that
     * no auto differentiation is needed.
     *
     * @param call The call containing inputs for the function which created the payload tensor of this GraphNode.
     * @param function The function which produced the payload tensor of this GraphNode.
     * @return int The mode of this GraphNode! ( m&lt;0 : backward-AD, m&gt;0 : forward-AD, m=0 : no-AD )
     */
    private int _modeOf( ExecutionCall&lt;Device&gt; call, Function function )
    {
<span class="fc" id="L569">        Tsr&lt;ValueType&gt;[] inputs = call.getTensors();</span>
<span class="fc" id="L570">        int resultMode = 0;</span>
<span class="fc" id="L571">        int[] modes = new int[inputs.length];</span>
<span class="fc" id="L572">        int inputMode = 0;</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">        for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L574">            GraphNode node = inputs[ i ].find( GraphNode.class ); // Not null checked in constructor!</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            modes[ i ] = ( inputs[ i ].rqsGradient() ) ? 1 : node.getMode();</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">            inputMode += ( modes[ i ] != 0) ? 1 : 0;</span>
        }
<span class="fc" id="L578">        _allows_forward = call.allowsForward();</span>
<span class="fc" id="L579">        _allows_backward = call.allowsBackward();</span>
<span class="fc bfc" id="L580" title="All 4 branches covered.">        if ( inputMode == 1 &amp;&amp; _allows_forward ) { // Convolution and reshaping prohibit forward AutoDiff</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">            for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc bfc" id="L582" title="All 4 branches covered.">                resultMode += ( modes[ i ] == 0 ) ? 0 : ( modes[ i ] &lt; 0 ) ? 1 : modes[ i ] + 1;</span>
            }
        } // Reverse mode auto-differentiation :
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">        else if ( _allows_backward ) resultMode = -inputMode;</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">        if ( !function.getOperation().isDifferentiable() ) resultMode = 0;</span>
<span class="fc" id="L587">        return resultMode;</span>
    }

    /**
     * This short method simply migrates the error to the device of
     * the payload tensor and possibly also applies the error to
     * the payload if its 'requires gradient' flag is set to true.
     *
     * @param e This is an error value passed to this method ba a backward traversal.
     */
    private void _migrateAndOrApplyError( Tsr&lt;ValueType&gt; e, Consumer&lt;Tsr&lt;ValueType&gt;&gt; also ) {
<span class="fc" id="L598">        Tsr&lt;ValueType&gt; payload = getPayload();</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">        if ( payload == null ) return; // Garbage collected!</span>
        try {
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (payload.isOutsourced()) payload.device().store(e);</span>
<span class="nc" id="L602">        } catch ( Exception exception ) {</span>
<span class="nc" id="L603">            exception.printStackTrace();</span>
<span class="fc" id="L604">        }</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">        if ( payload.rqsGradient() ) payload.addToGradient(e);</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">        if ( also!=null ) also.accept(payload);</span>
<span class="fc" id="L607">    }</span>


    /**
     * This method is the entry-point for the back-propagation process.
     * It sets up a key/value map which stores nodes and their intermediate error accumulations.
     * Accumulations occurs inside the private '_backward' method which traverses the computation graph
     * recursively, halts when errors can be accumulated, adds a PendingError and returns to the method below!
     * Here all the nodes and error values will then be carried (propagated) to the gradients!
     *
     * @param error The current error which is created by multiplying it with current size and traversing it.
     */
    public void backward( Tsr&lt;ValueType&gt; error ) {
<span class="fc" id="L620">        Set&lt;GraphNode&gt; pendingNodes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L621">        _backward( error, pendingNodes, false ); // Entry-point to private recursive back-propagation!</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        if ( Neureka.instance().settings().autograd().isRetainingPendingErrorForJITProp() ) {</span>
<span class="fc" id="L623">            pendingNodes.forEach( n -&gt; n._carryPendingBackPropToGradients( pendingNodes ) );</span>
        } else {
<span class="fc" id="L625">            pendingNodes.forEach( n -&gt; {</span>
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">                if ( !n._pendingError.isFullyAccumulated() )</span>
<span class="nc" id="L627">                    throw new IllegalStateException(&quot;Pending error has not received expected accumulation.&quot;);</span>
<span class="fc" id="L628">                n.backward( n._pendingError.getAccumulatedError() ); // Continue back-propagation recursively!</span>
<span class="fc" id="L629">            });</span>
        }
<span class="fc" id="L631">        _deleteDerivativesRecursively(); // Cleanup after back-propagation!</span>
<span class="fc" id="L632">    }</span>

    /**
     * This method traverses the computation graph and applies errors to gradients.
     * Errors might be accumulated temporarily or possibly longer for 'Just In Time propagation'.
     * JITProp is enabled in the global Neureka class.
     * It will traverse the path between a pending error and a tensor (rqsGradient==true)
     * containing the JITProp component which is triggered as soon as new gradients are needed or requested (applied).
     * This traverse however does not occur through the method below.
     * Instead the 'backwardJIT' method is called by the JITProp component if present.
     * Intermediate error accumulations are stored in the '_pending_error' variable.
     * The method halts when an error can be accumulated and returns.
     * This graph node however is not forgotten but being noted in the 'pendingNodes' Set.
     *
     * @param error A tensor which traverses the computation graph according to the rules of reverse mode AutoDiff.
     */
    private void _backward( Tsr&lt;ValueType&gt; error, Set&lt;GraphNode&gt; pendingNodes, boolean allowPendingError )
    {
<span class="fc" id="L650">        _migrateAndOrApplyError( error, null );</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">        if ( this.usesAD() ) {</span>
            /* Checking JIT-Prop conditions and create Pending error if possible */
<span class="fc bfc" id="L653" title="All 4 branches covered.">            if ( allowPendingError &amp;&amp; !this.isLeave() ) {//==&gt; We are NOT inside a 'Just-In-Time-Backprop' process (new pending error can be created)</span>
<span class="fc" id="L654">                int numOfADPaths = _numberOfReverseModeADChildren();// Multiple children triggers creation of a pending error</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">                if ( numOfADPaths &gt; 1 ) {</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">                    if ( _pendingError == null ) {</span>
<span class="fc" id="L657">                        _pendingError = new PendingError( error, numOfADPaths - 1 );</span>
<span class="fc" id="L658">                        pendingNodes.add( this );</span>
<span class="fc" id="L659">                    } else _pendingError.accumulate( error );</span>
<span class="fc" id="L660">                    return;</span>
                    /* Backprop will be continued later! This node is being remembered in 'PendingError'
                       NOTE: Multiple AutoDiff paths leading to one node in history will be accumulated first! (performance)
                             This optimization is a light version of JITProp. JITProp builds on this!
                    */
                }
            }
            // The following call ADAgents for reverse-mode AutoDiff!
<span class="fc" id="L668">            this.forEachBackward( error, ( t, e ) -&gt; t._backward( e, pendingNodes, true ) );</span>
            // Standard reverse mode-AutoDiff!
        }
<span class="fc" id="L671">    }</span>

    /**
     * This method is called only if JIT-propagation is enabled.
     * It carries pending errors to the tensors requiring gradients which will
     * later on be processed just in time.
     * The path is being marked with '_relies_on_JITProp' so that intermediate size will
     * not be deleted.
     *
     * @param pendingBackProp
     */
    private void _carryPendingBackPropToGradients( Set&lt;GraphNode&lt;ValueType&gt;&gt; pendingBackProp ) {
<span class="fc" id="L683">        _reliesOnJustInTimeProp = true; //:=&gt; Shall be traversed at a later point in time...</span>
<span class="fc" id="L684">        this.forEachTarget( t -&gt; t._carryPendingBackPropToGradients( pendingBackProp ) );</span>
<span class="pc bpc" id="L685" title="1 of 4 branches missed.">        if ( this.isLeave() &amp;&amp; getPayload().rqsGradient() ) {</span>
<span class="fc" id="L686">            JITProp&lt;ValueType&gt; jit = getPayload().find( JITProp.class );</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">            if ( jit == null ) jit = new JITProp&lt;&gt;( pendingBackProp );</span>
<span class="nc" id="L688">            else jit.addPending( pendingBackProp );</span>
<span class="fc" id="L689">            getPayload().set( jit );</span>
        }
<span class="fc" id="L691">    }</span>

    /**
     * This method is called only when JITProp is active.
     * If an error has accumulated inside a JITProp component and
     * the component is triggered to continue pending backward calls
     * then this happens through this method.
     * The node from where the pending error stems from
     * is being passed down the graph (back in 'time')
     * in order to mark this error source as 'done'
     * so that other JITProp components do not propagate
     * this 'source' node multiple times.
     *
     * @param error
     */
    public void backwardJIT(Tsr&lt;ValueType&gt; error) {
<span class="fc" id="L707">        _backwardJIT( error, this );</span>
<span class="fc" id="L708">        _deleteDerivativesRecursively();// Cleanup after back-propagation!</span>
<span class="fc" id="L709">    }</span>

    private void _backwardJIT(Tsr&lt;ValueType&gt; error, GraphNode&lt;ValueType&gt; source) {
<span class="fc" id="L712">        _reliesOnJustInTimeProp = false; // JITProp is currently being handled in this method. Afterwards it is not relying on it anymore!</span>
<span class="fc" id="L713">        _migrateAndOrApplyError( error, payload -&gt; {</span>
<span class="fc" id="L714">            JITProp&lt;ValueType&gt; jit = payload.find( JITProp.class );//Get JIT-Prop node.</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">            if ( jit != null ) {</span>
<span class="fc" id="L716">                jit.noteFinished( source );//note pending errors and store them as 'done'</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">                if ( jit.isDone() ) payload.remove( JITProp.class );</span>
            }
<span class="fc" id="L719">        });</span>
<span class="pc bpc" id="L720" title="3 of 4 branches missed.">        if ( _pendingError != null &amp;&amp; source != this ) {</span>
<span class="nc" id="L721">            _pendingError.accumulate( error );</span>
            /*
              A pending error has been found, so this means that this node
              is referenced by one or more JIT-Prop components.
              If among these components is the one that issued this very
              traverse we are in at this moment, then this pending error at this node will later on
              be continued to be propagated.
              Otherwise it makes sense to accumulate errors further and wait for JIT-Prop traversing!
             */
<span class="nc" id="L730">            return;// This node will continue its propagation via a JIT-Prop component later!</span>
        }
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">        if ( this.usesAD() ) {</span>
            // The following call ADAgents for reverse-mode AutoDiff!
<span class="fc" id="L734">            this.forEachBackward( error, ( t, e ) -&gt; t._backwardJIT( e, source ) );</span>
            // JITProp reverse mode-AutoDiff!
        }
<span class="fc" id="L737">    }</span>

    /**
     * This method is called after the backward call has been executed fully.
     * Derivatives are no longer used and will therefore be deleted when possible.
     * Deletion is forbidden if this node is flagged
     * as JITProp job. This means that the node is on the path between gradients
     * and pending error objects.
     * Only if JITProp is enabled (Neureka.instance().settings().autograd()...) this flag will
     * deviate from its default state, namely: true!
     */
    private void _deleteDerivativesRecursively() {
<span class="fc bfc" id="L749" title="All 2 branches covered.">        if ( !Neureka.instance().settings().debug().isKeepingDerivativeTargetPayloads() ) { // &lt;=- This flag is almost always false. (Used for testing)</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">            if ( !this.isReliesOnJustInTimeProp() ) _targets_derivatives = null;</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">            if ( !this.isGraphLeave() ) forEachTarget( GraphNode::_deleteDerivativesRecursively );</span>
        }
<span class="fc" id="L753">    }</span>

    /**
     * Counts how many child nodes will later on provide error values for back-propagation!
     *
     * @return The number of child nodes using reverse-mode auto-differentiation.
     */
    private int _numberOfReverseModeADChildren() {
<span class="fc" id="L761">        int count = 0;</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">        if ( _children != null ) {</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">            for ( WeakReference&lt;GraphNode&gt; weak : _children ) {</span>
<span class="pc bpc" id="L764" title="2 of 4 branches missed.">                if ( weak != null &amp;&amp; weak.get() != null ) {</span>
<span class="fc" id="L765">                    GraphNode child = weak.get(); // TODO: make test which asserts that Detached Function does not trigger this!</span>
<span class="pc bpc" id="L766" title="1 of 4 branches missed.">                    if ( child!=null &amp;&amp; child.usesReverseAD() ) count++;</span>
                }
<span class="fc" id="L768">            }</span>
        }
<span class="fc" id="L770">        return count;</span>
    }


    /**
     * @param target nodes are graph nodes which contain either tensors requiring errors for accumulation and/or more targets.
     * @param agent ADAgent's are used during back-propagation in order to distribute an error throughout the graph.
     */
    public void put(GraphNode&lt;ValueType&gt; target, ADAgent agent) {
<span class="fc bfc" id="L779" title="All 2 branches covered.">        if ( _targets_derivatives == null ) _targets_derivatives = new TreeMap&lt;&gt;((a, b) -&gt; a.hashCode() - b.hashCode());</span>

<span class="fc bfc" id="L781" title="All 2 branches covered.">        if ( _targets_derivatives.containsKey( target ) ) {</span>
<span class="fc" id="L782">            _targets_derivatives.get( target ).add( agent );</span>
<span class="fc" id="L783">        } else _targets_derivatives.put( target, new ArrayList&lt;&gt;( Arrays.asList( agent ) ) );</span>

<span class="fc" id="L785">        Tsr&lt;?&gt; d = agent.derivative();</span>
<span class="fc bfc" id="L786" title="All 4 branches covered.">        if ( d != null &amp;&amp; d.has( GraphNode.class ) ) d.find( GraphNode.class )._isUsedAsDerivative = true;</span>
<span class="fc" id="L787">    }</span>

    /**
     * This method returns what is needed for AD, usually a derivative of AD-Agent.
     *
     * @param target
     * @return Tsr&amp;lt;ValueType&amp;gt;
     */
    public List&lt;ADAgent&gt; get( GraphNode&lt;ValueType&gt; target ) {
<span class="nc bnc" id="L796" title="All 2 branches missed.">        if ( _targets_derivatives == null ) return null;</span>
<span class="nc" id="L797">        return _targets_derivatives.get( target );</span>
    }

    /**
     * This method checks if a given graph node is an AD target of this node.
     * This would mean that this node contains an AD-action for the given GraphNode (target).
     *
     * @param target
     * @return boolean
     */
    public boolean has( GraphNode&lt;ValueType&gt; target ) {
<span class="nc bnc" id="L808" title="All 2 branches missed.">        if ( _targets_derivatives == null ) return false;</span>
<span class="nc" id="L809">        return _targets_derivatives.containsKey( target );</span>
    }

    /**
     * This is the number of AD-actions stored inside this node.
     * It can be interpreted as the 'number of AD paths'.
     *
     * @return int
     */
    public int size() {
<span class="fc bfc" id="L819" title="All 2 branches covered.">        return ( _targets_derivatives != null ) ? this._targets_derivatives.size() : 0;</span>
    }

    /**
     * @param action
     */
    public void forEachDerivative( BiConsumer&lt;GraphNode&lt;ValueType&gt;, ADAgent&gt; action ) {
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">        if ( _targets_derivatives == null ) return;</span>
<span class="fc" id="L827">        _targets_derivatives.forEach(</span>
<span class="fc" id="L828">                ( t, agents ) -&gt; agents.forEach( a -&gt; action.accept( t, a ) )</span>
        );
<span class="fc" id="L830">    }</span>

    /**
     * @param action A lambda action providing derivative and target node as parameter.
     */
    public void forEachBackward( Tsr&lt;ValueType&gt; error, BiConsumer&lt;GraphNode&lt;ValueType&gt;, Tsr&lt;ValueType&gt;&gt; action ) {
<span class="fc bfc" id="L836" title="All 2 branches covered.">        if ( _targets_derivatives == null ) return;</span>
<span class="fc" id="L837">        _targets_derivatives.forEach( ( t, agents ) -&gt; {</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">            for ( ADAgent a : agents ) action.accept( t, a.backward( t, error ) );</span>
<span class="fc" id="L839">        });</span>
<span class="fc" id="L840">    }</span>

    /**
     * @param action
     */
    public void forEachTarget( Consumer&lt;GraphNode&lt;ValueType&gt;&gt; action ) {
<span class="fc bfc" id="L846" title="All 2 branches covered.">        if ( _targets_derivatives == null ) return;</span>
<span class="fc" id="L847">        _targets_derivatives.forEach( ( t, o ) -&gt; action.accept( t ) );</span>
<span class="fc" id="L848">    }</span>

    /**
     * @param action
     */
    public void forEachTargetAgentPair( BiConsumer&lt;GraphNode&lt;ValueType&gt;, ADAgent&gt; action ) {
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        if ( _targets_derivatives == null ) return;</span>
<span class="fc" id="L855">        _targets_derivatives</span>
<span class="fc" id="L856">                .forEach(</span>
                    ( targetNode, agents ) -&gt;
<span class="fc" id="L858">                        agents.forEach(</span>
<span class="fc" id="L859">                            a -&gt; action.accept( targetNode, a )</span>
                        )
                );
<span class="fc" id="L862">    }</span>


    /**
     * @return Checks if this node stores target / AD-action (usually derivatives) pairs.
     */
    public boolean hasDerivatives() {
<span class="pc bpc" id="L869" title="3 of 4 branches missed.">        return ( _targets_derivatives != null ) &amp;&amp; _targets_derivatives.size() &gt; 0;</span>
    }

    /**
     * @return Returns the type of the node as descriptive String in capital letters.
     */
    public String type() {
<span class="fc" id="L876">        String type = &quot;&quot;;</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">        if ( this.isLeave() ) type += &quot;LEAVE&quot;;</span>
<span class="fc" id="L878">        else type += &quot;BRANCH&quot;;</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">        if ( getPayload() == null ) type = type + &quot; DELETED&quot;;</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">        else if ( getPayload().rqsGradient() ) type += &quot; RQS GRADIENT&quot;;</span>
<span class="fc" id="L881">        return type;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L886">        return toString( &quot;&quot; );</span>
    }

    /**
     * @param m Stands for 'mode' and is expected to contain certain letters which are used as settings.
     * @return Returns a String representation of this node.
     */
    public String toString( String m ) {
<span class="fc bfc" id="L894" title="All 2 branches covered.">        if ( m.contains( &quot;g&quot; ) ) {</span>
<span class="fc" id="L895">            String flags = m.replace( &quot;g&quot;, &quot;&quot; );</span>
<span class="fc" id="L896">            return &quot;]&gt; LOCK: &quot; + getLock() + &quot; |&gt; GRAPH:\n]\n&quot; + _toString( &quot;]    0&quot;, true, flags ) + &quot;\n]\n]|END|&gt;&quot;;</span>
        }
<span class="fc bfc" id="L898" title="All 2 branches covered.">        String nid = ( m.contains( &quot;n&quot; ) ) ? &quot;NID:&quot; + Long.toHexString( getNodeID() ) : &quot;NODE&quot;;</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">        if ( m.contains( &quot;v&quot; ) ) {</span>
<span class="fc" id="L900">            return &quot;(&quot; + this.type() + &quot;): [&quot; + nid + &quot;]:&lt;(  &quot;</span>
                    + &quot;f&quot; +
                    (
<span class="fc bfc" id="L903" title="All 2 branches covered.">                            ( _function == null ) ? &quot;(NONE)&quot; : _function</span>
                    )
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">                    + &quot; =&gt; &quot; + ( (getPayload() == null ) ? &quot;NULL&quot; : getPayload().toString( &quot;cs&quot; ) ) + &quot;  )&gt;&quot;;</span>
        } else
<span class="nc" id="L907">            return</span>
                    &quot;[&quot; + nid + &quot;]:( &quot; + (
<span class="nc bnc" id="L909" title="All 2 branches missed.">                            ( getPayload() == null )</span>
<span class="nc" id="L910">                                    ? &quot;NULL&quot;</span>
<span class="nc" id="L911">                                    : getPayload().toString(&quot;cs&quot;)</span>
                    ) + &quot; )&quot;;
    }

    /**
     * A private recursive method used by its public counterpart ( 'toString(String m)' )
     * in order to build a indented multi-line tree-like
     * String representation of the entire computation graph
     * starting at the node from where this method is called.
     *
     * @param deep The current depth / indentation
     * @param isLast Tells if this is the last parent node of this child.
     * @return A indented multi-line tree-like String representation of the computation graph.
     */
    private String _toString( String deep, boolean isLast, String flags ) {
<span class="fc bfc" id="L926" title="All 2 branches covered.">        String delimiter = ( (isLast) ? (&quot;    &quot;) : (&quot;|   &quot;) );</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">        String arrow = ( (char) 187 ) + &quot;&quot; + ( (_parents != null) ? ( String.valueOf( _parents.length ) ) : &quot;0&quot; ) + ( (char) 187 );</span>
<span class="fc" id="L928">        StringBuilder asString = new StringBuilder( deep + arrow + toString( flags ) );</span>
<span class="fc" id="L929">        deep = deep.substring( 0, deep.length() - 1 );</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">        if ( _parents != null ) {</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">            asString.append( &quot;\n&quot; ).append( deep ).append( ( isLast ) ? &quot;   \\\n&quot; : &quot;|  \\\n&quot; );</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">            for ( int i = 0; i &lt; _parents.length; i++ ) {</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">                boolean last = ( i == _parents.length - 1 );</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">                asString.append( ( i != 0 ) ? deep + delimiter + &quot;|\n&quot; : &quot;&quot; );</span>
<span class="fc" id="L935">                asString.append( _parents[ i ]._toString(deep + delimiter + i, last, flags) ).append( &quot;\n&quot; );</span>
            }
<span class="fc" id="L937">            asString = new StringBuilder( asString.substring( 0, asString.length() - 1 ) );</span>
        }
<span class="fc" id="L939">        return asString.toString();</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>