<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.autograd</a> &gt; <span class="el_source">GraphNode.java</span></div><h1>GraphNode.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    _____                 _     _   _           _
   / ____|               | |   | \ | |         | |
  | |  __ _ __ __ _ _ __ | |__ |  \| | ___   __| | ___
  | | |_ | '__/ _` | '_ \| '_ \| . ` |/ _ \ / _` |/ _ \
  | |__| | | | (_| | |_) | | | | |\  | (_) | (_| |  __/
   \_____|_|  \__,_| .__/|_| |_|_| \_|\___/ \__,_|\___|
                   | |
                   |_|

    This class defines the nodes which form the computation graph used to track operations performed on tensors,
    or more precisely :
    instances of the 'Tensor' class!

*/

package neureka.autograd;

import neureka.Neureka;
import neureka.Tensor;
import neureka.backend.api.AutoDiffMode;
import neureka.backend.api.ExecutionCall;
import neureka.backend.api.Result;
import neureka.common.composition.Component;
import neureka.common.utility.LogUtil;
import neureka.devices.Device;
import neureka.dtype.DataType;
import neureka.math.Function;
import neureka.math.args.Arg;

import java.lang.ref.WeakReference;
import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 *  Instances of the {@link GraphNode} class are components of tensors ({@link Tensor} instances)
 *  which model and record computations / operations between them.
 *  {@link GraphNode}s form a computation graph when operations are applied to tensors.
 *  This graph can then later on be used for traversal by an important algorithm implemented inside
 *  this class, namely: backpropagation.
 *  This algorithm is more generally known as reverse mode auto differentiation.
 *  The parent graph nodes of a given node are the nodes of the tensors
 *  from which the tensor of the current node was formed,
 *  whereas children are the nodes (also) produced by the computation modelled by said current node.
 *  Children are weakly referenced so that abandoned / detached
 *  graph branches (child nodes) can be garbage collected...
 *  ...whereas parents are strongly referenced in order to grant successful traversal.
 */
public class GraphNode&lt;V&gt; implements Component&lt;Tensor&lt;V&gt;&gt;
{
    /*
         mode state meaning:
       -+------------+----------------------------------+-
        | _mode == 0 |  no Auto-Differentiation         |
       -+------------+----------------------------------+-
        | _mode &gt; 0  |  forward Auto-Differentiation    |
       -+------------+----------------------------------+-
        | _mode &lt; 0  |  backward Auto-Differentiation   |
       -+------------+----------------------------------+-
    */
    private final int _mode;

    private final AutoDiffMode _adMode;

    private final Function _function;

    /**
     * The GraphNodes of the input tensors. ('Parents' of the tensor of this node)
     * These are always the GraphNodes of the tensors from which the tensor payload of this
     * GraphNode has been formed.
     */
    private final GraphNode&lt;V&gt;[] _parents;

    private final List&lt;BackPropTargets&lt;V&gt;&gt; _targetsToAgents;

<span class="fc" id="L103">    private final List&lt;WeakReference&lt;GraphNode&lt;V&gt;&gt;&gt; _children = new ArrayList&lt;&gt;(1);</span>

    private final NodePayload&lt;V&gt; _nodePayload;

<span class="fc" id="L107">    private int _usedAsDerivative = 0;</span>

<span class="fc" id="L109">    private boolean _reliesOnJustInTimeProp = false;</span>

<span class="fc" id="L111">    private PendingError&lt;V&gt; _pendingError = null;</span>




    /**
     * @param function        Is the function that lead to the creation of this node.
     * @param call            The execution call, or null if the node is not a result of an execution call (a leave).
     * @param payloadSupplier Provides the payload of this node.
     */
    public GraphNode( Function function, ExecutionCall&lt;Device&lt;?&gt;&gt; call, Supplier&lt;Result&gt; payloadSupplier )
<span class="fc" id="L122">    {</span>
<span class="fc" id="L123">        _checkConstructorArgValidity( function, call );</span>

<span class="fc" id="L125">        Result out = payloadSupplier.get();</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if ( out == null ) throw new NullPointerException( &quot;The result must no be null!&quot; );</span>

<span class="fc" id="L128">        NodePayload&lt;V&gt; data    = new NodePayload&lt;&gt;( null );</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        AutoDiffMode   adMode  = ( call != null ? call.autogradMode()                     : AutoDiffMode.NOT_SUPPORTED          );</span>
<span class="fc bfc" id="L130" title="All 4 branches covered.">        int            mode    = ( call != null ? GraphNodeUtility.modeOf( adMode, call ) : ( out.get().rqsGradient() ? 1 : 0 ) );</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        GraphNode&lt;V&gt;[] parents = ( call != null ? new GraphNode[call.arity()]             : null                                );</span>

<span class="fc bfc" id="L133" title="All 4 branches covered.">        if ( function != null &amp;&amp; function.isDoingAD() ) { // Only functions with AutoDiff enabled create computation graphs!</span>
<span class="fc" id="L134">            data = new NodePayload&lt;&gt;( out.get() );</span>
<span class="fc" id="L135">            ((Tensor&lt;V&gt;)out.get()).set(this);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            if ( call != null ) {</span>
<span class="fc" id="L137">                Tensor&lt;V&gt;[] inputs = (Tensor&lt;V&gt;[]) call.inputs();</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">                for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="pc" id="L139">                    parents[i] = inputs[i].getGraphNode().orElseThrow(()-&gt;new IllegalStateException(&quot;Input tensors of a new graph-node must contain leave graph-nodes!&quot;));</span>
<span class="fc" id="L140">                    parents[i]._attachChild(this);</span>
                }
            }
        }
<span class="fc" id="L144">        _nodePayload     = data;</span>
<span class="fc" id="L145">        _mode            = mode;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">        _function        = ( call == null ? null : function );</span>
<span class="fc" id="L147">        _adMode          = adMode;</span>
<span class="fc" id="L148">        _parents         = parents;</span>
<span class="fc" id="L149">        _targetsToAgents = _registerADActions( out, function, call );</span>
<span class="fc" id="L150">    }</span>

    private void _checkConstructorArgValidity(
        Function function,
        ExecutionCall&lt;Device&lt;?&gt;&gt; call
    ) {
<span class="pc bpc" id="L156" title="1 of 4 branches missed.">        if ( function == null &amp;&amp; call != null )</span>
<span class="nc" id="L157">            throw new IllegalArgumentException( &quot;Branch graph nodes require a function!&quot; );</span>

<span class="fc bfc" id="L159" title="All 2 branches covered.">        if ( call != null ) {</span>
<span class="fc" id="L160">            Tensor&lt;?&gt;[] inputs = call.inputs();</span>
            /* Applying JITProp and gradients */
<span class="fc" id="L162">            Neureka.Settings.AutoGrad adSetting = Neureka.get().settings().autograd();</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            if ( adSetting.isApplyingGradientWhenTensorIsUsed() ) {</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">                for ( Tensor&lt;?&gt; t : inputs ) {</span>
<span class="fc bfc" id="L165" title="All 4 branches covered.">                    if ( !adSetting.isApplyingGradientWhenRequested() || t.gradientApplyRequested() ) {</span>
<span class="fc" id="L166">                        t.applyGradient(); // activates JITProp if present and removes it...</span>
<span class="fc" id="L167">                        t.setGradientApplyRequested( false );</span>
                    }
                }
            }
<span class="fc" id="L171">            _checkInputValidity( inputs, function );</span>
        }
<span class="fc" id="L173">    }</span>

    private void _checkInputValidity(Tensor&lt;?&gt;[] inputs, Function function )
    {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L178">            GraphNode&lt;V&gt; child = (GraphNode&lt;V&gt;) inputs[ i ].getGraphNode().orElse(null);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            if ( child == null )</span>
<span class="fc" id="L180">                throw new IllegalStateException(</span>
                        &quot;Input tensor at index '&quot; + i + &quot;' did not return a GraphNode instance.&quot; +
                         &quot;Input tensors of a new GraphNode must be part of the computation graph!&quot;
                    );
<span class="fc bfc" id="L184" title="All 4 branches covered.">            if ( function.getOperation().isInline() &amp;&amp; child.usesAD() )</span>
<span class="fc" id="L185">                throw new IllegalStateException(</span>
<span class="fc" id="L186">                        &quot;Trying to apply inline operation '&quot; + function.getOperation().getIdentifier() + &quot;'\n&quot; +</span>
                        &quot;on active autograd computation graph in non detached function.\n&quot; +
<span class="fc" id="L188">                        &quot;Please use detached functions instead! ( 'Function.create(\&quot;&quot; + function.getOperation().getIdentifier() + &quot;(...)\&quot;, false)' )\n&quot;</span>
                    );
        }
<span class="fc" id="L191">    }</span>

    /**
     *  This method extracts {@link ADAction}s from the provided {@link Function}
     *  (and its underlying {@link neureka.backend.api.Operation}) to be stored associated with a
     *  particular target {@link GraphNode} node used as reference for back-prop traversal
     *  when doing back-prop/autograd later on...
     */
    private List&lt;BackPropTargets&lt;V&gt;&gt; _registerADActions(
        Result output, Function function, ExecutionCall&lt;? extends Device&lt;?&gt;&gt; call
    ) {
<span class="pc bpc" id="L202" title="1 of 4 branches missed.">        if ( call == null || !function.isFlat() )</span>
<span class="fc" id="L203">            return Collections.emptyList(); // Leave nodes don't need agents!</span>

<span class="fc" id="L205">        BackPropTargetCollector&lt;V&gt; collector = new BackPropTargetCollector&lt;&gt;();</span>

<span class="fc" id="L207">        Tensor&lt;V&gt;[] inputs = (Tensor&lt;V&gt;[]) call.inputs();</span>
        /* Returning if the above cannot form an AutoDiff computation graph! : */
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for ( Tensor&lt;V&gt; t : inputs )</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if ( t == output.get() ) return collector.getTargets(); // Output must be a unique tensor for AD!</span>

<span class="pc bpc" id="L212" title="1 of 4 branches missed.">        if ( this.usesAD() &amp;&amp; function.isFlat() ) {</span>
            /* Preparing for back propagation: */
<span class="fc bfc" id="L214" title="All 2 branches covered.">            if ( this.usesForwardAD() )</span>
            {
<span class="fc bfc" id="L216" title="All 2 branches covered.">                for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L217">                    GraphNode&lt;V&gt; srcNode = inputs[ i ].getGraphNode().orElseThrow(IllegalStateException::new);</span>
<span class="fc bfc" id="L218" title="All 4 branches covered.">                    if ( srcNode.usesAD() &amp;&amp; function.dependsOn(i) ) {</span>
<span class="fc" id="L219">                        if (</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                            srcNode.size() == 0</span>
                               || // Sources created by for example by dot/mm or x-mul are reverse-mode cases!
<span class="pc bpc" id="L222" title="1 of 4 branches missed.">                            !srcNode.isLeave() &amp;&amp; !srcNode._adMode.allowsForward()</span>
                        ) {
<span class="fc" id="L224">                            ADAction agent = output.getAgentSupplier().supplyADActionFor(function, call.withArgs(Arg.DerivIdx.of(i)) );</span>
<span class="fc" id="L225">                            collector.put( i, srcNode, agent );</span>
<span class="fc" id="L226">                            _informPartialDerivative(agent);</span>
<span class="fc" id="L227">                        } else {</span>
                            /*  Chain rule (forward) for every derivative w.r.t. leaves (reverseAD or user leaves): */
<span class="fc" id="L229">                            int finalI = i;</span>
<span class="fc" id="L230">                            Tensor&lt;V&gt; localDerivative = function.derive( inputs, i );</span>
<span class="fc" id="L231">                            srcNode._forEachTargetActionPair(</span>
                                ( targets, localADAction ) -&gt;
                                {
                                    // The agent multiplies the local derivative with its stored partial derivative...
<span class="fc" id="L235">                                    Tensor&lt;?&gt; targetDerivative = localADAction.act( new ADTarget&lt;&gt;(targets.index(), this, localDerivative) );</span>
                                    // ...this is now the new partial derivative with respect to the target node!
<span class="fc" id="L237">                                    ADAction agent = output.getAgentSupplier()</span>
<span class="fc" id="L238">                                                            .supplyADActionFor(</span>
                                                                function,
<span class="fc" id="L240">                                                                call.withArgs(</span>
<span class="fc" id="L241">                                                                    Arg.VarIdx.of(call.getValOf(Arg.VarIdx.class)),</span>
<span class="fc" id="L242">                                                                    Arg.DerivIdx.of(finalI),</span>
<span class="fc" id="L243">                                                                    Arg.Derivative.of(targetDerivative)</span>
                                                                )
                                                            );
<span class="fc" id="L246">                                    collector.put( finalI, targets.node(), agent );</span>
<span class="fc" id="L247">                                    _informPartialDerivative(agent);</span>
<span class="fc" id="L248">                                }</span>
                            );
                        }
                    }
                }
            }
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">            else if ( this.usesReverseAD() )</span>
            {
<span class="fc bfc" id="L256" title="All 2 branches covered.">                for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L257">                    GraphNode&lt;V&gt; srcNode = inputs[ i ].getGraphNode().orElseThrow(IllegalStateException::new);</span>
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">                    if ( ( srcNode.usesAD() || inputs[ i ].rqsGradient() )) {</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                        if ( !function.dependsOn(i) )</span>
<span class="nc" id="L260">                            throw new IllegalStateException(</span>
                                    &quot;The function '&quot; + function + &quot;' does not have an input for &quot; +
                                    &quot;for argument index '&quot; + i + &quot;'!\n&quot; +
                                    &quot;This is most likely due to a bug in the implementation of the function or the underlying operation(s).&quot;
                                );

<span class="fc" id="L266">                        ADAction agent = output.getAgentSupplier().supplyADActionFor(</span>
                                                        function,
<span class="fc" id="L268">                                                        call.withArgs(Arg.DerivIdx.of(i),Arg.VarIdx.of(call.getValOf(Arg.VarIdx.class)))</span>
                                                    );
<span class="fc" id="L270">                        collector.put( i, srcNode, agent );</span>
<span class="fc" id="L271">                        _informPartialDerivative(agent);</span>
                    }
                }
            }
        }
<span class="fc" id="L276">        return collector.getTargets();</span>
    }


    /**
     * This short method simply migrates the error to the device of
     * the payload tensor and possibly also applies the error to
     * the payload if its 'requires gradient' flag is set to true.
     *
     * @param e This is an error value passed to this method ba a backward traversal.
     */
    private void _migrateAndOrApplyError( Tensor&lt;V&gt; e, Consumer&lt;Tensor&lt;V&gt;&gt; also ) {
<span class="fc" id="L288">        this.getPayload().ifPresent( payload -&gt; {</span>
            // It was not garbage collected:
            try {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">                if ( payload.isOutsourced() ) payload.getDevice().store( e );</span>
<span class="nc" id="L292">            } catch ( Exception exception ) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                if ( payload.isUndefined() )</span>
<span class="nc" id="L294">                    throw new IllegalStateException(</span>
                            &quot;An undefined payload tensor has been detected inside the computation graph!\n&quot; +
                            &quot;This is most likely due to an error occurring during tensor identity transfer (Also see AbstractComponentOwner).\n&quot; +
                            &quot;One type of constructor in the 'Tensor' class enables passing a String expression for execution, &quot; +
                            &quot;whose resulting tensor needs to be merged into the newly created one...&quot;
                        );
                else
<span class="nc" id="L301">                    exception.printStackTrace();</span>
<span class="fc" id="L302">            }</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            if ( payload.rqsGradient() ) payload.mut().addToGradient( e );</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            if ( also != null ) also.accept( payload );</span>
<span class="fc" id="L305">        });</span>
<span class="fc" id="L306">    }</span>


    /**
     * This gradient node is involved in auto-differentiation.
     *
     * @return boolean
     */
<span class="fc bfc" id="L314" title="All 2 branches covered.">    public boolean usesAD() { return ( _mode != 0 ); }</span>

    /**
     * This node propagates forward.
     *
     * @return boolean
     */
<span class="fc bfc" id="L321" title="All 2 branches covered.">    public boolean usesForwardAD() { return ( _mode &gt; 0 ); }</span>

    /**
     * This node propagates _backward.
     *
     * @return boolean
     */
<span class="fc bfc" id="L328" title="All 2 branches covered.">    public boolean usesReverseAD() { return ( _mode &lt; 0 ); }</span>

    /**
     * This node (and the corresponding tensor) was not created by a function! (it's a leave tensor)
     *
     * @return boolean
     */
<span class="pc bpc" id="L335" title="1 of 4 branches missed.">    public boolean isLeave() { return _parents == null &amp;&amp; _function == null; }</span>

    public boolean isGraphLeave() {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if ( this.isLeave() ) return true;</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        for ( GraphNode&lt;V&gt; p : _parents )</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            if ( p != null ) return true;</span>

<span class="nc" id="L342">        return false;</span>
    }

    /**
     *  Note: This method will never return null even if the actual payload tensor was garbage collected.
     *  This is because the {@link GraphNode} will remember the shape of the tensor.
     *
     *  @return The shape of the payload tensor represented by this {@link GraphNode}.
     */
<span class="fc" id="L351">    public List&lt;Integer&gt; getPayloadShape() { return _nodePayload.getPayloadShape(); }</span>

    /**
     * @param newChild which references it's input namely the parent (this) has...
     */
    private synchronized void _attachChild( GraphNode&lt;V&gt; newChild ) {
<span class="fc" id="L357">        Objects.requireNonNull( newChild );</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if ( _pendingError != null )</span>
<span class="nc" id="L359">            throw new IllegalStateException(</span>
                    &quot;This node cannot be used for forward propagation because it is currently actively involved in backward propagation!\n&quot; +
                    &quot;Only after the pending error of this node has received all expected error contributions from its children, &quot; +
                    &quot;can it be used for forward propagation again.&quot;
                );
<span class="fc" id="L364">        _children.add( new WeakReference&lt;&gt;( newChild, null ) );</span>
<span class="fc" id="L365">    }</span>

    /**
     *  The value of a graph node is the tensor to which it belongs (is a component of).  &lt;br&gt;&lt;br&gt;
     *  Meaning it is the tensor owning this {@link GraphNode} component.
     *  It is referenced weakly because it might not be needed any more (Not referenced inside AD-Agent for example)
     *  and can therefore be garbage collected.
     *  &lt;p&gt;
     *  Warning: This method might return null because
     *           the payload is weakly referenced!
     *           Meaning that it might get garbage collected.
     *
     * @return The tensor payload of this graph-node.
     */
<span class="fc" id="L379">    public Optional&lt;Tensor&lt;V&gt;&gt; getPayload() { return Optional.ofNullable(_nodePayload.getPayload()); }</span>

    @Override
    public boolean update( OwnerChangeRequest&lt;Tensor&lt;V&gt;&gt; changeRequest ) {
<span class="fc" id="L383">        changeRequest.executeChange(); // This can be an 'add', 'remove' or 'transfer' of this component!</span>
<span class="fc" id="L384">        return true;</span>
    }

    /**
     * This method is called by the JITProp component.
     * A pending should only ever be retrieved from a GraphNode once because
     * afterward the accumulated error is about to be back-propagated.
     * Therefore, this method nulls the reference when returning the PendingError instance.
     * @return Returns an instance of the PendingError class containing a error accumulation.
     */
    public PendingError&lt;V&gt; getAndRemovePendingError() {
<span class="fc" id="L395">        PendingError&lt;V&gt; pending = _pendingError;</span>
<span class="fc" id="L396">        _pendingError = null;</span>
<span class="fc" id="L397">        return pending;</span>
    }

    /**
     * This method is the entry-point for the back-propagation process.
     * It sets up a key/value map which stores nodes and their intermediate error accumulations.
     * Accumulation occurs inside the private '_backward' method which traverses the computation graph
     * recursively, halts when errors can be accumulated, adds a PendingError and returns to the method below!
     * Here all the nodes and error values will then be carried (propagated) to the gradients!
     *
     * @param error The current error which is created by multiplying it with current size and traversing it.
     */
    public void backward( Tensor&lt;V&gt; error ) {
<span class="fc" id="L410">        Set&lt;GraphNode&lt;V&gt;&gt; pendingNodes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L411">        _backward( error, pendingNodes, false ); // Entry-point to private recursive back-propagation!</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if ( Neureka.get().settings().autograd().isRetainingPendingErrorForJITProp() )</span>
<span class="fc" id="L413">            pendingNodes.forEach( n -&gt; n._carryPendingBackPropToGradients( pendingNodes ) );</span>
        else {
            /*
                Now we have a set of pending graph nodes with their respective error accumulations.
                However, some of them may not be accumulated fully yet, and that is not necessarily a problem.
                One un-accumulated error may only be un-accumulated because another (fully accumulated) pending error
                is not yet back-propagated to the gradients of the tensor owning the un-accumulated error.
                So we first need to back-propagate all fully accumulated errors recursively
                and then check if there are still un-accumulated errors left:
            */
            long numberOfFullyAccumulated;
            do {
<span class="fc bfc" id="L425" title="All 2 branches covered.">                for ( GraphNode&lt;V&gt; n : new ArrayList&lt;&gt;(pendingNodes) )</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">                    if ( n._pendingError.isFullyAccumulated() ) {</span>
<span class="fc" id="L427">                        n.backward(n._pendingError.getAccumulatedError()); // Continue back-propagation recursively!</span>
<span class="fc" id="L428">                        pendingNodes.remove( n );</span>
                    }

<span class="fc" id="L431">                numberOfFullyAccumulated = pendingNodes.stream().filter( n -&gt; n._pendingError.isFullyAccumulated() ).count();</span>
            }
<span class="fc bfc" id="L433" title="All 2 branches covered.">            while ( numberOfFullyAccumulated &gt; 0 ); // Repeat until all fully accumulated errors are back-propagated!</span>

            // Now we can check if there are still un-accumulated errors left (there shouldn't be any!):
<span class="fc" id="L436">            _verifyErrorAccumulation( pendingNodes );</span>
        }
<span class="fc" id="L438">        _deleteDerivativesRecursively(); // Cleanup after back-propagation!</span>
<span class="fc" id="L439">    }</span>

    private void _verifyErrorAccumulation( Set&lt;GraphNode&lt;V&gt;&gt; pendingNodes )
    {
<span class="fc" id="L443">        List&lt;GraphNode&lt;V&gt;&gt; notFullyAccumulated = pendingNodes</span>
<span class="fc" id="L444">                                                    .stream()</span>
<span class="pc bnc" id="L445" title="All 2 branches missed.">                                                    .filter( n -&gt; !n._pendingError.isFullyAccumulated() )</span>
<span class="fc" id="L446">                                                    .collect(Collectors.toList());</span>

<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if ( !notFullyAccumulated.isEmpty() ) {</span>
<span class="nc" id="L449">            String explanation = &quot;Not all graph nodes have received the expected amount of errors from their children!\n&quot; +</span>
                                 &quot;This usually happens because the recorded computation graph has multiple roots, which &quot; +
                                 &quot;is most likely because not all of your model outputs are captured by a common loss function.\n&quot;;
<span class="nc" id="L452">            String problem =</span>
                    &quot;The following graph nodes have not received the expected amount of errors from their children:\n\n&quot; +
                    notFullyAccumulated
<span class="nc" id="L455">                        .stream().map( n -&gt;</span>
<span class="nc" id="L456">                            &quot;    &quot; + n +&quot;;\n&quot; +</span>
<span class="nc" id="L457">                            &quot;        Accumulation: &quot; + n._pendingError.getReceived() + &quot;/&quot; + n._pendingError.getExpectedToBeReceived() + &quot;;\n&quot; +</span>
<span class="nc" id="L458">                            &quot;        Generation: &quot; + n._pendingError.getGeneration() + &quot;;\n&quot; +</span>
                            &quot;        Involved operations '&quot; +
<span class="nc" id="L460">                            Optional.ofNullable(n._function)</span>
<span class="nc" id="L461">                                    .map( fun -&gt;</span>
<span class="nc" id="L462">                                            fun.getAllFunctions()</span>
<span class="nc" id="L463">                                               .stream()</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                                               .filter( f -&gt; f.getOperation() != null )</span>
<span class="nc" id="L465">                                               .map( f -&gt; f.getOperation().getIdentifier() )</span>
<span class="nc" id="L466">                                               .collect(Collectors.joining(&quot;', '&quot;))</span>
                                    )
<span class="nc" id="L468">                                    .orElse(&quot;[]&quot;)</span>
                            + &quot;';\n&quot; +
<span class="nc" id="L470">                            &quot;        Children: &quot; + n._children.stream().map( c -&gt; String.valueOf(c.get())).collect(Collectors.joining(&quot;, &quot;)) + &quot;;&quot;</span>
                        )
<span class="nc" id="L472">                        .collect(Collectors.joining(&quot;\n&quot;)) +</span>
                        &quot;\n&quot;;

<span class="nc" id="L475">            List&lt;List&lt;GraphNode&lt;V&gt;&gt;&gt; rootPaths = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L476">            List&lt;List&lt;GraphNode&lt;V&gt;&gt;&gt; longestPaths = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            for ( GraphNode&lt;V&gt; node : notFullyAccumulated ) {</span>
<span class="nc" id="L478">                List&lt;GraphNode&lt;V&gt;&gt; longPath = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L479">                node._findRootPathsRecursively( rootPaths, new ArrayList&lt;&gt;(), longPath, this );</span>
<span class="nc" id="L480">                longestPaths.add( longPath );</span>
<span class="nc" id="L481">            }</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if ( !rootPaths.isEmpty() )</span>
<span class="nc" id="L483">                problem += &quot;\nThe following paths from the current node to the root node have been found:\n&quot; +</span>
<span class="nc" id="L484">                          IntStream.range(0, rootPaths.size())</span>
<span class="nc" id="L485">                            .mapToObj( i -&gt; (1+i) + &quot;.: &quot; + rootPaths.get(i).stream().map(GraphNode::toString).collect(Collectors.joining(&quot; -&gt; &quot;)) )</span>
<span class="nc" id="L486">                            .collect(Collectors.joining(&quot;\n&quot;))+&quot;\n&quot;;</span>
            else
<span class="nc" id="L488">                problem += &quot;\nWe tried to find paths from the current node to root nodes but failed to do so.\n&quot; +</span>
                            &quot;This is really strange and should not happen!\n&quot; +
                            &quot;Here a snapshot of the computation graph from the root graph node:&quot; +
                            &quot;\n&quot; +
<span class="nc" id="L492">                            _fancyToString(112);</span>

<span class="nc bnc" id="L494" title="All 2 branches missed.">            if ( !longestPaths.isEmpty() )</span>
<span class="nc" id="L495">                problem += &quot;\nHere are the longest paths:\n&quot; +</span>
<span class="nc" id="L496">                            IntStream.range(0, longestPaths.size())</span>
<span class="nc" id="L497">                                .mapToObj( i -&gt; (1+i) + &quot;.: &quot; + longestPaths.get(i).stream().map(GraphNode::toString).collect(Collectors.joining(&quot; -&gt; &quot;)) )</span>
<span class="nc" id="L498">                                .collect(Collectors.joining(&quot;\n&quot;))+&quot;\n&quot;;</span>

<span class="nc" id="L500">            throw new IllegalStateException( explanation + problem );</span>
        }
<span class="fc" id="L502">    }</span>

    private boolean _findRootPathsRecursively(
        List&lt;List&lt;GraphNode&lt;V&gt;&gt;&gt; paths,
        List&lt;GraphNode&lt;V&gt;&gt; current,
        List&lt;GraphNode&lt;V&gt;&gt; longestPath,
        GraphNode&lt;V&gt; correctRoot
    ) {
        /*
           This method is used to find all possible paths from the current node to &quot;invalid&quot; root nodes.
           Root nodes are nodes which have no children but are still part of the autograd graph.
        */
<span class="nc" id="L514">        current.add( this );</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">        if ( this == correctRoot ) {</span>
<span class="nc" id="L517">            paths.add( new ArrayList&lt;&gt;(current) ); // We have found a path to a root node!</span>
        }
<span class="nc bnc" id="L519" title="All 2 branches missed.">        else if ( current.size() &gt; longestPath.size() ) {</span>
<span class="nc" id="L520">            longestPath.clear();// We are looking for paths to root nodes which are not the correct root node! (debugging)</span>
<span class="nc" id="L521">            longestPath.addAll( current );</span>
        }

<span class="nc" id="L524">        boolean foundRoot = false;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if ( !_children.isEmpty() )</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            for ( WeakReference&lt;GraphNode&lt;V&gt;&gt; child : new ArrayList&lt;&gt;(_children) ) {</span>
<span class="nc" id="L527">                GraphNode&lt;V&gt; c = child.get();</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                if ( c != null )</span>
<span class="nc bnc" id="L529" title="All 4 branches missed.">                    foundRoot = foundRoot || c._findRootPathsRecursively( paths, current, longestPath, correctRoot );</span>
<span class="nc" id="L530">            }</span>

<span class="nc" id="L532">        current.remove( this ); // Remove this node from the current path so that we can continue searching for other paths!</span>

<span class="nc" id="L534">        return foundRoot;</span>
    }

    /**
     * This method traverses the computation graph and applies errors to gradients.
     * Errors might be accumulated temporarily or possibly longer for 'Just In Time propagation'.
     * JITProp is enabled in the global Neureka class.
     * It will traverse the path between a pending error and a tensor (rqsGradient==true)
     * containing the JITProp component which is triggered as soon as new gradients are needed or requested (applied).
     * This traverse however does not occur through the method below.
     * Instead, the 'backwardJIT' method is called by the JITProp component if present.
     * Intermediate error accumulations are stored in the '_pending_error' variable.
     * The method halts when an error can be accumulated and returns.
     * This graph node however is not forgotten but being noted in the 'pendingNodes' Set.
     *
     * @param error A tensor which traverses the computation graph according to the rules of reverse mode AutoDiff.
     */
    private void _backward( Tensor&lt;V&gt; error, Set&lt;GraphNode&lt;V&gt;&gt; pendingNodes, boolean allowPendingError )
    {
<span class="fc" id="L553">        _migrateAndOrApplyError( error, null );</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        if ( this.usesAD() ) {</span>
            /* Checking JIT-Prop conditions and create Pending error if possible */
<span class="fc bfc" id="L556" title="All 4 branches covered.">            if ( allowPendingError &amp;&amp; !this.isLeave() ) {//==&gt; We are NOT inside a 'Just-In-Time-Backprop' process (new pending error can be created)</span>
<span class="fc" id="L557">                int numOfADPaths = _numberOfReverseModeADChildren();// Multiple children triggers creation of a pending error</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">                if ( numOfADPaths &gt; 1 ) {</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                    if ( _pendingError == null ) {</span>
<span class="fc" id="L560">                        _pendingError = new PendingError&lt;&gt;( error, numOfADPaths, 1 );</span>
<span class="fc" id="L561">                        pendingNodes.add( this );</span>
                    }
                    else {
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">                        if ( _pendingError.isFullyAccumulated() )</span>
<span class="nc" id="L565">                            _pendingError = new PendingError&lt;&gt;( _pendingError.getAccumulatedError(), numOfADPaths, _pendingError.getGeneration() + 1 );</span>

<span class="fc" id="L567">                        _pendingError.accumulate( error );</span>
                    }

<span class="fc" id="L570">                    return;</span>
                    /* Back-prop will be continued later! This node is being remembered in 'PendingError'
                       NOTE: Multiple AutoDiff paths leading to one node in history will be accumulated first! (performance)
                             This optimization is a light version of JITProp. JITProp builds on this!
                    */
                }
            }
            // The following call ADActions for reverse-mode AutoDiff!
<span class="fc" id="L578">            _forEachBackRef( error, ( t, e ) -&gt; t._backward( e, pendingNodes, true ) );</span>
            // Standard reverse mode-AutoDiff!
        }
<span class="fc" id="L581">    }</span>

    /**
     * This method is called only if JIT-propagation is enabled.
     * It carries pending errors to the tensors requiring gradients which will
     * later on be processed just in time.
     * The path is being marked with '_relies_on_JITProp' so that intermediate size will
     * not be deleted.
     *
     * @param pendingBackProp The set of graph nodes where further propagation is pending.
     */
    private void _carryPendingBackPropToGradients( Set&lt;GraphNode&lt;V&gt;&gt; pendingBackProp ) {
<span class="fc" id="L593">        _reliesOnJustInTimeProp = true; //:=&gt; Shall be traversed at a later point in time...</span>
<span class="fc" id="L594">        this.forEachTarget( t -&gt; t._carryPendingBackPropToGradients( pendingBackProp ) );</span>
<span class="fc" id="L595">        this.getPayload().ifPresent( p -&gt; {</span>
<span class="pc bpc" id="L596" title="1 of 4 branches missed.">            if ( this.isLeave() &amp;&amp; p.rqsGradient() ) {</span>
<span class="fc" id="L597">                JITProp&lt;V&gt; jit = p.get( JITProp.class );</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">                if ( jit == null ) jit = new JITProp&lt;&gt;( pendingBackProp );</span>
<span class="nc" id="L599">                else jit.addPending( pendingBackProp );</span>
<span class="fc" id="L600">                p.set( jit );</span>
            }
<span class="fc" id="L602">        });</span>
<span class="fc" id="L603">    }</span>

    /**
     * This method is called only when JITProp is active.
     * If an error has accumulated inside a JITProp component and
     * the component is triggered to continue pending backward calls
     * then this happens through this method.
     * The node from where the pending error stems from
     * is being passed down the graph (back in 'time')
     * in order to mark this error source as 'done'
     * so that other JITProp components do not propagate
     * this 'source' node multiple times.
     *
     * @param error The error which ought to be back-propagated just-in-time.
     */
    public void backwardJIT( Tensor&lt;V&gt; error ) {
<span class="fc" id="L619">        _backwardJIT( error, this );</span>
<span class="fc" id="L620">        _deleteDerivativesRecursively();// Cleanup after back-propagation!</span>
<span class="fc" id="L621">    }</span>

    private void _backwardJIT(Tensor&lt;V&gt; error, GraphNode&lt;V&gt; source ) {
<span class="fc" id="L624">        _reliesOnJustInTimeProp = false; // JITProp is currently being handled in this method. Afterwards it is not relying on it anymore!</span>
<span class="fc" id="L625">        _migrateAndOrApplyError( error, payload -&gt; {</span>
<span class="fc" id="L626">            JITProp&lt;V&gt; jit = payload.get( JITProp.class );//Get JIT-Prop node.</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">            if ( jit != null ) {</span>
<span class="fc" id="L628">                jit.noteFinished( source );//note pending errors and store them as 'done'</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">                if ( jit.isDone() ) payload.remove( JITProp.class );</span>
            }
<span class="fc" id="L631">        });</span>
<span class="pc bpc" id="L632" title="3 of 4 branches missed.">        if ( _pendingError != null &amp;&amp; source != this ) {</span>
<span class="nc" id="L633">            _pendingError.accumulate( error );</span>
            /*
              A pending error has been found, so this means that this node
              is referenced by one or more JIT-Prop components.
              If among these components is the one that issued this very
              traverse we are in at this moment, then this pending error at this node will later on
              be continued to be propagated.
              Otherwise, it makes sense to accumulate errors further and wait for JIT-Prop traversing!
             */
<span class="nc" id="L642">            return; // This node will continue its propagation via a JIT-Prop component later!</span>
        }
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">        if ( this.usesAD() )</span>
            // The following call ADActions for reverse-mode AutoDiff!
<span class="fc" id="L646">            _forEachBackRef( error, ( t, e ) -&gt; t._backwardJIT( e, source ) );</span>
            // JITProp reverse mode-AutoDiff!
<span class="fc" id="L648">    }</span>

    /**
     * This method is called after the backward call has been executed fully.
     * Derivatives are no longer used and will therefore be deleted when possible.
     * Deletion is forbidden if this node is flagged
     * as JITProp job. This means that the node is on the path between gradients
     * and pending error objects.
     * Only if JITProp is enabled (Neureka.get().settings().autograd()...) this flag will
     * deviate from its default state, namely: true!
     */
    private void _deleteDerivativesRecursively() {
<span class="fc bfc" id="L660" title="All 2 branches covered.">        if ( !Neureka.get().settings().debug().isKeepingDerivativeTargetPayloads() ) { // &lt;=- This flag is almost always false. (Used for testing)</span>
<span class="pc bpc" id="L661" title="1 of 4 branches missed.">            if ( !this.isReliesOnJustInTimeProp() &amp;&amp; !_targetsToAgents.isEmpty() ) _targetsToAgents.clear();</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">            if ( !this.isGraphLeave() ) forEachTarget( GraphNode::_deleteDerivativesRecursively );</span>
        }
<span class="fc" id="L664">    }</span>

    /**
     * Counts how many child nodes will later on provide error values for back-propagation!
     *
     * @return The number of child nodes using reverse-mode auto-differentiation.
     */
    private int _numberOfReverseModeADChildren() {
<span class="fc" id="L672">        int count = 0;</span>
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">        if ( !_children.isEmpty() ) {</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">            for ( WeakReference&lt;GraphNode&lt;V&gt;&gt; weak : _children ) {</span>
<span class="pc bpc" id="L675" title="2 of 4 branches missed.">                if ( weak != null &amp;&amp; weak.get() != null ) {</span>
<span class="fc" id="L676">                    GraphNode&lt;V&gt; child = weak.get(); // TODO: make test which asserts that Detached Function does not trigger this!</span>
<span class="pc bpc" id="L677" title="1 of 4 branches missed.">                    if ( child != null &amp;&amp; child.usesReverseAD() ) count++;</span>
                }
<span class="fc" id="L679">            }</span>
        }
<span class="fc" id="L681">        return count;</span>
    }

    private void _informPartialDerivative( ADAction agent ) {
<span class="fc" id="L685">        agent.partialDerivative()</span>
<span class="fc" id="L686">            .ifPresent( d -&gt;  {</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">                if ( !d.has( GraphNode.class ) )</span>
<span class="fc" id="L688">                    d.set(new GraphNode&lt;&gt;( null, null, () -&gt; Result.of(d) ));</span>
<span class="fc" id="L689">                d.getGraphNode().get()._usedAsDerivative++;</span>
<span class="fc" id="L690">            });</span>
<span class="fc" id="L691">    }</span>

    /**
     * This method checks if a given graph node is an AD target of this node.
     * This would mean that this node contains an AD-action for the given GraphNode (target).
     *
     * @param target The targeted derivation graph node reference.
     * @return boolean
     */
    public boolean has( GraphNode&lt;V&gt; target ) {
<span class="nc bnc" id="L701" title="All 2 branches missed.">        return _targetsToAgents.stream().anyMatch( ref -&gt; ref.node() == target );</span>
    }

    /**
     * This is the number of AD-actions stored inside this node.
     * It can be interpreted as the 'number of AD paths'.
     *
     * @return int
     */
    public int size() {
<span class="fc" id="L711">        return _targetsToAgents.size();</span>
    }

    /**
     * @param action The lambda performing an action on all targeted nodes and their agents.
     */
    public void forEachDerivative( BiConsumer&lt;GraphNode&lt;V&gt;, ADAction&gt; action ) {
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">        if ( _targetsToAgents.isEmpty() ) return;</span>
<span class="fc" id="L719">        new ArrayList&lt;&gt;(_targetsToAgents).forEach(</span>
<span class="fc" id="L720">            ( ref ) -&gt; ref.actions().forEach( a -&gt; action.accept( ref.node(), a ) )</span>
        );
<span class="fc" id="L722">    }</span>

    /**
     * @param error The error which ought to be passed to the {@link ADAction}s.
     * @param action A lambda action providing derivative and target node as parameter.
     */
    private void _forEachBackRef( Tensor&lt;V&gt; error, BiConsumer&lt;GraphNode&lt;V&gt;, Tensor&lt;V&gt;&gt; action ) {
<span class="fc bfc" id="L729" title="All 2 branches covered.">        if ( _targetsToAgents.isEmpty() ) return;</span>
<span class="fc" id="L730">        error.getMut().setIsIntermediate( false );</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">        for ( BackPropTargets&lt;V&gt; ref : new ArrayList&lt;&gt;(_targetsToAgents) )</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            for ( ADAction a : ref.actions() )</span>
<span class="fc" id="L733">                action.accept( ref.node(), (Tensor&lt;V&gt;) a.act( new ADTarget&lt;&gt;(ref.index(), ref.node(), error) ));</span>
<span class="fc" id="L734">    }</span>

    /**
     * @param action An action which should be applied to the graph nodes of all the partial derivatives.
     */
    public void forEachTarget( Consumer&lt;GraphNode&lt;V&gt;&gt; action ) {
<span class="fc bfc" id="L740" title="All 2 branches covered.">        if ( _targetsToAgents.isEmpty() ) return;</span>
<span class="fc" id="L741">        new ArrayList&lt;&gt;(_targetsToAgents).forEach( ref -&gt; action.accept( ref.node() ) );</span>
<span class="fc" id="L742">    }</span>

    /**
     * @param action The action which ought to be applied to each target {@link GraphNode} / {@link ADAction} pair.
     */
    private void _forEachTargetActionPair( BiConsumer&lt;BackPropTargets&lt;V&gt;, ADAction&gt; action ) {
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">        if ( _targetsToAgents.isEmpty() ) return;</span>
<span class="fc" id="L749">        new ArrayList&lt;&gt;( _targetsToAgents )</span>
<span class="fc" id="L750">                .forEach( ref  -&gt; ref.actions().forEach(a -&gt; action.accept( ref, a ) ) );</span>
<span class="fc" id="L751">    }</span>


    /**
     * @return Checks if this node stores target / AD-action (usually derivatives) pairs.
     */
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">    public boolean hasDerivatives() { return !_targetsToAgents.isEmpty(); }</span>

    /**
     *  This is the getter for an important {@link GraphNode} property which
     *  holds the auto-differentiation mode used by this instance to
     *  decide if a given error should be forward propagated
     *  backward propagated or not propagated at all.
     *  If the mode is greater than 0, then this means this {@link GraphNode}
     *  will perform forward propagation. In this case the mode number
     *  is also the cumulative number of forward propagation steps
     *  in the tree of source {@link GraphNode} instances.
     *  If the mode is below 0, then this means this instance will
     *  perform reverse mode differentiation (back-propagation).
     *  The absolute of a negative mode represents the number of
     *  referenced source nodes which have a mode state other than zero.
     *  This means that they directly or indirectly reference
     *  a {@link GraphNode} instance which represents a {@link Tensor} instance
     *  having the {@link Tensor#rqsGradient()} flag set to true!
     *                                                              &lt;br&gt;
     *  Mode state meaning:                                         &lt;br&gt;
     *  ----------------------------------------------------------- &lt;br&gt;
     *  |  mode equals 0  |  no Auto-Differentiation                &lt;br&gt;
     *  ----------------------------------------------------------- &lt;br&gt;
     *  |  mode greater 0  |  forward Auto-Differentiation          &lt;br&gt;
     *  ----------------------------------------------------------- &lt;br&gt;
     *  |  mode lesser 0  |  backward Auto-Differentiation          &lt;br&gt;
     *  ----------------------------------------------------------- &lt;br&gt;&lt;br&gt;
     *
     * @return The differentiation mode represented as an integer which encodes 3 distinct states.
     */
<span class="fc" id="L787">    public int getMode() { return _mode; }</span>

    /**
     * This flag is used for a performance optimization feature namely 'Just In Time Propagation'.
     * This feature accumulates errors and continues propagation
     * as soon as they are needed. (At the end of 'backward()' or when the tensor is used again).
     * If the flag {@link Neureka.Settings.AutoGrad#isRetainingPendingErrorForJITProp()} is set to true
     * then error values will accumulate whenever it makes sense.
     * This technique however uses more memory but will
     * improve performance for some networks substantially.
     * &lt;p&gt;
     * All nodes between a Pending-Error and those requiring gradients will
     * be marked with '_relies_on_JIPProp=true'!
     *
     * @return The truth value determining if this graph node relies on just in time propagation.
     */
<span class="fc" id="L803">    public boolean isReliesOnJustInTimeProp() { return _reliesOnJustInTimeProp; }</span>

    /**
     * Used by the Just-In-Time back-prop component.
     */
<span class="fc" id="L808">    public Optional&lt;PendingError&lt;V&gt;&gt; getPendingError() { return Optional.ofNullable( _pendingError ); }</span>

    /**
     * The chain-rule states that the derivative of f(x) = h(g(x)) with respect to x is: g'(x) * h'(g(x))
     * An example would be:
     * f(x) = ((x*y)*z)
     * f'(x) = (1*y) * (1*z) = z*y
     * The values z,y or z*y must not be deleted as they are needed for back-propagation!
     */
<span class="fc bfc" id="L817" title="All 2 branches covered.">    public boolean isUsedAsDerivative() { return _usedAsDerivative &gt; 0; }</span>

    /**
     * Recorded Function which produced this {@link GraphNode}.
     */
<span class="fc" id="L822">    public Optional&lt;Function&gt; getFunction() { return Optional.ofNullable( _function ); }</span>

<span class="fc bfc" id="L824" title="All 2 branches covered.">    public List&lt;GraphNode&lt;V&gt;&gt; getParents() { return _parents == null ? Collections.emptyList() : Arrays.asList( _parents ); }</span>

    /**
     *  This variable holds a copy of the version of the payload tensor
     *  recorded when this GraphNode instance is instantiated.
     *  It must be treated as final and should never be modified.
     *  However, it can be read freely in order to
     *  check that the version of the payload hasn't changed.
     */
<span class="fc" id="L833">    public int getPayloadReferenceVersion() { return _nodePayload.payloadReferenceVersion(); }</span>

<span class="nc" id="L835">    public DataType&lt;V&gt; getPayloadDataType() { return _nodePayload.payloadDataType(); }</span>

    /**
     *  The children are {@link GraphNode} instances which represent computations
     *  involving the payload of this very {@link GraphNode} instance.
     */
    public List&lt;WeakReference&lt;GraphNode&lt;V&gt;&gt;&gt; getChildren() {
<span class="fc" id="L842">        return Collections.unmodifiableList( _children );</span>
    }

    public boolean canBeDeleted() {
<span class="fc" id="L846">        Tensor&lt;V&gt; payload = _nodePayload.getPayload();</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">        if ( payload == null ) return true;</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if ( !isUsedAsDerivative() ) return true;</span>
        /*
            This node is a derivative of another node.
            Should we delete it? Usually not, but if the
            payload tensor is not used by any other node
            then we can delete it.
         */
<span class="fc" id="L855">        int aliveAncestors = _numberOfExistingAncestors();</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">        if ( aliveAncestors &gt; 0 ) {</span>
            /*
                This node has ancestors whose &quot;backward()&quot; methods could be called.
                In this case we must not delete this node, because it might be used!
             */
<span class="fc" id="L861">            return false;</span>
        }
        else {
            /*
                If the number of ancestors is zero then this means that it can most likely be deleted
                because no ancestors means that theoretically this node is not used as a derivative in the computation...
                However, it is theoretically possible that this node is used as a derivative
                in an alternative computation graph which is not connected to this computation graph.
             */
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">            return _numberOfDerivativeUsages(payload) == _usedAsDerivative;</span>
        }
    }

    private int _numberOfExistingAncestors() {
<span class="fc" id="L875">        return getChildren()</span>
<span class="fc" id="L876">                .stream()</span>
<span class="fc" id="L877">                .map( WeakReference::get )</span>
<span class="fc" id="L878">                .filter( Objects::nonNull )</span>
<span class="fc" id="L879">                .mapToInt( n -&gt; {</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">                    int count = n.getPayload().map( p -&gt; !p.isDeleted() ? 1 : 0 ).orElse( 0 );</span>
<span class="fc" id="L881">                    return count + n._numberOfExistingAncestors();</span>
                })
<span class="fc" id="L883">                .sum();</span>
    }

    private long _numberOfDerivativeUsages( Tensor&lt;V&gt; derivative ) {
<span class="fc" id="L887">        return getChildren()</span>
<span class="fc" id="L888">                .stream()</span>
<span class="fc" id="L889">                .map( WeakReference::get )</span>
<span class="fc" id="L890">                .filter( Objects::nonNull )</span>
<span class="fc" id="L891">                .mapToLong( n -&gt; {</span>
<span class="fc" id="L892">                    long usages =</span>
                            n._targetsToAgents
<span class="fc" id="L894">                            .stream()</span>
<span class="fc" id="L895">                            .flatMap( t -&gt; t.actions().stream() )</span>
<span class="fc" id="L896">                            .map( a -&gt; a.partialDerivative().orElse(null) )</span>
<span class="fc" id="L897">                            .filter( Objects::nonNull )</span>
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">                            .filter( d -&gt; d == derivative )</span>
<span class="fc" id="L899">                            .count();</span>

<span class="fc" id="L901">                    return usages + n._numberOfDerivativeUsages( derivative );</span>
                })
<span class="fc" id="L903">                .sum();</span>
    }

    /**
     * @return Returns the type of the node as descriptive String in capital letters.
     */
    public String type() {
<span class="fc" id="L910">        String type = &quot;&quot;;</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">        if ( this.isLeave() ) type += &quot;LEAVE&quot;;</span>
<span class="fc" id="L912">        else type += &quot;BRANCH&quot;;</span>
<span class="fc" id="L913">        type += this.getPayload()</span>
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">                    .filter( p -&gt; !p.isDeleted() )</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">                    .map( p -&gt; p.rqsGradient() ? &quot; RQS GRADIENT&quot; : &quot;&quot; )</span>
<span class="fc" id="L916">                    .orElse(&quot; DELETED&quot;);</span>
<span class="fc" id="L917">        return type;</span>
    }

    @Override
<span class="fc" id="L921">    public String toString() { return toString( Print.SIMPLE ); }</span>

<span class="fc" id="L923">    public enum Print { SIMPLE, COMPACT, FANCY }</span>

    /**
     * @param mode The format of the string representation.
     * @return Returns a String representation of this node.
     */
    public String toString( Print mode ) {
<span class="fc" id="L930">        LogUtil.nullArgCheck( mode, &quot;mode&quot;, Print.class );</span>
<span class="pc bpc" id="L931" title="1 of 4 branches missed.">        switch ( mode ) {</span>
<span class="fc" id="L932">            case SIMPLE: return _simpleToString();</span>
<span class="fc" id="L933">            case FANCY: return _fancyToString(1028);</span>
<span class="fc" id="L934">            case COMPACT: return _compactToString();</span>
        }
<span class="nc" id="L936">        throw new IllegalStateException();</span>
    }

    private String _simpleToString() {
<span class="fc" id="L940">        return this.getClass().getSimpleName()+&quot;@&quot;+Integer.toHexString(hashCode())+&quot;[&quot; +</span>
<span class="fc" id="L941">                            &quot;parents=[&quot; + ( _parentsToString() ) + &quot;],&quot; +</span>
<span class="fc bfc" id="L942" title="All 2 branches covered.">                            &quot;function=&quot; + (_function == null ? &quot;?&quot; : _function) + &quot;,&quot; +</span>
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">                            &quot;shape=&quot; + (getPayloadShape() != null ? getPayloadShape().stream().map(Object::toString).collect(Collectors.joining(&quot;x&quot;)) : &quot;?&quot; ) +</span>
                        &quot;]&quot;;
    }

    private String _parentsToString() {
<span class="fc" id="L948">        return</span>
<span class="fc" id="L949">            Optional.ofNullable( _parents ).map( parents -&gt;</span>
<span class="fc" id="L950">                Arrays.stream(_parents)</span>
<span class="fc" id="L951">                .map(GraphNode::getPayload)</span>
<span class="fc" id="L952">                .map( p -&gt;</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">                    p.filter( t -&gt; !t.isDeleted() )</span>
<span class="fc" id="L954">                    .map( t-&gt;t.shape().stream().map(Object::toString).collect(Collectors.joining(&quot;x&quot;)))</span>
<span class="fc" id="L955">                    .orElse(&quot;?&quot;)</span>
                )
<span class="fc" id="L957">                .collect(Collectors.joining(&quot;, &quot;))</span>
            )
<span class="fc" id="L959">            .orElse(&quot;?&quot;);</span>
    }

    private String _fancyToString( int depthLimit ) {
<span class="fc" id="L963">        return &quot;]&gt; GRAPH:\n]\n&quot; + _toString( &quot;]    0&quot;, true, Print.COMPACT, depthLimit ) + &quot;\n]\n]|END|&gt;&quot;;</span>
    }

    private String _compactToString() {
<span class="fc" id="L967">        Optional&lt;Tensor&lt;V&gt;&gt; payload = getPayload();</span>
<span class="fc" id="L968">        String nid = this.getClass().getSimpleName();// + ( m.contains( &quot;n&quot; ) ? &quot;#&quot; + Long.toHexString( getNodeID() ) : &quot;&quot; );</span>
<span class="fc" id="L969">        return &quot; &quot; + nid + &quot;[ &quot;</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">                + ( _function == null ? &quot;&quot; : _function + &quot; =&gt; &quot; )</span>
                + (
<span class="fc" id="L972">                    payload.map( p -&gt; p.toString(</span>
<span class="fc" id="L973">                        settings -&gt; settings</span>
<span class="fc" id="L974">                                .setRowLimit( 3 )</span>
<span class="fc" id="L975">                                .setIsScientific( true )</span>
<span class="fc" id="L976">                                .setIsMultiline( false )</span>
<span class="fc" id="L977">                                .setHasGradient( false )</span>
<span class="fc" id="L978">                                .setCellSize( 1 )</span>
<span class="fc" id="L979">                                .setHasValue( true )</span>
<span class="fc" id="L980">                                .setHasRecursiveGraph( false )</span>
<span class="fc" id="L981">                                .setHasDerivatives( false )</span>
<span class="fc" id="L982">                                .setHasShape( true )</span>
<span class="fc" id="L983">                                .setIsCellBound( false )</span>
<span class="fc" id="L984">                                .setPostfix( &quot;&quot; )</span>
<span class="fc" id="L985">                                .setPrefix( &quot;&quot; )</span>
<span class="fc" id="L986">                                .setHasSlimNumbers( false )</span>
                        )
<span class="fc" id="L988">                    ).orElse(&quot;?&quot;)</span>
                ) +
<span class="fc" id="L990">                &quot;, type='&quot; + this.type() + &quot;'&quot; +</span>
                &quot;] &quot;;
    }

    /**
     * A private recursive method used by its public counterpart ( 'toString(String m)' )
     * in order to build a indented multi-line tree-like
     * String representation of the entire computation graph
     * starting at the node from where this method is called.
     *
     * @param deep The current depth / indentation
     * @param isLast Tells if this is the last parent node of this child.
     * @return A indented multi-line tree-like String representation of the computation graph.
     */
    private String _toString( String deep, boolean isLast, Print mode, int depthLimit ) {
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        String delimiter = ( isLast ? (&quot;    &quot;) : (&quot;|   &quot;) );</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">        String arrow = ( (char) 187 ) + &quot;&quot; + ( _parents != null ? String.valueOf( _parents.length ) : &quot;0&quot; ) + ( (char) 187 );</span>
<span class="fc" id="L1007">        StringBuilder asString = new StringBuilder( deep + arrow + toString( mode ) );</span>
<span class="fc" id="L1008">        deep = deep.substring( 0, deep.length() - 1 );</span>
<span class="fc bfc" id="L1009" title="All 2 branches covered.">        if ( _parents != null ) {</span>
<span class="fc bfc" id="L1010" title="All 2 branches covered.">            asString.append( &quot;\n&quot; ).append( deep ).append( isLast ? &quot;   \\\n&quot; : &quot;|  \\\n&quot; );</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">            for ( int i = 0; i &lt; _parents.length; i++ ) {</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">                boolean last = ( i == _parents.length - 1 );</span>
<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">                if ( deep.length() &lt; depthLimit ) { // prevent stack overflow + blowing up the heap (although the heap will probably already have blown up before this point)</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">                    asString.append( i != 0 ? deep + delimiter + &quot;|\n&quot; : &quot;&quot; );</span>
<span class="fc" id="L1015">                    asString.append( _parents[ i ]._toString( deep + delimiter + i, last, mode, depthLimit ) ).append( &quot;\n&quot; );</span>
                } else
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                    asString.append( deep + delimiter + i + &quot; ... (graph to deep for further traversal) &quot; + (!last ? &quot;\n&quot; : &quot; &quot;) );</span>
            }
<span class="fc" id="L1019">            asString = new StringBuilder( asString.substring( 0, asString.length() - 1 ) );</span>
        }
<span class="fc" id="L1021">        return asString.toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>