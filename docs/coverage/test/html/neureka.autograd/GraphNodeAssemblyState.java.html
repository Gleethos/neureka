<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphNodeAssemblyState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.autograd</a> &gt; <span class="el_source">GraphNodeAssemblyState.java</span></div><h1>GraphNodeAssemblyState.java</h1><pre class="source lang-java linenums">package neureka.autograd;

import neureka.Tsr;
import neureka.backend.api.ExecutionCall;
import neureka.calculus.Function;
import neureka.devices.Device;

/**
 *  This class exists in order to allow for {@link GraphNode}s to be instantiated
 *  with final field variables by collecting them when defined
 *  within constructor methods...
 */
<span class="fc" id="L13">final class GraphNodeAssemblyState&lt;V&gt; {</span>

    private int _mode;

    private boolean _allowsForward;

    private boolean _allowsBackward;

    private Function _function;

    private GraphNode&lt;V&gt;[] _parents;

<span class="fc" id="L25">    private int _payloadReferenceVersion = -1;</span>

    private GraphLock _lock;

<span class="fc" id="L29">    private long _nodeID = -1;</span>


<span class="fc" id="L32">    public int mode() { return _mode; }</span>

    /**
     * @param mode The mode of this GraphNode! ( m&lt;0 : backward-AD, m&gt;0 : forward-AD, m=0 : no-AD )
     */
    public GraphNodeAssemblyState&lt;V&gt; setMode(int mode ) {
<span class="fc" id="L38">        _mode = mode;</span>
<span class="fc" id="L39">        return this;</span>
    }

    /**
     *  Evaluates and sets the auto-grad/auto-differentiation mode:
     *  A positive value means that the AD-procedure will be forward mode AD,
     *  whereas a negative value is backward mode AD.
     *  If the resulting mode equals 0 then this means that no auto differentiation is needed.
     *  This class tries to optimize the calculation of partial derivatives by forward propagating them
     *  for as long as only a single input for every computation graph node requires gradients
     *  and they all are differentiable!
     *
     *
     * @param call The call containing inputs for the function which created the payload tensor of this GraphNode.
     */
    public void _modeOf( ExecutionCall&lt;? extends Device&lt;?&gt;&gt; call )
    {
<span class="fc" id="L56">        Tsr&lt;V&gt;[] inputs = (Tsr&lt;V&gt;[]) call.inputs();</span>
<span class="fc" id="L57">        int resultMode = 0;</span>
<span class="fc" id="L58">        int[] modes = new int[ inputs.length ];</span>
<span class="fc" id="L59">        int inputMode = 0;</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">        for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L61">            GraphNode&lt;V&gt; node = inputs[ i ].getGraphNode(); // Not null checked in constructor!</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">            modes[ i ] = ( inputs[ i ].rqsGradient() ) ? 1 : node.getMode();</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">            inputMode += ( modes[ i ] != 0) ? 1 : 0;</span>
        }
<span class="fc" id="L65">        _allowsForward = call.allowsForward();</span>
<span class="fc" id="L66">        _allowsBackward = call.allowsBackward();</span>
<span class="fc bfc" id="L67" title="All 4 branches covered.">        if ( inputMode == 1 &amp;&amp; _allowsForward) { // Convolution and reshaping prohibit forward AutoDiff</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">            for ( int i = 0; i &lt; inputs.length; i++ ) {</span>
<span class="fc" id="L69">                resultMode +=</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">                        ( modes[ i ] == 0 )</span>
<span class="fc" id="L71">                                ? 0</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">                                : ( modes[ i ] &lt; 0 ) ? 1 : modes[ i ] + 1;</span>
            }
        } // Reverse mode auto-differentiation :
<span class="fc bfc" id="L75" title="All 2 branches covered.">        else if (_allowsBackward) resultMode = -inputMode;</span>

<span class="fc" id="L77">        _mode = resultMode;</span>
<span class="fc" id="L78">    }</span>

<span class="fc" id="L80">    public boolean isAllowsForward() { return _allowsForward; }</span>

<span class="fc" id="L82">    public boolean isAllowsBackward() { return _allowsBackward; }</span>

<span class="fc" id="L84">    public Function function() { return _function; }</span>

    public GraphNodeAssemblyState&lt;V&gt; setFunction(Function function ) {
<span class="fc" id="L87">        _function = function;</span>
<span class="fc" id="L88">        return this;</span>
    }

<span class="fc" id="L91">    public GraphNode&lt;V&gt;[] parents() { return _parents; }</span>

    public GraphNodeAssemblyState&lt;V&gt; setParents(GraphNode&lt;V&gt;[] parents ) {
<span class="fc" id="L94">        _parents = parents;</span>
<span class="fc" id="L95">        return this;</span>
    }

<span class="fc" id="L98">    public int payloadReferenceVersion() { return _payloadReferenceVersion; }</span>

    public GraphNodeAssemblyState&lt;V&gt; setPayloadReferenceVersion(int payloadReferenceVersion) {
<span class="fc" id="L101">        _payloadReferenceVersion = payloadReferenceVersion;</span>
<span class="fc" id="L102">        return this;</span>
    }

<span class="fc" id="L105">    public GraphLock lock() { return _lock; }</span>

    public GraphNodeAssemblyState&lt;V&gt; setLock(GraphLock lock) {
<span class="fc" id="L108">        _lock = lock;</span>
<span class="fc" id="L109">        return this;</span>
    }

<span class="fc" id="L112">    public long nodeID() { return _nodeID; }</span>

    public GraphNodeAssemblyState&lt;V&gt; setNodeID(long nodeID) {
<span class="fc" id="L115">        _nodeID = nodeID;</span>
<span class="fc" id="L116">        return this;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>