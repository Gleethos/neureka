<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GEMM.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.backend.main.operations.linear.internal.blas</a> &gt; <span class="el_source">GEMM.java</span></div><h1>GEMM.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
package neureka.backend.main.operations.linear.internal.blas;

import neureka.devices.host.CPU;

/**
 *  A collection of primitive sub-routines for matrix multiplication performed on
 *  continuous arrays which are designed so that they can be vectorized by the
 *  JVMs JIT compiler (AVX instructions).
 */
<span class="nc" id="L33">public class GEMM {</span>

    @FunctionalInterface
    public interface VectorOperationF32 {
        void invoke(
                float[] product,
                float[] left,
                int complexity,
                float[] right
        );
    }

    @FunctionalInterface
    public interface VectorOperationF64 {
        void invoke(
                double[] product,
                double[] left,
                int complexity,
                double[] right
        );
    }

    public static VectorOperationF32 operationForF32(
            boolean rowMajor, final long rows, final long columns
    ) {
<span class="pc bpc" id="L58" title="1 of 4 branches missed.">        if ( rows &gt; CPU.PARALLELIZATION_THRESHOLD &amp;&amp; columns &gt; CPU.PARALLELIZATION_THRESHOLD) {</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">            return ( rowMajor</span>
<span class="fc" id="L60">                    ? GEMM::threaded_F32_MxN_RM</span>
<span class="fc" id="L61">                    : GEMM::threaded_F32_MxN_CM</span>
                );
        }
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if ( columns == 1 ) {</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">            return ( rowMajor</span>
<span class="fc" id="L66">                    ? GEMM::full_F32_Mx1_RM</span>
<span class="fc" id="L67">                    : GEMM::full_F32_Mx1_CM</span>
                );
        }
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if ( rows == 1 )</span>
<span class="fc" id="L71">            return (</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">                    rowMajor</span>
<span class="fc" id="L73">                            ? GEMM::full_F32_1xN_RM</span>
<span class="fc" id="L74">                            : GEMM::full_F32_1xN_CM</span>
            );
<span class="fc" id="L76">        return (</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">                rowMajor</span>
<span class="fc" id="L78">                        ? GEMM::full_F32_MxN_RM</span>
<span class="fc" id="L79">                        : GEMM::full_F32_MxN_CM</span>
            );
    }

    public static VectorOperationF64 operationForF64(
            boolean rowMajor, final long rows, final long columns
    ) {
<span class="pc bpc" id="L86" title="1 of 4 branches missed.">        if ( rows &gt; CPU.PARALLELIZATION_THRESHOLD &amp;&amp; columns &gt; CPU.PARALLELIZATION_THRESHOLD )</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            return ( rowMajor</span>
<span class="fc" id="L88">                ? GEMM::threaded_F64_MxN_RM</span>
<span class="fc" id="L89">                : GEMM::threaded_F64_MxN_CM</span>
            );

<span class="fc bfc" id="L92" title="All 2 branches covered.">        if ( !rowMajor ) { // Supported in column major only!</span>
<span class="fc bfc" id="L93" title="All 4 branches covered.">            if (rows == 5 &amp;&amp; columns == 5) return GEMM::full_F64_5x5_CM;</span>
<span class="fc bfc" id="L94" title="All 4 branches covered.">            if (rows == 4 &amp;&amp; columns == 4) return GEMM::full_F64_4x4_CM;</span>
<span class="fc bfc" id="L95" title="All 4 branches covered.">            if (rows == 3 &amp;&amp; columns == 3) return GEMM::full_F64_3x3_CM;</span>
<span class="fc bfc" id="L96" title="All 4 branches covered.">            if (rows == 2 &amp;&amp; columns == 2) return GEMM::full_F64_2x2_CM;</span>
<span class="fc bfc" id="L97" title="All 4 branches covered.">            if (rows == 1 &amp;&amp; columns == 1) return GEMM::full_F64_1x1_CM;</span>
        }
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if ( columns == 1 )</span>
<span class="fc" id="L100">            return (</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">                rowMajor</span>
<span class="fc" id="L102">                    ? GEMM::full_F64_Mx1_RM</span>
<span class="fc" id="L103">                    : GEMM::full_F64_Mx1_CM</span>
            );

<span class="fc bfc" id="L106" title="All 2 branches covered.">        if ( !rowMajor ) { // Supported in column major only!</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if ( rows == 10) return GEMM::full_F64_0xN_CM;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if ( rows == 9 ) return GEMM::full_F64_9xN_CM;</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            if ( rows == 8 ) return GEMM::full_F64_8xN_CM;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            if ( rows == 7 ) return GEMM::full_F64_7xN_CM;</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            if ( rows == 6 ) return GEMM::full_F64_6xN_CM;</span>
        }
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if ( rows == 1 )</span>
<span class="fc" id="L114">            return (</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                    rowMajor</span>
<span class="fc" id="L116">                            ? GEMM::full_F64_1xN_RM</span>
<span class="fc" id="L117">                            : GEMM::full_F64_1xN_CM</span>
                );

<span class="fc" id="L120">        return (</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">                rowMajor</span>
<span class="fc" id="L122">                        ? GEMM::full_F64_MxN_RM</span>
<span class="fc" id="L123">                        : GEMM::full_F64_MxN_CM</span>
            );
    }

    static void full_F64_Mx1_CM(
            final double[] product,
            final double[] left,
            final int colCount,
            final double[] right
    ) {
<span class="fc" id="L133">        int rowCount = product.length;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for ( int c = 0; c &lt; colCount; c++ ) {</span>
<span class="fc" id="L135">            AXPY.invoke(</span>
                    product,
                    0,
                    right[c],
                    left,
                    c * rowCount,
                    0,
                    rowCount
            );
        }
<span class="fc" id="L145">    }</span>

    static void full_F64_Mx1_RM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L153">        int colCount = right.length;</span>
<span class="fc" id="L154">        int leftRowCount = left.length / complexity;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        for (int ri = 0; ri &lt; leftRowCount; ri++) {</span>
<span class="fc" id="L156">            product[ri] =</span>
<span class="fc" id="L157">                 DOT.invoke(</span>
                         left,
                         ri * complexity,
                         right,
                         0,
                         0,
                         colCount
                 );
        }
<span class="fc" id="L166">    }</span>

    static void full_F32_Mx1_CM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L174">        int nbRows = product.length;</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L177">            AXPY.invoke(</span>
                    product,
                    0,
                    right[c],
                    left,
                    c * nbRows,
                    0, nbRows
            );
        }
<span class="fc" id="L186">    }</span>

    static void full_F32_Mx1_RM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L194">            int colCount = right.length;</span>
<span class="fc" id="L195">            int leftRowCount = left.length / complexity;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            for ( int ri = 0; ri &lt; leftRowCount; ri++ ) {</span>
<span class="fc" id="L197">                product[ri] =</span>
<span class="fc" id="L198">                        DOT.invoke(</span>
                                left,
                                ri * complexity,
                                right,
                                0,
                                0,
                                colCount
                        );
            }
<span class="fc" id="L207">    }</span>

    static void partial_F64_MxN_CM(
            final double[] product,
            final int firstColumn,
            final int columnLimit,
            final double[] left,
            final int commonColumnCount,
            final double[] right
    ) {
<span class="fc" id="L217">        int leftRowCount = left.length / commonColumnCount;</span>

<span class="fc bfc" id="L219" title="All 2 branches covered.">        for ( int ci = 0; ci &lt; commonColumnCount; ci++ ) {</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            for ( int j = firstColumn; j &lt; columnLimit; j++ ) {</span>
<span class="fc" id="L221">                AXPY.invoke(</span>
                        product,
                        j * leftRowCount,
                        right[ci + j * commonColumnCount],
                        left,
                        ci * leftRowCount,
                        0,
                        leftRowCount
                );
            }
        }
<span class="fc" id="L232">    }</span>

    static void partial_F64_MxN_RM(
        final double[] product,
        final int firstRow,
        final int rowLimit,
        final double[] left,
        final int complexity,
        final double[] right
    ) {
<span class="fc" id="L242">        int rightCols = right.length / complexity;</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        for ( int c = 0; c &lt; complexity; c++ ) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">            for ( int j = firstRow; j &lt; rowLimit; j++ ) {</span>
<span class="fc" id="L245">                AXPY.invoke(</span>
                        product,
                        j * rightCols,
                        left[c + j * complexity],
                        right,
                        c * rightCols,
                        0,
                        rightCols
                );
            }
        }
<span class="fc" id="L256">    }</span>

    static void partial_F32_MxN_CM(
            final float[] product,
            final int firstColumn, // right column
            final int columnLimit,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L266">        int nbRows = left.length / complexity;</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        for ( int c = 0; c &lt; complexity; c++ ) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            for ( int j = firstColumn; j &lt; columnLimit; j++ ) {</span>
<span class="fc" id="L269">                AXPY.invoke(</span>
                        product,
                        j * nbRows,
                        right[c + j * complexity],
                        left,
                        c * nbRows,
                        0,
                        nbRows
                );
            }
        }
<span class="fc" id="L280">    }</span>

    static void partial_F32_MxN_RM(
        final float[] product,
        final int firstRow, // left row
        final int rowLimit,
        final float[] left,
        final int complexity,
        final float[] right
    ) {
<span class="fc" id="L290">        int rightCols = right.length / complexity;</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        for ( int c = 0; c &lt; complexity; c++ ) {</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">            for ( int j = firstRow; j &lt; rowLimit; j++ ) {</span>
<span class="fc" id="L293">                AXPY.invoke(</span>
                        product,
                        j * rightCols,
                        left[c + j * complexity],
                        right,
                        c * rightCols,
                        0,
                        rightCols
                );
            }
        }
<span class="fc" id="L304">    }</span>


    static void threaded_F64_MxN_CM(final double[] product, final double[] left, final int complexity, final double[] right) {
<span class="fc" id="L308">        CPU.get()</span>
<span class="fc" id="L309">           .getExecutor()</span>
<span class="fc" id="L310">           .threaded(</span>
                0,
                right.length / complexity,
<span class="fc" id="L313">                (f, l) -&gt; GEMM.partial_F64_MxN_CM(product, f, l, left, complexity, right)</span>
            );
<span class="fc" id="L315">    }</span>

    static void threaded_F32_MxN_CM(final float[] product, final float[] left, final int complexity, final float[] right) {
<span class="fc" id="L318">        CPU.get()</span>
<span class="fc" id="L319">           .getExecutor()</span>
<span class="fc" id="L320">           .threaded(</span>
                0,
                right.length / complexity,
<span class="fc" id="L323">                (f, l) -&gt; GEMM.partial_F32_MxN_CM(product, f, l, left, complexity, right)</span>
            );
<span class="fc" id="L325">    }</span>

    static void threaded_F32_MxN_RM(final float[] product, final float[] left, final int complexity, final float[] right) {
<span class="fc" id="L328">        CPU.get()</span>
<span class="fc" id="L329">           .getExecutor()</span>
<span class="fc" id="L330">           .threaded(</span>
                0,
                left.length / complexity,
<span class="fc" id="L333">                (f, l) -&gt; GEMM.partial_F32_MxN_RM(product, f, l, left, complexity, right)</span>
            );
<span class="fc" id="L335">    }</span>

    static void threaded_F64_MxN_RM(final double[] product, final double[] left, final int complexity, final double[] right) {
<span class="fc" id="L338">        CPU.get()</span>
<span class="fc" id="L339">           .getExecutor()</span>
<span class="fc" id="L340">           .threaded(</span>
                0,
                left.length / complexity,
<span class="fc" id="L343">                (f, l) -&gt; GEMM.partial_F64_MxN_RM(product, f, l, left, complexity, right)</span>
            );
<span class="fc" id="L345">    }</span>

    static void full_F64_0xN_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {

<span class="fc" id="L354">        int tmpRowDim = 10;</span>
<span class="fc" id="L355">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L357" title="All 2 branches covered.">        for ( int j = 0; j &lt; tmpColDim; j++ ) {</span>

<span class="fc" id="L359">            double tmp0J = 0.0;</span>
<span class="fc" id="L360">            double tmp1J = 0.0;</span>
<span class="fc" id="L361">            double tmp2J = 0.0;</span>
<span class="fc" id="L362">            double tmp3J = 0.0;</span>
<span class="fc" id="L363">            double tmp4J = 0.0;</span>
<span class="fc" id="L364">            double tmp5J = 0.0;</span>
<span class="fc" id="L365">            double tmp6J = 0.0;</span>
<span class="fc" id="L366">            double tmp7J = 0.0;</span>
<span class="fc" id="L367">            double tmp8J = 0.0;</span>
<span class="fc" id="L368">            double tmp9J = 0.0;</span>

<span class="fc" id="L370">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">            for ( int c = 0; c &lt; complexity; c++ ) {</span>
<span class="fc" id="L372">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L373">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L374">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L375">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L376">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L377">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L378">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L379">                tmp6J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L380">                tmp7J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L381">                tmp8J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L382">                tmp9J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L385">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L386">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L387">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L388">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L389">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L390">            product[++tmpIndex] = tmp5J;</span>
<span class="fc" id="L391">            product[++tmpIndex] = tmp6J;</span>
<span class="fc" id="L392">            product[++tmpIndex] = tmp7J;</span>
<span class="fc" id="L393">            product[++tmpIndex] = tmp8J;</span>
<span class="fc" id="L394">            product[++tmpIndex] = tmp9J;</span>
        }
<span class="fc" id="L396">    }</span>

    static void full_F64_1x1_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L404">        double tmp00 = 0.0;</span>

<span class="fc" id="L406">        int nbRows = left.length / complexity;</span>

<span class="fc bfc" id="L408" title="All 2 branches covered.">        for ( int c = 0; c &lt; complexity; c++ )</span>
<span class="fc" id="L409">            tmp00 += left[c * nbRows] * right[c];</span>

<span class="fc" id="L411">        product[0] = tmp00;</span>
<span class="fc" id="L412">    }</span>

    static void full_F64_1xN_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc bfc" id="L420" title="All 2 branches covered.">        for ( int j = 0, nbCols = product.length; j &lt; nbCols; j++ )</span>
<span class="fc" id="L421">            product[j] = DOT.invoke(left, 0, right, j * complexity, 0, complexity);</span>
<span class="fc" id="L422">    }</span>

    static void full_F64_1xN_RM(
            final double[] product,
            final double[] left,
            final int rowCount,
            final double[] right
    ) {//...
<span class="fc" id="L430">        int rightColCount = right.length / rowCount;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">        for ( int ci = 0; ci &lt; rowCount; ci++ ) {</span>
<span class="fc" id="L432">            AXPY.invoke(</span>
                    product,
                    0,
                    left[ci],
                    right,
                    ci * rightColCount,
                    0,
                    rightColCount
            );
        }
<span class="fc" id="L442">    }</span>

    static void full_F32_1xN_CM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc bfc" id="L450" title="All 2 branches covered.">        for (int j = 0, nbCols = product.length; j &lt; nbCols; j++) {</span>
<span class="fc" id="L451">            product[j] = DOT.invoke(left, 0, right, j * complexity, 0, complexity);</span>
        }
<span class="fc" id="L453">    }</span>


    static void full_F32_1xN_RM(
            final float[] product,
            final float[] left,
            final int rowCount,
            final float[] right
    ) {//...
<span class="fc" id="L462">        int rightColCount = right.length / rowCount;</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">        for ( int ci = 0; ci &lt; rowCount; ci++ ) {</span>
<span class="fc" id="L464">            AXPY.invoke(</span>
                product,
                0,
                left[ci],
                right,
                ci * rightColCount,
                0,
                rightColCount
            );
        }
<span class="fc" id="L474">    }</span>


    static void full_F64_2x2_CM(
        final double[] product,
        final double[] left,
        final int complexity,
        final double[] right
    ) {
<span class="fc" id="L483">        double tmp00 = 0.0;</span>
<span class="fc" id="L484">        double tmp10 = 0.0;</span>
<span class="fc" id="L485">        double tmp01 = 0.0;</span>
<span class="fc" id="L486">        double tmp11 = 0.0;</span>

        int tmpIndex;
<span class="fc bfc" id="L489" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>

<span class="fc" id="L491">            tmpIndex = c * 2;</span>
<span class="fc" id="L492">            double tmpLeft0 = left[tmpIndex];</span>
<span class="fc" id="L493">            tmpIndex++;</span>
<span class="fc" id="L494">            double tmpLeft1 = left[tmpIndex];</span>
<span class="fc" id="L495">            tmpIndex = c;</span>
<span class="fc" id="L496">            double tmpRight0 = right[tmpIndex];</span>
<span class="fc" id="L497">            tmpIndex += complexity;</span>
<span class="fc" id="L498">            double tmpRight1 = right[tmpIndex];</span>

<span class="fc" id="L500">            tmp00 += tmpLeft0 * tmpRight0;</span>
<span class="fc" id="L501">            tmp10 += tmpLeft1 * tmpRight0;</span>
<span class="fc" id="L502">            tmp01 += tmpLeft0 * tmpRight1;</span>
<span class="fc" id="L503">            tmp11 += tmpLeft1 * tmpRight1;</span>
        }

<span class="fc" id="L506">        product[0] = tmp00;</span>
<span class="fc" id="L507">        product[1] = tmp10;</span>
<span class="fc" id="L508">        product[2] = tmp01;</span>
<span class="fc" id="L509">        product[3] = tmp11;</span>
<span class="fc" id="L510">    }</span>

    static void full_F64_3x3_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L518">        double tmp00 = 0.0;</span>
<span class="fc" id="L519">        double tmp10 = 0.0;</span>
<span class="fc" id="L520">        double tmp20 = 0.0;</span>
<span class="fc" id="L521">        double tmp01 = 0.0;</span>
<span class="fc" id="L522">        double tmp11 = 0.0;</span>
<span class="fc" id="L523">        double tmp21 = 0.0;</span>
<span class="fc" id="L524">        double tmp02 = 0.0;</span>
<span class="fc" id="L525">        double tmp12 = 0.0;</span>
<span class="fc" id="L526">        double tmp22 = 0.0;</span>

        int tmpIndex;
<span class="fc bfc" id="L529" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>

<span class="fc" id="L531">            tmpIndex = c * 3;</span>
<span class="fc" id="L532">            double tmpLeft0 = left[tmpIndex];</span>
<span class="fc" id="L533">            tmpIndex++;</span>
<span class="fc" id="L534">            double tmpLeft1 = left[tmpIndex];</span>
<span class="fc" id="L535">            tmpIndex++;</span>
<span class="fc" id="L536">            double tmpLeft2 = left[tmpIndex];</span>
<span class="fc" id="L537">            tmpIndex = c;</span>
<span class="fc" id="L538">            double tmpRight0 = right[tmpIndex];</span>
<span class="fc" id="L539">            tmpIndex += complexity;</span>
<span class="fc" id="L540">            double tmpRight1 = right[tmpIndex];</span>
<span class="fc" id="L541">            tmpIndex += complexity;</span>
<span class="fc" id="L542">            double tmpRight2 = right[tmpIndex];</span>

<span class="fc" id="L544">            tmp00 += tmpLeft0 * tmpRight0;</span>
<span class="fc" id="L545">            tmp10 += tmpLeft1 * tmpRight0;</span>
<span class="fc" id="L546">            tmp20 += tmpLeft2 * tmpRight0;</span>
<span class="fc" id="L547">            tmp01 += tmpLeft0 * tmpRight1;</span>
<span class="fc" id="L548">            tmp11 += tmpLeft1 * tmpRight1;</span>
<span class="fc" id="L549">            tmp21 += tmpLeft2 * tmpRight1;</span>
<span class="fc" id="L550">            tmp02 += tmpLeft0 * tmpRight2;</span>
<span class="fc" id="L551">            tmp12 += tmpLeft1 * tmpRight2;</span>
<span class="fc" id="L552">            tmp22 += tmpLeft2 * tmpRight2;</span>
        }

<span class="fc" id="L555">        product[0] = tmp00;</span>
<span class="fc" id="L556">        product[1] = tmp10;</span>
<span class="fc" id="L557">        product[2] = tmp20;</span>
<span class="fc" id="L558">        product[3] = tmp01;</span>
<span class="fc" id="L559">        product[4] = tmp11;</span>
<span class="fc" id="L560">        product[5] = tmp21;</span>
<span class="fc" id="L561">        product[6] = tmp02;</span>
<span class="fc" id="L562">        product[7] = tmp12;</span>
<span class="fc" id="L563">        product[8] = tmp22;</span>
<span class="fc" id="L564">    }</span>

    static void full_F64_4x4_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L572">        double tmp00 = 0.0;</span>
<span class="fc" id="L573">        double tmp10 = 0.0;</span>
<span class="fc" id="L574">        double tmp20 = 0.0;</span>
<span class="fc" id="L575">        double tmp30 = 0.0;</span>
<span class="fc" id="L576">        double tmp01 = 0.0;</span>
<span class="fc" id="L577">        double tmp11 = 0.0;</span>
<span class="fc" id="L578">        double tmp21 = 0.0;</span>
<span class="fc" id="L579">        double tmp31 = 0.0;</span>
<span class="fc" id="L580">        double tmp02 = 0.0;</span>
<span class="fc" id="L581">        double tmp12 = 0.0;</span>
<span class="fc" id="L582">        double tmp22 = 0.0;</span>
<span class="fc" id="L583">        double tmp32 = 0.0;</span>
<span class="fc" id="L584">        double tmp03 = 0.0;</span>
<span class="fc" id="L585">        double tmp13 = 0.0;</span>
<span class="fc" id="L586">        double tmp23 = 0.0;</span>
<span class="fc" id="L587">        double tmp33 = 0.0;</span>

        int tmpIndex;
<span class="fc bfc" id="L590" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>

<span class="fc" id="L592">            tmpIndex = c * 4;</span>
<span class="fc" id="L593">            double tmpLeft0 = left[tmpIndex];</span>
<span class="fc" id="L594">            tmpIndex++;</span>
<span class="fc" id="L595">            double tmpLeft1 = left[tmpIndex];</span>
<span class="fc" id="L596">            tmpIndex++;</span>
<span class="fc" id="L597">            double tmpLeft2 = left[tmpIndex];</span>
<span class="fc" id="L598">            tmpIndex++;</span>
<span class="fc" id="L599">            double tmpLeft3 = left[tmpIndex];</span>
<span class="fc" id="L600">            tmpIndex = c;</span>
<span class="fc" id="L601">            double tmpRight0 = right[tmpIndex];</span>
<span class="fc" id="L602">            tmpIndex += complexity;</span>
<span class="fc" id="L603">            double tmpRight1 = right[tmpIndex];</span>
<span class="fc" id="L604">            tmpIndex += complexity;</span>
<span class="fc" id="L605">            double tmpRight2 = right[tmpIndex];</span>
<span class="fc" id="L606">            tmpIndex += complexity;</span>
<span class="fc" id="L607">            double tmpRight3 = right[tmpIndex];</span>

<span class="fc" id="L609">            tmp00 += tmpLeft0 * tmpRight0;</span>
<span class="fc" id="L610">            tmp10 += tmpLeft1 * tmpRight0;</span>
<span class="fc" id="L611">            tmp20 += tmpLeft2 * tmpRight0;</span>
<span class="fc" id="L612">            tmp30 += tmpLeft3 * tmpRight0;</span>
<span class="fc" id="L613">            tmp01 += tmpLeft0 * tmpRight1;</span>
<span class="fc" id="L614">            tmp11 += tmpLeft1 * tmpRight1;</span>
<span class="fc" id="L615">            tmp21 += tmpLeft2 * tmpRight1;</span>
<span class="fc" id="L616">            tmp31 += tmpLeft3 * tmpRight1;</span>
<span class="fc" id="L617">            tmp02 += tmpLeft0 * tmpRight2;</span>
<span class="fc" id="L618">            tmp12 += tmpLeft1 * tmpRight2;</span>
<span class="fc" id="L619">            tmp22 += tmpLeft2 * tmpRight2;</span>
<span class="fc" id="L620">            tmp32 += tmpLeft3 * tmpRight2;</span>
<span class="fc" id="L621">            tmp03 += tmpLeft0 * tmpRight3;</span>
<span class="fc" id="L622">            tmp13 += tmpLeft1 * tmpRight3;</span>
<span class="fc" id="L623">            tmp23 += tmpLeft2 * tmpRight3;</span>
<span class="fc" id="L624">            tmp33 += tmpLeft3 * tmpRight3;</span>
        }

<span class="fc" id="L627">        product[0] = tmp00;</span>
<span class="fc" id="L628">        product[1] = tmp10;</span>
<span class="fc" id="L629">        product[2] = tmp20;</span>
<span class="fc" id="L630">        product[3] = tmp30;</span>
<span class="fc" id="L631">        product[4] = tmp01;</span>
<span class="fc" id="L632">        product[5] = tmp11;</span>
<span class="fc" id="L633">        product[6] = tmp21;</span>
<span class="fc" id="L634">        product[7] = tmp31;</span>
<span class="fc" id="L635">        product[8] = tmp02;</span>
<span class="fc" id="L636">        product[9] = tmp12;</span>
<span class="fc" id="L637">        product[10] = tmp22;</span>
<span class="fc" id="L638">        product[11] = tmp32;</span>
<span class="fc" id="L639">        product[12] = tmp03;</span>
<span class="fc" id="L640">        product[13] = tmp13;</span>
<span class="fc" id="L641">        product[14] = tmp23;</span>
<span class="fc" id="L642">        product[15] = tmp33;</span>
<span class="fc" id="L643">    }</span>

    static void full_F64_5x5_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L651">        double tmp00 = 0.0;</span>
<span class="fc" id="L652">        double tmp10 = 0.0;</span>
<span class="fc" id="L653">        double tmp20 = 0.0;</span>
<span class="fc" id="L654">        double tmp30 = 0.0;</span>
<span class="fc" id="L655">        double tmp40 = 0.0;</span>
<span class="fc" id="L656">        double tmp01 = 0.0;</span>
<span class="fc" id="L657">        double tmp11 = 0.0;</span>
<span class="fc" id="L658">        double tmp21 = 0.0;</span>
<span class="fc" id="L659">        double tmp31 = 0.0;</span>
<span class="fc" id="L660">        double tmp41 = 0.0;</span>
<span class="fc" id="L661">        double tmp02 = 0.0;</span>
<span class="fc" id="L662">        double tmp12 = 0.0;</span>
<span class="fc" id="L663">        double tmp22 = 0.0;</span>
<span class="fc" id="L664">        double tmp32 = 0.0;</span>
<span class="fc" id="L665">        double tmp42 = 0.0;</span>
<span class="fc" id="L666">        double tmp03 = 0.0;</span>
<span class="fc" id="L667">        double tmp13 = 0.0;</span>
<span class="fc" id="L668">        double tmp23 = 0.0;</span>
<span class="fc" id="L669">        double tmp33 = 0.0;</span>
<span class="fc" id="L670">        double tmp43 = 0.0;</span>
<span class="fc" id="L671">        double tmp04 = 0.0;</span>
<span class="fc" id="L672">        double tmp14 = 0.0;</span>
<span class="fc" id="L673">        double tmp24 = 0.0;</span>
<span class="fc" id="L674">        double tmp34 = 0.0;</span>
<span class="fc" id="L675">        double tmp44 = 0.0;</span>

        int tmpIndex;
<span class="fc bfc" id="L678" title="All 2 branches covered.">        for (int c = 0; c &lt; complexity; c++) {</span>

<span class="fc" id="L680">            tmpIndex = c * 5;</span>
<span class="fc" id="L681">            double tmpLeft0 = left[tmpIndex];</span>
<span class="fc" id="L682">            tmpIndex++;</span>
<span class="fc" id="L683">            double tmpLeft1 = left[tmpIndex];</span>
<span class="fc" id="L684">            tmpIndex++;</span>
<span class="fc" id="L685">            double tmpLeft2 = left[tmpIndex];</span>
<span class="fc" id="L686">            tmpIndex++;</span>
<span class="fc" id="L687">            double tmpLeft3 = left[tmpIndex];</span>
<span class="fc" id="L688">            tmpIndex++;</span>
<span class="fc" id="L689">            double tmpLeft4 = left[tmpIndex];</span>
<span class="fc" id="L690">            tmpIndex = c;</span>
<span class="fc" id="L691">            double tmpRight0 = right[tmpIndex];</span>
<span class="fc" id="L692">            tmpIndex += complexity;</span>
<span class="fc" id="L693">            double tmpRight1 = right[tmpIndex];</span>
<span class="fc" id="L694">            tmpIndex += complexity;</span>
<span class="fc" id="L695">            double tmpRight2 = right[tmpIndex];</span>
<span class="fc" id="L696">            tmpIndex += complexity;</span>
<span class="fc" id="L697">            double tmpRight3 = right[tmpIndex];</span>
<span class="fc" id="L698">            tmpIndex += complexity;</span>
<span class="fc" id="L699">            double tmpRight4 = right[tmpIndex];</span>

<span class="fc" id="L701">            tmp00 += tmpLeft0 * tmpRight0;</span>
<span class="fc" id="L702">            tmp10 += tmpLeft1 * tmpRight0;</span>
<span class="fc" id="L703">            tmp20 += tmpLeft2 * tmpRight0;</span>
<span class="fc" id="L704">            tmp30 += tmpLeft3 * tmpRight0;</span>
<span class="fc" id="L705">            tmp40 += tmpLeft4 * tmpRight0;</span>
<span class="fc" id="L706">            tmp01 += tmpLeft0 * tmpRight1;</span>
<span class="fc" id="L707">            tmp11 += tmpLeft1 * tmpRight1;</span>
<span class="fc" id="L708">            tmp21 += tmpLeft2 * tmpRight1;</span>
<span class="fc" id="L709">            tmp31 += tmpLeft3 * tmpRight1;</span>
<span class="fc" id="L710">            tmp41 += tmpLeft4 * tmpRight1;</span>
<span class="fc" id="L711">            tmp02 += tmpLeft0 * tmpRight2;</span>
<span class="fc" id="L712">            tmp12 += tmpLeft1 * tmpRight2;</span>
<span class="fc" id="L713">            tmp22 += tmpLeft2 * tmpRight2;</span>
<span class="fc" id="L714">            tmp32 += tmpLeft3 * tmpRight2;</span>
<span class="fc" id="L715">            tmp42 += tmpLeft4 * tmpRight2;</span>
<span class="fc" id="L716">            tmp03 += tmpLeft0 * tmpRight3;</span>
<span class="fc" id="L717">            tmp13 += tmpLeft1 * tmpRight3;</span>
<span class="fc" id="L718">            tmp23 += tmpLeft2 * tmpRight3;</span>
<span class="fc" id="L719">            tmp33 += tmpLeft3 * tmpRight3;</span>
<span class="fc" id="L720">            tmp43 += tmpLeft4 * tmpRight3;</span>
<span class="fc" id="L721">            tmp04 += tmpLeft0 * tmpRight4;</span>
<span class="fc" id="L722">            tmp14 += tmpLeft1 * tmpRight4;</span>
<span class="fc" id="L723">            tmp24 += tmpLeft2 * tmpRight4;</span>
<span class="fc" id="L724">            tmp34 += tmpLeft3 * tmpRight4;</span>
<span class="fc" id="L725">            tmp44 += tmpLeft4 * tmpRight4;</span>
        }

<span class="fc" id="L728">        product[0] = tmp00;</span>
<span class="fc" id="L729">        product[1] = tmp10;</span>
<span class="fc" id="L730">        product[2] = tmp20;</span>
<span class="fc" id="L731">        product[3] = tmp30;</span>
<span class="fc" id="L732">        product[4] = tmp40;</span>
<span class="fc" id="L733">        product[5] = tmp01;</span>
<span class="fc" id="L734">        product[6] = tmp11;</span>
<span class="fc" id="L735">        product[7] = tmp21;</span>
<span class="fc" id="L736">        product[8] = tmp31;</span>
<span class="fc" id="L737">        product[9] = tmp41;</span>
<span class="fc" id="L738">        product[10] = tmp02;</span>
<span class="fc" id="L739">        product[11] = tmp12;</span>
<span class="fc" id="L740">        product[12] = tmp22;</span>
<span class="fc" id="L741">        product[13] = tmp32;</span>
<span class="fc" id="L742">        product[14] = tmp42;</span>
<span class="fc" id="L743">        product[15] = tmp03;</span>
<span class="fc" id="L744">        product[16] = tmp13;</span>
<span class="fc" id="L745">        product[17] = tmp23;</span>
<span class="fc" id="L746">        product[18] = tmp33;</span>
<span class="fc" id="L747">        product[19] = tmp43;</span>
<span class="fc" id="L748">        product[20] = tmp04;</span>
<span class="fc" id="L749">        product[21] = tmp14;</span>
<span class="fc" id="L750">        product[22] = tmp24;</span>
<span class="fc" id="L751">        product[23] = tmp34;</span>
<span class="fc" id="L752">        product[24] = tmp44;</span>
<span class="fc" id="L753">    }</span>

    static void full_F64_6xN_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {

<span class="fc" id="L762">        int tmpRowDim = 6;</span>
<span class="fc" id="L763">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L765" title="All 2 branches covered.">        for (int j = 0; j &lt; tmpColDim; j++) {</span>

<span class="fc" id="L767">            double tmp0J = 0.0;</span>
<span class="fc" id="L768">            double tmp1J = 0.0;</span>
<span class="fc" id="L769">            double tmp2J = 0.0;</span>
<span class="fc" id="L770">            double tmp3J = 0.0;</span>
<span class="fc" id="L771">            double tmp4J = 0.0;</span>
<span class="fc" id="L772">            double tmp5J = 0.0;</span>

<span class="fc" id="L774">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">            for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L776">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L777">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L778">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L779">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L780">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L781">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L782">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L785">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L786">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L787">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L788">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L789">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L790">            product[++tmpIndex] = tmp5J;</span>
        }
<span class="fc" id="L792">    }</span>

    static void full_F64_7xN_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {

<span class="fc" id="L801">        int tmpRowDim = 7;</span>
<span class="fc" id="L802">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L804" title="All 2 branches covered.">        for (int j = 0; j &lt; tmpColDim; j++) {</span>

<span class="fc" id="L806">            double tmp0J = 0.0;</span>
<span class="fc" id="L807">            double tmp1J = 0.0;</span>
<span class="fc" id="L808">            double tmp2J = 0.0;</span>
<span class="fc" id="L809">            double tmp3J = 0.0;</span>
<span class="fc" id="L810">            double tmp4J = 0.0;</span>
<span class="fc" id="L811">            double tmp5J = 0.0;</span>
<span class="fc" id="L812">            double tmp6J = 0.0;</span>

<span class="fc" id="L814">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">            for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L816">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L817">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L818">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L819">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L820">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L821">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L822">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L823">                tmp6J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L826">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L827">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L828">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L829">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L830">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L831">            product[++tmpIndex] = tmp5J;</span>
<span class="fc" id="L832">            product[++tmpIndex] = tmp6J;</span>
        }
<span class="fc" id="L834">    }</span>

    static void full_F64_8xN_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {

<span class="fc" id="L843">        int tmpRowDim = 8;</span>
<span class="fc" id="L844">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L846" title="All 2 branches covered.">        for (int j = 0; j &lt; tmpColDim; j++) {</span>

<span class="fc" id="L848">            double tmp0J = 0.0;</span>
<span class="fc" id="L849">            double tmp1J = 0.0;</span>
<span class="fc" id="L850">            double tmp2J = 0.0;</span>
<span class="fc" id="L851">            double tmp3J = 0.0;</span>
<span class="fc" id="L852">            double tmp4J = 0.0;</span>
<span class="fc" id="L853">            double tmp5J = 0.0;</span>
<span class="fc" id="L854">            double tmp6J = 0.0;</span>
<span class="fc" id="L855">            double tmp7J = 0.0;</span>

<span class="fc" id="L857">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">            for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L859">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L860">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L861">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L862">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L863">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L864">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L865">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L866">                tmp6J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L867">                tmp7J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L870">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L871">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L872">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L873">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L874">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L875">            product[++tmpIndex] = tmp5J;</span>
<span class="fc" id="L876">            product[++tmpIndex] = tmp6J;</span>
<span class="fc" id="L877">            product[++tmpIndex] = tmp7J;</span>
        }
<span class="fc" id="L879">    }</span>

    static void full_F64_9xN_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {

<span class="fc" id="L888">        int tmpRowDim = 9;</span>
<span class="fc" id="L889">        int tmpColDim = right.length / complexity;</span>

<span class="fc bfc" id="L891" title="All 2 branches covered.">        for (int j = 0; j &lt; tmpColDim; j++) {</span>

<span class="fc" id="L893">            double tmp0J = 0.0;</span>
<span class="fc" id="L894">            double tmp1J = 0.0;</span>
<span class="fc" id="L895">            double tmp2J = 0.0;</span>
<span class="fc" id="L896">            double tmp3J = 0.0;</span>
<span class="fc" id="L897">            double tmp4J = 0.0;</span>
<span class="fc" id="L898">            double tmp5J = 0.0;</span>
<span class="fc" id="L899">            double tmp6J = 0.0;</span>
<span class="fc" id="L900">            double tmp7J = 0.0;</span>
<span class="fc" id="L901">            double tmp8J = 0.0;</span>

<span class="fc" id="L903">            int tmpIndex = 0;</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">            for (int c = 0; c &lt; complexity; c++) {</span>
<span class="fc" id="L905">                double tmpRightCJ = right[c + j * complexity];</span>
<span class="fc" id="L906">                tmp0J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L907">                tmp1J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L908">                tmp2J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L909">                tmp3J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L910">                tmp4J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L911">                tmp5J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L912">                tmp6J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L913">                tmp7J += left[tmpIndex++] * tmpRightCJ;</span>
<span class="fc" id="L914">                tmp8J += left[tmpIndex++] * tmpRightCJ;</span>
            }

<span class="fc" id="L917">            product[tmpIndex = j * tmpRowDim] = tmp0J;</span>
<span class="fc" id="L918">            product[++tmpIndex] = tmp1J;</span>
<span class="fc" id="L919">            product[++tmpIndex] = tmp2J;</span>
<span class="fc" id="L920">            product[++tmpIndex] = tmp3J;</span>
<span class="fc" id="L921">            product[++tmpIndex] = tmp4J;</span>
<span class="fc" id="L922">            product[++tmpIndex] = tmp5J;</span>
<span class="fc" id="L923">            product[++tmpIndex] = tmp6J;</span>
<span class="fc" id="L924">            product[++tmpIndex] = tmp7J;</span>
<span class="fc" id="L925">            product[++tmpIndex] = tmp8J;</span>
        }
<span class="fc" id="L927">    }</span>

    static void full_F64_MxN_CM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L935">        GEMM.partial_F64_MxN_CM(product, 0, right.length / complexity, left, complexity, right);</span>
<span class="fc" id="L936">    }</span>

    static void full_F64_MxN_RM(
            final double[] product,
            final double[] left,
            final int complexity,
            final double[] right
    ) {
<span class="fc" id="L944">        GEMM.partial_F64_MxN_RM(product, 0, left.length / complexity, left, complexity, right);</span>
<span class="fc" id="L945">    }</span>

    static void full_F32_MxN_CM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L953">        GEMM.partial_F32_MxN_CM(product, 0, right.length / complexity, left, complexity, right);</span>
<span class="fc" id="L954">    }</span>

    static void full_F32_MxN_RM(
            final float[] product,
            final float[] left,
            final int complexity,
            final float[] right
    ) {
<span class="fc" id="L962">        GEMM.partial_F32_MxN_RM(product, 0, left.length / complexity, left, complexity, right);</span>
<span class="fc" id="L963">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>