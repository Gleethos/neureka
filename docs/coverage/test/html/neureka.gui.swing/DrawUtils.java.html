<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DrawUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.gui.swing</a> &gt; <span class="el_source">DrawUtils.java</span></div><h1>DrawUtils.java</h1><pre class="source lang-java linenums">package neureka.gui.swing;

import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.Area;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;

<span class="nc" id="L10">public class DrawUtils {</span>

    private final static int OUTER_REFERENCE_RADIUS = 300;
    private final static int INNER_REFERENCE_RADIUS = 100;

    //=================================================================================================================================================

    public static void IconStar(double x, double y, double r, Graphics2D brush)
    {
<span class="nc" id="L19">        RoundRectangle2D rec = new RoundRectangle2D.Double(</span>
                (x - (r / 10)),
                (y - r * 0.650),
                (2* r / 10),
                (1* r * 0.75),
                (r * 0.4), (r * 0.4)
        );
<span class="nc" id="L26">        int n = 5;</span>
<span class="nc" id="L27">        double theta = 2*Math.PI/n;</span>
<span class="nc bnc" id="L28" title="All 2 branches missed.">        for(int i=0; i&lt;n; i++){</span>
<span class="nc" id="L29">            brush.fill(rec);</span>
<span class="nc bnc" id="L30" title="All 2 branches missed.">            brush.rotate(((i==n-1)?-n+1:1)*theta, x, y);</span>

        }
<span class="nc" id="L33">    }</span>

    public static void IconPlus(double x, double y, double r, Graphics2D brush){
<span class="fc" id="L36">        Rectangle2D rec = new Rectangle2D.Double(</span>
                (x - (r / 10)),
                (y - r * 0.650),
                (2* r / 10),
                (1* r * 0.75)
        );
<span class="fc" id="L42">        int n = 4;</span>
<span class="fc" id="L43">        double theta = 2*Math.PI/n;</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">        for(int i=0; i&lt;n; i++){</span>
<span class="fc" id="L45">            brush.fill(rec);</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">            brush.rotate(((i==n-1)?-n+1:1)*theta, x, y);</span>

        }
<span class="fc" id="L49">    }</span>

    //------------------------------------------------
    /*
    public static void IconClose(double x, double y, Graphics2D brush, double birthScale, double animScale) {
        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;
        double ovalRadius = (radius - innerRadius) / 3;
        brush.setColor(new Color(255, 70, 50));
        brush.fillOval((int) (x - ovalRadius), (int) (y - ovalRadius), (int) (ovalRadius * 2), (int) (ovalRadius * 2));
        ovalRadius *= 0.75;
        brush.rotate(Math.PI * 0.25, x, y);
        brush.setColor(Color.BLACK);
        brush.fillRect((int) (x - ovalRadius), (int) (y - ovalRadius / 5), (int) (ovalRadius * 2), (int) (ovalRadius * 2 / 5));
        brush.fillRect((int) (x - ovalRadius / 5), (int) (y - ovalRadius), (int) (ovalRadius * 2 / 5), (int) (ovalRadius * 2));
        brush.rotate(-Math.PI * 0.25, x, y);
    }
    */
    //------------------------------------------------

    /*
    public static void IconBasicRoot(double x, double y, Graphics2D brush, double birthScale, double animScale) {
        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;
        double ovalRadius = (radius - innerRadius) / 5;
        brush.setColor(Color.BLACK);
        double oX = x + ovalRadius / 2.55;
        double oY = y + ovalRadius / 2.55;

        IconNodeBase(x, y, brush, birthScale, 1.0);
        brush.setColor(Color.CYAN);
        brush.fillRect((int) (oX - ovalRadius / 2), (int) (oY - ovalRadius / 16),
                (int) (2 * ovalRadius / 2), (int) (2 * ovalRadius / 16));
        brush.fillRect((int) (oX - ovalRadius / 16), (int) (oY - ovalRadius / 2),
                (int) (2 * ovalRadius / 16), (int) (2 * ovalRadius / 2));
        brush.rotate(Math.PI / 4, oX, oY);
        brush.fillRect((int) (oX - ovalRadius / 2), (int) (oY - ovalRadius / 16),
                (int) (2 * ovalRadius / 2), (int) (2 * ovalRadius / 16));
        brush.fillRect((int) (oX - ovalRadius / 16), (int) (oY - ovalRadius / 2),
                (int) (2 * ovalRadius / 16), (int) (2 * ovalRadius / 2));
        brush.rotate(-Math.PI / 4, oX, oY);
    }
    */
    /*
    //------------------------------------------------
    public static void IconNodeType(double x, double y, Graphics2D brush, double birthScale, double animScale) {
        //IconDefaultNode(x,y,brush, birthScale, 1.0);
        IconNodeBase(x, y, brush, birthScale, 1.0);
        brush.setColor(Color.cyan);
        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;
        double ovalRadius = ((radius - innerRadius) / 5);
        double oX = x + ovalRadius / 2.55;
        double oY = y + ovalRadius / 2.55;
        Font txt = new Font(&quot;Verdana&quot;, Font.LAYOUT_LEFT_TO_RIGHT, (int) ((70 / birthScale) * animScale));
        brush.setFont(txt);
        char[] c = new char[1];
        c[0] = '?';
        brush.drawChars(c, 0, 1, (int) (oX - ovalRadius / 2), (int) (oY + ovalRadius / 1.5));
    }
    */
    /*
    //------------------------------------------------
    public static void IconDefaultNode(double x, double y, Graphics2D brush, double birthScale, double animScale) {
        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;
        double ovalRadius = ((radius - innerRadius) / 5);
        if (ovalRadius &lt;= 0) {
            return;
        }
        brush.setColor(Color.BLACK);
        double oX = x + ovalRadius / 2.55;
        double oY = y + ovalRadius / 2.55;
        brush.fillOval((int) (oX - ovalRadius), (int) (oY - ovalRadius),
                (int) (2 * ovalRadius), (int) (2 * ovalRadius));
        brush.setColor(PaletteUtils.NEURAL_BLUE);
        //brush.setColor(Color.BLACK);
        brush.fillOval((int) (oX - ovalRadius * 0.8), (int) (oY - ovalRadius * 0.8),
                (int) (2 * ovalRadius * 0.8), (int) (2 * ovalRadius * 0.8));
        //----------------------------
        brush.setColor(Color.BLACK);
        ovalRadius = (radius - innerRadius) / 15;
        oX = (x - ovalRadius);
        oY = (y - ovalRadius);
        brush.setStroke(new BasicStroke((int) (ovalRadius / 2)));
        brush.drawLine((int) (oX), (int) (oY), (int) (oX - 3 * ovalRadius), (int) (oY));
        brush.rotate(Math.PI / 4, oX, oY);
        brush.drawLine((int) (oX), (int) (oY), (int) (oX - 3 * ovalRadius), (int) (oY));
        brush.rotate(Math.PI / 4, oX, oY);
        brush.drawLine((int) (oX), (int) (oY), (int) (oX - 3 * ovalRadius), (int) (oY));
        brush.rotate(-Math.PI / 2, oX, oY);

        brush.fillOval((int) (oX - ovalRadius), (int) (oY - ovalRadius),
                (int) (2 * ovalRadius), (int) (2 * ovalRadius));
        brush.setColor(Color.CYAN);
        brush.fillRect((int) (oX - ovalRadius / 2), (int) (oY - ovalRadius / 6),
                (int) (2 * ovalRadius / 2), (int) (2 * ovalRadius / 6));
        brush.fillRect((int) (oX - ovalRadius / 6), (int) (oY - ovalRadius / 2),
                (int) (2 * ovalRadius / 6), (int) (2 * ovalRadius / 2));
    }

    */
    //------------------------------------------------
    /*

    public static void IconNodeFunctionSettings(double x, double y, Graphics2D brush, double birthScale, double animScale) {

        IconDefaultNode(x, y, brush, birthScale, 1.0);
        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;
        double ovalRadius = (radius - innerRadius) / 5;
        brush.setColor(Color.BLACK);
        double oX = x + ovalRadius / 2.55;
        double oY = y + ovalRadius / 2.55;
        double scaleHolder = birthScale;
        birthScale *= 2.5;
        IconPanelSettings(oX, oY, brush, birthScale, 1.0);
        birthScale = scaleHolder;
    }
    */
    /*
    //------------------------------------------------
    public static void IconSuperRoot(double x, double y, Graphics2D brush, double birthScale, double animScale) {

        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;

        double ovalRadius = (radius - innerRadius) / 3;

        brush.setColor(Color.BLACK);
        double oX = x - ovalRadius / 14;
        double oY = y - ovalRadius / 14;
        brush.fillOval((int) (oX - ovalRadius), (int) (oY - ovalRadius),
                (int) (2 * ovalRadius), (int) (2 * ovalRadius));

        brush.setColor(neureka.gui.swing.PaletteUtils.SYSTEM_OCEAN);
        brush.fillOval((int) (oX - ovalRadius * 0.9), (int) (oY - ovalRadius * 0.9),
                (int) (2 * ovalRadius * 0.9), (int) (2 * ovalRadius * 0.9));
        brush.setClip(null);

        ovalRadius = (radius - innerRadius) / 5;
        brush.setColor(Color.BLACK);
        oX = x + ovalRadius / 2;
        oY = y + ovalRadius / 2;
        double scaleHolder = birthScale;
        birthScale *= 1.25;
        IconDefaultNode(oX, oY, brush, birthScale, 1.0);
        birthScale = scaleHolder;

    }
    */
    /*
    //------------------------------------------------
    public static void IconPanelSettings(double x, double y, Graphics2D brush, double birthScale, double animScale) {

        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;
        brush.setColor(Color.BLACK);
        IconCogwheelBase(x, y, brush, birthScale, 1.0);
        double ovalRadius = (radius - innerRadius) / 4;
        brush.setColor(Color.BLACK);
        brush.fillOval((int) (x - ovalRadius * 0.5), (int) (y - ovalRadius * 0.5),
                (int) (2 * ovalRadius * 0.5), (int) (2 * ovalRadius * 0.5));

    }
    //------------------------------------------------
    */
    /*

    public static void IconNodeSettings(double x, double y, Graphics2D brush, double birthScale, double animScale) {

        brush.setColor(Color.BLACK);
        IconCogwheelBase(x, y, brush, birthScale, 1.0);
        //double scaleHolder = birthScale;
        birthScale *= 1.575;
        IconDefaultNode(x, y, brush, birthScale, 1.0);
        //birthScale = scaleHolder;

    }

    */
    /*
    public static void IconBackEndNodeWindow(double x, double y, Graphics2D brush, double birthScale, double animScale) {

        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;
        
        brush.setColor(Color.BLACK);
        double a = innerRadius * 1.1;
        double b = innerRadius * 1.0;
        brush.fillRect((int) (x - a / 2), (int) (y - b / 2), (int) a, (int) b);

        brush.setColor(PaletteUtils.SYSTEM_OCEAN);
        brush.fillRect((int) (x + a * 0.025), (int) (y - b / 3.1), (int) (a / 2.2 - a * 0.05), (int) (b / 2.33));
        brush.fillRect((int) (x - a / 2.2 + a * 0.025), (int) (y - b / 2.3), (int) (a / 2.2 - a * 0.05), (int) (b / 3.55));
        double scaleHolder = birthScale;
        birthScale *= 5;
        brush.setColor(Color.BLACK);
        IconSigmoidBase((((x + a / 4.375))), (((y - b / 9))), brush, birthScale, 1.0);
        birthScale = scaleHolder;
        brush.setColor(Color.CYAN);
        brush.fillRect((int) (((x + a * 0.025))), (int) (((y - b / 2.3))), (int) ((a / 2.2) - a * 0.05), (int) (b / 15));

        brush.fillRect((int) (((x + a * 0.025))), (int) (((y + b * 0.15))), (int) ((a / 2.2 - a * 0.05)), (int) (b / 15));
        brush.fillRect((int) (((x - a / 2.2 + a * 0.025))), (int) (((y - b * 0.1))), (int) ((a / 2.2) - a * 0.05), (int) (b / 15));
        Area clipArea = new Area(new Rectangle.Double((x - a / 2), (y - b / 2), a, b));
        brush.setClip(clipArea);
        brush.setColor(PaletteUtils.SYSTEM_OCEAN);
        scaleHolder = birthScale;
        birthScale *= 3.25;
        IconCogwheelBase(x - a / 4.25, y + b / 4.5, brush, birthScale, 1.0);
        birthScale = scaleHolder;
        brush.setClip(null);
    }
    */
    /*

    //===============================================================================
    //===============================================================================
    //Basic subcomponents:
    public static void IconNodeBase(double x, double y, Graphics2D brush, double birthScale, double animScale) {

        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;
        double ovalRadius = (radius - innerRadius) / 5;
        if (ovalRadius &lt;= 0) {
            return;
        }
        brush.setColor(Color.BLACK);
        double oX = x + ovalRadius / 2.55;
        double oY = y + ovalRadius / 2.55;
        brush.fillOval((int) (oX - ovalRadius), (int) (oY - ovalRadius),
                (int) (2 * ovalRadius), (int) (2 * ovalRadius));

        //----------------------------
        brush.setColor(Color.BLACK);
        ovalRadius = (radius - innerRadius) / 15;
        oX = (x - ovalRadius);
        oY = (y - ovalRadius);
        brush.setStroke(new BasicStroke((int) (ovalRadius / 2)));
        brush.drawLine((int) (oX), (int) (oY), (int) (oX - 3 * ovalRadius), (int) (oY));
        brush.rotate(Math.PI / 4, oX, oY);
        brush.drawLine((int) (oX), (int) (oY), (int) (oX - 3 * ovalRadius), (int) (oY));
        brush.rotate(Math.PI / 4, oX, oY);
        brush.drawLine((int) (oX), (int) (oY), (int) (oX - 3 * ovalRadius), (int) (oY));
        brush.rotate(-Math.PI / 2, oX, oY);

        brush.fillOval((int) (oX - ovalRadius), (int) (oY - ovalRadius),
                (int) (2 * ovalRadius), (int) (2 * ovalRadius));

        brush.setColor(Color.CYAN);
        brush.fillRect((int) (oX - ovalRadius / 2), (int) (oY - ovalRadius / 6),
                (int) (2 * ovalRadius / 2), (int) (2 * ovalRadius / 6));

        brush.fillRect((int) (oX - ovalRadius / 6), (int) (oY - ovalRadius / 2),
                (int) (2 * ovalRadius / 6), (int) (2 * ovalRadius / 2));

    }
    */
    /*
    public static void IconCogwheelBase(double x, double y, Graphics2D brush, double birthScale, double animScale) {

        double radius =
                (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius =
                (INNER_REFERENCE_RADIUS * animScale) / birthScale;

        double ovalRadius =
                ((radius - innerRadius) / 4);

        //brush.setColor(Color.BLACK);
        double oX = x;
        double oY = y;

        //brush.fillRect((int)(x-ovalRadius), (int)(y-ovalRadius), (int)(2*ovalRadius), (int)(2*ovalRadius));

        Area clipArea = new Area(new Rectangle.Double((x - radius), (y - radius), (2 * radius), (2 * radius)));
        clipArea.subtract(new Area(new Ellipse2D.Double((oX - ovalRadius * 0.7), (oY - ovalRadius * 0.7), (2 * ovalRadius * 0.7), (2 * ovalRadius * 0.7))));
        brush.setClip(clipArea);

        Polygon p = new Polygon();
        p.addPoint((int) (oX - ovalRadius / 4), (int) (oY + ovalRadius / 10));
        p.addPoint((int) (oX - ovalRadius / 7), (int) (oY - ovalRadius / 3));
        p.addPoint((int) (oX + ovalRadius / 7), (int) (oY - ovalRadius / 3));
        p.addPoint((int) (oX + ovalRadius / 4), (int) (oY + ovalRadius / 10));
        p.translate(0, (int) (-ovalRadius));
        int max = 9;
        for (int i = 0; i &lt; max; i++) {
            brush.rotate((2 * Math.PI / max), oX, oY);
            brush.fillPolygon(p);
        }
        brush.fillOval((int) (oX - ovalRadius), (int) (oY - ovalRadius),
                (int) (2 * ovalRadius), (int) (2 * ovalRadius));

        brush.setClip(null);

    }
    */

    public static void IconSigmoidBase(double x, double y, Graphics2D brush, double birthScale, double animScale) {

<span class="fc" id="L349">        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;</span>
<span class="fc" id="L350">        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;</span>

        Area clipArea;
<span class="fc" id="L353">        double r = (radius - innerRadius) / 2.5;</span>
<span class="fc" id="L354">        x += 0.05*r;</span>
<span class="fc" id="L355">        y += 0.05*r;</span>
<span class="fc" id="L356">        brush.fillRect((int) (x - r * 1.25), (int) (y - 1.25 * r / 9),</span>
                (int) (2 * r * 1.25), (int) (2 * 1.25 * r / 9));
<span class="fc" id="L358">        brush.fillRect((int) (x - 1.25 * r / 9), (int) (y - r * 1.25),</span>
                (int) (2 * 1.25 * r / 9), (int) (2 * r * 1.25));

<span class="fc" id="L361">        double cX = x - r * 0.2;</span>
<span class="fc" id="L362">        double cY = y - r + r * 0.1;</span>
<span class="fc" id="L363">        clipArea = new Area(new Rectangle.Double((x), (y - r), (r), (r)));</span>
<span class="fc" id="L364">        clipArea.subtract(new Area(new Ellipse2D.Double((cX + r * 0.375), (cY + 0.175 * r), (2 * r + 0.4 * r), (2 * r - 0.35 * r))));</span>
<span class="fc" id="L365">        brush.setClip(clipArea);</span>
        //brush.setColor(Color.BLUE);
<span class="fc" id="L367">        brush.fillOval((int) (cX), (int) (cY), (int) (2 * r + r * 0.4), (int) (2 * r));</span>
        //brush.rotate(-Math.PI, x, y);
<span class="fc" id="L369">        cX = x - 2 * r - r * 0.2;</span>
<span class="fc" id="L370">        cY = y - r - r * 0.1;</span>
<span class="fc" id="L371">        clipArea = new Area(new Rectangle.Double((x - r), (y), (r), (r)));</span>
<span class="fc" id="L372">        clipArea.subtract(new Area(new Ellipse2D.Double((cX - r * 0.4), (cY + 0.2 * r), (2 * r + r * 0.4), (2 * r - 0.4 * r))));</span>
<span class="fc" id="L373">        brush.setClip(clipArea);</span>
<span class="fc" id="L374">        brush.fillOval((int) (cX), (int) (cY), (int) (2 * r + r * 0.4), (int) (2 * r));</span>
<span class="fc" id="L375">        brush.setClip(null);</span>
<span class="fc" id="L376">    }</span>

    /*
    //------------------------------------------------x
    public static void IconTanhNode(double x, double y, Graphics2D brush, double birthScale, double animScale) {
        double radius = (OUTER_REFERENCE_RADIUS * animScale) / birthScale;
        double innerRadius = (INNER_REFERENCE_RADIUS * animScale) / birthScale;
        double ovalRadius = (radius - innerRadius) / 5;
        brush.setColor(Color.BLACK);
        double oX = x + ovalRadius / 2.55;
        double oY = y + ovalRadius / 2.55;

        IconDefaultNode(x, y, brush, birthScale, 1.0);

        double scaleHolder = birthScale;
        birthScale *= (4.5);
        brush.setColor(Color.BLACK);
        IconSigmoidBase(oX, oY, brush, birthScale, 1.0);
        birthScale = scaleHolder;

    }
    */


}









</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>