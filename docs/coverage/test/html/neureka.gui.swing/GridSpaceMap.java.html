<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GridSpaceMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.gui.swing</a> &gt; <span class="el_source">GridSpaceMap.java</span></div><h1>GridSpaceMap.java</h1><pre class="source lang-java linenums">package neureka.gui.swing;

import javax.swing.text.Element;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.util.*;


public class GridSpaceMap extends AbstractSpaceMap {

	AbstractSpaceMap TLNode, TRNode, BLNode, BRNode;
	double X, Y;
	double size;
	LinkedList&lt;SurfaceObject&gt; Elements;
	//CREATE : &quot;EDGE MAP&quot;

	GridSpaceMap(double centerX, double centerY, double size)
<span class="fc" id="L19">	{</span>
<span class="fc" id="L20">		X = centerX;</span>
<span class="fc" id="L21">		Y = centerY;</span>
<span class="fc" id="L22">		this.size = size;</span>
<span class="fc" id="L23">		TLNode=null;</span>
<span class="fc" id="L24">		TRNode=null;</span>
<span class="fc" id="L25">		BLNode=null;</span>
<span class="fc" id="L26">		BRNode=null;</span>
<span class="fc" id="L27">		Elements = null;</span>
<span class="fc" id="L28">	}</span>
	//------------------------------------------------------------------
	
	public void setTLNode(AbstractSpaceMap node) {
<span class="nc" id="L32">		TLNode = node;</span>
<span class="nc" id="L33">	}</span>
	public void setTRNode(AbstractSpaceMap node) {
<span class="fc" id="L35">		TRNode = node;</span>
<span class="fc" id="L36">	}</span>
	public void setBLNode(AbstractSpaceMap node) {
<span class="fc" id="L38">		BLNode = node;</span>
<span class="fc" id="L39">	}</span>
	public void setBRNode(AbstractSpaceMap node) {
<span class="nc" id="L41">		BRNode = node;</span>
<span class="nc" id="L42">	}</span>
	//------------------------------------------------------------------
	//==============================================================================



	//------------------------------------------------------------------
	@Override
	public synchronized AbstractSpaceMap addAndUpdate(SurfaceObject object)
	{
<span class="fc" id="L52">		double LP = object.getLeftPeripheral();</span>
<span class="fc" id="L53">		double RP = object.getRightPeripheral();</span>
<span class="fc" id="L54">		double TP = object.getTopPeripheral();</span>
<span class="fc" id="L55">		double BP = object.getBottomPeripheral();</span>
		
<span class="fc" id="L57">		boolean isBranchable=true;</span>
<span class="fc bfc" id="L58" title="All 4 branches covered.">		if     (LP&lt;=X &amp;&amp; X&lt;=RP){isBranchable=false;}</span>
<span class="fc bfc" id="L59" title="All 4 branches covered.">		else if(TP&lt;=Y &amp;&amp; Y&lt;=BP){isBranchable=false;}</span>

<span class="fc bfc" id="L61" title="All 2 branches covered.">		if(  (Math.max(Math.abs(X-LP),Math.abs(X-RP))&gt;size </span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">		   || Math.max(Math.abs(Y-TP),Math.abs(Y-BP))&gt;size)) </span>
		{
<span class="pc bpc" id="L64" title="1 of 4 branches missed.">			if(RP&lt;(X+size) &amp;&amp; BP&lt;(Y+size)) {</span>
<span class="nc" id="L65">				GridSpaceMap newBranch = new GridSpaceMap((X-size),(Y-size), 2*size);</span>
<span class="nc" id="L66">				newBranch.setBRNode(this);</span>
<span class="nc" id="L67">				newBranch = (GridSpaceMap)newBranch.addAndUpdate(object);//Stack fucking overflow?!?</span>
<span class="nc" id="L68">				return newBranch;</span>
			}
<span class="pc bpc" id="L70" title="1 of 4 branches missed.">			else if(LP&gt;(X-size) &amp;&amp; BP&lt;(Y+size)) {</span>
<span class="fc" id="L71">				GridSpaceMap newBranch = new GridSpaceMap((X+size),(Y-size), 2*size);</span>
<span class="fc" id="L72">				newBranch.setBLNode(this);</span>
<span class="fc" id="L73">				newBranch = (GridSpaceMap)newBranch.addAndUpdate(object);</span>
<span class="fc" id="L74">				return newBranch;</span>
			}
<span class="pc bpc" id="L76" title="2 of 4 branches missed.">			else if(RP&lt;(X+size) &amp;&amp; TP&gt;(Y-size)) {</span>
<span class="fc" id="L77">				GridSpaceMap newBranch = new GridSpaceMap((X-size),(Y+size), 2*size);</span>
<span class="fc" id="L78">				newBranch.setTRNode(this);</span>
<span class="fc" id="L79">				newBranch = (GridSpaceMap)newBranch.addAndUpdate(object);</span>
<span class="fc" id="L80">				return newBranch;</span>
			}
<span class="nc bnc" id="L82" title="All 4 branches missed.">			else if(LP&gt;(X-size) &amp;&amp; TP&gt;(Y-size)) {</span>
<span class="nc" id="L83">				GridSpaceMap newBranch = new GridSpaceMap((X+size),(Y+size), 2*size);</span>
<span class="nc" id="L84">				newBranch.setTLNode(this);</span>
<span class="nc" id="L85">				newBranch = (GridSpaceMap)newBranch.addAndUpdate(object);</span>
<span class="nc" id="L86">				return newBranch;</span>
			}
		}
<span class="fc bfc" id="L89" title="All 2 branches covered.">		if(isBranchable==false) </span>
		{
<span class="fc bfc" id="L91" title="All 2 branches covered.">			if(Elements==null) {Elements=new LinkedList&lt;SurfaceObject&gt;();}</span>
<span class="fc" id="L92">			Elements.add(object);</span>
<span class="fc" id="L93">			return this;</span>
		}
<span class="fc bfc" id="L95" title="All 4 branches covered.">		if    (RP &lt;= X &amp;&amp; BP &lt;= Y) {</span>
<span class="fc" id="L96">			TLNode = add(TLNode, object, false, false);</span>
		}
<span class="fc bfc" id="L98" title="All 4 branches covered.">			else if(LP &gt; X &amp;&amp; BP &lt;= Y) {</span>
<span class="fc" id="L99">			TRNode = add(TRNode, object, true, false);</span>
		}
<span class="pc bpc" id="L101" title="1 of 4 branches missed.">		else if(RP &lt; X &amp;&amp; TP &gt;= Y) {</span>
<span class="fc" id="L102">			BLNode = add(BLNode, object, false, true);</span>
		}
<span class="pc bpc" id="L104" title="2 of 4 branches missed.">		else if(LP &gt;= X &amp;&amp; TP &gt; Y) {</span>
<span class="fc" id="L105">			BRNode = add(BRNode, object, true, true);//Stack fucking overflow?!?</span>
		}
<span class="fc" id="L107">		return this;</span>
	}
	private AbstractSpaceMap add(AbstractSpaceMap MapNode, SurfaceObject newObject, boolean quadrantX, boolean quadrantY)
	{
<span class="fc bfc" id="L111" title="All 2 branches covered.">		if(MapNode!=null) </span>
		{
<span class="fc bfc" id="L113" title="All 2 branches covered.">			if(MapNode instanceof Leave) </span>
			{
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">			   if(MapNode.getCount()&gt;=MAX)</span>
			   {
<span class="nc bnc" id="L117" title="All 2 branches missed.">				   double vecX = size/2; if(quadrantX==false) {vecX*=-1;}</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">				   double vecY = size/2; if(quadrantY==false) {vecY*=-1;}</span>
<span class="nc" id="L119">				   GridSpaceMap newBranch = new GridSpaceMap(X+vecX, Y+vecY, size/2);</span>
<span class="nc" id="L120">				   newBranch = (GridSpaceMap)newBranch.addAndUpdate(newObject);</span>
				
<span class="nc" id="L122">				   LinkedList&lt;SurfaceObject&gt; oldNodes =((Leave)MapNode).getLeaveElements();</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">				   for(int i=0; i&lt;oldNodes.size(); i++) {newBranch = (GridSpaceMap)newBranch.addAndUpdate(oldNodes.get(i));}</span>
<span class="nc" id="L124">				   return newBranch;</span>
			   }
			   else 
			   {
<span class="fc" id="L128">				return MapNode.addAndUpdate(newObject);}</span>
			}
			else 
<span class="fc" id="L131">			{return MapNode.addAndUpdate(newObject);}//Stack fucking overflow?!?!</span>
		}
		else 
		{
<span class="fc" id="L135">			MapNode = new Leave(); </span>
<span class="fc" id="L136">			MapNode = MapNode.addAndUpdate(newObject); </span>
		}
<span class="fc" id="L138">		return MapNode;</span>
	}
	//==============================================================================
	
	
	//==============================================================================
	//------------------------------------------------------------------
	@Override
	public synchronized AbstractSpaceMap removeAndUpdate(SurfaceObject object)
	{
		//if(object==null) {return this;}
		//Why not check if branchable? -&gt; The size f the object might have changed! -&gt; not on edge anymore
<span class="fc bfc" id="L150" title="All 2 branches covered.">		if(Elements!=null) </span>
		{
<span class="fc bfc" id="L152" title="All 2 branches covered.">			if(Elements.remove(object))</span>
			{
<span class="fc bfc" id="L154" title="All 2 branches covered.">				if(Elements.size()==0) {Elements=null;}</span>
<span class="fc" id="L155">				return bestSelf();</span>
			}
		}
<span class="fc" id="L158">		double LP = object.getLeftPeripheral();</span>
<span class="fc" id="L159">		double RP = object.getRightPeripheral();</span>
<span class="fc" id="L160">		double TP = object.getTopPeripheral();</span>
<span class="fc" id="L161">		double BP = object.getBottomPeripheral();</span>
<span class="fc bfc" id="L162" title="All 4 branches covered.">		if    (RP &lt;= X &amp;&amp; BP &lt;= Y) {</span>
<span class="fc" id="L163">			TLNode = remove(TLNode, object);</span>
		}
<span class="fc bfc" id="L165" title="All 4 branches covered.">		else if(LP &gt; X &amp;&amp; BP &lt;= Y) {//</span>
<span class="fc" id="L166">			TRNode = remove(TRNode, object);</span>
		}
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">		else if(RP &lt; X &amp;&amp; TP &gt;= Y) {//	</span>
<span class="fc" id="L169">			BLNode = remove(BLNode, object);</span>
		}
<span class="pc bpc" id="L171" title="2 of 4 branches missed.">		else if(LP &gt;= X &amp;&amp; TP &gt; Y) {//	</span>
<span class="fc" id="L172">			BRNode = remove(BRNode, object);</span>
		}
<span class="fc" id="L174">		return bestSelf();</span>
	}
	
	private synchronized AbstractSpaceMap bestSelf()
	{
<span class="fc" id="L179">		byte counter=0;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">		if(TLNode  ==null) {counter++;}</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">		if(TRNode  ==null) {counter++;}</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">		if(BLNode  ==null) {counter++;}</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">		if(BRNode  ==null) {counter++;}</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">		if(Elements==null) {counter++;}</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">		if(counter==5) {return null;}</span>
		//If the node is a branch: return ... else getFrom leave elements and put them into an new branch!
<span class="pc bpc" id="L187" title="1 of 4 branches missed.">		if(counter==4 &amp;&amp; Elements==null) </span>
		{
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">			if(TLNode!=null) {return TLNode;}</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">			if(TRNode!=null) {return TRNode;}</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">			if(BLNode!=null) {return BLNode;}</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">			if(BRNode!=null) {return BRNode;}</span>
		}
<span class="fc" id="L194">		return this;</span>
	}
	
	private synchronized AbstractSpaceMap remove(AbstractSpaceMap MapNode, SurfaceObject oldNode)
	{
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">		if(MapNode!=null) {MapNode = MapNode.removeAndUpdate(oldNode);} </span>
<span class="fc" id="L200">		return MapNode;</span>
	}
	//==============================================================================
	
	@Override
	public synchronized int getCount() 
	{
<span class="nc" id="L207">		int nodeCount = 0;</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">		if(Elements!=null) {nodeCount+=Elements.size();}</span>
<span class="nc" id="L209">		return nodeCount;</span>
	}

	/*
	@Override
	public synchronized SurfaceObject get(int i)
	{
		int nodeCount = 0;
		int currentCount=0;
		if(Elements!=null) {
			int count = Elements.size();
			if(i&lt;count) 
			   {return Elements.get(i);}
			else
			   {nodeCount+=count;}
		}
		
		if(TLNode!=null) 
		{
			currentCount=TLNode.getCount();
			if(i&lt;(nodeCount+currentCount)) {return TLNode.get(i-nodeCount);}
			nodeCount += currentCount;
		}
		if(TRNode!=null) 
		{
			currentCount=TRNode.getCount();
			if(i&lt;(nodeCount+currentCount)) {return TRNode.get(i-nodeCount);}
			nodeCount += currentCount;
		}
		if(BLNode!=null) 
		{
			currentCount=BLNode.getCount();
			if(i&lt;(nodeCount+currentCount)) {return BLNode.get(i-nodeCount);}
			nodeCount += currentCount;
		}
		if(BRNode!=null) 
		{
			currentCount=BRNode.getCount();
			if(i&lt;(nodeCount+currentCount)) {return BRNode.get(i-nodeCount);}
			nodeCount += currentCount;
		}
		return null;
	}
	*/

	/*
	@Override
	public synchronized LinkedList&lt;SurfaceObject&gt; getAllClosestTo(double x, double y)
	{	
		LinkedList&lt;SurfaceObject&gt; present = Elements;
		if(present==null) {
			if    (x &lt;= X &amp;&amp; y &lt;= Y &amp;&amp; TLNode!=null) {
				return TLNode.getAllClosestTo(x, y);
			}
			else if(x &gt; X &amp;&amp; y &lt;= Y &amp;&amp; TRNode!=null) {
				return TRNode.getAllClosestTo(x, y);
			}
			else if(x &lt; X &amp;&amp; y &gt;= Y &amp;&amp; BLNode!=null) {
				return BLNode.getAllClosestTo(x, y);
			}
			else if(x &gt;= X &amp;&amp; y &gt; Y &amp;&amp; BRNode!=null) {
				return BRNode.getAllClosestTo(x, y);
			}
		}
		else 
		{
			if (x &lt;= X &amp;&amp; y &lt;= Y &amp;&amp; TLNode!=null) {
			    LinkedList&lt;SurfaceObject&gt; found = TLNode.getAllClosestTo(x, y);
				if(found!=null) {found.addAll(present);}
				return found;
			}
			else if(x &gt; X &amp;&amp; y &lt;= Y &amp;&amp; TRNode!=null) {
				LinkedList&lt;SurfaceObject&gt; found = TRNode.getAllClosestTo(x, y);
				if(found!=null) {found.addAll(present);}
				return found;
			}
			else if(x &lt; X &amp;&amp; y &gt;= Y &amp;&amp; BLNode!=null) {
				LinkedList&lt;SurfaceObject&gt; found = BLNode.getAllClosestTo(x, y);
				if(found!=null) {found.addAll(present);}
				return found;
			}
			else if(x &gt;= X &amp;&amp; y &gt; Y &amp;&amp; BRNode!=null) {
				LinkedList&lt;SurfaceObject&gt; found = BRNode.getAllClosestTo(x, y);
				if(found!=null) {found.addAll(present);}
				return found;
			}
		}
		return null;
	}
	*/

	@Override
	public synchronized LinkedList&lt;SurfaceObject&gt; findAllAt(double x, double y, MapAction condition)
	{
<span class="fc" id="L303">		LinkedList&lt;SurfaceObject&gt; someFound = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">		if(Elements!=null) </span>
		{
<span class="nc" id="L306">			someFound.addAll(filter(condition,Elements));</span>
		}
<span class="pc bpc" id="L308" title="1 of 4 branches missed.">		if     (x &lt;= X &amp;&amp; y &lt;= Y) </span>
			    { 
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">				    if(TLNode!=null) {someFound.addAll(TLNode.findAllAt(x, y, condition));}</span>
<span class="fc" id="L311">			        return someFound;</span>
			    }
<span class="pc bpc" id="L313" title="1 of 4 branches missed.">		else if(x &gt; X &amp;&amp; y &lt;= Y) </span>
			    {
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">			        if(TRNode!=null) {someFound.addAll(TRNode.findAllAt(x, y, condition));}</span>
<span class="fc" id="L316">			        return someFound;</span>
		        }
<span class="pc bpc" id="L318" title="3 of 4 branches missed.">		else if(x &lt; X &amp;&amp; y &gt;= Y) </span>
				{
<span class="nc bnc" id="L320" title="All 2 branches missed.">			        if(BLNode!=null) {someFound.addAll(BLNode.findAllAt(x, y, condition));}</span>
<span class="nc" id="L321">			        return someFound;</span>
		        }
<span class="pc bpc" id="L323" title="2 of 4 branches missed.">		else if(x &gt;= X &amp;&amp; y &gt; Y) </span>
		        {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">			        if(BRNode!=null) {someFound.addAll(BRNode.findAllAt(x, y, condition));}</span>
<span class="fc" id="L326">				    return someFound;</span>
		        }
<span class="nc" id="L328">		return null;</span>
	}
	private synchronized LinkedList&lt;SurfaceObject&gt; filter(MapAction Actor, LinkedList&lt;SurfaceObject&gt; List)
	{
<span class="nc" id="L332">		LinkedList&lt;SurfaceObject&gt; filteredList = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">		List.forEach((current)-&gt;{if(Actor.act(current)) {filteredList.add(current);}});</span>
<span class="nc" id="L334">		return filteredList;</span>
	}


	@Override
	public synchronized void paintStructure(Graphics2D brush) {

<span class="nc" id="L341">		Font F = new Font(&quot;Tahoma&quot;, Font.PLAIN, (int)(size*(0.1)));</span>
<span class="nc" id="L342">		Color C = brush.getColor();</span>
<span class="nc" id="L343">		Color B = Color.ORANGE;</span>
<span class="nc" id="L344">		brush.setFont(F);</span>
		
<span class="nc bnc" id="L346" title="All 2 branches missed.">		if(TLNode!=null) {</span>
<span class="nc" id="L347">		brush.setColor(C);	</span>
<span class="nc" id="L348">		TLNode.paintStructure(brush);brush.fillOval((int)(X-2000), (int)(Y-2000), 2000, 2000);</span>
<span class="nc" id="L349">		brush.setColor(B);</span>
<span class="nc" id="L350">		brush.drawString(TLNode.getCount()+&quot;&quot;, (int)(X-1600), (int)(Y-1200));</span>
		}
<span class="nc bnc" id="L352" title="All 2 branches missed.">		if(TRNode!=null) {</span>
<span class="nc" id="L353">		brush.setColor(C);	</span>
<span class="nc" id="L354">		TRNode.paintStructure(brush);brush.fillOval((int)(X     ), (int)(Y-2000), 2000, 2000);</span>
<span class="nc" id="L355">		brush.setColor(B);</span>
<span class="nc" id="L356">		brush.drawString(TRNode.getCount()+&quot;&quot;, (int)(X+1000 ), (int)(Y-1200));</span>
		}
<span class="nc bnc" id="L358" title="All 2 branches missed.">		if(BLNode!=null) {</span>
<span class="nc" id="L359">		brush.setColor(C);	</span>
<span class="nc" id="L360">		BLNode.paintStructure(brush);brush.fillOval((int)(X-2000), (int)(Y     ), 2000, 2000);</span>
<span class="nc" id="L361">		brush.setColor(B);</span>
<span class="nc" id="L362">		brush.drawString(BLNode.getCount()+&quot;&quot;, (int)(X-1600), (int)(Y+1200 ));</span>
		}
<span class="nc bnc" id="L364" title="All 2 branches missed.">		if(BRNode!=null) {</span>
<span class="nc" id="L365">		brush.setColor(C);	</span>
<span class="nc" id="L366">		BRNode.paintStructure(brush);brush.fillOval((int)(X     ), (int)(Y     ), 2000, 2000);</span>
<span class="nc" id="L367">		brush.setColor(B);</span>
<span class="nc" id="L368">		brush.drawString(BRNode.getCount()+&quot;&quot;, (int)(X+1000 ), (int)(Y+1200));</span>
		}
<span class="nc bnc" id="L370" title="All 2 branches missed.">		if(Elements!=null) </span>
		{
<span class="nc" id="L372">			ListIterator&lt;SurfaceObject&gt; ElementIterator = Elements.listIterator();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">			while (ElementIterator.hasNext()) </span>
			{//System.out.println(&quot;checking elements...&quot;);
<span class="nc" id="L375">				SurfaceObject current = ElementIterator.next();</span>
<span class="nc" id="L376">				brush.setColor(Color.GREEN);</span>
<span class="nc" id="L377">				brush.fillOval((int)(current.getX()-1000), (int)(current.getY()-1000), 2000, 2000);</span>
<span class="nc" id="L378">			}</span>
<span class="nc" id="L379">		brush.setColor(Color.RED);</span>
<span class="nc" id="L380">		brush.fillOval((int)(X-1000), (int)(Y-1000), 2000, 2000);	</span>
<span class="nc" id="L381">		brush.setColor(B);</span>
<span class="nc" id="L382">		brush.drawString(this.getCount()+&quot;&quot;, (int)(X-300), (int)(Y-50));</span>
<span class="nc" id="L383">		brush.setColor(C);</span>
		}
<span class="nc" id="L385">		brush.setColor(Color.GREEN);</span>
<span class="nc" id="L386">		brush.drawLine((int)(X), (int)(Y-size),(int)(X), (int)(Y+size));</span>
<span class="nc" id="L387">		brush.drawLine((int)(X-size), (int)(Y),(int)(X+size), (int)(Y));</span>
<span class="nc" id="L388">		brush.setColor(Color.BLUE);</span>
<span class="nc" id="L389">		brush.drawRect((int)(X-size), (int)(Y-size), (int)(size*2), (int)(size*2));</span>
<span class="nc" id="L390">	}</span>

	@Override
	public synchronized boolean applyToAll(MapAction Actor) {
		
<span class="fc" id="L395">		boolean[] actorCheck = {false};</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">		if(Elements!=null) </span>
		{//System.out.println(&quot;Branch node -&gt; apply to all! START&quot;);
<span class="fc" id="L398">			Elements.forEach((current)-&gt;{</span>
<span class="fc" id="L399">				boolean check = Actor.act(current);</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">				if(check) {actorCheck[0]=true;}</span>
<span class="fc" id="L401">			});</span>
		}
<span class="pc bpc" id="L403" title="1 of 4 branches missed.">		if(TLNode!=null) {if(TLNode.applyToAll(Actor)) {actorCheck[0]=true;}}</span>
<span class="pc bpc" id="L404" title="1 of 4 branches missed.">		if(TRNode!=null) {if(TRNode.applyToAll(Actor)) {actorCheck[0]=true;}}</span>
<span class="pc bpc" id="L405" title="1 of 4 branches missed.">		if(BLNode!=null) {if(BLNode.applyToAll(Actor)) {actorCheck[0]=true;}}</span>
<span class="pc bpc" id="L406" title="1 of 4 branches missed.">		if(BRNode!=null) {if(BRNode.applyToAll(Actor)) {actorCheck[0]=true;}}</span>
<span class="fc" id="L407">		return actorCheck[0];</span>
	}

	@Override
	public synchronized AbstractSpaceMap addAll(LinkedList&lt;SurfaceObject&gt; elements)
	{
<span class="nc bnc" id="L413" title="All 2 branches missed.">		if(elements==null) {return this;}</span>
<span class="nc" id="L414">		AbstractSpaceMap[] newNode = {this};</span>
<span class="nc" id="L415">		elements.forEach((current)-&gt;{newNode[0] = newNode[0].addAndUpdate(current);});</span>
<span class="nc" id="L416">		return newNode[0];</span>
	}

	@Override
	public synchronized LinkedList&lt;SurfaceObject&gt; getAll()
	{
<span class="fc" id="L422">		LinkedList&lt;SurfaceObject&gt; List = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">		if(Elements!=null) {List.addAll(Elements);}</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">		if(TLNode!=null) {List.addAll(TLNode.getAll());}</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">		if(TRNode!=null) {List.addAll(TRNode.getAll());}</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">		if(BLNode!=null) {List.addAll(BLNode.getAll());}</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">		if(BRNode!=null) {List.addAll(BRNode.getAll());}</span>
<span class="fc" id="L428">		return List;</span>
	}

	@Override
	public synchronized Object applyAndGet(AdvancedMapAction Actor) 
	{
<span class="nc" id="L434">		Object thing = null;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">		if(Elements!=null)</span>
		{
<span class="nc" id="L437">			ListIterator&lt;SurfaceObject&gt; ElementIterator = Elements.listIterator();</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">			while (ElementIterator.hasNext()) </span>
			{
<span class="nc" id="L440">				SurfaceObject current = ElementIterator.next();</span>
<span class="nc" id="L441">				thing=Actor.act(thing, current);</span>
<span class="nc" id="L442">			}</span>
		}
<span class="nc bnc" id="L444" title="All 2 branches missed.">		if(TLNode!=null) {thing = (TLNode.applyAndGet(Actor));}</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">		if(TRNode!=null) {thing = (TRNode.applyAndGet(Actor));}</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">		if(BLNode!=null) {thing = (BLNode.applyAndGet(Actor));}</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">		if(BRNode!=null) {thing = (BRNode.applyAndGet(Actor));}</span>
<span class="nc" id="L448">		return thing;</span>
	}

	@Override
	public synchronized Object applyAndGet(Object Data, AdvancedMapAction Actor) 
	{
<span class="nc bnc" id="L454" title="All 2 branches missed.">		if(Elements!=null) </span>
		{
<span class="nc" id="L456">			ListIterator&lt;SurfaceObject&gt; ElementIterator = Elements.listIterator();</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">			while (ElementIterator.hasNext()) </span>
			{
<span class="nc" id="L459">				SurfaceObject current = ElementIterator.next();</span>
<span class="nc" id="L460">				Data=Actor.act(Data, current);</span>
<span class="nc" id="L461">			}</span>
		}
<span class="nc bnc" id="L463" title="All 2 branches missed.">		if(TLNode!=null) {Data = (TLNode.applyAndGet(Data,Actor));}</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">		if(TRNode!=null) {Data = (TRNode.applyAndGet(Data,Actor));}</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">		if(BLNode!=null) {Data = (BLNode.applyAndGet(Data,Actor));}</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">		if(BRNode!=null) {Data = (BRNode.applyAndGet(Data,Actor));}</span>
<span class="nc" id="L467">		return Data;</span>
	}

	@Override
	public synchronized void apply(Object Data, AdvancedMapAction Actor) 
	{
<span class="nc bnc" id="L473" title="All 2 branches missed.">		if(Actor.act(this, null)==null) {return;}</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">		if(Elements!=null)</span>
		{
<span class="nc" id="L476">			Object[] D = {Data};</span>
<span class="nc" id="L477">			Elements.forEach((current)-&gt;{D[0]=Actor.act(D[0], current);});</span>
		}
<span class="nc bnc" id="L479" title="All 2 branches missed.">		if(TLNode!=null) {TLNode.apply(Data,Actor);}</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">		if(TRNode!=null) {TRNode.apply(Data,Actor);}</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">		if(BLNode!=null) {BLNode.apply(Data,Actor);}</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">		if(BRNode!=null) {BRNode.apply(Data,Actor);}</span>
<span class="nc" id="L483">	}</span>

<span class="nc" id="L485">	public double getX() {return X;}</span>
<span class="nc" id="L486">	public double getY() {return Y;}</span>
<span class="nc" id="L487">	public double getSize() {return size;}</span>
	

	@Override
	public synchronized LinkedList&lt;SurfaceObject&gt; getAllWithin(double[] frame)
	{
<span class="fc" id="L493">		LinkedList&lt;SurfaceObject&gt; List = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">		if(Elements!=null){</span>
<span class="fc" id="L495">			List.addAll(Elements);</span>
		}
<span class="fc" id="L497">		double LP = frame[0]; double RP = frame[1];</span>
<span class="fc" id="L498">		double TP = frame[2]; double BP = frame[3];</span>
<span class="fc bfc" id="L499" title="All 6 branches covered.">		if(TLNode!=null &amp;&amp; LP&lt;(X) &amp;&amp; TP&lt;(Y)) {</span>
<span class="fc" id="L500">			List.addAll(TLNode.getAllWithin(frame));</span>
		}
<span class="fc bfc" id="L502" title="All 6 branches covered.">		if(TRNode!=null &amp;&amp; RP&gt;(X) &amp;&amp; TP&lt;(Y)) {</span>
<span class="fc" id="L503">			List.addAll(TRNode.getAllWithin(frame));</span>
		}
<span class="fc bfc" id="L505" title="All 6 branches covered.">		if(BLNode!=null &amp;&amp; LP&lt;(X) &amp;&amp; BP&gt;(Y)) {</span>
<span class="fc" id="L506">			List.addAll(BLNode.getAllWithin(frame));</span>
		}
<span class="fc bfc" id="L508" title="All 6 branches covered.">		if(BRNode!=null &amp;&amp; RP&gt;(X) &amp;&amp; TP&gt;(Y)) {</span>
<span class="fc" id="L509">			List.addAll(BRNode.getAllWithin(frame));</span>
		}
<span class="fc" id="L511">		return List;</span>
	}

	@Override
	public synchronized LinkedList&lt;SurfaceObject&gt; findAllWithin(double[] frame, MapAction Actor)
	{
<span class="fc" id="L517">		LinkedList&lt;SurfaceObject&gt; List = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">		if(Elements!=null){</span>
<span class="fc" id="L519">			Elements.forEach(</span>
					(o)-&gt;
					{
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">						if(Actor.act(o))</span>
						{
<span class="pc bpc" id="L524" title="2 of 4 branches missed.">							if(o.getRightPeripheral() &gt;frame[0]&amp;&amp;o.getLeftPeripheral()&lt;frame[2]</span>
<span class="nc bnc" id="L525" title="All 4 branches missed.">									&amp;&amp;o.getBottomPeripheral()&gt;frame[1]&amp;&amp;o.getTopPeripheral() &lt;frame[3])</span>
							{
<span class="nc" id="L527">								List.add(o);</span>
							}
						}
<span class="fc" id="L530">					});</span>
		}
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">		if(TLNode!=null) {List.addAll(TLNode.findAllWithin(frame, Actor));}</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">		if(TRNode!=null) {List.addAll(TRNode.findAllWithin(frame, Actor));}</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">		if(BLNode!=null) {List.addAll(BLNode.findAllWithin(frame, Actor));}</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">		if(BRNode!=null) {List.addAll(BRNode.findAllWithin(frame, Actor));}</span>
<span class="fc" id="L536">		return List;</span>
	}
	
	@Override
	public synchronized boolean applyToAllWithin(double[] frame, MapAction Actor) 
	{
<span class="fc" id="L542">		boolean[] check = {false};</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">		if(Elements!=null)</span>
		{
<span class="fc" id="L545">				Elements.forEach(</span>
				(o)-&gt;
				{
<span class="pc bpc" id="L548" title="2 of 4 branches missed.">					if(o.getRightPeripheral()&gt; frame[0]&amp;&amp;o.getLeftPeripheral()&lt;frame[2]</span>
<span class="pc bpc" id="L549" title="1 of 4 branches missed.">					 &amp;&amp;o.getBottomPeripheral()&gt;frame[1]&amp;&amp;o.getTopPeripheral() &lt;frame[3]) </span>
					{
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">						if(Actor.act(o)) </span>
<span class="fc" id="L552">						{check[0]=true;}</span>
					}
					
<span class="fc" id="L555">				});</span>
		}
<span class="pc bpc" id="L557" title="1 of 4 branches missed.">		if(TLNode!=null) {if(TLNode.applyToAllWithin(frame,Actor)) {check[0]=true;}}</span>
<span class="pc bpc" id="L558" title="1 of 4 branches missed.">		if(TRNode!=null) {if(TRNode.applyToAllWithin(frame,Actor)) {check[0]=true;}}</span>
<span class="fc bfc" id="L559" title="All 4 branches covered.">		if(BLNode!=null) {if(BLNode.applyToAllWithin(frame,Actor)) {check[0]=true;}}</span>
<span class="pc bpc" id="L560" title="1 of 4 branches missed.">		if(BRNode!=null) {if(BRNode.applyToAllWithin(frame,Actor)) {check[0]=true;}}</span>
<span class="fc" id="L561">		return check[0];</span>
	}
		

	
	//===============================================================================================
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	//=&gt; EdgeLeave
	/*
	 * getFrom(i)
	 * addInto(GridSpaceMap node)
	 * remove(GridSpaceMap node)
	 * forEach(action){}
	 * 
	 * */
	//===============================================================================================
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	public class Leave extends AbstractSpaceMap {
		 
<span class="fc" id="L581">		HashMap&lt;SurfaceObject, SurfaceObject&gt; Elements = null;</span>
		
<span class="fc" id="L583">		Leave(){}</span>
		//-------------------------------------------------------------------
		public synchronized LinkedList&lt;SurfaceObject&gt; getLeaveElements()
		{  
<span class="fc" id="L587">			LinkedList&lt;SurfaceObject&gt; List = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="fc" id="L588">			Elements.forEach((k, v) -&gt; {List.add(v);});</span>
<span class="fc" id="L589">			return List;</span>
		}
		//-------------------------------------------------------------------
		//==============================================================================
		//------------------------------------------------------------------
		@Override
		public synchronized AbstractSpaceMap addAndUpdate(SurfaceObject node)
		{
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">			if(node==null) {return this;}</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">			if(Elements==null) </span>
			{
<span class="fc" id="L600">				Elements = new HashMap&lt;SurfaceObject, SurfaceObject&gt;();</span>
			}
			else 
			{
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">				if(Elements.size()&gt;=MAX) </span>
				{
					AbstractSpaceMap newNode;
<span class="nc" id="L607">					double[] newCenterX= {node.getX()};</span>
<span class="nc" id="L608">					double[] newCenterY= {node.getY()};</span>

<span class="nc" id="L610">					Elements.forEach((k, v) -&gt; </span>
					{
<span class="nc" id="L612">						newCenterX[0] += v.getX();</span>
<span class="nc" id="L613">						newCenterY[0] += v.getY();</span>
<span class="nc" id="L614">					});</span>
<span class="nc" id="L615">					newCenterX[0] /= Elements.size()+1;</span>
<span class="nc" id="L616">					newCenterY[0] /= Elements.size()+1;</span>
<span class="nc" id="L617">					double[] newSize =  {Math.pow(Math.pow(newCenterX[0]-node.getX(), 2)+Math.pow(newCenterY[0]-node.getY(), 2), 0.5)};</span>

<span class="nc" id="L619">					LinkedList&lt;SurfaceObject&gt; List = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="nc" id="L620">					Elements.forEach((k, v) -&gt; </span>
					{
<span class="nc" id="L622">						List.add(v);</span>
<span class="nc" id="L623">						double distance = Math.pow(Math.pow(newCenterX[0]-v.getX(), 2)+Math.pow(newCenterY[0]-v.getY(), 2), 0.5);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">						if(distance&gt;newSize[0]) {newSize[0]=distance;}</span>
<span class="nc" id="L625">					});</span>
<span class="nc" id="L626">					newNode = new GridSpaceMap(newCenterX[0], newCenterY[0], newSize[0]);</span>
<span class="nc" id="L627">					newNode.addAll(List);</span>
<span class="nc" id="L628">					newNode = newNode.addAndUpdate(node);</span>
<span class="nc" id="L629">					return newNode;//new grid</span>
				}
			}
<span class="fc" id="L632">			Elements.put(node,node);//Elements.addInto(node);</span>
<span class="fc" id="L633">			return this;</span>
		}
		//==============================================================================
		//------------------------------------------------------------------
		@Override
		public synchronized AbstractSpaceMap removeAndUpdate(SurfaceObject node) {
			
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">			if(Elements!=null) </span>
			{
<span class="fc" id="L642">				Elements.remove(node);</span>
			}
<span class="fc bfc" id="L644" title="All 2 branches covered.">			if(Elements.size()==0) </span>
			{
<span class="fc" id="L646">				return null;</span>
			}
<span class="fc" id="L648">			return this;</span>
		}
		//==============================================================================
		@Override
		public synchronized int getCount() 
		{
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">			if(Elements!=null) </span>
			{
<span class="fc" id="L656">				return Elements.size();</span>
			}
<span class="nc" id="L658">			return 0;</span>
		}
		//==============================================================================
		/*
		@Override
		public synchronized SurfaceObject get(int i)
		{
			if(Elements!=null) 
			{
				return Elements.get(i);
			}
			return null;
		}
		*/
		//==============================================================================
		/*
		@Override
		public synchronized LinkedList&lt;SurfaceObject&gt; getAllClosestTo(double x, double y)
		{
			return this.getLeaveElements();
		}
		*/

		@Override
		public synchronized LinkedList&lt;SurfaceObject&gt; findAllAt(double x, double y, MapAction condition)
		{
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">			if(Elements==null) {return null;}</span>
<span class="fc" id="L685">			LinkedList&lt;SurfaceObject&gt; List = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">			Elements.forEach((k, v) -&gt; {if(condition.act(v)) {List.add(v);}});	</span>
<span class="fc" id="L687">			return List;</span>
		}
		//==============================================================================
		@Override
		public synchronized void paintStructure(Graphics2D brush) 
		{
<span class="nc bnc" id="L693" title="All 2 branches missed.">			if(Elements==null) {return;}</span>
<span class="nc" id="L694">			Elements.forEach((k, v) -&gt; </span>
			{
<span class="nc" id="L696">				brush.drawOval((int)(v.getX()-500), (int)(v.getY()-500), 1000, 1000);</span>
<span class="nc" id="L697">				brush.drawOval((int)(v.getX()-700), (int)(v.getY()-700), 1400, 1400);</span>
<span class="nc" id="L698">				brush.drawOval((int)(v.getX()-1000), (int)(v.getY()-1000), 2000, 2000);</span>
<span class="nc" id="L699">				brush.drawOval((int)(v.getX()-2000), (int)(v.getY()-2000), 4000, 4000);</span>
<span class="nc" id="L700">			});</span>
<span class="nc" id="L701">		}</span>
		//==============================================================================
		@Override
		public synchronized boolean applyToAll(MapAction Actor) 
		{
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">			if(Elements==null) {return false;}</span>
<span class="fc" id="L707">			boolean[] actorCheck = {false};</span>
			
<span class="fc" id="L709">			Elements.forEach((k, v) -&gt; </span>
			{
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">				if(Actor.act(v)) {actorCheck[0]=true;}</span>
<span class="fc" id="L712">			});</span>
<span class="fc" id="L713">			return actorCheck[0];</span>
		}
		//==============================================================================
		@Override
		public synchronized AbstractSpaceMap addAll(LinkedList&lt;SurfaceObject&gt; elements)
		{
<span class="nc bnc" id="L719" title="All 2 branches missed.">			if(elements==null) {return this;}	</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">			if(Elements==null) </span>
			   {
<span class="nc bnc" id="L722" title="All 2 branches missed.">					if(elements.size()&lt;=MAX) </span>
					{
<span class="nc" id="L724">						Elements=new HashMap&lt;SurfaceObject, SurfaceObject&gt;();</span>
<span class="nc" id="L725">						elements.forEach((v)-&gt;{Elements.put(v, v);});</span>
					}
<span class="nc" id="L727">				return this;</span>
			   }
			
<span class="nc bnc" id="L730" title="All 2 branches missed.">			if((elements.size()+Elements.size())&gt;MAX) {return this;}//return new branch!</span>
			
<span class="nc" id="L732">			elements.forEach((v)-&gt;{Elements.put(v, v);});</span>
<span class="nc" id="L733">			return this;</span>
		}
		//==============================================================================
		@Override
		public synchronized LinkedList&lt;SurfaceObject&gt; getAll()
		{
			//if(Elements!=null){
			//	LinkedList&lt;SurfaceObject&gt; List = this.getLeaveElements();
			//	Elements.forEach((k, v) -&gt; {List.add(v);});
			//	return List;
			//}
<span class="fc" id="L744">			return this.getLeaveElements();</span>
		}
		//==============================================================================
		@Override
		public synchronized Object applyAndGet(AdvancedMapAction Actor) 
		{
<span class="nc bnc" id="L750" title="All 2 branches missed.">			if(Elements==null) {return null;}</span>
<span class="nc" id="L751">			Object[] thing = {null};</span>
<span class="nc" id="L752">			Elements.forEach((k, v) -&gt; </span>
			{
<span class="nc" id="L754">				thing[0]=Actor.act(thing[0], v);</span>
<span class="nc" id="L755">			});</span>
<span class="nc" id="L756">			return thing;</span>
		}
		//==============================================================================
		@Override
		public synchronized Object applyAndGet(Object Data, AdvancedMapAction Actor) 
		{
<span class="nc bnc" id="L762" title="All 2 branches missed.">			if(Elements==null) {return Data;}</span>
<span class="nc" id="L763">			Object[] enclosed = {Data};</span>
<span class="nc" id="L764">			Elements.forEach((k, v) -&gt; {enclosed[0]=Actor.act(enclosed[0], v);});</span>
<span class="nc" id="L765">			return Data;</span>
		}
		//==============================================================================
		@Override
		public synchronized void apply(Object Data, AdvancedMapAction Actor) 
		{
<span class="nc bnc" id="L771" title="All 2 branches missed.">			if(Elements==null) {return;}</span>
<span class="nc" id="L772">			Object[] enclosed = {Data};</span>
<span class="nc" id="L773">			Elements.forEach((k, v) -&gt; {enclosed[0]=Actor.act(enclosed[0], v);});</span>
<span class="nc" id="L774">		}</span>
		@Override
		public synchronized LinkedList&lt;SurfaceObject&gt; getAllWithin(double[] frame) {
<span class="fc" id="L777">			LinkedList&lt;SurfaceObject&gt; List = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="fc" id="L778">			_withinFrame(List, Elements, frame);</span>
<span class="fc" id="L779">			return List;</span>
		}
		@Override
		public synchronized LinkedList&lt;SurfaceObject&gt; findAllWithin(double[] frame, MapAction Actor)
		{
<span class="fc" id="L784">			LinkedList&lt;SurfaceObject&gt; List = new LinkedList&lt;SurfaceObject&gt;();</span>
<span class="fc" id="L785">			_withinFrame(List, Elements, frame);</span>
<span class="fc" id="L786">			return List;</span>
		}
		@Override
		public synchronized boolean applyToAllWithin(double[] frame, MapAction Actor) 
		{
<span class="fc" id="L791">			boolean[] check = {false};</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">			if(Elements!=null) </span>
			{
<span class="fc" id="L794">				Elements.forEach(</span>
					(k,o)-&gt;
					{
<span class="pc bpc" id="L797" title="1 of 4 branches missed.">						if(o.getRightPeripheral()&gt;frame[0]&amp;&amp;o.getLeftPeripheral()&lt;frame[2]</span>
<span class="pc bpc" id="L798" title="1 of 4 branches missed.">						 &amp;&amp;o.getBottomPeripheral()&gt;frame[1]&amp;&amp;o.getTopPeripheral()&lt;frame[3]) </span>
						{
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">							if(Actor.act(o)) </span>
<span class="fc" id="L801">							{check[0]=true;}</span>
						}
						
<span class="fc" id="L804">					});</span>
			}
<span class="fc" id="L806">			return check[0];</span>
		}
	}
	//===============================================================================================
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


}




</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>