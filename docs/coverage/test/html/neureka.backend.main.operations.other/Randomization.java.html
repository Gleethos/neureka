<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Randomization.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.backend.main.operations.other</a> &gt; <span class="el_source">Randomization.java</span></div><h1>Randomization.java</h1><pre class="source lang-java linenums">package neureka.backend.main.operations.other;

import neureka.Tsr;
import neureka.backend.api.AutoDiffMode;
import neureka.backend.api.ExecutionCall;
import neureka.backend.api.template.algorithms.AbstractDeviceAlgorithm;
import neureka.backend.api.template.operations.AbstractOperation;
import neureka.backend.api.template.operations.OperationBuilder;
import neureka.backend.main.algorithms.Activation;
import neureka.backend.main.implementations.CPUImplementation;
import neureka.calculus.Function;
import neureka.calculus.args.Arg;
import neureka.devices.host.CPU;
import neureka.devices.opencl.OpenCLDevice;
import neureka.ndim.iterator.NDIterator;

import java.util.Arrays;

/**
 *  This {@link neureka.backend.api.Operation} takes an optional user seed,
 *  the shape of its input tensor, and
 *  the indices of individual elements within said tensor to generate
 *  floats or doubles with a gaussian distribution where the mean
 *  is 0 and the standard deviation is 1.
 *  This operation is very fast because it generates numbers in parallel unlike
 *  the JDKs random number generator class {@link java.util.Random}.
 */
public class Randomization extends AbstractOperation
{
    private static final long   MULTIPLIER = 0x5DEECE66DL;
    private static final long   ADDEND = 0xBL;
    private static final long   MASK = (1L &lt;&lt; 48) - 1;
    private static final double DOUBLE_UNIT = 0x1.0p-53; // 1.0 / (1L &lt;&lt; 53)

    public Randomization()
    {
<span class="fc" id="L37">        super(</span>
            new OperationBuilder()
<span class="fc" id="L39">                .setIdentifier(       &quot;random&quot;   )</span>
<span class="fc" id="L40">                .setOperator(         &quot;rand&quot;     )</span>
<span class="fc" id="L41">                .setArity(            1          )</span>
<span class="fc" id="L42">                .setIsOperator(       true       )</span>
<span class="fc" id="L43">                .setIsIndexer(        false      )</span>
<span class="fc" id="L44">                .setIsDifferentiable( false      )</span>
<span class="fc" id="L45">                .setIsInline(         true       )</span>
        );

<span class="fc" id="L48">        setAlgorithm(</span>
            new Activation()
<span class="fc" id="L50">                .setAutogradModeFor( call -&gt; AutoDiffMode.NOT_SUPPORTED)</span>
<span class="fc" id="L51">                .setDeviceExecution( (context, callback) -&gt; AbstractDeviceAlgorithm.executeDeviceAlgorithm( context.call(), callback ) )</span>
<span class="fc" id="L52">                .setCallPreparation( call -&gt;</span>
                {
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">                    if ( call.input( 0 ) == null )</span>
<span class="fc" id="L55">                        call = call.withInputAt( 0, call.input( 1 ) );</span>

<span class="fc" id="L57">                    call.input( 0 ).getUnsafe().incrementVersion(call);</span>

<span class="fc" id="L59">                    int hash = Arrays.hashCode( call.input( 0 ).getNDConf().shape() );</span>
<span class="fc" id="L60">                    Arg.Seed seed = call.get(Arg.Seed.class);</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">                    if ( seed != null ) seed = Arg.Seed.of( initialScramble(seed.get() + hash) );</span>
<span class="fc" id="L62">                    else seed = Arg.Seed.of( initialScramble(hash) );</span>

<span class="fc" id="L64">                    return call.withArgs(seed);</span>
                })
<span class="fc" id="L66">                .buildFunAlgorithm()</span>
<span class="fc" id="L67">                .setImplementationFor(</span>
                    CPU.class,
                    CPUImplementation
<span class="fc" id="L70">                        .withArity(1)</span>
<span class="fc" id="L71">                        .andImplementation(</span>
                            call -&gt; {
<span class="fc" id="L73">                                call</span>
<span class="fc" id="L74">                                .getDevice()</span>
<span class="fc" id="L75">                                .getExecutor()</span>
<span class="fc" id="L76">                                .threaded(</span>
<span class="fc" id="L77">                                    call.input( Number.class, 0 ).size(),</span>
<span class="fc" id="L78">                                    _newWorkloadFor( call )</span>
                                );
<span class="fc" id="L80">                                return call.input( 0 );</span>
                            }
                        )
                )
<span class="fc" id="L84">                .setImplementationFor(</span>
                    OpenCLDevice.class,
                    call -&gt; {
<span class="nc" id="L87">                        throw new IllegalStateException(&quot;Not yet implemented&quot;);</span>
                    }
                )
        );

<span class="fc" id="L92">    }</span>

    private static CPU.RangeWorkload _newWorkloadFor( ExecutionCall&lt;?&gt; call )
    {
<span class="fc" id="L96">        Tsr&lt;?&gt; tensor = call.input( 0 );</span>
<span class="fc" id="L97">        tensor.setIsVirtual(false);</span>
<span class="fc" id="L98">        Class&lt;?&gt; type = tensor.getItemType();</span>
<span class="fc" id="L99">        boolean isSimple = tensor.getNDConf().isSimple();</span>
<span class="fc" id="L100">        long seed = call.getValOf(Arg.Seed.class);</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">        if ( type == Double.class ) {</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">            if ( isSimple )</span>
<span class="fc" id="L104">                return (i, end) -&gt; {</span>
<span class="fc" id="L105">                    double[] t0_value = tensor.getUnsafe().getDataForWriting(double[].class);</span>
<span class="fc" id="L106">                    double[] gaussian = {0, 0};</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">                    if ( i % 2 == 1 ) {</span>
<span class="fc" id="L108">                        gaussianFrom(seed + i - 1, gaussian);</span>
<span class="fc" id="L109">                        t0_value[i] = gaussian[1];</span>
<span class="fc" id="L110">                        i++;</span>
                    }
<span class="fc bfc" id="L112" title="All 2 branches covered.">                    for ( ; i &lt; end; i += 2 ) // increment on drain accordingly:</span>
                    {
<span class="fc" id="L114">                        gaussianFrom(seed + i, gaussian);</span>
<span class="fc" id="L115">                        t0_value[i + 0] = gaussian[0];</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">                        if ( i + 1 &lt; end ) t0_value[i + 1] = gaussian[1];</span>
                    }
<span class="fc" id="L118">                };</span>
            else
<span class="fc" id="L120">                return (i, end) -&gt; {</span>
<span class="fc" id="L121">                    NDIterator t0Idx = NDIterator.of(tensor);</span>
<span class="fc" id="L122">                    t0Idx.set(tensor.indicesOfIndex(i));</span>
<span class="fc" id="L123">                    double[] t0_value = tensor.getUnsafe().getDataForWriting(double[].class);</span>
<span class="fc" id="L124">                    double[] gaussian = {0, 0};</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                    if ( i % 2 == 1 ) {</span>
<span class="fc" id="L126">                        gaussianFrom(seed + i - 1, gaussian);</span>
<span class="fc" id="L127">                        t0_value[t0Idx.getIndexAndIncrement()] = gaussian[1];</span>
<span class="fc" id="L128">                        i++;</span>
                    }
<span class="fc bfc" id="L130" title="All 2 branches covered.">                    for ( ; i &lt; end; i += 2 ) // increment on drain accordingly:</span>
                    {
<span class="fc" id="L132">                        gaussianFrom(seed + i, gaussian);</span>
<span class="fc" id="L133">                        t0_value[t0Idx.getIndexAndIncrement()] = gaussian[0];</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">                        if ( i + 1 &lt; end ) t0_value[t0Idx.getIndexAndIncrement()] = gaussian[1];</span>
                    }
<span class="fc" id="L136">                };</span>
        } else {
<span class="fc bfc" id="L138" title="All 2 branches covered.">            if ( isSimple )</span>
<span class="fc" id="L139">                return (i, end) -&gt; {</span>
<span class="fc" id="L140">                    float[] t0_value = tensor.getUnsafe().getDataForWriting(float[].class);</span>
<span class="fc" id="L141">                    double[] gaussian = {0, 0};</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">                    if ( i % 2 == 1 ) {</span>
<span class="fc" id="L143">                        gaussianFrom(seed + i - 1, gaussian);</span>
<span class="fc" id="L144">                        t0_value[i] = (float) gaussian[1];</span>
<span class="fc" id="L145">                        i++;</span>
                    }
<span class="fc bfc" id="L147" title="All 2 branches covered.">                    for ( ; i &lt; end; i += 2 ) // increment on drain accordingly:</span>
                    {
<span class="fc" id="L149">                        gaussianFrom(seed + i, gaussian);</span>
<span class="fc" id="L150">                        t0_value[i + 0] = (float) gaussian[0];</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">                        if ( i + 1 &lt; end ) t0_value[i + 1] = (float) gaussian[1];</span>
                    }
<span class="fc" id="L153">                };</span>
            else
<span class="fc" id="L155">                return (i, end) -&gt; {</span>
<span class="fc" id="L156">                    NDIterator t0Idx = NDIterator.of(tensor);</span>
<span class="fc" id="L157">                    t0Idx.set(tensor.indicesOfIndex(i));</span>
<span class="fc" id="L158">                    float[] t0_value = tensor.getUnsafe().getDataForWriting(float[].class);</span>
<span class="fc" id="L159">                    double[] gaussian = {0, 0};</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">                    if ( i % 2 == 1 ) {</span>
<span class="fc" id="L161">                        gaussianFrom(seed + i - 1, gaussian);</span>
<span class="fc" id="L162">                        t0_value[t0Idx.getIndexAndIncrement()] = (float) gaussian[1];</span>
<span class="fc" id="L163">                        i++;</span>
                    }
<span class="fc bfc" id="L165" title="All 2 branches covered.">                    for ( ; i &lt; end; i += 2 ) // increment on drain accordingly:</span>
                    {
<span class="fc" id="L167">                        gaussianFrom(seed + i, gaussian);</span>
<span class="fc" id="L168">                        t0_value[t0Idx.getIndexAndIncrement()] = (float) gaussian[0];</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                        if ( i + 1 &lt; end ) t0_value[t0Idx.getIndexAndIncrement()] = (float) gaussian[1];</span>
                    }
<span class="fc" id="L171">                };</span>
        }
    }

    @Override
    public String stringify( String[] children ) {
<span class="fc" id="L177">        String expression = String.join( &quot;, &quot;, children );</span>
<span class="pc bpc" id="L178" title="3 of 4 branches missed.">        if ( expression.charAt( 0 ) == '(' &amp;&amp; expression.charAt( expression.length() - 1 ) == ')' ) {</span>
<span class="nc" id="L179">            return &quot;rand&quot; + expression;</span>
        }
<span class="fc" id="L181">        return &quot;rand&quot; + &quot;(&quot; + expression + &quot;)&quot;;</span>
    }

    @Override
    public String asDerivative( Function[] children, int derivationIndex) {
<span class="nc" id="L186">        throw new IllegalStateException(&quot;Operation does not support dynamic derivation!&quot;);</span>
    }

    @Override
    public double calculate( double[] inputs, int j, int d, Function[] src ) {
<span class="nc" id="L191">        return src[ 0 ].call( inputs, j );</span>
    }

<span class="fc" id="L194">    public static long initialScramble( long seed ) { return (seed ^ MULTIPLIER) &amp; MASK; }</span>

    public static void gaussianFrom( long seed, double[] out )
    {
        // See Knuth, ACP, Section 3.4.1 Algorithm C.
        double v1, v2, s;
        do {
<span class="fc" id="L201">            long seed1 = _next(seed );</span>
<span class="fc" id="L202">            long seed2 = _next(seed1);</span>
<span class="fc" id="L203">            long seed3 = _next(seed2);</span>
<span class="fc" id="L204">            long seed4 = _next(seed3);</span>
<span class="fc" id="L205">            v1 = 2 * _doubleFrom( seed1, seed2 ) - 1; // between -1 and 1</span>
<span class="fc" id="L206">            v2 = 2 * _doubleFrom( seed3, seed4 ) - 1; // between -1 and 1</span>
<span class="fc" id="L207">            s = v1 * v1 + v2 * v2;</span>
<span class="fc" id="L208">            seed = seed4;</span>
        }
<span class="pc bpc" id="L210" title="1 of 4 branches missed.">        while ( s &gt;= 1 || s == 0 );</span>

<span class="fc" id="L212">        double multiplier = StrictMath.sqrt( -2 * StrictMath.log(s) / s );</span>

<span class="fc" id="L214">        out[0] = v1 * multiplier;</span>
<span class="fc" id="L215">        out[1] = v2 * multiplier;</span>
<span class="fc" id="L216">    }</span>

    private static long _next( long currentSeed )
    {
        long oldseed, nextseed;
        do {
<span class="fc" id="L222">            oldseed = currentSeed;</span>
<span class="fc" id="L223">            nextseed = (oldseed * MULTIPLIER + ADDEND) &amp; MASK;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        } while ( oldseed == (currentSeed = nextseed) );</span>
<span class="fc" id="L225">        return nextseed;</span>
    }

    private static double _doubleFrom( long seed1, long seed2 )
    {
<span class="fc" id="L230">        return (((long)(_intFrom(26, seed1)) &lt;&lt; 27) + _intFrom(27, seed2)) * DOUBLE_UNIT;</span>
    }

<span class="fc" id="L233">    private static int _intFrom( int bits, long seed ) { return (int)(seed &gt;&gt;&gt; (48 - bits)); }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>