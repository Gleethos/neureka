<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tsr.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka</a> &gt; <span class="el_source">Tsr.java</span></div><h1>Tsr.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 __________
 \__    ___\
    |  |____ _ __
    | /  ___/ '___\
    | \___  \ |
     \/_____/_|         A long yet shallow class.

    This is the the core work-horse class of Neureka. The 'Tsr' class!
    It is a three-letter abbreviation of the word &quot;Tensor&quot;!

------------------------------------------------------------------------------------------------------------------------

   'Any fool can write code that a computer can understand.
    Good programmers write code that humans can understand.'
    â€“ Martin Fowler

    Use the following as search keys :)

    $(1) : CONSTRUCTION
        $(1.0) : GENERIC CONSTRUCTION
        $(1.1) : SHAPE LIST BASED CONSTRUCTION
        $(1.2) : SHAPE ARRAY BASED CONSTRUCTION
        Â§(1.3) : LAMBDA BASED CONSTRUCTION
        Â§(1.4) : FUNCTION BASED CONSTRUCTION

    Â§(2) : FLAGS
        Â§(2.0) : GRADIENT REQUIREMENT
        Â§(2.1) : SOURCE LOCATION (DEVICE)
        Â§(2.2) : VIRTUAL / ACTUAL
        Â§(2.3) : GRADIENT APPLY REQUIREMENT
        Â§(2.4) : DELETION

    Â§(3) : COMPONENT SYSTEM
        Â§(3.0) : SETTING / REJECTING
        Â§(3.1) : REMOVING / REJECTING
        Â§(3.2) : UPDATING

    Â§(4) : PROPERTIES
        $(4.0) : HIGH LEVEL PROPERTIES
        Â§(4.1) : COMPONENT PROPERTIES
        Â§(4.2) : INNER PROPERTIES

    Â§(5) : OBJECT STATE MODIFICATION

    Â§(6) : ND-ITERATOR LOGIC

    Â§(7) : COMPONENT SPECIFIC
        Â§(7.0) : AUTO-GRAD
        Â§(7.1) : FRAMING

    Â§(8) : (OVERLOADABLE) OPERATORS &amp; OPERATIONS
        Â§(8.0) : OPERATORS
        Â§(8.1) : OPERATIONS

    Â§(9) : SLICING, INDEXING &amp; INJECTING
        Â§(9.0) : SLICING
        Â§(9.1) : INJECTING

    Â§(10) : MAPPING
*/

package neureka;

import neureka.autograd.GraphNode;
import neureka.autograd.JITProp;
import neureka.backend.api.ExecutionCall;
import neureka.backend.main.memory.MemUtil;
import neureka.backend.main.operations.other.Reshape;
import neureka.calculus.Function;
import neureka.calculus.Functions;
import neureka.common.composition.AbstractComponentOwner;
import neureka.common.composition.Component;
import neureka.common.utility.DataConverter;
import neureka.common.utility.ListReader;
import neureka.common.utility.LogUtil;
import neureka.devices.Device;
import neureka.devices.host.CPU;
import neureka.dtype.DataType;
import neureka.dtype.custom.*;
import neureka.fluent.building.TensorBuilder;
import neureka.fluent.building.states.IterByOrIterFromOrAll;
import neureka.fluent.building.states.WithShapeOrScalarOrVector;
import neureka.fluent.building.states.WithShapeOrScalarOrVectorOnDevice;
import neureka.fluent.slicing.SliceBuilder;
import neureka.fluent.slicing.SmartSlicer;
import neureka.framing.NDFrame;
import neureka.framing.Relation;
import neureka.framing.fluent.AxisFrame;
import neureka.ndim.AbstractTensor;
import neureka.ndim.Filler;
import neureka.ndim.config.AbstractNDC;
import neureka.ndim.config.NDConfiguration;
import neureka.ndim.iterator.NDIterator;
import neureka.optimization.Optimizer;
import neureka.view.TsrAsString;
import neureka.view.TsrStringSettings;
import org.jetbrains.annotations.NotNull;
import org.slf4j.LoggerFactory;

import java.awt.*;
import java.awt.image.*;
import java.util.List;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;


/**
 *  This class name {@link Tsr} is a 3 letter abbreviation of the word &quot;tensor&quot;, a mathematical concept.
 *  A tensor is a type of multidimensional data-structure with certain transformation properties.
 *  Technically however, it is mostly a simple container / data-structure which can house data indexed by N dimensions.
 *  Therefore it is often also described as a nd-array.
 *  Elements of a tensor are also mostly numeric.&lt;br&gt;
 *  This means that: &lt;br&gt;
 *  &lt;i&gt;&lt;b&gt;...a tensor of rank 0 is a scalar, a tensor of rank 1 is a vector and a tensor of rank 2 is a matrix, etc...&lt;/b&gt;&lt;/i&gt;
 *  &lt;br&gt;&lt;br&gt;
 *  Consequently, tensors are a perfect fit for applying various operations on them.
 *  Such operations might be simple elementwise operations or more complex linear operations like
 *  the dot-product, matrix- or even tensor multiplications. &lt;br&gt;
 *  &lt;br&gt;
 * @param &lt;V&gt; The type parameter for the individual value items within this tensor.
 */
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">public class Tsr&lt;V&gt; extends AbstractTensor&lt;Tsr&lt;V&gt;, V&gt; implements Component&lt;Tsr&lt;V&gt;&gt;, Cloneable</span>
{
    static {
<span class="fc" id="L151">        _CPU = CPU.get();</span>
<span class="fc" id="L152">        _LOG = LoggerFactory.getLogger( Tsr.class );</span>
<span class="fc" id="L153">    }</span>

    /**
     *  The default device is an instance of the {@link CPU} class. &lt;br&gt;
     *  This field is a reference to this default device implementation.
     */
    private static final Device&lt;Object&gt; _CPU;

    /**
     *  This field contains multiple flags.
     *  The bits of this integer are used to encode various states which a tensor can have.
     *  These bits are flipped by bitmasks which are defined below.
     */
<span class="fc" id="L166">    private byte _flags = 0;</span>

    /**
     *  The following fields are bit masks used to store true / false values
     *  in a targeted bit inside the {@link #_flags} variable.
     */
    private static final byte RQS_GRADIENT_MASK       = 1;
    private static final byte IS_OUTSOURCED_MASK      = 2;
    private static final byte IS_VIRTUAL_MASK         = 4;
    private static final byte GRADIENT_APPLY_RQD_MASK = 8;
    private static final byte IS_DELETED_MASK         = 16;
    private static final byte IS_INTERMEDIATE_MASK    = 32;

    /**
     *  This integer represents the version of the data (accessible through {@link #getData()})
     *  stored within this tensor.
     *  It gets incremented every time an inline operation occurs!
     *  {@link GraphNode} instances tied to this tensor (as component) store
     *  a reference version which is a copy of this field.
     *  If this version changes, despite there being a GraphNode which might
     *  perform auto-differentiation at some point, then an exception will be thrown for debugging.
     *  &lt;br&gt;
     *  The corresponding getter returns the version of the data (accessible through {@link #getData()})
     *  stored within this tensor.
     */
<span class="fc" id="L191">    private int _version = 0;</span>


    /*==================================================================================================================
    |
    |       Â§(1) : CONSTRUCTION
    |   ---------------------------
    */
    /*
        -------------------------------------------
            Â§(1.0) : GENERIC CONSTRUCTION
        --------------------------------------------
    */

    /**
     *  This static factory method creates and return a completely empty and undefined tensor
     *  which is void of any contents and meaning.
     *  The use case for this would be to use the produced {@link Tsr}
     *  instance as a target for an inline operations which fills the instance with an actual value. &lt;br&gt;
     *  An example of this approach would be to call the {@link #putAt(List, Tsr)} method with an empty list as key.
     *  This will be interpreted as an inline copy of the contents of the
     *  second parameter into this {@link Tsr} instance.
     *
     * @return A new and completely empty / unitialized {@link Tsr} instance.
     */
<span class="fc" id="L216">    public static Tsr&lt;Object&gt; newInstance() { return new Tsr&lt;&gt;(); }</span>

    /**
     *  This constructor creates a completely empty tensor which is void of any contents and meaning.
     *  The use case for this would be to use the produced {@link Tsr}
     *  instance as a target for an inline operation which fills this instance with an actual value. &lt;br&gt;
     *  An example of this approach would be to call the {@link #putAt(List, Tsr)} method with an empty list as key.
     *  This will be interpreted as an inline copy of the contents of the
     *  second parameter into this {@link Tsr} instance.
     *  This constructor will be called by the {@link Tsr#newInstance()} factory method.
     */
<span class="fc" id="L227">    private Tsr() {}</span>

    /**
     *  Use this to conveniently operate on 2 tensors.
     *  A simple example would be: {@code Tsr.of(a,'*',b)}.
     *
     * @param a The left operand.
     * @param o The operator, which may be '+', '-', '*'...
     * @param b The right operand.
     * @param &lt;T&gt; The value item type parameter for the involved tensors.
     * @return The result of the operation defined by the provided character.
     */
<span class="nc" id="L239">    public static &lt;T&gt; Tsr&lt;T&gt; of( Tsr&lt;T&gt; a, char o, Tsr&lt;T&gt; b ) { return _of( a, String.valueOf(o), b ); }</span>

    /**
     *  Use this to conveniently operate on 3 tensors.
     *  A simple example would be: {@code Tsr.of(a,'*',b,'+',c)}.
     *
     * @param a The first and left most operand.
     * @param o1 The first operator, which may be '+', '-', '*'...
     * @param b The second operand.
     * @param o2 The second operator, which may also be '+', '-', '*'...
     * @param c The third and last operand.
     * @param &lt;T&gt; The value item type parameter for the involved tensors.
     * @return The result of the operations defined by the 2 provided characters.
     */
    public static &lt;T&gt; Tsr&lt;T&gt; of( Tsr&lt;T&gt; a, char o1, Tsr&lt;T&gt; b, char o2, Tsr&lt;T&gt; c ) {
<span class="nc" id="L254">        return _of( a, String.valueOf(o1), b, String.valueOf(o2), c );</span>
    }

    /**
     *  Use this to conveniently operate on a tensor.
     *  A simple example would be: {@code Tsr.of(&quot;sig(tanh(&quot;,a,&quot;))&quot;)}.
     *
     * @param e1 The first part of the string expression defining how the provided tensor should be processed.
     * @param a The tensor which ought to be sent to whatever is defined by the provided expressions.
     * @param e2 The latter part of the expression defining how the provided tensor should be executed.
     * @param &lt;T&gt; The value item type parameter for the involved tensor.
     * @return The result of the operation(s) defined by the provided strings.
     */
<span class="fc" id="L267">    public static &lt;T&gt; Tsr&lt;T&gt; of( String e1, Tsr&lt;T&gt; a, String e2 ) { return _of( e1, a, e2 ); }</span>

    /**
     *  Use this to conveniently operate on 2 tensors.
     *  A simple example would be: {@code Tsr.of(&quot;relu(&quot;,a,'-',b,&quot;)*2&quot;)}.
     *
     * @param e1 The first part of the string expression defining how the provided tensor should be processed.
     * @param a The first tensor which ought to be sent to whatever function is defined by the provided expressions.
     * @param o An operator combining both {@code a} and {@code b} to form a result.
     * @param b The second tensor and right operand which ought to be sent to whatever function is defined by the provided expressions.
     * @param e2 The latter part of the expression defining how the provided tensor should be executed.
     * @param &lt;T&gt; The value item type parameter for the involved tensor.
     * @return The result of the operation(s) defined by the provided strings.
     *
     */
    public static &lt;T&gt; Tsr&lt;T&gt; of( String e1, Tsr&lt;T&gt; a, char o, Tsr&lt;T&gt; b, String e2 ) {
<span class="fc" id="L283">        return _of( e1, a, String.valueOf(o), b, e2 );</span>
    }

    /**
     *  Use this to conveniently operate on 3 tensors.
     *  A simple example would be:
     *  {@code Tsr.of(&quot;abs((&quot;,a,&quot;-&quot;,b,&quot;) * &quot;,c,&quot;)&quot;)}.
     *
     * @param e1 The first part of the expression which would typically be used to define a function name.
     * @param a The first argument.
     * @param e2 The second part of the expression, which might be an operation.
     * @param b The second argument.
     * @param e3 The third part of the expression...
     * @param c The third argument.
     * @param e4 The last part of the expression which should syntactically match the other expression...
     * @param &lt;T&gt; The type parameter for the involved tensors.
     * @return The result of the calculation defined by the provided expressions and arguments.
     */
    public static &lt;T&gt; Tsr&lt;T&gt; of(
            String e1, Tsr&lt;T&gt; a, String e2, Tsr&lt;T&gt; b, String e3, Tsr&lt;T&gt; c, String e4
    ) {
<span class="fc" id="L304">        return _of( e1, a, e2, b, e3, c, e4 );</span>
    }


    /**
     *  This static {@link Tsr} factory method tries to interpret the provided
     *  arguments to create the instance the use might wants.
     *
     * @param args The arguments which ought to be interpreted.
     * @return The result of the interpretation in the form of a {@link Tsr} instance of typ {@link Object}.
     */
<span class="fc" id="L315">    public static &lt;T&gt; Tsr&lt;T&gt; of( Object... args ) { return _of( args ); }</span>

    private static &lt;T&gt; Tsr&lt;T&gt; _of( Object... args )
    {
<span class="pc bpc" id="L319" title="2 of 4 branches missed.">        if ( args == null || args.length == 0 ) return new Tsr&lt;&gt;();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if ( args.length == 1 ) {</span>
<span class="fc" id="L321">            Tsr&lt;T&gt; t = new Tsr&lt;&gt;();</span>
<span class="fc" id="L322">            boolean success = t.createConstructionAPI().constructAllFromOne( new int[]{ 1 }, args[ 0 ] );</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">            if ( !success ) {</span>
<span class="nc" id="L324">                String message = &quot;Cannot create tensor from argument of type '&quot; + args[ 0 ].getClass().getName() + &quot;'!&quot;;</span>
<span class="nc" id="L325">                _LOG.error( message );</span>
<span class="nc" id="L326">                throw new IllegalArgumentException( message );</span>
            }
<span class="fc" id="L328">            return t;</span>
        }
<span class="fc bfc" id="L330" title="All 2 branches covered.">        args[ 0 ] = ( args[ 0 ] instanceof ArrayList ) ? ( (List&lt;?&gt;) args[ 0 ] ).toArray() : args[ 0 ];</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        args[ 1 ] = ( args[ 1 ] instanceof ArrayList ) ? ( (List&lt;?&gt;) args[ 1 ] ).toArray() : args[ 1 ];</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if ( args[ 0 ] instanceof Object[] ) {</span>
<span class="pc bpc" id="L333" title="3 of 4 branches missed.">            if ( ( (Object[]) args[ 0 ] )[ 0 ] instanceof Integer || ((Object[])args[ 0 ])[ 0 ] instanceof Double) {</span>
<span class="fc" id="L334">                args[ 0 ] = DataConverter.get().convert( args[ 0 ], int[].class );</span>
            }
        }
        //CASES:
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if ( args[ 0 ] instanceof int[] ) {</span>
<span class="pc bpc" id="L339" title="3 of 4 branches missed.">            if ( args[ 1 ] instanceof Double || args[ 1 ] instanceof Integer ) {</span>
<span class="fc" id="L340">                Tsr&lt;T&gt; t = new Tsr&lt;&gt;();</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">                args[ 1 ] = ( args[ 1 ] instanceof Integer ) ? ( (Integer) args[ 1 ] ).doubleValue() : args[ 1 ];</span>
<span class="fc" id="L342">                t.createConstructionAPI().constructAllFromOne( (int[]) args[ 0 ], args[ 1 ] );</span>
<span class="fc" id="L343">                return t;</span>
            } else {
<span class="nc" id="L345">                Tsr&lt;T&gt; t = new Tsr&lt;&gt;();</span>
<span class="nc" id="L346">                t._setDataType( DataType.of( args[1].getClass() ) );</span>
<span class="nc" id="L347">                t._constructAndAllocate( (int[]) args[0], true );</span>
<span class="nc" id="L348">                ((Object[])t._getData())[0] = args[1];</span>
<span class="nc" id="L349">                return t;</span>
            }
        }
        /* EXPRESSION BASED CONSTRUCTION: 
            The following allows the creation of tensors based on passing an expression
            alongside input tensors to the constructor.
            An example would be:
            
                Tsr&lt;?&gt; t = Tsr.of( &quot;tanh(&quot;, x, &quot;) * 7 ^&quot;, y );  
        */
<span class="fc" id="L359">        boolean containsString = false;</span>
<span class="fc" id="L360">        int numberOfTensors = 0;</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        for ( Object o : args ) {</span>
<span class="fc bfc" id="L362" title="All 4 branches covered.">            containsString = ( o instanceof String ) || containsString;</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            if ( o instanceof Tsr )</span>
<span class="fc" id="L364">                numberOfTensors++;</span>
        }
<span class="fc" id="L366">        Tsr&lt;T&gt;[] tensors = new Tsr[ numberOfTensors ];</span>
<span class="fc" id="L367">        StringBuilder f = new StringBuilder();</span>
<span class="fc" id="L368">        int ti = 0;</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        for ( Object o : args ) {</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">            if ( o instanceof Tsr ) {</span>
<span class="fc" id="L371">                tensors[ ti ] = ( (Tsr&lt;T&gt;) o );</span>
<span class="fc" id="L372">                f.append( &quot;I[&quot; ).append( ti ).append( &quot;]&quot; );</span>
<span class="fc" id="L373">                ti++;</span>
            }
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">            else if ( o instanceof String ) f.append( (String) o );</span>
            else
<span class="nc" id="L377">                _LOG.debug(</span>
<span class="nc" id="L378">                    &quot;Unexpected tensor construction argument of type '&quot;+o.getClass().getSimpleName()+&quot;'&quot;</span>
                );
        }
<span class="pc bpc" id="L381" title="2 of 4 branches missed.">        if ( tensors.length == 0 || tensors[0] == null) return new Tsr&lt;&gt;();</span>
<span class="fc" id="L382">        return Function.of( f.toString(), true ).call( tensors );</span>
    }


    /*
        -------------------------------------------
            Â§(1.1) : SHAPE LIST BASED CONSTRUCTION
        --------------------------------------------
    */

    /**
     *  This is a convenient factory method for creating {@link Tsr} instances for
     *  values of type {@link T} based on a list of integers
     *  defining a shape made up of axes sizes as well as a scalar value of type {@link T}
     *  which will fill out the data array spanned by the provided shape information.
     *
     * @param shape A list of integers whose values ought to define the size of the axes of the shape of the new {@link Tsr}.
     * @param value An object of type {@link T} which will populate the data array of the new instance.
     * @return A new {@link Tsr} instance for the generic type {@link T}.
     */
    public static &lt;T&gt; Tsr&lt;T&gt; of( List&lt;Integer&gt; shape, T value ) {
<span class="fc" id="L403">        LogUtil.nullArgCheck( shape, &quot;shape&quot;, List.class );</span>
<span class="fc" id="L404">        LogUtil.nullArgCheck( value, &quot;value&quot;, Object.class );</span>
<span class="fc" id="L405">        return of( (Class&lt;T&gt;) value.getClass(), shape, value );</span>
    }

    /**
     *  This factory method will create and return a {@link Tsr} instance
     *  based on a list of {@link Number} instances whose rounded values will be interpreted as
     *  the shape of this new {@link Tsr} instance and a seed which will serve
     *  as a source of pseudo randomness to generate the values for the new instance.
     *
     * @param shape A list of {@link Number} instances which will be interpreted as a shape array.
     * @param seed A source of pseudo randomness for the {@link Tsr} instance created by this method.
     * @return A new {@link Tsr} instance created based on a shape and a seed.
     */
    public static Tsr&lt;Double&gt; of( List&lt;? extends Number&gt; shape, String seed ) {
<span class="fc" id="L419">        int[] shapeArray = new int[ shape.size() ];</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">        for ( int i = 0; i &lt; shapeArray.length; i++ ) shapeArray[ i ] = shape.get( i ).intValue();</span>
<span class="fc" id="L421">        return of( Double.class, shapeArray, seed );</span>
    }

    /**
     *  Creates a new {@link Tsr} instance based on a list of numbers representing the shape,
     *  and a list of values representing the value of the resulting tensor.
     *
     * @param shape A list of numbers whose integer values will be used to form the shape of the resulting {@link Tsr}.
     * @param value A list of values which will be used to populate the data array of the resulting {@link Tsr}.
     * @param &lt;V&gt; The type parameter of the value list and returned tensor.
     * @return A new {@link Tsr} instance constructed based on the provided shape and value list.
     */
    public static &lt;V&gt; Tsr&lt;V&gt; of( List&lt;? extends Number&gt; shape, List&lt;V&gt; value ) {
<span class="fc" id="L434">        Class&lt;V&gt; typeClass = (Class&lt;V&gt;) Object.class;</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        if ( value.size() &gt; 0 ) typeClass = (Class&lt;V&gt;) value.get(0).getClass();</span>
<span class="fc" id="L436">        return Tsr.of(</span>
<span class="fc" id="L437">                    DataType.of(typeClass),</span>
<span class="fc" id="L438">                    shape.stream().mapToInt(Number::intValue).toArray(),</span>
                    value
                );
    }

    /**
     *  Creates a new {@link Tsr} instance based on an array of integers representing the shape,
     *  and a list of values representing the value of the resulting tensor.
     *
     * @param shape An array of integers will be used to form the shape of the resulting {@link Tsr}.
     * @param value A list of values which will be used to populate the data array of the resulting {@link Tsr}.
     * @param &lt;V&gt; The type parameter of the value list and returned tensor.
     * @return A new {@link Tsr} instance constructed based on the provided shape and value list.
     */
    public static &lt;V&gt; Tsr&lt;V&gt; of( int[] shape, List&lt;V&gt; value ) {
<span class="fc" id="L453">        Class&lt;V&gt; typeClass = (Class&lt;V&gt;) Object.class;</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if ( value.size() &gt; 0 ) typeClass = (Class&lt;V&gt;) value.get(0).getClass();</span>
<span class="fc" id="L455">        return Tsr.of( DataType.of(typeClass), shape, value );</span>
    }

    /**
     *  This factory method will turn a list of values or nested lists of values into a {@link Tsr}
     *  instance with the corresponding rank and shape.
     *
     * @param conf A list of either values or nested lists which are themselves either or.
     * @return A new {@link Tsr} instance whose shape and data is based on the provided list structure.
     */
<span class="fc" id="L465">    public static Tsr&lt;Object&gt; of( List&lt;Object&gt; conf ) { return of( (Class&lt;Object&gt;) null, conf ); }</span>

    /**
     *  This factory method will turn a list of values or nested lists of values into a {@link Tsr}
     *  instance with the corresponding rank and shape and whose values
     *  are of the provided type.
     *
     * @param targetType The type of the tensor produced by this factory method.
     * @param conf A list of either values or nested lists which are themselves either or.
     * @param &lt;T&gt; The type parameter of the tensor returned by this factoy method.
     * @return A new {@link Tsr} instance whose shape and data is based on the provided list structure.
     */
    public static &lt;T&gt; Tsr&lt;T&gt; of( Class&lt;T&gt; targetType, List&lt;Object&gt; conf ) {
<span class="fc" id="L478">        boolean isDoubleMatrix = </span>
<span class="fc" id="L479">                            conf.stream()</span>
<span class="fc" id="L480">                                .allMatch( e -&gt;</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">                                    e instanceof List</span>
                                            &amp;&amp;
<span class="fc bfc" id="L483" title="All 2 branches covered.">                                    ((List&lt;Object&gt;) e).stream().allMatch( v -&gt; v instanceof Double )</span>
                                );

<span class="fc bfc" id="L486" title="All 2 branches covered.">        if ( isDoubleMatrix )</span>
<span class="fc" id="L487">            return new Tsr&lt;&gt;( conf );</span>

<span class="fc bfc" id="L489" title="All 2 branches covered.">        ListReader.Result result = ListReader.read( conf, o -&gt; ( o instanceof Number ? ((Number)o).doubleValue() : o ) );</span>
        Class&lt;T&gt; resultType;
        Object[] resultData;
<span class="fc" id="L492">        int[] shape = result.getShape().stream().mapToInt(i -&gt; i).toArray();</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if ( targetType == null ) {</span>
<span class="fc" id="L494">            resultType = (Class&lt;T&gt;) result.getType();</span>
<span class="fc" id="L495">            resultData = result.getData().toArray();</span>
        } else {
<span class="fc" id="L497">            DataConverter converter = DataConverter.get();</span>
<span class="fc" id="L498">            resultType = targetType;</span>
<span class="fc" id="L499">            resultData = result.getData().parallelStream().map( v -&gt; converter.convert(v, targetType) ).toArray();</span>
        }
<span class="fc" id="L501">        return Tsr.of( DataType.of(resultType), shape, resultData );</span>
    }

    /**
     *  See {@link #of(List)}.
     */
<span class="fc" id="L507">    private Tsr( List&lt;Object&gt; conf ) {</span>
<span class="fc" id="L508">        createConstructionAPI().constructFor( conf.stream().map(e -&gt; (List&lt;Object&gt;) e ).collect( Collectors.toList() ) );</span>
<span class="fc" id="L509">    }</span>

    /*
        -------------------------------------------
            Â§(1.2) : SHAPE ARRAY BASED CONSTRUCTION
        --------------------------------------------
    */

    /**
     *  This is the entry point to the fluent tensor builder API for building
     *  {@link Tsr} instances in a readable and type safe fashion.
     *  The returned {@link WithShapeOrScalarOrVector} is the next step in the
     *  fluent {@link Tsr} builder API which will lead to the creation
     *  of a tensor storing values defined by the provided type class.
     *
     * @return The next step of the {@link Tsr} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L526">    public static &lt;V&gt; WithShapeOrScalarOrVectorOnDevice&lt;V&gt; of( Class&lt;V&gt; typeClass ) { return new TensorBuilder&lt;&gt;( typeClass ); }</span>

    /**
     *  This is a simple convenience method which is simply calling the {@link Tsr#of(Class)}
     *  method like so: {@code Tsr.of(Double.class)}.
     *  The returned {@link WithShapeOrScalarOrVector} is the next step in the
     *  fluent {@link Tsr} builder API which in this case will lead to the creation
     *  of a tensor storing doubles.
     *
     * @return The next step of the {@link Tsr} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L537">    public static WithShapeOrScalarOrVectorOnDevice&lt;Double&gt; ofDoubles() { return of(Double.class); }</span>

    /**
     *  This is a simple convenience method which is simply calling the {@link Tsr#of(Class)}
     *  method like so: {@code Tsr.of(Float.class)}.
     *  The returned {@link WithShapeOrScalarOrVector} is the next step in the
     *  fluent {@link Tsr} builder API which in this case will lead to the creation
     *  of a tensor storing floats.
     *
     * @return The next step of the {@link Tsr} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L548">    public static WithShapeOrScalarOrVectorOnDevice&lt;Float&gt; ofFloats() { return of(Float.class); }</span>

    /**
     *  This is a simple convenience method which is simply calling the {@link Tsr#of(Class)}
     *  method like so: {@code Tsr.of(Integer.class)}.
     *  The returned {@link WithShapeOrScalarOrVector} is the next step in the
     *  fluent {@link Tsr} builder API which in this case will lead to the creation
     *  of a tensor storing integers.
     *
     * @return The next step of the {@link Tsr} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L559">    public static WithShapeOrScalarOrVectorOnDevice&lt;Integer&gt; ofInts() { return of(Integer.class); }</span>

    /**
     *  This is a simple convenience method which is simply calling the {@link Tsr#of(Class)}
     *  method like so: {@code Tsr.of(Short.class)}.
     *  The returned {@link WithShapeOrScalarOrVector} is the next step in the
     *  fluent {@link Tsr} builder API which in this case will lead to the creation
     *  of a tensor storing shorts.
     *
     * @return The next step of the {@link Tsr} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L570">    public static WithShapeOrScalarOrVectorOnDevice&lt;Short&gt; ofShorts() { return of(Short.class); }</span>

    /**
     *  This is a simple convenience method which is simply calling the {@link Tsr#of(Class)}
     *  method like so: {@code Tsr.of(Byte.class)}.
     *  The returned {@link WithShapeOrScalarOrVector} is the next step in the
     *  fluent {@link Tsr} builder API which in this case will lead to the creation
     *  of a tensor storing bytes.
     *
     * @return The next step of the {@link Tsr} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L581">    public static WithShapeOrScalarOrVectorOnDevice&lt;Byte&gt; ofBytes() { return of(Byte.class); }</span>

    /**
     * @param value The scalar value which ought to be represented as tensor.
     * @return A scalar double tensor.
     */
<span class="fc" id="L587">    public static Tsr&lt;Double&gt; of( double value ) { return Tsr.of( Double.class, new int[]{ 1 }, value ); }</span>

    /**
     *  Constructs a vector of floats based on the provided array.
     *
     * @param value The array of floats from which a 1D tensor ought to be constructed.
     * @return A vector / 1D tensor of floats.
     */
<span class="fc" id="L595">    public static Tsr&lt;Float&gt; of( float... value ) { return Tsr.of( Float.class, new int[]{ value.length }, value ); }</span>

    /**
     *  Constructs a vector of doubles based on the provided array.
     *
     * @param value The array of doubles from which a 1D tensor ought to be constructed.
     * @return A vector / 1D tensor of doubles.
     */
<span class="fc" id="L603">    public static Tsr&lt;Double&gt; of( double... value ) { return Tsr.of( Double.class, new int[]{ value.length }, value ); }</span>

    /**
     *  Constructs a vector of bytes based on the provided array.
     *
     * @param value The array of bytes from which a 1D tensor ought to be constructed.
     * @return A vector / 1D tensor of bytes.
     */
<span class="fc" id="L611">    public static Tsr&lt;Byte&gt; of( byte... value ) { return Tsr.of( Byte.class, new int[]{ value.length }, value ); }</span>

    /**
     *  Constructs a vector of ints based on the provided array.
     *
     * @param value The array of ints from which a 1D tensor ought to be constructed.
     * @return A vector / 1D tensor of ints.
     */
<span class="fc" id="L619">    public static Tsr&lt;Integer&gt; of( int... value ) { return Tsr.of( Integer.class, new int[]{ value.length }, value ); }</span>

    /**
     *  Constructs a vector of longs based on the provided array.
     *
     * @param value The array of longs from which a 1D tensor ought to be constructed.
     * @return A vector / 1D tensor of longs.
     */
<span class="fc" id="L627">    public static Tsr&lt;Long&gt; of( long... value ) { return Tsr.of( Long.class, new int[]{ value.length }, value ); }</span>

    /**
     *  Constructs a vector of shorts based on the provided array.
     *
     * @param value The array of shorts from which a 1D tensor ought to be constructed.
     * @return A vector / 1D tensor of shorts.
     */
<span class="fc" id="L635">    public static Tsr&lt;Short&gt; of( short... value ) { return Tsr.of( Short.class, new int[]{ value.length }, value ); }</span>

    /**
     *  Constructs a vector of booleans based on the provided array.
     *
     * @param value The array of booleans from which a 1D tensor ought to be constructed.
     * @return A vector / 1D tensor of shorts.
     */
<span class="fc" id="L643">    public static Tsr&lt;Boolean&gt; of( boolean... value ) { return Tsr.of( Boolean.class, new int[]{ value.length }, value ); }</span>

    /**
     *  Use this to construct and return a seeded tensor of the specified type.
     *
     * @param valueType The type class of the items stored by the resulting tensor.
     * @param shape The shape of the resulting tensor consisting of any number of axis-sizes.
     * @param seed An arbitrary {@link String} whose hash will be used to as a seed.
     * @param &lt;V&gt; The type parameter of individual tensor items.
     * @return A newly created and seeded tensor of the provided type and shape.
     */
<span class="fc" id="L654">    public static &lt;V&gt; Tsr&lt;V&gt; of( Class&lt;V&gt; valueType, int[] shape, String seed ) { return new Tsr&lt;&gt;( valueType, shape, seed ); }</span>

    /**
     *  See {@link #of(Class, int[], String)} and {@link #of(List, String)}
     */
<span class="fc" id="L659">    private Tsr( Class&lt;V&gt; valueType, int[] shape, String seed ) {</span>
<span class="fc" id="L660">        createConstructionAPI().constructSeeded( valueType, shape, seed );</span>
<span class="fc" id="L661">    }</span>

<span class="fc" id="L663">    public static Tsr&lt;Double&gt; of( int[] shape, double value ) { return Tsr.of( Double.class, shape, value ); }</span>

<span class="fc" id="L665">    public static Tsr&lt;Double&gt; of( int[] shape, double[] value ) { return Tsr.of( Double.class, shape, value ); }</span>

<span class="fc" id="L667">    public static Tsr&lt;Integer&gt; of( int[] shape, int[] value ) { return Tsr.of( Integer.class, shape, value ); }</span>

<span class="fc" id="L669">    public static Tsr&lt;Byte&gt; of( int[] shape, byte[] value ) { return Tsr.of( Byte.class, shape, value ); }</span>

<span class="fc" id="L671">    public static Tsr&lt;Long&gt; of( int[] shape, long[] value ) { return Tsr.of( Long.class, shape, value ); }</span>

<span class="fc" id="L673">    public static Tsr&lt;Short&gt; of( int[] shape, short[] value ) { return Tsr.of( Short.class, shape, value ); }</span>

<span class="fc" id="L675">    public static Tsr&lt;Float&gt; of( int[] shape, float[] value ) { return Tsr.of( Float.class, shape, value ); }</span>

<span class="fc" id="L677">    public static Tsr&lt;Boolean&gt; of( int[] shape, boolean[] value ) { return Tsr.of( Boolean.class, shape, value ); }</span>

<span class="fc" id="L679">    public static &lt;V&gt; Tsr&lt;V&gt; of( DataType&lt;V&gt; type, int[] shape ) { return new Tsr&lt;&gt;( shape, type ); }</span>

    private Tsr( int[] shape, DataType&lt;?&gt; type )
<span class="fc" id="L682">    {</span>
<span class="fc" id="L683">        _setDataType( DataType.of( type.getRepresentativeType() ) );</span>
<span class="fc" id="L684">        _constructAndAllocate( shape, true );</span>
<span class="fc" id="L685">    }</span>

    public static &lt;V&gt; Tsr&lt;V&gt; of( Class&lt;V&gt; typeClass, int[] shape, Object data ) {
<span class="fc" id="L688">        return of( DataType.of(typeClass), shape, data );</span>
    }

    public static &lt;V&gt; Tsr&lt;V&gt; of( Class&lt;V&gt; typeClass, List&lt;Integer&gt; shape, Object data ) {
<span class="fc" id="L692">        return of( DataType.of(typeClass), shape.stream().mapToInt(i -&gt; i).toArray(), data );</span>
    }

    public static &lt;V&gt; Tsr&lt;V&gt; of( Class&lt;V&gt; typeClass, List&lt;Integer&gt; shape, List&lt;V&gt; data ) {
<span class="fc" id="L696">        return of( DataType.of( typeClass ), shape.stream().mapToInt( e -&gt; e ).toArray(), data );</span>
    }

    public static &lt;V&gt; Tsr&lt;V&gt; of( DataType&lt;V&gt; dataType, List&lt;Integer&gt; shape,  List&lt;V&gt; data ) {
<span class="fc" id="L700">        return of( dataType, shape.stream().mapToInt( i -&gt; i ).toArray(), data.toArray() );</span>
    }

    /**
     *  This factory method is among the most flexible and forgiving ways to create a {@link Tsr} instance.
     *  It receives a {@link DataType} for type safety and to ensure that the produced {@link Tsr} instance
     *  will contain elements of the correct type, a shape array which stores the sizes of the axes that the
     *  instance ought to possess, and finally it receives a data {@link Object} which can be anything ranging from
     *  a {@link List} to an array or simply a single value which ought to fill out the entire {@link Tsr}.
     *
     * @param dataType The data type of the data represented by {@link Tsr} instance created by this method.
     * @param shape An array of axis sizes describing the dimensionality of the {@link Tsr} created by this method.
     * @param data The data for the {@link Tsr} that is about to be created, which can be a list, an array or scalar.
     * @return A new {@link Tsr} instance of the specified type, shape and containing the provided data.
     */
<span class="fc" id="L715">    public static &lt;V&gt; Tsr&lt;V&gt; of( DataType&lt;V&gt; dataType, int[] shape, Object data ) { return new Tsr&lt;&gt;( shape, dataType, data ); }</span>

<span class="fc" id="L717">    private Tsr( int[] shape, DataType&lt;?&gt; dataType, Object data ) { createConstructionAPI().tryConstructing( shape, dataType, data ); }</span>

    // Inner construction layer:

    private void _constructAndAllocate(int[] shape, boolean virtual )
    {
<span class="fc" id="L723">        createConstructionAPI().configureFromNewShape( shape, virtual, true );</span>
<span class="fc" id="L724">    }</span>

    /*
        -------------------------------------------
            Â§(1.3) : LAMBDA BASED CONSTRUCTION
        --------------------------------------------
    */

    /**
     *  This factory method allows the creation of tensors with an additional initialization
     *  lambda for filling the underlying data array with desired values.
     *  Other than regular numeric types it is also possible to initialize the
     *  tensor with regular Objects like String instances or custom data types like complex
     *  numbers for example... &lt;br&gt;
     *  Therefore the constructor requires not only a shape as argument but also
     *  the data type which ought to be allocated as well as the initialization
     *  lambda which will be called iteratively.
     *
     * @param type The data type this tensor ought to have.
     * @param shape The shape of this new tensor ought to have.
     * @param filler The lambda Object which ought to fill this tensor with the appropriate data.
     * @param &lt;T&gt; The type parameter for the actual data array items.
     */
    public static &lt;T&gt; Tsr&lt;T&gt; of( DataType&lt;T&gt; type, List&lt;Integer&gt; shape, Filler&lt;T&gt; filler) {
<span class="fc" id="L748">        LogUtil.nullArgCheck( shape, &quot;shape&quot;, List.class );</span>
<span class="fc" id="L749">        return Tsr.of( type, shape.stream().mapToInt( e -&gt; e ).toArray(), filler );</span>
    }

    /**
     *  This factory method allows the creation of tensors with an additional initialization
     *  lambda for filling the underlying data array with desired values.
     *  Besides regular numeric types it is also possible to initialize the
     *  tensor with regular objects like {@link String} instances or custom data types like complex
     *  numbers for example... &lt;br&gt;
     *  Therefore the constructor requires not only a shape as argument but also
     *  the data type which ought to be allocated as well as the initialization
     *  lambda which will be called iteratively.
     *
     * @param type The data type this tensor ought to have.
     * @param shape The shape of this new tensor ought to have.
     * @param filler The lambda Object which ought to fill this tensor with the appropriate data.
     * @param &lt;T&gt; The type parameter for the actual data array items.
     */
    public static &lt;T&gt; Tsr&lt;T&gt; of( DataType&lt;T&gt; type, int[] shape, Filler&lt;T&gt; filler) {
<span class="fc" id="L768">        return new Tsr&lt;&gt;( shape, type, filler);</span>
    }

    /**
     *  see {@link #of(DataType, int[], Filler)}
     *
     * @param shape The shape of this new tensor ought to have.
     * @param type The data type this tensor ought to have.
     * @param filler The lambda Object which ought to fill this tensor with the appropriate data.
     * @param &lt;T&gt; The type parameter for the actual data array items.
     */
    private &lt;T&gt; Tsr( int[] shape, DataType&lt;T&gt; type, Filler&lt;T&gt; filler)
<span class="fc" id="L780">    {</span>
<span class="fc" id="L781">        _constructFromInitializer( shape, type, filler);</span>
<span class="fc" id="L782">    }</span>

    /**
     * @param shape The shape of that this new tensor ought to have.
     * @param type The data type that this tensor ought to have.
     * @param filler The lambda Object which ought to fill this tensor with the appropriate data.
     * @param &lt;T&gt; The type parameter for the actual data array items.
     */
    private &lt;T&gt; void _constructFromInitializer(int[] shape, DataType&lt;T&gt; type, Filler&lt;T&gt; filler)
    {
<span class="fc" id="L792">        LogUtil.nullArgCheck( shape, &quot;shape&quot;, int[].class );</span>
<span class="fc" id="L793">        LogUtil.nullArgCheck( type, &quot;type&quot;, DataType.class );</span>
<span class="fc" id="L794">        LogUtil.nullArgCheck( type, &quot;filler&quot;, Filler.class );</span>
<span class="fc" id="L795">        _setDataType( type );</span>
<span class="fc" id="L796">        _constructAndAllocate( shape, false );</span>
<span class="fc" id="L797">        _initData(filler);</span>
<span class="fc" id="L798">    }</span>


    /*
        -------------------------------------------
            Â§(1.4) : FUNCTION BASED CONSTRUCTION
        --------------------------------------------
     */

    /**
     *  This factory method allows for the creation and execution of {@link Function} instances
     *  without actually instantiating them manually,
     *  where the result will then be returned by this factory method. &lt;br&gt;&lt;br&gt;
     *  The passed {@link String} will be parsed into a {@link Function} AST which will be cached
     *  using the expression as key in case it will be used in future constructor calls
     *  like this one, or elsewhere...
     *  The created / retrieved {@link Function} will then be called with the supplied input list
     *  in order to trigger an execution.
     *  The result of which will be used for the population of the fields of this
     *  very instance.                                                                      &lt;br&gt;
     *  An example would be the following :                                                 &lt;br&gt;
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = Tsr.of( &quot;sin( I[0] ) / I[1]&quot;, 12f, -6.34f )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param expression A String which will be used for parsing a Function AST.
     * @param inputs An array of inputs which can be tensors or numeric types.
     */
    @SafeVarargs
    public static &lt;V extends Number&gt; Tsr&lt;V&gt; of( String expression, V... inputs ) {
<span class="fc" id="L828">        return Function.of( expression, true ).call( Arrays.stream(inputs).map(args -&gt; _of(args)).toArray(Tsr[]::new) );</span>
    }

    /**
     *  This factory method allows for the creation and execution of {@link Function} instances
     *  without actually instantiating them manually,
     *  where the result will then be returned by this factory method. &lt;br&gt;&lt;br&gt;
     *  The passed {@link String} will be parsed into a {@link Function} AST which will be cached
     *  using the expression as key in case it will be used in future constructor calls
     *  like this one, or elsewhere...
     *  The created / retrieved {@link Function} will then be called with the supplied input list
     *  in order to trigger an execution.
     *  The result of which will be used for the population of the fields of this
     *  very instance.                                                                      &lt;br&gt;
     *  An example would be the following :                                                 &lt;br&gt;
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = Tsr.of( &quot;sin( I[0] ) / I[1]&quot;, List.of(b, c) )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param expression A String which will be used for parsing a Function AST.
     * @param inputs A list of inputs which can be tensors or numeric types.
     */
    public static &lt;V&gt; Tsr&lt;V&gt; of( String expression, List&lt;Tsr&lt;V&gt;&gt; inputs ) {
<span class="fc" id="L851">        return Function.of( expression, true ).call( inputs );</span>
    }

    /**
     *  This method takes a list of tensors and a String expression describing
     *  operations which ought to be applied to the tensors in said list.
     *  It also receives a boolean flag which determines if the defined function
     *  should be executed with autograd enabled.
     *  The provided expression will be parsed to a {@link Function} instance expecting as many inputs
     *  as there are array entries, namely : &quot;I[0]&quot;, &quot;I[1]&quot;, &quot;I[2]&quot;, ...                    &lt;br&gt;
     *  An example would be the following :                                                 &lt;br&gt;
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = Tsr.of( &quot;sin( I[0] ) / I[1]&quot;, true, List.of(b, c) )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *  Which takes the tensor 'b' and 'c' and applies the function &quot;f(x,y) = sin(x) / y&quot;
     *  element-wise to produce a new tensor 'a'!
     *  Additionally, there is a helpful flag which allows one to specify if the
     *  parsed {@link Function} instance emerging from the provided expression
     *  should also allow the tracking of computations via a computation graph ({@link GraphNode} instances).
     *  This history tracking then enables auto-differentiation. &lt;br&gt;
     *
     * @param expression The expression describing operations applied to the provided tensors.
     * @param doAD A flag which when set to true commands the creation of a computation graph during operation execution.
     * @param tensors A list of tensors used as inputs to the Function instance parsed from the provided expression.
     */
    public static &lt;V&gt; Tsr&lt;V&gt; of( String expression, boolean doAD, List&lt;Tsr&lt;V&gt;&gt; tensors ) {
<span class="fc" id="L877">        return Function.of( expression, doAD ).call( tensors );</span>
    }

    /**
     *  This method takes a tensor and a String expression describing
     *  operations which ought to be applied to said tensor.
     *  This expression will be parsed to a {@link Function} instance expecting one input,
     *  namely : &quot;I[0]&quot; &lt;br&gt;
     *  An example would be the following :
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = Tsr.of( &quot;sin( I[0] ) * 2&quot;, b )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     *  Which takes the tensor 'b' and applies the function &quot;f(x) = sin(x) * 2&quot;
     *  element-wise to produce a new tensor 'a'! &lt;br&gt;
     *  &lt;br&gt;
     *
     * @param tensor A tensor which serves as input to the Function instance parsed from the given expression.
     * @param expression The expression describing operations applied to the provided tensor.
     */
    public static &lt;V&gt; Tsr&lt;V&gt; of( String expression, Tsr&lt;V&gt; tensor ) {
<span class="fc" id="L898">        return Function.of( expression, true ).call( tensor );</span>
    }

    /**
     *  This method takes an array of tensors and a String expression describing
     *  operations which ought to be applied to the tensors in said array.
     *  This expression will be parsed to a {@link Function} instance expecting as many inputs
     *  as there are array entries, namely : &quot;I[0]&quot;, &quot;I[1]&quot;, &quot;I[2]&quot;, ... &lt;br&gt;
     *  An example would be the following :
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = Tsr.of( &quot;sin( I[0] ) / I[1]&quot;, b, c )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     *  Which takes the tensor 'b' and 'c' and applies the function &quot;f(x,y) = sin(x) / y&quot;
     *  element-wise to produce a new tensor 'a'! &lt;br&gt;
     *
     * @param expression The expression describing operations applied to the provided tensors.
     * @param tensors An array of tensors used as inputs to the Function instance parsed from the provided expression.
     */
    @SafeVarargs
    public static &lt;V&gt; Tsr&lt;V&gt; of( String expression, Tsr&lt;V&gt;... tensors ) {
<span class="fc" id="L919">        return Function.of( expression, true ).call( tensors );</span>
    }

    /**
     *  This method takes an array of tensors and a String expression describing
     *  operations which ought to be applied to the tensors in said array.
     *  It also receives a boolean flag which determines if the defined function
     *  should be executed with autograd enabled.
     *  The provided expression will be parsed to a {@link Function} instance expecting as many inputs
     *  as there are array entries, namely : &quot;I[0]&quot;, &quot;I[1]&quot;, &quot;I[2]&quot;, ...                    &lt;br&gt;
     *  An example would be the following :                                                 &lt;br&gt;
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = Tsr.of( &quot;sin( I[0] ) / I[1]&quot;, true, b, c )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *  Which takes the tensor 'b' and 'c' and applies the function &quot;f(x,y) = sin(x) / y&quot;
     *  element-wise to produce a new tensor 'a'!
     *  Additionally, there is a helpful flag which allows one to specify if the
     *  parsed {@link Function} instance emerging from the provided expression
     *  should also allow the tracking of computations via a computation graph ({@link GraphNode} instances).
     *  This history tracking then enables auto-differentiation. &lt;br&gt;
     *
     * @param expression The expression describing operations applied to the provided tensors.
     * @param doAD A flag which when set to true commands the creation of a computation graph during operation execution.
     * @param tensors An array of tensors used as inputs to the Function instance parsed from the provided expression.
     */
    @SafeVarargs
    public static &lt;V&gt; Tsr&lt;V&gt; of( String expression, boolean doAD, Tsr&lt;V&gt;... tensors ) {
<span class="fc" id="L946">        return Function.of( expression, doAD ).call( tensors );</span>
    }

    /*==================================================================================================================
    |
    |       Â§(2) : FLAGS
    |   ----------------------
    */
    /*
        --------------------------------------------
            Â§(2.0) : GRADIENT REQUIREMENT  :
        --------------------------------------------
    */

    /**
     *  Settings this flag via this setter will indirectly trigger the activation of
     *  the autograd / auto-differentiation system of this library!
     *  If the flag is set to 'true' and the tensor is used for computation then
     *  it will also receive gradients when the {@link #backward()} method is being called
     *  on any descendant tensor within the computation graph.
     *
     * @param rqsGradient The truth value determining if this tensor ought to receive gradients via
     *                     the built-in automatic backpropagation system.
     * @return This very {@link Tsr} instance in order to enable method chaining.
     */
    public final Tsr&lt;V&gt; setRqsGradient( boolean rqsGradient ) {
<span class="fc bfc" id="L972" title="All 4 branches covered.">        if ( rqsGradient() != rqsGradient &amp;&amp; !rqsGradient ) this.remove( Tsr.class );</span>
<span class="fc" id="L973">        _setRqsGradient( rqsGradient );</span>
<span class="fc" id="L974">        return this;</span>
    }

    /**
     *  This flag will indirectly trigger the activation of the autograd / auto-differentiation system of this library!
     *  If the flag is set to 'true' and the tensor is used for computation then
     *  it will also receive gradients when the {@link #backward()} method is being called
     *  on any descendant tensor within the computation graph.
     *
     * @return The truth value determining if this tensor ought to receive gradients via
     *         the built in automatic backpropagation system.
     */
<span class="fc bfc" id="L986" title="All 2 branches covered.">    public boolean rqsGradient() { return ( _flags &amp; RQS_GRADIENT_MASK ) == RQS_GRADIENT_MASK; }</span>

    protected void _setRqsGradient( boolean rqsGradient ) {
<span class="fc bfc" id="L989" title="All 2 branches covered.">        if ( rqsGradient() != rqsGradient ) {</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">            if ( rqsGradient ) _flags += RQS_GRADIENT_MASK;</span>
<span class="fc" id="L991">            else               _flags -= RQS_GRADIENT_MASK;</span>
        }
<span class="fc" id="L993">    }</span>

    /**
     *  Intermediate tensors are internal non-user tensors which may be eligible
     *  for deletion when further consumed by a {@link Function}.
     *  For the casual user of Neureka, this flag should always be false!
     *
     * @return The truth value determining if this tensor is not a user tensor but an internal
     *         tensor which may be eligible for deletion by {@link Function}s consuming it.
     */
<span class="fc bfc" id="L1003" title="All 2 branches covered.">    public boolean isIntermediate() { return ( _flags &amp; IS_INTERMEDIATE_MASK ) == IS_INTERMEDIATE_MASK; }</span>

    /**
     *  Intermediate tensors are internal non-user tensors which may be eligible
     *  for deletion when further consumed by a {@link Function}.
     *  For the casual user of Neureka, this flag should always be false!
     *
     * @param isIntermediate The truth value determining if this tensor is not a user tensor but an internal
     *                       tensor which may be eligible for deletion by {@link Function}s consuming it.
     */
    protected void _setIsIntermediate( boolean isIntermediate ) {
<span class="fc bfc" id="L1014" title="All 2 branches covered.">        if ( isIntermediate() != isIntermediate ) {</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">            if ( isIntermediate ) _flags += IS_INTERMEDIATE_MASK;</span>
<span class="fc" id="L1016">            else                  _flags -= IS_INTERMEDIATE_MASK;</span>
        }
<span class="fc" id="L1018">    }</span>

    /*
    ---------------------------------------------
        Â§(2.1) : SOURCE LOCATION (DEVICE)  :
    ---------------------------------------------
    */

    /**
     *  This method informs this tensor if it's data is supposed to be kept in RAM
     *  or if it has already been migrated somewhere else.
     *  In the latter case, the tensor will nullify the reference to it's
     *  underlying data array to make it elegable for garbage collection.
     *  Otherwise, if {@code isOutsourced} is set to true, the method might
     *  allocate a new data array if none is present.
     *
     * @param isOutsourced The truth value which determines if this tensor should live in RAM or somewhere else.
     * @return This very instance to allow for method chaining.
     */
    public final Tsr&lt;V&gt; setIsOutsourced( boolean isOutsourced ) {
<span class="fc" id="L1038">        _setIsOutsourced( isOutsourced );</span>
<span class="fc bfc" id="L1039" title="All 2 branches covered.">        if ( isOutsourced )</span>
<span class="fc" id="L1040">            _setData( null );</span>
<span class="fc" id="L1041">        else if (</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">            !forComponent(</span>
                Device.class,
                device -&gt; {
                    try {
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">                        if ( device.has( this ) ) device.restore( this );</span>
<span class="nc" id="L1047">                    } catch ( Exception exception ) {</span>
<span class="nc" id="L1048">                        _LOG.error(</span>
                            &quot;Tensor could not be restored from device component when trying to migrate it back to RAM.&quot;,
                            exception
                        );
<span class="nc" id="L1052">                        throw exception;</span>
<span class="fc" id="L1053">                    }</span>
<span class="fc" id="L1054">                    this.remove( Device.class );</span>
<span class="fc" id="L1055">                    forComponent(</span>
                        Tsr.class,
                        gradient -&gt;
<span class="fc" id="L1058">                            ( (Tsr&lt;V&gt;) gradient ).forComponent(</span>
                                Device.class,
                                gradDevice -&gt; {
                                    try {
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">                                        if ( gradDevice.has( gradient ) ) gradDevice.restore( gradient );</span>
                                    }
<span class="nc" id="L1064">                                    catch ( Exception exception ) {</span>
<span class="nc" id="L1065">                                        _LOG.error(</span>
                                                &quot;Gradient could not be restored from device component when trying to migrate it back to RAM.&quot;,
                                                exception
                                        );
<span class="nc" id="L1069">                                        throw exception;</span>
<span class="fc" id="L1070">                                    }</span>
<span class="fc" id="L1071">                                    gradient.remove( Device.class );</span>
<span class="fc" id="L1072">                                })</span>
                    );
<span class="fc" id="L1074">                }</span>
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">            ) &amp;&amp; _getData() == null</span>
        ) {
<span class="fc" id="L1077">            _setIsVirtual( true );</span>
<span class="fc" id="L1078">            _allocate( 1 ); // Only a single value representing the rest.</span>
        }
<span class="fc" id="L1080">        return this;</span>
    }

    /**
     *  Outsourced means that the tensor is stored on a {@link Device} implementation instance.
     *
     * @return The truth value determining if the data of this tensor is not actually stored inside of it
     *         in the form of of a traditional primitive JVM array!
     */
<span class="fc bfc" id="L1089" title="All 2 branches covered.">    public boolean isOutsourced() { return ( _flags &amp; IS_OUTSOURCED_MASK ) == IS_OUTSOURCED_MASK; }</span>

    protected void _setIsOutsourced( boolean isOutsourced ) {
<span class="fc bfc" id="L1092" title="All 2 branches covered.">        if ( isOutsourced() != isOutsourced ) {</span>
<span class="fc bfc" id="L1093" title="All 2 branches covered.">            if ( isOutsourced ) _flags += IS_OUTSOURCED_MASK;</span>
<span class="fc" id="L1094">            else                _flags -= IS_OUTSOURCED_MASK;</span>
        }
<span class="fc" id="L1096">    }</span>

    /*
    --------------------------------------------
        Â§(2.2) : VIRTUAL / ACTUAL  :
    --------------------------------------------
    */

    /**
     *  Virtualizing is the opposite to actualizing a tensor.
     *  A tensor is virtual if the size of the underlying data is not actually equal to
     *  the number of elements which the tensor claims to store, aka its size.
     *  This is for example the case when initializing a tensor filled with a single
     *  value continuously. In that case the tensor will flag itself as virtual and only allocate the
     *  underlying data array to hold a single item even though the tensor might actually hold
     *  many more items.
     *  The reasons for this feature is that it greatly improves performance in certain cases.
     *  In essence this feature is a form of lazy loading.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param isVirtual The truth value determining if this tensor ought to be virtualized.
     * @return This very tensor to enable method chaining.
     */
    @Override
    public final Tsr&lt;V&gt; setIsVirtual( boolean isVirtual ) {

<span class="pc bpc" id="L1122" title="2 of 4 branches missed.">        assert getNDConf() != null;</span>

<span class="fc bfc" id="L1124" title="All 2 branches covered.">        if ( isVirtual() != isVirtual ) {</span>
            // Currently, we avoid offloading the virtualization by restoring outsourced tensors into RAM...
<span class="fc" id="L1126">            Device&lt;V&gt; device = this.get( Device.class );</span>
            try {
                // TODO: Fix this imperformant mess below:
<span class="fc bfc" id="L1129" title="All 2 branches covered.">                if ( device != null ) device.restore( this );</span>
<span class="nc" id="L1130">            } catch ( Exception exception ) {</span>
<span class="nc" id="L1131">                _LOG.error(</span>
                        &quot;Tensor could not be restored from device component when changing flag 'isVirtual' to &quot; + isVirtual + &quot;.&quot;,
                        exception
                );
<span class="nc" id="L1135">                throw exception;</span>
<span class="fc" id="L1136">            }</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">            if ( isVirtual ) {</span>
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">                if ( _getData() != null ) _virtualize();</span>
            }
<span class="fc" id="L1140">            else _actualize();</span>
            // Virtual and actual tensors require a different mapping from a given index to the underlying data..
            // Therefore, we need to re-initialize the NDConfiguration object:
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">            createConstructionAPI().configureFromNewShape( getNDConf().shape(), isVirtual, _getData() == null );</span>
<span class="fc bfc" id="L1144" title="All 2 branches covered.">            if ( isVirtual ) {</span>
<span class="fc" id="L1145">                Relation&lt;V&gt; relation = get( Relation.class );</span>
<span class="pc bpc" id="L1146" title="1 of 2 branches missed.">                if ( relation!=null )</span>
<span class="nc" id="L1147">                    relation.foreachChild( c -&gt; {</span>
<span class="nc" id="L1148">                                c._setData( _getData());</span>
<span class="nc" id="L1149">                                c.setIsVirtual( true );</span>
<span class="nc" id="L1150">                            });</span>
<span class="fc" id="L1151">            } else {</span>
<span class="pc bpc" id="L1152" title="1 of 2 branches missed.">                Tsr&lt;?&gt; parentTensor = ( this.isSlice() ) ? get(Relation.class).getParent() : null;</span>
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">                if ( parentTensor != null ) parentTensor.get( Relation.class ).remove( this );</span>
            }

            try {
<span class="fc bfc" id="L1157" title="All 2 branches covered.">                if ( device != null ) device.store( this );</span>
<span class="nc" id="L1158">            } catch ( Exception exception ) {</span>
<span class="nc" id="L1159">                String message =</span>
                        &quot;Tensor could not be migrated back to host device after changing flag 'isVirtual' to &quot;+isVirtual+&quot;.&quot;;
<span class="nc" id="L1161">                _LOG.error(</span>
                        message,
                        exception
                );
<span class="nc" id="L1165">                throw new IllegalStateException( message );</span>
<span class="fc" id="L1166">            }</span>
<span class="fc" id="L1167">        }</span>
<span class="pc bpc" id="L1168" title="3 of 4 branches missed.">        else if ( isVirtual &amp;&amp; _getData() == null ) _allocate( 1 ); //&gt; Only a single value representing the rest.</span>
<span class="fc" id="L1169">        return this;</span>
    }

    /**
     *  A tensor is virtual if the size of the underlying data is not actually equal to
     *  the number of elements which the tensor claims to store, aka its size.
     *  This is for example the case when initializing a tensor filled with a single
     *  value continuously. In that case the tensor will flag itself as virtual and only allocate the
     *  underlying data array to hold a single item even though the tensor might actually hold
     *  many more items.
     *  The reasons for this feature is that it greatly improves performance in certain cases.
     *  In essence this feature is a form of lazy loading.
     *  &lt;br&gt;&lt;br&gt;
     * @return The truth value determining if this tensor is virtual (and therefore not &quot;actual&quot;).
     */
    @Override
<span class="fc bfc" id="L1185" title="All 2 branches covered.">    public boolean isVirtual() { return ( _flags &amp; IS_VIRTUAL_MASK ) == IS_VIRTUAL_MASK; }</span>

    /**
     *  This method is the inner counterpart to the public &quot;{@link Tsr#setIsVirtual}&quot; method.
     *  It actually performs the bit flipping by applying the corresponding bit mask. &lt;br&gt;
     *  &lt;br&gt;
     * @param isVirtual The truth value which ought to be applied.
     */
    @Override
    protected void _setIsVirtual( boolean isVirtual ) {
<span class="fc bfc" id="L1195" title="All 2 branches covered.">        if ( isVirtual() != isVirtual ) {</span>
<span class="fc bfc" id="L1196" title="All 2 branches covered.">            if ( isVirtual ) _flags += IS_VIRTUAL_MASK;</span>
<span class="fc" id="L1197">            else             _flags -= IS_VIRTUAL_MASK;</span>
        }
<span class="fc" id="L1199">    }</span>

    /*
    --------------------------------------------
        Â§(2.3) : GRADIENT APPLY REQUIREMENT  :
    --------------------------------------------
    */

    /**
     *  This flag works alongside two autograd features which can be enables inside the library settings.
     *  They will come into effect when flipping their feature flags, &lt;br&gt;
     *  namely: &lt;i&gt;'isApplyingGradientWhenRequested'&lt;/i&gt; and &lt;i&gt;'isApplyingGradientWhenTensorIsUsed'&lt;/i&gt;&lt;br&gt;
     *  As the first flag name suggests gradients will be applied to their tensors when it is set to true,
     *  however this will only happened when the second flag is set to true as well, because otherwise gradients
     *  wouldn't be applied to their tensors automatically in the first place... &lt;br&gt;
     *  &lt;br&gt;
     *  Setting both flags to true will inhibit effect of the second setting &lt;i&gt;'isApplyingGradientWhenTensorIsUsed'&lt;/i&gt;
     *  unless a form of &quot;permission&quot; is being signaled to the autograd system.
     *  This signal comes in the form of a &quot;request&quot; flag which marks a tensor as &lt;b&gt;allowed to
     *  be updated by its gradient&lt;/b&gt;.&lt;br&gt;
     *  &lt;br&gt;
     * @param applyRequested The truth value determining if the application of the gradient of this tensor is requested.
     * @return This very tensor instance in order to enable method chaining.
     */
    public final Tsr&lt;V&gt; setGradientApplyRequested(boolean applyRequested ) {
<span class="fc bfc" id="L1224" title="All 2 branches covered.">        if ( gradientApplyRequested() != applyRequested ) {</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">            if ( applyRequested ) {</span>
                if (
<span class="fc bfc" id="L1227" title="All 2 branches covered.">                        Neureka.get().settings().autograd().isApplyingGradientWhenRequested() &amp;&amp;</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">                                !Neureka.get().settings().autograd().isApplyingGradientWhenTensorIsUsed()</span>
                )
<span class="fc" id="L1230">                    this.applyGradient();</span>
                else
<span class="fc" id="L1232">                    _flags += GRADIENT_APPLY_RQD_MASK;</span>
            }
<span class="fc" id="L1234">            else _flags -= GRADIENT_APPLY_RQD_MASK;</span>
        }
<span class="fc" id="L1236">        return this;</span>
    }

    /**
     *  This flag works alongside two autograd features which can be enables inside the library settings.
     *  They will come into effect when flipping their feature flags, &lt;br&gt;
     *  namely: &lt;i&gt;'isApplyingGradientWhenRequested'&lt;/i&gt; and &lt;i&gt;'isApplyingGradientWhenTensorIsUsed'&lt;/i&gt;&lt;br&gt;
     *  As the first flag name suggests gradients will be applied to their tensors when it is set to true,
     *  however this will only happened when the second flag is set to true as well, because otherwise gradients
     *  wouldn't be applied to their tensors automatically in the first place... &lt;br&gt;
     *  &lt;br&gt;
     *  Setting both flags to true will inhibit the effect of the second setting &lt;i&gt;'isApplyingGradientWhenTensorIsUsed'&lt;/i&gt;
     *  unless a form of &quot;permission&quot; is being signaled to the autograd system.
     *  This signal comes in the form of a &quot;request&quot; flag which marks a tensor as &lt;b&gt;allowed to
     *  be updated by its gradient&lt;/b&gt;.&lt;br&gt;
     *  &lt;br&gt;
     * @return The truth value determining if the application of the gradient of this tensor is requested.
     */
<span class="fc bfc" id="L1254" title="All 2 branches covered.">    public boolean gradientApplyRequested() { return ( _flags &amp; GRADIENT_APPLY_RQD_MASK ) == GRADIENT_APPLY_RQD_MASK; }</span>

    /*
    --------------------------------------------
        Â§(2.4) : DELETION  :
    --------------------------------------------
    */

    /**
     *  This will check if the {@link #_delete()} method was previously called on this tensor.
     *  This means that any references inside the tensor will be null
     *  as well as that the tensor data was freed on every device,
     *  meaning that what was previously referenced was most likely garbage collected...
     *
     * @return The truth value which determines if {@link #_delete()} was called on this tensor,
     *         making it in essence an empty shell void of any references to data.
     */
<span class="fc bfc" id="L1271" title="All 2 branches covered.">    public boolean isDeleted() { return ( _flags &amp; IS_DELETED_MASK ) == IS_DELETED_MASK; }</span>

    /**
     *  Although tensors will be garbage collected when they are not strongly referenced,
     *  there is also the option to manually free up the tensor and its associated data.
     *  This is especially useful when tensors are stored on a device like the OpenCLDevice.
     *  In that case calling the &quot;{@link Tsr#_delete()}&quot; method will free the memory reserved for this tensor.
     *  This manual memory freeing through this method can be faster than waiting for
     *  the garbage collector to kick in... &lt;br&gt;
     *  &lt;br&gt;
     *
     * @return This very tensor instance to allow for method chaining.
     */
    private Tsr&lt;V&gt; _delete()
    {
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">        if ( isDeleted() ) return this;</span>
<span class="fc" id="L1287">        forComponent( GraphNode.class, n -&gt; {</span>
<span class="fc bfc" id="L1288" title="All 2 branches covered.">            if ( n.isUsedAsDerivative() ) {</span>
<span class="fc" id="L1289">                String message = &quot;Cannot delete a tensor which is used as derivative by the AD computation graph!&quot;;</span>
<span class="fc" id="L1290">                _LOG.error( message );</span>
<span class="fc" id="L1291">                throw new IllegalStateException( message );</span>
            }
<span class="fc" id="L1293">        });</span>
<span class="fc" id="L1294">        forComponent( Device.class, device -&gt; device.free( this ) );</span>
<span class="fc" id="L1295">        _setData( null );</span>
<span class="fc" id="L1296">        _setNDConf( null );</span>
<span class="fc" id="L1297">        _flags = 0;</span>
<span class="fc" id="L1298">        forComponent( Tsr.class, t -&gt; t.getUnsafe().delete() );</span>
<span class="fc" id="L1299">        _deleteComponents();</span>
<span class="fc" id="L1300">        _flags += IS_DELETED_MASK;</span>

<span class="fc" id="L1302">        return this;</span>
    }

    /*==================================================================================================================
    |
    |       Â§(3) : COMPONENT SYSTEM
    |   --------------------------------
    */
    /*
    --------------------------------------------
        Â§(3.0) : SETTING / REJECTING  :
    --------------------------------------------
    */

    /**
     * This method is executed when a new Component is added to the tensor.
     * The public add method is implemented in the super class
     * '{@link AbstractComponentOwner}' from which this class inherits.
     * In this super class the component logic is implemented.
     *
     * @param newComponent A component used to access features. ({@link GraphNode}, {@link NDFrame}, {@link Relation}, int[], ...)
     * @return The unchanged object or maybe in future versions: null (component rejected)
     */
    @Override
    protected &lt; T extends Component&lt;Tsr&lt;V&gt;&gt; &gt; T _setOrReject( T newComponent )
    {
<span class="fc" id="L1328">        return newComponent;</span>
    }

    /*
    --------------------------------------------
        Â§(3.1) : REMOVING / REJECTING  :
    --------------------------------------------
    */
    /**
     * This method is executed when a component is being removed from the tensor.
     * The public remove method is implemented in the super class
     * '{@link AbstractComponentOwner}' from which this class inherits.
     * In this super class the component logic is implemented.
     *
     * @param newComponent A component used to access features. ({@link GraphNode}, {@link NDFrame}, {@link Relation}, int[], ...)
     * @return The unchanged object or when rejected: null (component rejected)
     */
    @Override
    protected &lt;T extends Component&lt;Tsr&lt;V&gt;&gt;&gt; T _removeOrReject(T newComponent )
    {
<span class="fc bfc" id="L1348" title="All 2 branches covered.">        if ( newComponent instanceof Device ) {</span>
<span class="fc" id="L1349">            Device&lt;V&gt; device = (Device&lt;V&gt;) newComponent;</span>
            /*
                The following seems like a redundant check, however often times a tensor
                will be removed from a Device implementation inside the &quot;restore&quot; method
                when the tensor has already been removed from the device...
                With out the condition below a stack overflow would occur!
             */
<span class="fc bfc" id="L1356" title="All 2 branches covered.">            if ( device.has( this ) ) {</span>
                try {
<span class="fc" id="L1358">                    device.restore( this );</span>
<span class="nc" id="L1359">                } catch ( Exception exception ) {</span>
<span class="nc" id="L1360">                    _LOG.error(</span>
                            &quot;Removing device from tensor / tensor from device failed.\n&quot; +
                            &quot;Restoring tensor from device threw exception.\n&quot;,
                            exception
                    );
<span class="nc" id="L1365">                    throw exception;</span>
<span class="fc" id="L1366">                }</span>
            }
        }
<span class="fc" id="L1369">        return newComponent;</span>
    }

    /*
    ----------------------------
        Â§(3.2) : UPDATING  :
    ----------------------------
    */
    /**
     *  Important : Components of type {@link Tsr} are simply gradients!
     *  Currently this method is used only to catch illegal arguments which
     *  is for example the case when trying to attach a gradient with a different shape...
     *  (Otherwise the gradient tensor &quot;does not mind&quot; an owner change...)
     */
    @Override
    public boolean update( OwnerChangeRequest&lt;Tsr&lt;V&gt;&gt; changeRequest ) {
<span class="fc bfc" id="L1385" title="All 2 branches covered.">        if ( changeRequest.type() == IsBeing.ADDED ) {</span>
<span class="fc" id="L1386">            if (</span>
<span class="pc bpc" id="L1387" title="1 of 2 branches missed.">                    changeRequest.getNewOwner().shape().hashCode() != this.shape().hashCode() ||</span>
<span class="pc bpc" id="L1388" title="1 of 2 branches missed.">                            Arrays.hashCode(changeRequest.getNewOwner().getNDConf().shape()) != Arrays.hashCode( getNDConf().shape() )</span>
            ) {
<span class="nc" id="L1390">                throw new IllegalArgumentException(</span>
                        &quot;Trying to attach a tensor as gradient component to a tensor with different shape.&quot;
                );
            }
        }
<span class="fc" id="L1395">        changeRequest.executeChange(); // This can be an 'add', 'remove' or 'transfer' of this component!</span>
        // If the change request type is set to &quot;REPLACED&quot; then
        // this is means that this tensor is a gradient that is being
        // transferred to another tensor to serve as gradient...
        // No update task needs to occur. (This might change in the future...)
<span class="fc" id="L1400">        return true;</span>
    }

    /**
     * This method taked a {@link Device} and tries to migrate the contents of this {@link Tsr}
     * instance to that {@link Device}!
     *
     * @param device The {@link Device} which should host this {@link Tsr} as well as be added to its components list.
     * @return This very class to enable method chaining.
     */
<span class="fc" id="L1410">    public final Tsr&lt;V&gt; to( Device&lt;?&gt; device ){ super._set( device ); return this; }</span>

<span class="fc" id="L1412">    public final Tsr&lt;V&gt; to( String deviceType ) { return this.to(Device.get(deviceType)); }</span>

    /*==================================================================================================================
    |
    |       Â§(4) : PROPERTIES :
    |   ---------------------------------------
    */
    /*
    --------------------------------------------
        Â§(4.0) : HIGH LEVEL PROPERTIES  :
    --------------------------------------------
    */

    /**
     *  A tensor is empty if there is neither data referenced within the tensor directly
     *  or within any given device to which the tensor might belong.
     *
     * @return The truth value determining if this tensor has data.
     */
<span class="fc bfc" id="L1431" title="All 4 branches covered.">    public boolean isEmpty() { return _getData() == null &amp;&amp; !this.isOutsourced(); }</span>

    /**
     *  A tensor is &quot;undefined&quot; if it has either no {@link NDConfiguration} implementation instance
     *  or this instance does not have a shape set for this {@link Tsr} which is needed for
     *  a tensor to also have a rank and dimensionality...
     *
     * @return The truth value determining if this tensor has an {@link NDConfiguration} stored internally.
     */
<span class="pc bpc" id="L1440" title="2 of 4 branches missed.">    public boolean isUndefined() { return getNDConf() == null || getNDConf().shape() == null; }</span>

    /**
     *  If this tensor is a slice of a parent tensor then this method will yield true.
     *  Slices can be created by calling the variations of the &quot;{@link Tsr#getAt}&quot; method.
     *
     * @return The truth value determining if this tensor is a slice of another tensor.
     */
    public boolean isSlice() {
<span class="fc" id="L1449">        Relation&lt;V&gt; child = get( Relation.class );</span>
<span class="fc bfc" id="L1450" title="All 4 branches covered.">        return ( child != null &amp;&amp; child.hasParent() );</span>
    }

    /**
     *  This method returns the number of slices which have been
     *  created from this very tensor.
     *  It does so by accessing the {@link Relation} component if present
     *  which internally keeps track of slices via weak references.
     *
     * @return The number of slices derived from this tensor.
     */
    public int sliceCount() {
<span class="fc" id="L1462">        Relation&lt;V&gt; child = this.get( Relation.class );</span>
<span class="pc bpc" id="L1463" title="1 of 2 branches missed.">        return ( child != null ) ? child.childCount() : 0;</span>
    }

    /**
     *  If slices have been derived from this tensor then it is a &quot;slice parent&quot;.
     *  This is what this method will determine, in which case, it will return true.
     *
     * @return The truth value determining if slices have been derived from this tensor.
     */
    public boolean isSliceParent() {
<span class="fc" id="L1473">        Relation&lt;V&gt; parent = this.get( Relation.class );</span>
<span class="pc bpc" id="L1474" title="1 of 4 branches missed.">        return ( parent != null &amp;&amp; parent.hasChildren() );</span>
    }

    /**
     *  Tensors which are used or produced by the autograd system will have a {@link GraphNode} component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  This autograd system however, will only be triggered by {@link Function} implementations which
     *  are not &quot;detached&quot;, meaning they have their &quot;{@link Function#isDoingAD()}&quot; flags set to true! &lt;br&gt;
     *  Detached functions (like those pre-instantiated in Function.Detached.*) will not attach {@link GraphNode}
     *  instances to involved tensors which will prevent the formation of a computation graph.
     *
     * @return The truth value determining if this tensor belongs to a recorded computation graph.
     */
<span class="fc" id="L1487">    public boolean belongsToGraph() { return this.has( GraphNode.class ); }</span>

    /**
     *  Tensors which are used or produced by the autograd system will have a {@link GraphNode} component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  This autograd system however, will only be triggered by {@link Function} implementations which
     *  are not &quot;detached&quot;, meaning they have their &quot;{@link Function#isDoingAD()}&quot; flags set to true! &lt;br&gt;
     *  A tensor is a leave if it is attached to a computation graph in which it is not an intermediate / branch node
     *  but input / branch node.
     *
     * @return The truth value determining if this tensor is attached to a computation graph as leave node.
     */
<span class="pc bpc" id="L1499" title="1 of 4 branches missed.">    public boolean isLeave() { return (!this.has( GraphNode.class )) || this.get( GraphNode.class ).isLeave(); }</span>

    /**
     *  Tensors which are used or produced by the autograd system will have a {@link GraphNode} component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  This autograd system however, will only be triggered by {@link Function} implementations which
     *  are not &quot;detached&quot;, meaning they have their &quot;{@link Function#isDoingAD()}&quot; flags set to true! &lt;br&gt;
     *  A tensor is a branch if it is attached to a computation graph in which it is not an input / leave node
     *  but intermediate / branch node.
     *
     * @return The truth value determining if this tensor is attached to a computation graph as branch node.
     */
<span class="fc bfc" id="L1511" title="All 2 branches covered.">    public boolean isBranch() { return !this.isLeave(); }</span>

    /**
     *  Tensors can be components of other tensors which makes the
     *  implicitly their gradients.
     *
     * @return The truth value determining if this tensor has another tensor attached to it (which is its gradient).
     */
<span class="fc" id="L1519">    public boolean hasGradient() { return this.has( Tsr.class ); }</span>

    /*
        ----------------------------------------------
            Â§(4.1) : COMPONENT BASED PROPERTIES :
        ----------------------------------------------
     */

    /**
     * @return The gradient of this tensor which is internally stored as component.
     */
<span class="fc" id="L1530">    public final Tsr&lt;V&gt; getGradient() { return this.get( Tsr.class ); }</span>

    /**
     * @return The device on which this tensor is stored or {@link CPU} if it is not outsourced.
     */
    public Device&lt;V&gt; getDevice() {
<span class="fc bfc" id="L1536" title="All 2 branches covered.">        if ( this.isOutsourced() ) return this.get( Device.class );</span>
<span class="fc" id="L1537">        return (Device&lt;V&gt;) _CPU;</span>
    }

    /**
     * @return The graph node of the computation graph to which this tensor belongs or null if not part of a graph.
     */
<span class="fc" id="L1543">    public GraphNode&lt;V&gt; getGraphNode() { _guardGet(&quot;graph node&quot;); return get( GraphNode.class ); }</span>

    /**
     * @return An instance of the {@link NDFrame} component if present.
     */
<span class="fc" id="L1548">    public NDFrame&lt;V&gt; frame() { _guardGet(&quot;graph node&quot;); return get( NDFrame.class ); }</span>


    /*
        ---------------------------------------
            Â§(4.2) : INNER PROPERTIES :
        ---------------------------------------
     */


    /*==================================================================================================================
    |
    |       Â§(5) : OBJECT STATE MODIFICATION :
    |   ------------------------------------------
    */

    private void _toLayout( NDConfiguration.Layout target )
    {
<span class="fc bfc" id="L1566" title="All 2 branches covered.">        if ( target == this.getNDConf().getLayout() ) return;</span>

<span class="fc" id="L1568">        NDConfiguration old = this.getNDConf();</span>

<span class="fc bfc" id="L1570" title="All 2 branches covered.">        if ( target == NDConfiguration.Layout.ROW_MAJOR )</span>
<span class="fc" id="L1571">            _fromCMToRM();</span>
        else
<span class="fc" id="L1573">            _fromRMToCM();</span>

<span class="fc" id="L1575">        _checkLayoutConversion( this.getNDConf(), old, target );</span>
<span class="fc" id="L1576">    }</span>

    /**
     *  Converts this tensor from column major to column major layout.
     */
    private void _fromCMToRM() {
<span class="fc bfc" id="L1582" title="All 2 branches covered.">        if ( this.getNDConf().isVirtual() ) {</span>
<span class="fc" id="L1583">            this.setIsVirtual( false ); // We actualized the tensor before conversion!</span>
<span class="pc bpc" id="L1584" title="1 of 2 branches missed.">            if ( this.getNDConf().getLayout() == NDConfiguration.Layout.ROW_MAJOR )</span>
<span class="fc" id="L1585">                return;</span>
        }
<span class="fc" id="L1587">        Tsr&lt;V&gt; clone = clone(); // A clone will have by default a row major layout.</span>
<span class="fc" id="L1588">        _setNDConf( clone.getNDConf() );</span>
<span class="fc" id="L1589">        _assignIfActual( () -&gt; clone );</span>
<span class="fc" id="L1590">    }</span>

    /**
     *  Converts this tensor from row major to column major layout.
     */
    private void _fromRMToCM() {
<span class="fc" id="L1596">        _assignIfActual( () -&gt; Tsr.this.T().clone().detach() );</span>
<span class="fc" id="L1597">        NDConfiguration old = this.getNDConf();</span>
<span class="fc" id="L1598">        int[] newTranslation = NDConfiguration.Layout.COLUMN_MAJOR.newTranslationFor(old.shape());</span>
<span class="fc bfc" id="L1599" title="All 2 branches covered.">        if ( old.isVirtual() ) {</span>
<span class="fc" id="L1600">            this.setIsVirtual(false);</span>
<span class="fc" id="L1601">            old = this.getNDConf();</span>
        }
<span class="fc" id="L1603">        _setNDConf( _createNewNDCFrom( old, newTranslation, old.translation() ) );</span>
<span class="fc" id="L1604">    }</span>

    /**
     *  This will only call the supplier and copy its result into this tensor
     *  if this tensor is not virtual (meaning this is an actual tensor).
     */
    private void _assignIfActual( Supplier&lt;Tsr&lt;?&gt;&gt; provider ) {
<span class="fc bfc" id="L1611" title="All 2 branches covered.">        if ( !this.isVirtual() ) {</span>
<span class="fc" id="L1612">            Tsr&lt;?&gt; toBeAssigned = provider.get();</span>
<span class="fc" id="L1613">            MemUtil.keep(this, toBeAssigned,</span>
<span class="fc" id="L1614">                () -&gt; Neureka.get().backend().getFunction().idy().execute( this, toBeAssigned )</span>
            );
        }
<span class="fc" id="L1617">    }</span>

    private static NDConfiguration _createNewNDCFrom(
            NDConfiguration old, int[] newTranslation, int[] indicesMap
    ) {
<span class="pc bpc" id="L1622" title="2 of 4 branches missed.">        assert !old.isVirtual();</span>
<span class="fc" id="L1623">        return AbstractNDC.construct(</span>
<span class="fc" id="L1624">            old.shape(), newTranslation, indicesMap, old.spread(), old.offset()</span>
        );
    }

    private static void _checkLayoutConversion(
            NDConfiguration newConf,
            NDConfiguration oldConf,
            NDConfiguration.Layout targetLayout
    ) {
<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">        if ( newConf.isVirtual() )</span>
<span class="nc" id="L1634">            throw new IllegalStateException(&quot;Layout conversion produced a virtual nd-configuration!&quot;);</span>
<span class="pc bpc" id="L1635" title="1 of 2 branches missed.">        if ( !newConf.getLayout().isCompatible(targetLayout) )</span>
<span class="nc" id="L1636">            throw new IllegalArgumentException(</span>
<span class="nc" id="L1637">                    &quot;Failed to convert this tensor from its original layout '&quot;+oldConf.getLayout()+&quot;' &quot; +</span>
<span class="nc" id="L1638">                    &quot;to target layout '&quot;+targetLayout+&quot;'. Instead this tensor has layout '&quot;+newConf.getLayout()+&quot;'.&quot;</span>
            );
<span class="fc" id="L1640">    }</span>

    /**
     * This method is responsible for incrementing
     * the &quot;_version&quot; field variable which represents the version of the data of this tensor.
     * Meaning :
     * Every time the underlying data (_value) changes this version ought to increment alongside.
     * The method is called during the execution procedure.
     *
     * @param call The context object containing all relevant information that defines a call for tensor execution.
     */
    private void _incrementVersionBecauseOf( ExecutionCall&lt;?&gt; call ) {
<span class="fc bfc" id="L1652" title="All 2 branches covered.">        if ( Neureka.get().settings().autograd().isPreventingInlineOperations() ) {</span>
<span class="fc" id="L1653">            _version++;</span>
<span class="fc" id="L1654">            GraphNode&lt;?&gt; node = get( GraphNode.class );</span>
<span class="pc bpc" id="L1655" title="1 of 4 branches missed.">            if ( node != null &amp;&amp; node.getPayloadReferenceVersion() != _version ) {</span>
<span class="pc bpc" id="L1656" title="1 of 4 branches missed.">                if ( node.usesAD() || node.isUsedAsDerivative() ) {</span>
<span class="fc" id="L1657">                    String error = &quot;Inline operation occurred on tensor which is part of a computation graph node with autograd support!\n&quot; +</span>
<span class="fc" id="L1658">                                   &quot;The following OperationType caused an internal version mismatch: '&quot;+call.getOperation().getIdentifier()+&quot;'&quot;;</span>
<span class="fc" id="L1659">                    _LOG.error( error );</span>
<span class="fc" id="L1660">                    throw new IllegalStateException( error );</span>
                }
            }
        }
<span class="fc" id="L1664">    }</span>

    /**
     *  In essence tensors are merely fancy wrapper for some form of array of any type... 
     *  This wrapper usually stays the same of a given data array.
     *  However, sometimes a tensor changes its identity, or rather the underlying
     *  data changes the wrapping tensor instance. &lt;br&gt;
     *  &lt;br&gt;
     * @param tensor The tensor whose identity should be stolen.
     */
    protected void _become(Tsr&lt;V&gt; tensor )
    {
<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">        if ( tensor == null ) return;</span>
<span class="fc" id="L1677">        _setDataType( tensor.getDataType() );</span>
<span class="fc" id="L1678">        _setData( tensor._getData() );</span>
<span class="fc" id="L1679">        _setNDConf( tensor.getNDConf() );</span>
<span class="fc" id="L1680">        _flags = tensor._flags;</span>
<span class="fc" id="L1681">        _transferFrom( tensor );</span>
<span class="fc" id="L1682">        tensor._setData( null );</span>
<span class="fc" id="L1683">        tensor._setDataType( null );</span>
<span class="fc" id="L1684">        tensor._setNDConf( null );</span>
<span class="fc" id="L1685">        tensor._flags = 0;</span>
<span class="fc" id="L1686">    }</span>


    /*==================================================================================================================
    |
    |       Â§(6) : ND-ITERATOR LOGIC :
    |   ---------------------------------------
    */

    /**
     * This method returns an iterator over the elements of this tensor. &lt;br&gt;
     *
     * @return An iterator over elements of type ValType.
     */
    @NotNull
    @Override
    public Iterator&lt;V&gt; iterator()
    {
<span class="fc" id="L1704">        NDIterator _ndi = NDIterator.of( this );</span>
<span class="fc" id="L1705">        return new Iterator&lt;V&gt;()</span>
<span class="fc" id="L1706">        {</span>
<span class="fc" id="L1707">            private int _count = 0;</span>
<span class="fc" id="L1708">            private final int _size = Tsr.this.size();</span>

<span class="fc bfc" id="L1710" title="All 2 branches covered.">            @Override public boolean hasNext() { return _count != _size; }</span>

            @Override
            public V next() {
<span class="fc" id="L1714">                V value = Tsr.this.getDataAt( _ndi.i() );</span>
<span class="fc" id="L1715">                _ndi.increment();</span>
<span class="fc" id="L1716">                _count ++;</span>
<span class="fc" id="L1717">                return value;</span>
            }
        };
    }


    /*==================================================================================================================
    |
    |       Â§(7) : COMPONENT SPECIFIC :
    |   ---------------------------------------
    */
    /*
        -------------------------------
            Â§(7.0) : AUTO-GRAD :
        -------------------------------
        ... for more context see package 'autograd' ...
     */

    /**
     *  Tensors which are used or produced by the autograd system will have a {@link GraphNode} component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  If this tensor is part of a computation graph then this method
     *  will traverse an error backward in the recorded history towards tensors which require
     *  the accumulation of gradients.
     *
     * @param error A tensor which is back-propagated to gradients. Must match the size og this tensor.
     * @return The tensor on which this method was called. (factory pattern)
     */
    public final Tsr&lt;V&gt; backward( Tsr&lt;V&gt; error ) {
<span class="fc" id="L1746">        LogUtil.nullArgCheck(error, &quot;error&quot;, Tsr.class, &quot;Cannot back-propagate 'null'!&quot;);</span>
<span class="fc bfc" id="L1747" title="All 2 branches covered.">        if ( this.isOutsourced() )</span>
<span class="fc" id="L1748">            error = error.clone().to(this.getDevice());</span>

<span class="fc" id="L1750">        Tsr&lt;V&gt; finalError = error;</span>
<span class="pc bpc" id="L1751" title="1 of 4 branches missed.">        if ( !forComponent( GraphNode.class, node -&gt; node.backward(finalError) ) &amp;&amp; this.rqsGradient() ) {</span>
<span class="fc" id="L1752">            addToGradient( error );</span>
        }
<span class="fc" id="L1754">        return this;</span>
    }

    /**
     *  Tensors which are used or produced by the autograd system will have a {@link GraphNode} component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  If this tensor is part of a computation graph then this method
     *  will traverse an error backward in the recorded history towards tensors which require
     *  the accumulation of gradients.&lt;br&gt;
     *  &lt;br&gt;
     *  This method turns the given scalar value and
     *  turns it into a matching tensor ( with the same shape)
     *  which will then be back-propagated through the
     *  recorded computation graph.
     *
     * @param value A scalar which is back-propagated to gradients. Must match the size og this tensor.
     * @return The tensor on which this method was called. (factory pattern)
     */
    public final Tsr&lt;V&gt; backward( double value ) {
<span class="fc" id="L1773">        backward( Tsr.of( this.getValueClass(), getNDConf().shape(), value ) );</span>
<span class="fc" id="L1774">        return this;</span>
    }

    /**
     *  Tensors which are used or produced by the autograd system will have a {@link GraphNode} component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  If this tensor is part of a computation graph then this method
     *  will traverse an error backward in the recorded history towards tensors which require
     *  the accumulation of gradients. &lt;br&gt;
     *  &lt;br&gt;
     *  This method assumes that the user wants to back-propagate
     *  an error of &quot;1&quot; having the same shape as
     *  this tensor.
     *
     * @return The tensor on which this method was called. (factory pattern)
     */
    public final Tsr&lt;V&gt; backward()
    {
<span class="fc" id="L1792">        backward( 1 ); // By default we back-propagate a base factor of 1.</span>
<span class="fc" id="L1793">        return this;</span>
    }

    /**
     *  If this tensor owns a gradient tensor as component, then it can be applied by this method. &lt;br&gt;
     *  &quot;Applying&quot; a gradient to a tensor simply means adding the values inside the gradient element-wise
     *  to the owning host tensor via an inline operation. &lt;br&gt;
     */
    public final void applyGradient()
    {
        /*
           If the tensor has a JITProp component then it will trigger the continuation of the back-propagation which
           has been put on hold by saving the pending graph nodes inside the component. &lt;br&gt;
           This is because the gradient most likely has not yet been fully calculated.
         */
<span class="fc" id="L1808">        forComponent( JITProp.class, JITProp::execute );</span>
        // Afterwards the JITProp component is not needed anymore! So we remove it.
<span class="fc" id="L1810">        remove( JITProp.class );</span>
        // Now the gradient can be applied (Gradients are also tensors, which is why we provide its class as key).
<span class="fc" id="L1812">        forComponent(</span>
                Tsr.class,
                g -&gt; {
                    // If an optimizer is present then we also optimize the gradient first!
<span class="fc bfc" id="L1816" title="All 2 branches covered.">                    if ( this.has( Optimizer.class ) )</span>
<span class="fc" id="L1817">                        g = this.get(Optimizer.class).optimize( this );</span>
                    // And then we remove the gradient because it is no longer needed.
<span class="fc" id="L1819">                    remove( Tsr.class );</span>
                    // We are now ready to apply the gradient to the tensor. This is an inline operation!
                    // Therefore we need to turn off the inline operation safety net:
<span class="fc" id="L1822">                    boolean inlineSafety = Neureka.get().settings().autograd().isPreventingInlineOperations();</span>
<span class="pc bpc" id="L1823" title="1 of 2 branches missed.">                    if ( inlineSafety ) Neureka.get().settings().autograd().setIsPreventingInlineOperations( false );</span>
                    // INLINE OPERATION :
<span class="fc" id="L1825">                    Neureka.get().backend().getFunction().plusAssign().call( this, g ); //-&gt; Finally applying the gradient!</span>
                    // INLINE END ! -&gt; We can now revert to the previous setting:
<span class="pc bpc" id="L1827" title="1 of 2 branches missed.">                    if ( inlineSafety ) Neureka.get().settings().autograd().setIsPreventingInlineOperations( true );</span>
<span class="fc" id="L1828">                }</span>
        );
<span class="fc" id="L1830">    }</span>

    /**
     *  &lt;b&gt;This method detaches this tensor from its underlying computation-graph
     *  or simply does nothing if no graph is present.&lt;/b&gt; &lt;br&gt;
     *  Nodes within a computation graph are instances of the &quot;{@link GraphNode}&quot; class which are also
     *  simple components of the tensors they represent in the graph. &lt;br&gt;
     *  Therefore, &quot;detaching&quot; this tensor from the graph simply means removing its {@link GraphNode} component.
     *
     * @return This very instance in order to allows for a more streamline usage of this method.
     */
<span class="fc" id="L1841">    public final Tsr&lt;V&gt; detach() { this.remove( GraphNode.class ); return this; }</span>

    /*
        ----------------------------
            Â§(7.1) : FRAMING :
        ----------------------------
        ... for more context see package 'framing'...
     */

    /**
     *  This method receives a nested {@link String} array which
     *  ought to contain a label for the index of this tensor.
     *  The index for a single element of this tensor would be an array
     *  of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows:    &lt;br&gt;
     *                                                              &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                      &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                                 &lt;br&gt;
     *                                                              &lt;br&gt;
     *
     * @param labels A nested String array containing labels for indexes of the tensor dimensions.
     * @return This tensor (method chaining).
     */
    public final Tsr&lt;V&gt; label( String[][] labels )
    {
<span class="fc" id="L1869">        _label( null, labels );</span>
<span class="fc" id="L1870">        return this;</span>
    }

    /**
     *  This method receives a label for this tensor and a
     *  nested {@link String} array which ought to contain a
     *  label for the index of this tensor.
     *  The index for a single element of this tensor would be an array
     *  of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows:    &lt;br&gt;
     *                                                              &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                      &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                                 &lt;br&gt;
     *                                                              &lt;br&gt;
     *
     * @param tensorName A label for this tensor itself.
     * @param labels A nested String array containing labels for indexes of the tensor dimensions.
     * @return This tensor (method chaining).
     */
    public final Tsr&lt;V&gt; label( String tensorName, String[][] labels )
    {
<span class="fc" id="L1894">        _label( tensorName, labels );</span>
<span class="fc" id="L1895">        return this;</span>
    }

    /**
     *  This private method is used by public {@link Tsr#label} methods as a single source of
     *  responsibility for performing the actual labeling based on the user input...
     *
     * @param tensorName The name of this tensor which will be stored in an {@link NDFrame} component.
     * @param labels The label / alias information which will also be stored in an {@link NDFrame} component.
     */
    private void _label( String tensorName, String[][] labels )
    {
<span class="fc" id="L1907">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, String[][].class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="fc" id="L1908">        NDFrame&lt;V&gt; frame = get( NDFrame.class );</span>
<span class="fc bfc" id="L1909" title="All 2 branches covered.">        if ( frame == null ) {</span>
<span class="fc" id="L1910">            frame = new NDFrame( this.rank(), tensorName );</span>
<span class="fc" id="L1911">            set(frame);</span>
        }
<span class="pc bpc" id="L1913" title="2 of 4 branches missed.">        assert labels.length &lt;= this.rank();</span>
<span class="fc bfc" id="L1914" title="All 2 branches covered.">        for( int i = 0; i &lt; labels.length; i++ ) {</span>
<span class="pc bpc" id="L1915" title="1 of 2 branches missed.">            if ( labels[ i ] != null ) {</span>
<span class="fc" id="L1916">                AxisFrame&lt;Integer, V&gt; atAxis = frame.atAxis( i );</span>
<span class="fc bfc" id="L1917" title="All 2 branches covered.">                for ( int ii = 0; ii &lt; labels[ i ].length; ii++ ) {</span>
<span class="pc bpc" id="L1918" title="1 of 2 branches missed.">                    if ( labels[ i ][ ii ] != null )</span>
<span class="fc" id="L1919">                        atAxis.atIndexAlias( labels[ i ][ ii ] ).setIndex( ii );</span>
                }
            }
        }
<span class="fc" id="L1923">    }</span>

    /**
     *  This method receives a nested {@link String} list which
     *  ought to contain a label for the index of this tensor.
     *  The index for a single element of this tensor would be an array
     *  of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows: &lt;br&gt;
     *                                                           &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                   &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                              &lt;br&gt;
     *                                                           &lt;br&gt;
     * @param labels A nested String list containing labels for indexes of the tensor dimensions.
     * @return This tensor (method chaining).
     */
    public final Tsr&lt;V&gt; label( List&lt;List&lt;Object&gt;&gt; labels )
    {
<span class="fc" id="L1943">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, List.class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="fc" id="L1944">        NDFrame&lt;V&gt; frame = get( NDFrame.class );</span>
<span class="pc bpc" id="L1945" title="1 of 2 branches missed.">        if ( frame == null ) set( new NDFrame( labels, null ) );</span>
<span class="fc" id="L1946">        return this;</span>
    }

    /**
     *  This method receives a label for this tensor and a nested
     *  {@link String} list which ought to contain a label for the index of
     *  this tensor The index for a single element of this tensor would
     *  be an array of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows: &lt;br&gt;
     *                                                           &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                   &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                              &lt;br&gt;
     *                                                           &lt;br&gt;
     * @param tensorName A label for this tensor itself.
     * @param labels A nested String list containing labels for indexes of the tensor dimensions.
     * @return This tensor (method chaining).
     */
    public final Tsr&lt;V&gt; label( String tensorName, List&lt;List&lt;Object&gt;&gt; labels )
    {
<span class="fc" id="L1968">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, List.class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="fc" id="L1969">        NDFrame&lt;V&gt; frame = get( NDFrame.class );</span>
<span class="pc bpc" id="L1970" title="1 of 2 branches missed.">        if ( frame == null ) set( new NDFrame&lt;&gt;( labels, tensorName ) );</span>
<span class="fc" id="L1971">        return this;</span>
    }

    /**
     *  This method provides the ability to
     *  label not only the indices of the shape of this tensor, but also
     *  the dimension of the shape.
     *  The first and only argument of the method expects a map instance
     *  where keys are the objects which ought to act as dimension labels
     *  and the values are lists of labels for the indices of said dimensions.
     *  For example the shape (2,3) could be labeled as follows:            &lt;br&gt;
     *  [                                                                   &lt;br&gt;
     *      &quot;dim 0&quot; : [&quot;A&quot;, &quot;B&quot;],                                           &lt;br&gt;
     *      &quot;dim 1&quot; : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                                       &lt;br&gt;
     *  ]                                                                   &lt;br&gt;
     *                                                                      &lt;br&gt;
     * @param labels A map in which the keys are dimension labels and the values are lists of index labels for the dimension.
     * @return This tensor (method chaining).
     */
    public final Tsr&lt;V&gt; label( Map&lt;Object, List&lt;Object&gt;&gt; labels )
    {
<span class="fc" id="L1992">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, Map.class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="fc" id="L1993">        this.set( new NDFrame&lt;&gt;( labels, this, null ) );</span>
<span class="fc" id="L1994">        return this;</span>
    }

    public final Tsr&lt;V&gt; label( String tensorName, Map&lt;Object, List&lt;Object&gt;&gt; labels )
    {
<span class="nc" id="L1999">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, Map.class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="nc" id="L2000">        this.set( new NDFrame&lt;&gt;( labels, this, tensorName ) );</span>
<span class="nc" id="L2001">        return this;</span>
    }

    /*==================================================================================================================
    |
    |       Â§(8) : (OVERLOADABLE) OPERATORS &amp; OPERATIONS :
    |   -----------------------------------------------------
    |       ...for more context see package 'calculus'...
    |*/
    /*
        -----------------------------
            Â§(8.0) : OPERATORS :
        -----------------------------
     */

    /**
     *  This method will produce the sum of
     *  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
     *  where the left operand is this {@link Tsr}
     *  instance and the right operand is the tensor passed to the method.
     *  If the shapes of both of the involved tensors is identical then
     *  the result will be a regular element-wise addition.
     *  Otherwise, the method will also be able to perform broadcasting, however only if
     *  for every pair of shape dimension the following is true:
     *  Either the dimensions have the same size or one of them has size 1. &lt;br&gt;
     *  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       &lt;br&gt;
     *  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         &lt;br&gt;
     *
     * @param other The right operand of the addition.
     * @return The sum of this instance as the left and the passed {@link Tsr} instance as right operand.
     */
    public final Tsr&lt;V&gt; plus( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2033">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot add 'null' to a tensor!&quot;);</span>
<span class="fc" id="L2034">        return Neureka.get().backend().getAutogradFunction().plus().call( this, other );</span>
    }

    public final Tsr&lt;V&gt; plusAssign( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2038">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot add-assign 'null' to a tensor!&quot;);</span>
<span class="fc" id="L2039">        return Neureka.get().backend().getFunction().plusAssign().call( this, other );</span>
    }

    /**
     *  This method will create a new {@link Tsr}
     *  with the provided double scalar added to all elements of this {@link Tsr}.
     *
     *  The shapes of this tensor is irrelevant as the provided value will
     *  simply be broadcast to any possible shape.
     *
     * @param value The right operand of the addition.
     * @return The sum between this instance as the left and the passed double as right operand.
     */
<span class="fc" id="L2052">    public final Tsr&lt;V&gt; plus( double value ) { return plus( _of( this.shape(), value ) ); }</span>

    /**
     *  This method will perform subtraction on
     *  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
     *  where the left operand is this {@link Tsr}
     *  instance and the right operand is the tensor passed to the method.
     *  If the shapes of both of the involved tensors is identical then
     *  the result will be a regular element-wise subtraction.
     *  Otherwise, the method will also be able to perform broadcasting, however only if
     *  for every pair of shape dimension the following is true:
     *  Either the dimensions have the same size or one of them has size 1. &lt;br&gt;
     *  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       &lt;br&gt;
     *  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         &lt;br&gt;
     *
     * @param other The right operand of the subtraction.
     * @return The difference between this instance as the left and the passed {@link Tsr} instance as right operand.
     */
    public final Tsr&lt;V&gt; minus( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2071">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot subtract 'null' from a tensor!&quot;);</span>
<span class="fc" id="L2072">        return Neureka.get().backend().getAutogradFunction().minus().call( this, other );</span>
    }

    public final Tsr&lt;V&gt; minus( V other ) {
<span class="fc" id="L2076">        LogUtil.nullArgCheck(other, &quot;other&quot;, this.getValueClass(), &quot;Cannot subtract 'null' from a tensor!&quot;);</span>
<span class="fc" id="L2077">        return minus(</span>
<span class="fc" id="L2078">                 Tsr.of( this.getDataType().getValueTypeClass() )</span>
<span class="fc" id="L2079">                             .withShape(this.getNDConf().shape())</span>
<span class="fc" id="L2080">                             .all(other)</span>
        );
    }

    public final Tsr&lt;V&gt; minusAssign( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2085">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot subtract-assign 'null' from a tensor!&quot;);</span>
<span class="fc" id="L2086">        return Neureka.get().backend().getFunction().minusAssign().call( this, other );</span>
    }

    public final Tsr&lt;V&gt; minusAssign( V other ) {
<span class="fc" id="L2090">        LogUtil.nullArgCheck(other, &quot;other&quot;, this.getValueClass(), &quot;Cannot subtract-assign 'null' from a tensor!&quot;);</span>
<span class="fc" id="L2091">        return minusAssign(</span>
<span class="fc" id="L2092">                Tsr.of( this.getDataType().getValueTypeClass() )</span>
<span class="fc" id="L2093">                        .withShape(this.getNDConf().shape())</span>
<span class="fc" id="L2094">                        .all(other)</span>
        );
    }

    /**
     * @return A clone of this tensor where the signs of all elements are flipped.
     */
<span class="fc" id="L2101">    public final Tsr&lt;V&gt; negative() { return Neureka.get().backend().getAutogradFunction().neg().call( this ); }</span>

    /**
     *  This method is synonymous to the {@link #times(Tsr)} method.
     *  Both of which will produce the product of
     *  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
     *  where the left operand is this {@link Tsr}
     *  instance and the right operand is the tensor passed to the method.
     *  If the shapes of both of the involved tensors is identical then
     *  the result will be a regular element-wise product.
     *  Otherwise, the method will also be able to perform broadcasting, however only if
     *  for every pair of shape dimension the following is true:
     *  Either the dimensions have the same size or one of them has size 1. &lt;br&gt;
     *  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       &lt;br&gt;
     *  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         &lt;br&gt;
     *
     * @param other The right operand of the multiplication.
     * @return The product of this instance as the left and the passed {@link Tsr} instance as right operand.
     */
    public final Tsr&lt;V&gt; multiply( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2121">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot multiply 'null' with a tensor!&quot;);</span>
<span class="fc" id="L2122">        return Neureka.get().backend().getAutogradFunction().mul().call( this, other );</span>
    }

    /**
     * @param other The value which should be broadcast to all elements of a clone of this tensor.
     * @return A new clone of this tensor where all elements are multiplied by the provided value.
     */
    public final Tsr&lt;V&gt; multiply( V other ) {
<span class="fc" id="L2130">        LogUtil.nullArgCheck(other, &quot;other&quot;, this.getValueClass(), &quot;Cannot multiply 'null' with a tensor!&quot;);</span>
<span class="fc" id="L2131">        return multiply(</span>
<span class="fc" id="L2132">                           Tsr.of( this.getDataType().getValueTypeClass() )</span>
<span class="fc" id="L2133">                               .withShape( this.getNDConf().shape() )</span>
<span class="fc" id="L2134">                               .all( other )</span>
                        );
    }

    /**
     *  The {@link #times(Tsr)} method is synonymous to the {@link #multiply(Tsr)}.
     *  Both of which will produce the product of
     *  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
     *  where the left operand is this {@link Tsr}
     *  instance and the right operand is the tensor passed to the method.
     *  If the shapes of both of the involved tensors is identical then
     *  the result will be a regular elementwise product.
     *  Otherwise the method will also be able to perform broadcasting, however only if
     *  for every pair of shape dimension the following is true:
     *  Either the dimensions have the same size or one of them has size 1. &lt;br&gt;
     *  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       &lt;br&gt;
     *  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         &lt;br&gt;
     *
     * @param other The right operand of the multiplication.
     * @return The product of this instance as the left and the passed {@link Tsr} instance as right operand.
     */
    public final Tsr&lt;V&gt; times( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2156">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot multiply 'null' with a tensor!&quot;);</span>
<span class="fc" id="L2157">        return multiply( other );</span>
    }

    /**
     * @param other The value which should be broadcast to all elements of a clone of this tensor.
     * @return A new clone of this tensor where all elements are multiplied by the provided value.
     */
    public final Tsr&lt;V&gt; times( V other ) {
<span class="fc" id="L2165">        LogUtil.nullArgCheck(other, &quot;other&quot;, getValueClass(), &quot;Cannot multiply 'null' with a tensor!&quot;);</span>
<span class="fc" id="L2166">        return multiply( other );</span>
    }

    /**
     * @param other The tensor whose elements ought to be multiplied and assigned to elements in this tensor.
     * @return This instance where each value element was multiplied by the corresponding element in the provided tensor.
     */
    public final Tsr&lt;V&gt; timesAssign( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2174">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot multiply-assign 'null' to a tensor!&quot;);</span>
<span class="fc" id="L2175">        return Neureka.get().backend().getFunction().mulAssign().call( this, other );</span>
    }

    /**
     * @param other The value which ought to be multiplied and assigned to each element in this tensor.
     * @return This instance where each value element was multiplied by the provided element.
     */
    public final Tsr&lt;V&gt; timesAssign( V other ) {
<span class="fc" id="L2183">        LogUtil.nullArgCheck(other, &quot;other&quot;, this.getValueClass(), &quot;Cannot multiply-assign 'null' to a tensor!&quot;);</span>
<span class="fc" id="L2184">        return this.timesAssign( Tsr.of( getValueClass(), getNDConf().shape(), other ) );</span>
    }


    /**
     * @param value The value which should be broadcast to all elements of a clone of this tensor.
     * @return A new clone of this tensor where all elements are multiplied by the provided value.
     */
<span class="fc" id="L2192">    public final Tsr&lt;V&gt; multiply( double value ) { return multiply( Tsr.of( getValueClass(), getNDConf().shape(), value ) ); }</span>

    /**
     *  The {@link #div(Tsr)} method will produce the quotient of
     *  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
     *  where the left operand is this {@link Tsr}
     *  instance and the right operand is the tensor passed to the method.
     *  If the shapes of both of the involved tensors is identical then
     *  the result will be a regular element-wise division.
     *  Otherwise, the method will also be able to perform broadcasting, however only if
     *  for every pair of shape dimension the following is true:
     *  Either the dimensions have the same size or one of them has size 1. &lt;br&gt;
     *  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       &lt;br&gt;
     *  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         &lt;br&gt;
     *
     * @param other The right operand of the division.
     * @return The quotient of this instance as the left and the passed {@link Tsr} instance as right operand.
     */
    public final Tsr&lt;V&gt; div( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2211">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot divide a tensor by 'null' (In any sense of the word)!&quot;);</span>
<span class="fc" id="L2212">        return Neureka.get().backend().getAutogradFunction().div().call( this, other );</span>
    }

<span class="fc" id="L2215">    public final Tsr&lt;V&gt; div( double value ) { return div( Tsr.of( getValueClass(), getNDConf().shape(), value ) ); }</span>

    public final Tsr&lt;V&gt; divAssign( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2218">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot divide-assign a tensor by 'null' (In any sense of the word)!&quot;);</span>
<span class="fc" id="L2219">        return Neureka.get().backend().getFunction().divAssign().call( this, other );</span>
    }

    /**
     *  The {@link #mod(Tsr)} method will produce the modulus of
     *  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
     *  where the left operand is this {@link Tsr}
     *  instance and the right operand is the tensor passed to the method.
     *  If the shapes of both of the involved tensors is identical then
     *  the result will be a regular element-wise modulo operation.
     *  Otherwise, the method will also be able to perform broadcasting, however only if
     *  for every pair of shape dimension the following is true:
     *  Either the dimensions have the same size or one of them has size 1. &lt;br&gt;
     *  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       &lt;br&gt;
     *  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         &lt;br&gt;
     *
     * @param other The right operand of the modulo operation.
     * @return The modulus of this instance as the left and the passed {@link Tsr} instance as right operand.
     */
    public final Tsr&lt;V&gt; mod( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2239">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot perform tensor modulo 'null'!&quot;);</span>
<span class="fc" id="L2240">        return Neureka.get().backend().getAutogradFunction().mod().call( this, other );</span>
    }

<span class="nc" id="L2243">    public final Tsr&lt;V&gt; mod( int other ) { return mod(Tsr.of(getValueClass(), getNDConf().shape(), other)); }</span>
 
    /**
     *  This method is synonymous to the {@link #mod(int)} method.
     */
<span class="fc" id="L2248">    public final Tsr&lt;V&gt; rem( int other ) { return mod(Tsr.of(getValueClass(), getNDConf().shape(), other)); }</span>

    public final Tsr&lt;V&gt; modAssign( Tsr&lt;V&gt; other ) {
<span class="nc" id="L2251">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot perform tensor modulo 'null'!&quot;);</span>
<span class="nc" id="L2252">        return Neureka.get().backend().getFunction().modAssign().call( this, other );</span>
    }

    /**
     *  The {@link #power(Tsr)} (Tsr)} method will produce the power of
     *  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
     *  where the left operand is this {@link Tsr}
     *  instance and the right operand is the tensor passed to the method.
     *  If the shapes of both of the involved tensors is identical then
     *  the result will be a regular element-wise exponentiation.
     *  Otherwise, the method will also be able to perform broadcasting, however only if
     *  for every pair of shape dimension the following is true:
     *  Either the dimensions have the same size or one of them has size 1. &lt;br&gt;
     *  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       &lt;br&gt;
     *  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         &lt;br&gt;
     *
     * @param other The right operand, also known as exponent, of the exponentiation.
     * @return The power of this instance as the left and the passed {@link Tsr} instance as right operand.
     */
    public final Tsr&lt;V&gt; power( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2272">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot raise a tensor to the power of 'null'!&quot;);</span>
<span class="fc" id="L2273">        return Neureka.get().backend().getAutogradFunction().pow().call( this, other );</span>
    }

    public final Tsr&lt;V&gt; power( double value ) {
<span class="fc" id="L2277">        return power( _of( this.shape(), value ) );</span>
    }

    /**
     *  This method is synonymous to the {@link #power(Tsr)} method.
     */
    public final Tsr&lt;V&gt; xor( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2284">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot raise a tensor to the power of 'null'!&quot;);</span>
<span class="fc" id="L2285">        return Neureka.get().backend().getAutogradFunction().pow().call( this, other );</span>
    }

    /**
     *  This method is synonymous to the {@link #power(Tsr)} method.
     */
<span class="fc" id="L2291">    public final Tsr&lt;V&gt; xor( double value ) { return xor( _of( this.shape(), value ) ); }</span>

    /*
        -----------------------------
            Â§(8.1) : OPERATIONS :
        -----------------------------
     */

    /**
     *  A method which returns a new {@link Tsr} instance which is a transposed twin of this instance.
     *
     * @return A new transposed tensor with the same underlying data as this tensor.
     */
    public final Tsr&lt;V&gt; T() // Transposed!
    {
<span class="pc bpc" id="L2306" title="1 of 2 branches missed.">        if ( this.rank() == 1 ) return this;</span>
<span class="fc bfc" id="L2307" title="All 2 branches covered.">        else if ( this.rank() == 2 ) {</span>
<span class="fc" id="L2308">            boolean wasIntermediate = this.isIntermediate();</span>
<span class="fc" id="L2309">            this.getUnsafe().setIsIntermediate(false);</span>
<span class="fc" id="L2310">            Tsr&lt;V&gt; result = Neureka.get().backend().getFunction().transpose2D().call(this);</span>
<span class="fc" id="L2311">            this.getUnsafe().setIsIntermediate(wasIntermediate);</span>
<span class="fc" id="L2312">            return result;</span>
        }
<span class="fc" id="L2314">        StringBuilder operation = new StringBuilder();</span>
<span class="fc bfc" id="L2315" title="All 4 branches covered.">        for ( int i = rank() - 1; i &gt;= 0; i-- ) operation.append( i ).append( i == 0 ? &quot;&quot; : &quot;, &quot; );</span>
<span class="fc" id="L2316">        operation = new StringBuilder( &quot;[&quot; + operation + &quot;]:(I[ 0 ])&quot; );</span>
<span class="fc" id="L2317">        return Function.of( operation.toString(), true ).call( this );</span>
    }

    /**
     *  A method which returns a new {@link Tsr} instance which is a transposed twin of this instance.
     *  It is and alias method to the {@link #T()} method...
     *
     * @return A new transposed tensor with the same underlying data as this tensor.
     */
<span class="fc" id="L2326">    public final Tsr&lt;V&gt; getT() { return this.T(); } // Transposed</span>

    /**
     *  This method performs various operations by calling {@link Function} instances
     *  in order to ultimately calculate the mean value of all values
     *  of this very tensor!
     *  This scalar tensor is then returned.
     *
     * @return A scalar tensor which is the mean value of all values of this very tensor.
     */
    public final Tsr&lt;V&gt; mean() {
<span class="fc" id="L2337">        Functions functions = Neureka.get().backend().getAutogradFunction();</span>
<span class="fc" id="L2338">        Tsr&lt;V&gt; sum = sum();</span>
<span class="fc" id="L2339">        Tsr&lt;V&gt; result = functions.div().call( sum, Tsr.of( this.getValueClass(), new int[]{1}, this.size() ) );</span>
<span class="fc" id="L2340">        sum.getUnsafe().delete();</span>
<span class="fc" id="L2341">        return result;</span>
    }

    public final Tsr&lt;V&gt; sum() {
<span class="fc" id="L2345">        Functions functions = Neureka.get().backend().getAutogradFunction();</span>
<span class="fc" id="L2346">        Tsr&lt;V&gt; ones = Tsr.of( this.getValueClass(), this.getNDConf().shape(), 1 );</span>
<span class="fc" id="L2347">        Tsr&lt;V&gt; sum = functions.conv().call( this, ones );</span>
<span class="pc bpc" id="L2348" title="1 of 4 branches missed.">        if ( !ones.has(GraphNode.class) || !ones.getGraphNode().isUsedAsDerivative() )</span>
<span class="fc" id="L2349">            ones.getUnsafe().delete();</span>
<span class="pc bpc" id="L2350" title="1 of 2 branches missed.">        if ( sum == null )</span>
<span class="nc" id="L2351">            throw new IllegalStateException(</span>
                    &quot;Failed to calculate sum using convolution! Shapes: &quot;+
<span class="nc" id="L2353">                            Arrays.toString(this.getNDConf().shape())+&quot;x&quot;+Arrays.toString(ones.getNDConf().shape())</span>
            );
<span class="fc" id="L2355">        return sum;</span>
    }

    /**
     *  This method performs a convolutional based dot product between the last dimension of this tensor
     *  and the first dimension of the passed tensor.
     *
     * @param other The tensor which is the right part of the dot product operation.
     * @return A new tensor which is the dot product of this tensor and the passed one.
     */
    public final Tsr&lt;V&gt; convDot( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2366">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class);</span>
<span class="fc" id="L2367">        Tsr&lt;V&gt; a = this;</span>
<span class="fc" id="L2368">        int[][] fitter = AbstractTensor.Utility.makeFit( a.getNDConf().shape(), other.getNDConf().shape() );</span>
<span class="fc" id="L2369">        boolean doReshape = false;</span>
<span class="fc bfc" id="L2370" title="All 6 branches covered.">        for ( int i = 0; i &lt; fitter[ 0 ].length &amp;&amp; !doReshape; i++ ) if ( fitter[ 0 ][ i ] != i ) doReshape = true;</span>
<span class="pc bpc" id="L2371" title="1 of 6 branches missed.">        for ( int i = 0; i &lt; fitter[ 1 ].length &amp;&amp; !doReshape; i++ ) if ( fitter[ 1 ][ i ] != i ) doReshape = true;</span>
<span class="fc bfc" id="L2372" title="All 2 branches covered.">        if ( doReshape ) {</span>
<span class="fc" id="L2373">            a = Function.of( AbstractTensor.Utility.shapeString( fitter[ 0 ] ) + &quot;:(I[ 0 ])&quot; ).call( a );</span>
<span class="fc" id="L2374">            other = Function.of( AbstractTensor.Utility.shapeString( fitter[ 1 ] ) + &quot;:(I[ 0 ])&quot; ).call( other );</span>
        }
<span class="fc" id="L2376">        return Neureka.get()</span>
<span class="fc" id="L2377">                        .backend()</span>
<span class="fc" id="L2378">                        .getAutogradFunction()</span>
<span class="fc" id="L2379">                        .conv()</span>
<span class="fc" id="L2380">                        .call( a, other )</span>
<span class="fc" id="L2381">                        .dimtrim();</span>
    }

    /**
     *  This method performs a dot product between the last dimension of this tensor
     *  and the first dimension of the passed tensor.
     *  However, currently this method can only handle matrices which means
     *  that it is functionally completely identical to the {@link #matMul(Tsr)} method.
     *
     * @param other The tensor which is the right part of the dot product operation.
     * @return A new tensor which is the dot product of this tensor and the passed one.
     */
    public final Tsr&lt;V&gt; dot( Tsr&lt;V&gt; other ) {
<span class="nc" id="L2394">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot perform dot operation when second operand is 'null'!&quot;);</span>
<span class="nc bnc" id="L2395" title="All 4 branches missed.">        if ( this.rank() != 2 &amp;&amp; other.rank() != 2 )</span>
<span class="nc" id="L2396">            throw new IllegalStateException(&quot;Not yet implemented!&quot;); // This is not yet available in the backend!</span>
<span class="nc" id="L2397">        return this.matMul( other );</span>
    }

    /**
     *  The {@link #matMul(Tsr)} method will produce the matrix product of
     *  two 2 dimensional arrays, where the left operand is this {@link Tsr}
     *  instance and the right operand is the tensor passed to the method.
     *
     * @param other The right operand of the matrix multiplication.
     * @return The matrix product of this instance as the left and the passed {@link Tsr} instance as right operand.
     */
    public final Tsr&lt;V&gt; matMul( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2409">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot perform matrix multiplication operation when second operand is 'null'!&quot;);</span>
<span class="pc bpc" id="L2410" title="2 of 4 branches missed.">        if ( this.rank() != 2 || other.rank() != 2 ) {</span>
<span class="nc" id="L2411">            String message = &quot;Cannot perform matrix multiplication for tensors whose ranks are not both 2!\n&quot; +</span>
<span class="nc" id="L2412">                             &quot;Encountered ranks: &quot; + this.rank() + &quot;, &quot; + other.rank() + &quot;;&quot;;</span>
<span class="nc" id="L2413">            _LOG.error( message );</span>
<span class="nc" id="L2414">            throw new IllegalArgumentException( message );</span>
        }
<span class="fc" id="L2416">        return Neureka.get().backend().getAutogradFunction().matMul().call( this, other );</span>
    }

    /**
     *  This method creates a new tensor sharing the same data and whose shape is trimmed.
     *  A trimmed shape is simply a shape without preceding and trailing ones. &lt;br&gt;
     *  For example the shape (1x4x1x2x1) would be trimmed to (4x1x2).
     *  The underlying operation does not perform a removal of redundant ones all together.
     *  Only ones at the start and the beginning will be removed.
     *  A scalar tensor will not be affected by this operation.
     *
     * @return A tensor with the same underlying data but possibly trimmed shape without preceding or trailing ones.
     */
<span class="fc" id="L2429">    public final Tsr&lt;V&gt; dimtrim() { return Neureka.get().backend().getAutogradFunction().dimTrim().call( this ); }</span>

    /**
     *  This method name translates to the &quot;in&quot; keyword in Groovy!
     *  The same is true for the &quot;contains&quot; method in Kotlin.
     *  Both methods do the exact same thing, however they exist
     *  for better language support.
     *
     * @param other The tensor which will be checked.
     * @return The answer to the following question: Is the data of the provided tensor a subset of the data of this tensor?
     */
    public boolean isCase( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2441">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot perform 'is case' operation when second oprand is 'null'!&quot;);</span>
<span class="fc" id="L2442">        boolean[] found = { false };</span>
<span class="fc" id="L2443">        this.forComponent( Relation.class, r -&gt; r.foreachChild( c -&gt; {</span>
<span class="fc bfc" id="L2444" title="All 2 branches covered.">                if ( c.equals( other ) ) found[ 0 ] = true;</span>
<span class="fc" id="L2445">            }));</span>
<span class="fc" id="L2446">        return found[ 0 ];</span>
    }

    /**
     *  This method name translates to the &quot;in&quot; keyword in Kotlin!
     *  The same is true for the &quot;isCase&quot; method in Groovy.
     *  Both methods do the exact same thing, however they exist
     *  for better language support.
     *
     * @param other The tensor which will be checked.
     * @return The answer to the following question: Is the data of the provided tensor a subset of the data of this tensor?
     */
    public boolean contains( Tsr&lt;V&gt; other ) {
<span class="fc" id="L2459">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot perform 'contains' operation when second oprand is 'null'!&quot;);</span>
<span class="fc" id="L2460">        return isCase( other );</span>
    }


    /*==================================================================================================================
    |
    |       Â§(9) : SLICING, INDEXING &amp; INJECTING :
    |   -----------------------------------------------------
    |       ...for more context see package 'ndim.config'...
    */
    /*
        -----------------------------
            Â§(9.0) : SLICING :
        -----------------------------
     */

    /**
     *  The following method enables access to specific scalar elements within the tensor.
     *  The method name also translates to the subscript operator in Groovy.
     *
     * @param indices The index array of the element which should be returned.
     * @return An element located at the provided index.
     */
    @Override
    public final Tsr&lt;V&gt; getAt( int... indices ) {
<span class="fc" id="L2485">        LogUtil.nullArgCheck(indices, &quot;indices&quot;, int[].class, &quot;Indices array must not be 'null'!&quot;);</span>
<span class="fc" id="L2486">        return getAt( Arrays.stream( indices ).boxed().toArray() );</span>
    }

    /**
     *  This method is most useful when used in Groovy
     *  where defining maps is done through square brackets,
     *  making it possible to slice tensors like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      var b = a[[[0..0]:1, [0..0]:1, [0..3]:2]]
     *  }&lt;/pre&gt;
     *  Here a single argument with the format '[i..j]:k' is equivalent
     *  to Pythons 'i:j:k' syntax for indexing! (numpy)                            &lt;br&gt;
     *  i... start indexAlias.                                                      &lt;br&gt;
     *  j... end indexAlias. (inclusive!)                                           &lt;br&gt;
     *  k... step size.
     *
     * @param rankToStrides A map where the keys define where axes should be sliced and values which define the strides for the specific axis.
     * @return A tensor slice with an offset based on the provided map keys and
     *         strides based on the provided map values.
     */
    @Override
    public final Tsr&lt;V&gt; getAt( Map&lt;?,Integer&gt; rankToStrides )
    {
<span class="pc bpc" id="L2509" title="1 of 2 branches missed.">        if ( rankToStrides == null ) return this;</span>
        // ...not a simple slice... Advanced:
<span class="fc" id="L2511">        return SmartSlicer.slice(</span>
                        new Object[]{rankToStrides},
                        this,
                        this::_sliceOf
                    );
    }

    /**
     *  This is technically the equivalent to a full slice.
     *
     * @return A shallow copy where the underlying data is shared with this tensor.
     */
    public final Tsr&lt;V&gt; shallowCopy()
    {
<span class="pc bpc" id="L2525" title="1 of 4 branches missed.">        if ( this.isEmpty() || this.isUndefined() ) return this;</span>
<span class="fc" id="L2526">        List&lt;List&lt;Integer&gt;&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2527" title="All 2 branches covered.">        for ( int e : this.shape() ) {</span>
<span class="fc" id="L2528">            List&lt;Integer&gt; rangeAsList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2529" title="All 2 branches covered.">            for ( int i = 0; i &lt; e; i++ ) rangeAsList.add( i );</span>
<span class="fc" id="L2530">            ranges.add( rangeAsList);</span>
<span class="fc" id="L2531">        }</span>
<span class="fc" id="L2532">        return getAt( ranges.toArray() );</span>
    }

    /**
     *  This method enables tensor slicing!
     *  It takes a key of various types and configures a slice
     *  tensor which shares the same underlying data as the original tensor.
     *
     * @param key This object might be a wide range of objects including maps, lists or arrays...
     * @return A slice tensor or scalar value.
     */
    @Override
    public final Tsr&lt;V&gt; getAt( List&lt;?&gt; key ) {
<span class="fc" id="L2545">        LogUtil.nullArgCheck( key, &quot;key&quot;, List.class );</span>
<span class="fc bfc" id="L2546" title="All 4 branches covered.">        if ( key.stream().anyMatch( i -&gt; i == null ) )</span>
<span class="fc" id="L2547">            throw new IllegalArgumentException(&quot;List of indices/ranges may not contain entries which are null!&quot;);</span>
<span class="fc bfc" id="L2548" title="All 2 branches covered.">        if ( key.isEmpty() ) {</span>
            /*
                An empty List instance is being interpreted as
                the request to create an identical slice, meaning that the
                resulting tensor views the same data as its parent while not
                being the same instance. (In a sense, its a shallow copy!)
             */
<span class="fc" id="L2555">            return shallowCopy();</span>
        }

<span class="fc" id="L2558">        Object[] indices = key.toArray();</span>

<span class="fc" id="L2560">        boolean allInt = true;</span>
<span class="fc bfc" id="L2561" title="All 6 branches covered.">        for ( Object o : indices ) allInt = allInt &amp;&amp; o instanceof Integer;</span>
<span class="fc bfc" id="L2562" title="All 4 branches covered.">        if ( allInt &amp;&amp; indices.length == rank() ) {</span>
<span class="fc" id="L2563">            int[] newOffset = DataConverter.get().convert(indices, int[].class);</span>
<span class="fc bfc" id="L2564" title="All 2 branches covered.">            for ( int i = 0; i &lt; this.rank(); i++ )</span>
<span class="fc bfc" id="L2565" title="All 2 branches covered.">                newOffset[ i ] = ( newOffset[ i ] &lt; 0 ) ? getNDConf().shape( i ) + newOffset[ i ] : newOffset[ i ];</span>
<span class="fc bfc" id="L2566" title="All 2 branches covered.">            for ( int i = 0; i &lt; this.rank(); i++ )</span>
<span class="fc" id="L2567">                indices[ i ] = newOffset[ i ];</span>
<span class="fc" id="L2568">            allInt = false;</span>
        }
<span class="fc" id="L2570">        boolean hasScale = false;</span>
<span class="pc bpc" id="L2571" title="1 of 6 branches missed.">        for ( Object o : indices ) hasScale = hasScale || o instanceof Map;</span>
<span class="fc" id="L2572">        return SmartSlicer.slice(</span>
<span class="fc bfc" id="L2573" title="All 2 branches covered.">                ( allInt ? new Object[]{ DataConverter.get().convert(indices, int[].class) } : indices ),</span>
                this,
                this::_sliceOf
        );
    }

    /**
     *  If this tensor stores value types then this method will
     *  essentially produce a deep copy of this tensor.
     *  If the stored elements are reference types on the other hand,
     *  then the resulting clone may not be treated as a deep copy,
     *  especially if elements are mutable objects.
     *
     * @return A deep copy of this tensor.
     */
    @Override
    public final Tsr&lt;V&gt; clone() {
<span class="fc" id="L2590">        Function cloner = Neureka.get().backend().getFunction().idy();</span>
<span class="fc" id="L2591">        boolean thisIsIntermediate = this.isIntermediate();</span>
<span class="fc" id="L2592">        _setIsIntermediate( false );</span>
<span class="fc" id="L2593">        Tsr&lt;V&gt; clone = Tsr.of( this.getValueClass() )</span>
<span class="fc" id="L2594">                            .on(this.getDevice())</span>
<span class="fc" id="L2595">                            .withShape( this.getNDConf().shape() )</span>
<span class="fc" id="L2596">                            .all( (V) Double.valueOf(0.0) );</span>

<span class="fc" id="L2598">        clone = cloner.call(clone, this);</span>
<span class="fc" id="L2599">        clone.getUnsafe().setIsIntermediate( thisIsIntermediate );</span>
<span class="fc" id="L2600">        _setIsIntermediate( thisIsIntermediate );</span>
<span class="fc" id="L2601">        return clone;</span>
    }

    /**
     *  This method returns a {@link SliceBuilder} instance exposing a simple builder API
     *  which enables the configuration of a slice of the current tensor via method chaining.    &lt;br&gt;
     *  The following code snippet slices a 3-dimensional tensor into a tensor of shape (2x1x3)  &lt;br&gt;
     * &lt;pre&gt;{@code
     *  myTensor.slice()
     *          .axis(0).from(0).to(1)
     *          .then()
     *          .axis(1).at(5) // equivalent to '.from(5).to(5)'
     *          .then()
     *          .axis().from(0).to(2)
     *          .get();
     * }&lt;/pre&gt;
     *
     * @return An instance of the {@link SliceBuilder} class exposing a readable builder API for creating slices.
     */
<span class="fc" id="L2620">    public SliceBuilder&lt;V&gt; slice() { return new SliceBuilder&lt;&gt;( this, this::_sliceOf ); }</span>

    /**
     *  This method is where the creation of a slice occurs.
     *  When creating a slice via the {@link SliceBuilder} or simply by passing ranges in the form of
     *  arrays, lists or maps to a {@link Tsr#getAt}(...) method, then this method will be called eventually.
     *  The creation of a slice always requires information about the shape of the new slice
     *  its position within the original tensor and also the strides / steps.
     *
     * @param newShape The of the slice which ought to be created.
     * @param newOffset The position of the new slice within this tensor.
     * @param newSpread The spread / steps / strides of the slice within this tensor.
     * @return The newly created slice.
     */
    private Tsr&lt;V&gt; _sliceOf( int[] newShape, int[] newOffset, int[] newSpread )
    {
<span class="fc" id="L2636">        this.setIsVirtual( false );</span>
<span class="fc" id="L2637">        Tsr&lt;V&gt; subset = new Tsr&lt;&gt;();</span>
<span class="fc" id="L2638">        subset._setDataType( this.getDataType() );</span>
<span class="fc" id="L2639">        subset._setData( _getData() );</span>
<span class="fc" id="L2640">        int[] newTranslation = getNDConf().translation();</span>
<span class="fc" id="L2641">        int[] newIndicesMap = this.getNDConf().getLayout().newTranslationFor( newShape );</span>

<span class="fc bfc" id="L2643" title="All 2 branches covered.">        for ( int i = 0; i &lt; this.rank(); i++ )</span>
<span class="pc bpc" id="L2644" title="1 of 2 branches missed.">            newSpread[ i ] = ( newSpread[i] == 0 ) ? 1 : newSpread[ i ];</span>

<span class="fc bfc" id="L2646" title="All 2 branches covered.">        for ( int i = 0; i &lt; newOffset.length; i++ )</span>
<span class="fc" id="L2647">            newOffset[ i ] = newOffset[ i ] + getNDConf().offset( i ); // Offset is being inherited!</span>

<span class="fc bfc" id="L2649" title="All 2 branches covered.">        Tsr&lt;?&gt; rootTensor   = ( this.isSlice() ? get( Relation.class ).findRootTensor() : this );</span>
<span class="fc bfc" id="L2650" title="All 2 branches covered.">        Tsr&lt;?&gt; parentTensor = ( this.isSlice() ? get( Relation.class ).getParent()      : this );</span>
        /*
            The following code check the validity of the slice shape ranges with
            respect to the 'parentTensor' of this new slice.
         */
<span class="fc bfc" id="L2655" title="All 4 branches covered.">        if ( parentTensor.rank() != newShape.length || rootTensor != parentTensor ) {</span>
            // TODO! This requires some more thought about how to check this!
            // THIS CASE HAS NOT YET BEEN THOUGHT TROUGH!
<span class="fc" id="L2658">            _LOG.warn(</span>
                    &quot;Exceptional slice request detected. &quot; +
                    &quot;This type of tensor cannot yet be sliced. &quot; +
                    &quot;Please copy this tensor before slicing.&quot;
            );
        } else {
            /*
                1. We know that inside this else branch 'this' tensor is a first order slice!
                (So it is not a slice of a slice... reason : 'rootTensor == parentTensor' )

                2. There is however uncertainty about the 'true shape' of this parent tensor!
                Meaning : It might have been reshaped and could therefore be distorted with
                respect to the slice that is currently being prepared!
                -&gt; This means we have to take this possible reshaping into account!
                Like so:

                The following uses an int array also called 'reshapeRelation'.
                This is simply the 'reshape array' which has been recorded inside the 'Relation' component
                by the 'Reshape' operation! ( Hopefully! :) ... custom shape operations need to consider this as well! )

                The following would occur when : &quot;Tsr.of(...).T().getAt(...);&quot;
                Transposing a tensor performs an inline reshaping of an identical
                slice of the original tensor! Then again slicing this tensor
                via the 'getAt(...)' method leads us to a situation where
                the following variable is NOT NULL! :
             */
<span class="fc bfc" id="L2684" title="All 2 branches covered.">            int[] reshaped = ( this.isSlice() ) ? parentTensor.get( Relation.class ).getReshapeRelationFor( this ) : null;</span>
<span class="fc bfc" id="L2685" title="All 2 branches covered.">            reshaped = ( reshaped != null ) ? Reshape.invert( reshaped ) : null;</span>
<span class="fc bfc" id="L2686" title="All 2 branches covered.">            for ( int i = 0; i &lt; parentTensor.rank(); i++ ) {</span>
<span class="fc bfc" id="L2687" title="All 2 branches covered.">                int ii = ( reshaped != null ) ? reshaped[ i ] : i;</span>
<span class="fc" id="L2688">                int top = newOffset[ i ] + newShape[ i ];</span>
<span class="fc bfc" id="L2689" title="All 2 branches covered.">                if ( top &gt; parentTensor.shape( ii ) ) {</span>
<span class="fc" id="L2690">                    String message =</span>
                            &quot;Cannot create slice because ranges are out of the bounds of the targeted tensor.\n&quot; +
                            &quot;At index '&quot; + i + &quot;' : offset '&quot; + newOffset[ i ] + &quot;' + shape '&quot; + newShape[ i ] + &quot;' = '&quot; + top + &quot;',\n&quot; +
<span class="fc" id="L2693">                            &quot;which is larger than the target shape '&quot; + parentTensor.shape( ii ) + &quot;' at the same index!&quot;;</span>
<span class="fc" id="L2694">                    Exception exception = new IllegalArgumentException( message );</span>
<span class="fc" id="L2695">                    _LOG.error( message, exception );</span>
<span class="fc" id="L2696">                    throw new IllegalArgumentException( exception );</span>
                }
            }
        }
<span class="fc" id="L2700">        subset._setNDConf(</span>
<span class="fc" id="L2701">            AbstractNDC.construct(</span>
                newShape,
                newTranslation,
                newIndicesMap,
                newSpread,
                newOffset
            )
        );

<span class="fc bfc" id="L2710" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="fc" id="L2711">            Device&lt;V&gt; device = this.get( Device.class );</span>
<span class="fc" id="L2712">            device.store( subset, this );</span>
<span class="fc" id="L2713">            subset.setIsOutsourced( true );</span>
        }
<span class="pc bpc" id="L2715" title="1 of 2 branches missed.">        if ( this.isVirtual() ) subset.setIsVirtual( true );</span>
<span class="fc" id="L2716">        subset.set( new Relation().addParent( this ) );</span>
<span class="fc" id="L2717">        Relation&lt;V&gt; parent = get( Relation.class );</span>
<span class="fc bfc" id="L2718" title="All 2 branches covered.">        parent = ( parent != null ) ? parent : new Relation&lt;&gt;();</span>
<span class="fc" id="L2719">        parent.addChild( subset );</span>
<span class="fc" id="L2720">        this.set( parent );</span>
<span class="fc" id="L2721">        return subset;</span>
    }


    /*
        -----------------------------
            Â§(9.1) : INJECTING :
        -----------------------------
     */

    /**
     *  This method enables injecting slices of tensor to be assigned into this tensor!
     *  It takes a key of various types which is used to configure a slice
     *  tensor sharing the same underlying data as the original tensor.
     *  This slice is then used to assign the second argument to it, namely
     *  the &quot;value&quot; argument.
     *
     * @param key This object is a list defining a targeted index or range of indices...
     * @return A slice tensor or scalar value.
     */
    @Override
    public final Tsr&lt;V&gt; putAt( List&lt;?&gt; key, Tsr&lt;V&gt; value ) {
<span class="fc" id="L2743">        _putAtCheckFor( value );</span>
<span class="pc bpc" id="L2744" title="1 of 2 branches missed.">        Tsr&lt;V&gt; slice = ( key == null ) ? this : getAt( key );</span>
<span class="fc" id="L2745">        return _putAt( slice, value );</span>
    }

    /**
     *  Use this to place an element at a particular position
     *  within this tensor by providing a array of axis indices and said element.
     *
     * @param indices The array of axis indices defining the position for the provided item.
     * @param item The element which ought to be placed at the indexed position.
     * @return This tensor instance to allow for method chaining.
     */
    @Override
    public final Tsr&lt;V&gt; putAt( int[] indices, V item ) {
<span class="pc bpc" id="L2758" title="1 of 2 branches missed.">        if ( indices == null )</span>
<span class="nc" id="L2759">            throw new IllegalArgumentException( &quot;Provided indices are null!&quot; );</span>
<span class="pc bpc" id="L2760" title="1 of 2 branches missed.">        if ( indices.length &gt; this.rank() ) {</span>
<span class="nc" id="L2761">            int[] correct = new int[rank()];</span>
<span class="nc" id="L2762">            System.arraycopy( indices, 0, correct, 0, indices.length );</span>
<span class="nc" id="L2763">            indices = correct;</span>
        }
<span class="fc bfc" id="L2765" title="All 2 branches covered.">        if ( this.isVirtual() ) this.setIsVirtual( false );</span>
<span class="fc" id="L2766">        int i = getNDConf().indexOfIndices(indices);</span>
<span class="fc" id="L2767">        getUnsafe().setDataAt( i, item );</span>
<span class="fc" id="L2768">        return this;</span>
    }

    /**
     *  This method enables assigning a provided tensor to be a subset of this tensor!
     *  It takes a key which is used to configure a slice
     *  sharing the same underlying data as the original tensor.
     *  This slice is then used to assign the second argument {@code value} to it.
     *  The usage of this method is especially powerful when used in Groovy. &lt;br&gt;
     *  The following code illustrates this very well:
     *  &lt;pre&gt;{@code
     *      a[[[0..0]:1, [0..0]:1, [0..3]:2]] = b
     *  }&lt;/pre&gt;
     *  Here a single argument with the format '[i..j]:k' is equivalent
     *  to pythons 'i:j:k' syntax for indexing! (numpy)                            &lt;br&gt;
     *  i... start indexAlias.                                                      &lt;br&gt;
     *  j... end indexAlias. (inclusive!)                                           &lt;br&gt;
     *  k... step size.                                                             &lt;br&gt;
     *
     * @param key This object is a map defining a stride and a targeted index or range of indices...
     * @return A slice tensor or scalar value.
     */
    @Override
    public final Tsr&lt;V&gt; putAt( Map&lt;?,Integer&gt; key, Tsr&lt;V&gt; value ) {
<span class="fc" id="L2792">        _putAtCheckFor( value );</span>
<span class="pc bpc" id="L2793" title="1 of 2 branches missed.">        Tsr&lt;V&gt; slice = ( key == null ) ? this : getAt( key );</span>
<span class="fc" id="L2794">        return _putAt( slice, value );</span>
    }

    private void _putAtCheckFor( Tsr&lt;?&gt; value ) {
<span class="fc bfc" id="L2798" title="All 2 branches covered.">        if ( value.isEmpty() ) {</span>
<span class="fc" id="L2799">            String message = &quot;Provided tensor is empty! Empty tensors cannot be injected.&quot;;</span>
<span class="fc" id="L2800">            _LOG.error( message );</span>
<span class="fc" id="L2801">            throw new IllegalArgumentException( message );</span>
        }
<span class="fc" id="L2803">    }</span>

    private Tsr&lt;V&gt; _putAt( Tsr&lt;V&gt; slice, Tsr&lt;V&gt; value )
    {
<span class="fc" id="L2807">        boolean valueIsDeviceVisitor = false;</span>
<span class="fc bfc" id="L2808" title="All 4 branches covered.">        if ( slice.isOutsourced() &amp;&amp; !value.isOutsourced() ) {</span>
<span class="fc" id="L2809">            Device&lt;V&gt; device = slice.get( Device.class );</span>
            try {
<span class="fc" id="L2811">                device.store( value );</span>
<span class="nc" id="L2812">            } catch ( Exception e ) {</span>
<span class="nc" id="L2813">                _LOG.error( &quot;Trying to migrate target slice tensor to device failed.&quot;, e );</span>
<span class="nc" id="L2814">                throw e;</span>
<span class="fc" id="L2815">            }</span>
<span class="fc" id="L2816">            valueIsDeviceVisitor = true;</span>
        }
<span class="pc bpc" id="L2818" title="2 of 6 branches missed.">        if ( this.isEmpty() &amp;&amp; slice.isEmpty() || slice.size() != value.size() ) _become( value ); // TODO: Rethink this a little</span>
<span class="fc" id="L2819">        else Neureka.get().backend().getFunction().idy().call(  slice, value  );</span>
        try {
<span class="fc bfc" id="L2821" title="All 2 branches covered.">            if ( valueIsDeviceVisitor ) value.get( Device.class ).restore( value );</span>
<span class="nc" id="L2822">        } catch ( Exception exception ) {</span>
<span class="nc" id="L2823">            _LOG.error( &quot;Trying to migrate source tensor back to original location failed.&quot;, exception );</span>
<span class="nc" id="L2824">            throw exception;</span>
<span class="fc" id="L2825">        }</span>
<span class="fc" id="L2826">        return this;</span>
    }

    /**
     *  A tensor ought to have some way to access its underlying data array.
     *  This method simple returns an element within this data array sitting at position &quot;i&quot;.
     * @param i The position of the targeted item within the raw data array of the tensor.
     * @return The found object sitting at the specified index position.
     */
    @Override
<span class="fc" id="L2836">    public V getDataAt( int i ) { return getDevice().access( this ).readAt( i ); }</span>

    /**
     *  A tensor ought to have some way to selectively modify its underlying value array.
     *  This method simply overrides an element within this value array sitting at position &quot;i&quot;.
     * @param i The index of the value array entry which ought to be addressed.
     * @param o The object which ought to be placed at the requested position.
     * @return This very tensor in order to enable method chaining.
     */
    @Override
    public final Tsr&lt;V&gt; setValueAt( int i, V o ) {
<span class="fc" id="L2847">        _guardMod(&quot;data object&quot;);</span>
<span class="fc" id="L2848">        NDConfiguration ndc = this.getNDConf();</span>
<span class="fc" id="L2849">        _setDataAt( ndc.indexOfIndex( i ), o );</span>
<span class="fc" id="L2850">        return this;</span>
    }

    private void _setDataAt( int i, V o ) {
<span class="pc bpc" id="L2854" title="1 of 4 branches missed.">        if ( this.isVirtual() &amp;&amp; i &gt; 0 )</span>
<span class="nc" id="L2855">            throw new IllegalArgumentException(&quot;There is no data item at index &quot;+i+&quot; for this virtual tensor!&quot;);</span>

<span class="fc" id="L2857">        getDevice().access( this ).write( o ).at( i );</span>
<span class="fc" id="L2858">    }</span>

    /**
     *  This method will receive an object an try to interpret
     *  it or its contents to be set as value for this tensor.
     *  It will not necessarily replace the underlying data array object of this
     *  tensor itself, but also try to convert and copy the provided value
     *  into the data array of this tensor.
     *
     * @param value The value which may be a scalar or array and will be used to populate this tensor.
     * @return This very tensor to enable method chaining.
     */
    public final Tsr&lt;V&gt; setValue( Object value )
    {
<span class="fc" id="L2872">        LogUtil.nullArgCheck( value, &quot;value&quot;, Object.class );</span>
<span class="fc" id="L2873">        boolean success = true;</span>
<span class="fc bfc" id="L2874" title="All 2 branches covered.">        if ( Number.class.isAssignableFrom(value.getClass()) ) { // A virtual tensor!</span>
<span class="fc" id="L2875">            this.setIsVirtual( true );</span>
<span class="fc" id="L2876">            value = DataConverter.get().convert( value, this.valueClass() );</span>
<span class="fc" id="L2877">            this.getUnsafe().setDataAt( 0, (V) value );</span>
<span class="pc bpc" id="L2878" title="1 of 2 branches missed.">        } else if ( value.getClass().isArray() ) {</span>
<span class="fc bfc" id="L2879" title="All 2 branches covered.">            if ( this.isOutsourced() ) getDevice().access(this).writeFrom(value);</span>
            else {
<span class="fc bfc" id="L2881" title="All 2 branches covered.">                if ( _getData() == null ) {</span>
<span class="pc bpc" id="L2882" title="1 of 2 branches missed.">                    if      ( value instanceof float[]  ) _setDataType( DataType.of( F32.class ) );</span>
<span class="pc bpc" id="L2883" title="1 of 2 branches missed.">                    else if ( value instanceof double[] ) _setDataType( DataType.of( F64.class ) );</span>
<span class="fc" id="L2884">                    _setData( value );</span>
<span class="fc" id="L2885">                    return this;</span>
                } else {
<span class="fc" id="L2887">                    getDevice().access(this).writeFrom(value);</span>
<span class="fc" id="L2888">                    setIsVirtual(false);</span>
                }
            }
        }
<span class="nc" id="L2892">        else success = false;</span>

<span class="pc bpc" id="L2894" title="1 of 2 branches missed.">        if ( !success )</span>
<span class="nc" id="L2895">            _LOG.warn( &quot;Failed to set value of type '&quot;+value.getClass().getSimpleName()+&quot;'!&quot; );</span>

<span class="fc" id="L2897">        return this;</span>
    }

    /**
     *  This returns an unprocessed version of the underlying data of this tensor.
     *  If this tensor is outsourced (stored on a device), then the data will be loaded
     *  into an array and returned by this method.
     *  Do not expect the returned array to be actually stored within the tensor itself!
     *  Contrary to the {@link Tsr#getValue()} method, this one will
     *  return the data in an unbiased form, where for example a virtual (see {@link #isVirtual()})
     *  tensor will have this method return an array of length 1.
     *
     * @return An unbiased copy of the underlying data of this tensor.
     */
    public Object getData() {
<span class="fc" id="L2912">        _guardGet(&quot;data object&quot;);</span>
<span class="fc" id="L2913">        return _getData( true );</span>
    }

    private Object _getData( boolean clone ) {
<span class="fc" id="L2917">        Device&lt;V&gt; device = this.getDevice();</span>
<span class="fc bfc" id="L2918" title="All 2 branches covered.">        if ( device == null ) return null;</span>
<span class="fc" id="L2919">        else return device.access( this ).readAll( clone );</span>
    }

    public Object getValue() { // TODO : Make this what it is supposed to be!!! (returning a copy of the targeted data)
<span class="fc" id="L2923">        _guardGet(&quot;value object&quot;);</span>
<span class="fc bfc" id="L2924" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="fc" id="L2925">            Device&lt;V&gt; device = get( Device.class );</span>
<span class="fc bfc" id="L2926" title="All 2 branches covered.">            if ( device != null ) {</span>
<span class="pc bpc" id="L2927" title="1 of 4 branches missed.">                if ( this.getNDConf().isSimple() &amp;&amp; !this.isSlice() )</span>
<span class="fc" id="L2928">                    return device.access(this).readAll(false);</span>
                else
<span class="fc" id="L2930">                    return device.access( this.clone().setIsVirtual( false ) ).readAll(false);</span>
            }
        }
<span class="fc bfc" id="L2933" title="All 2 branches covered.">        if ( this.isVirtual() ) {</span>
<span class="fc bfc" id="L2934" title="All 2 branches covered.">            if ( _getData() == null ) return null;</span>
<span class="fc" id="L2935">            else return getDataType().actualize( _getData(), this.size() );</span>
        }
<span class="fc bfc" id="L2937" title="All 4 branches covered.">        else if ( this.getNDConf().isSimple() &amp;&amp; !this.isSlice() )</span>
<span class="fc" id="L2938">            return getData();</span>
        else
<span class="fc" id="L2940">            return this.clone()._getData();</span>
    }

    /*==================================================================================================================
    |
    |       Â§(10) : Mapping :
    |   -----------------------------------------------------
    |       ...transformation and modification...
    */

    public &lt;T&gt; Tsr&lt;T&gt; mapTo(
            Class&lt;T&gt; typeClass,
            java.util.function.Function&lt;V,T&gt; mapper
    ) {
<span class="pc bpc" id="L2954" title="1 of 2 branches missed.">        if ( this.isEmpty() )</span>
<span class="nc" id="L2955">            throw new IllegalArgumentException(&quot;Trying to map an empty tensor!&quot;);</span>
        /*
           The provided lambda cannot be executed anywhere but the CPU (Note: Maybe we should consider Aparapi here)
           This is a problem if this tensor here lives somewhere other than the JVM.
           So, therefore, we invite it back home for dinner!
         */
<span class="fc" id="L2961">        return _CPU // This little API will temporarily migrate this to the JVM.</span>
<span class="fc" id="L2962">                .borrow( (Tsr&lt;Object&gt;) this )</span>
<span class="fc" id="L2963">                .in( () -&gt; {</span>
<span class="fc" id="L2964">                    Object data = _getData();</span>
<span class="fc" id="L2965">                    DataConverter.ForTensor map = new DataConverter.ForTensor( this );</span>
<span class="pc bpc" id="L2966" title="1 of 2 branches missed.">                    if ( data == null ) {</span>
<span class="nc bnc" id="L2967" title="All 2 branches missed.">                        if ( this.isOutsourced() )</span>
<span class="nc" id="L2968">                            _LOG.error(&quot;Encountered an outsourced tensor! Only local tensors stored in RAM can be mapped.&quot;);</span>
                        else
<span class="nc" id="L2970">                            _LOG.error(&quot;Invalid tensor state encountered! Cannot map a tensor without data.&quot;);</span>
                    }
                    Object newData;
<span class="fc" id="L2973">                    String failMessage = &quot;Conversion to type &quot;+typeClass+&quot; not yet supported.&quot;;</span>
<span class="fc bfc" id="L2974" title="All 2 branches covered.">                    if ( Number.class.isAssignableFrom(typeClass) ) {</span>
                        java.util.function.Function&lt;Integer, Number&gt; access;
<span class="fc bfc" id="L2976" title="All 2 branches covered.">                        if ( this.getValueClass() == Integer.class ) {</span>
<span class="fc" id="L2977">                            int[] sourceData = (int[]) _getData();</span>
<span class="fc" id="L2978">                            access = (i -&gt; (Number) mapper.apply((V) Integer.valueOf(sourceData[i])));</span>
<span class="fc bfc" id="L2979" title="All 2 branches covered.">                        } else if (this.getValueClass() == Double.class) {</span>
<span class="fc" id="L2980">                            double[] sourceData = (double[]) _getData();</span>
<span class="fc" id="L2981">                            access = (i -&gt; (Number) mapper.apply((V) Double.valueOf(sourceData[i])));</span>
<span class="fc bfc" id="L2982" title="All 2 branches covered.">                        } else if (this.getValueClass() == Float.class) {</span>
<span class="fc" id="L2983">                            float[] sourceData = (float[]) _getData();</span>
<span class="fc" id="L2984">                            access = (i -&gt; (Number) mapper.apply((V) Float.valueOf(sourceData[i])));</span>
<span class="fc bfc" id="L2985" title="All 2 branches covered.">                        } else if (this.getValueClass() == Short.class) {</span>
<span class="fc" id="L2986">                            short[] sourceData = (short[]) _getData();</span>
<span class="fc" id="L2987">                            access = (i -&gt; (Number) mapper.apply((V) Short.valueOf(sourceData[i])));</span>
<span class="pc bpc" id="L2988" title="1 of 2 branches missed.">                        } else if (this.getValueClass() == Byte.class) {</span>
<span class="fc" id="L2989">                            byte[] sourceData = (byte[]) _getData();</span>
<span class="fc" id="L2990">                            access = (i -&gt; (Number) mapper.apply((V) Byte.valueOf(sourceData[i])));</span>
<span class="fc" id="L2991">                        } else</span>
<span class="nc" id="L2992">                            throw new IllegalArgumentException(failMessage);</span>

<span class="fc bfc" id="L2994" title="All 2 branches covered.">                        if (typeClass == Double.class) newData = map.toDoubleArray(access);</span>
<span class="fc bfc" id="L2995" title="All 2 branches covered.">                        else if ( typeClass == Integer.class ) newData = map.toIntArray(access);</span>
<span class="fc bfc" id="L2996" title="All 2 branches covered.">                        else if ( typeClass == Long.class    ) newData = map.toLongArray(access);</span>
<span class="fc bfc" id="L2997" title="All 2 branches covered.">                        else if ( typeClass == Byte.class    ) newData = map.toByteArray(access);</span>
<span class="fc bfc" id="L2998" title="All 2 branches covered.">                        else if ( typeClass == Float.class   ) newData = map.toFloatArray(access);</span>
<span class="pc bpc" id="L2999" title="1 of 2 branches missed.">                        else if ( typeClass == Short.class   ) newData = map.toShortArray(access);</span>
                        else
<span class="nc" id="L3001">                            throw new IllegalArgumentException(failMessage);</span>
<span class="fc" id="L3002">                    } else {</span>
<span class="fc" id="L3003">                        java.util.function.Function&lt;Integer, Object&gt; access = null;</span>
<span class="fc bfc" id="L3004" title="All 2 branches covered.">                        if ( this.getValueClass() == Integer.class ) {</span>
<span class="fc" id="L3005">                            int[] sourceData = (int[]) _getData();</span>
<span class="fc" id="L3006">                            access = (i -&gt; mapper.apply((V) Integer.valueOf(sourceData[i])));</span>
<span class="fc bfc" id="L3007" title="All 2 branches covered.">                        } else if ( this.getValueClass() == Double.class ) {</span>
<span class="fc" id="L3008">                            double[] sourceData = (double[]) _getData();</span>
<span class="fc" id="L3009">                            access = (i -&gt; mapper.apply((V) Double.valueOf(sourceData[i])));</span>
<span class="fc bfc" id="L3010" title="All 2 branches covered.">                        } else if ( this.getValueClass() == Float.class ) {</span>
<span class="fc" id="L3011">                            float[] sourceData = (float[]) _getData();</span>
<span class="fc" id="L3012">                            access = (i -&gt; mapper.apply((V) Float.valueOf(sourceData[i])));</span>
<span class="fc bfc" id="L3013" title="All 2 branches covered.">                        } else if ( this.getValueClass() == Short.class ) {</span>
<span class="fc" id="L3014">                            short[] sourceData = (short[]) _getData();</span>
<span class="fc" id="L3015">                            access = (i -&gt; mapper.apply((V) Short.valueOf(sourceData[i])));</span>
<span class="pc bpc" id="L3016" title="1 of 2 branches missed.">                        } else if ( this.getValueClass() == Byte.class ) {</span>
<span class="fc" id="L3017">                            byte[] sourceData = (byte[]) _getData();</span>
<span class="fc" id="L3018">                            access = (i -&gt; mapper.apply((V) Byte.valueOf(sourceData[i])));</span>
<span class="fc" id="L3019">                        } else</span>
<span class="nc" id="L3020">                            throw new IllegalArgumentException(failMessage);</span>

<span class="fc" id="L3022">                        newData = map.toObjectArray(access);</span>
                    }
<span class="fc" id="L3024">                    return Tsr.of( typeClass, this.getNDConf().shape(), newData );</span>
                });
    }

    /**
     *  Turns this tensor into a {@link BufferedImage} based on the provided
     *  {@link ImageType} formatting choice.
     *
     * @param type The type of format used to create the buffered image.
     * @return A {@link BufferedImage} populated with the contents of this tensor.
     */
    public BufferedImage asImage( ImageType type )
    {
<span class="pc bpc" id="L3037" title="1 of 4 branches missed.">        switch ( type.bufferType )</span>
        {
            case BufferedImage.TYPE_3BYTE_BGR: {
<span class="fc" id="L3040">                _checkRankForImageConversion(type, Number.class, 0, 0, 3);</span>
                // We expect a tensor of shape (height x width x 3)!
<span class="fc" id="L3042">                BufferedImage image = new BufferedImage(shape(1), shape(0), type.bufferType);</span>
<span class="fc" id="L3043">                byte[] data = DataConverter.get().convert( _getData(), byte[].class);</span>
<span class="fc" id="L3044">                _writeImgData(new DataBufferByte(data, data.length), image);</span>
<span class="fc" id="L3045">                return image;</span>
            }
            case BufferedImage.TYPE_4BYTE_ABGR:
            case BufferedImage.TYPE_4BYTE_ABGR_PRE:
            {
<span class="fc" id="L3050">                _checkRankForImageConversion(type, Number.class, 0, 0, 4);</span>
<span class="fc" id="L3051">                BufferedImage image = new BufferedImage(shape(1), shape(0), type.bufferType);</span>
<span class="fc" id="L3052">                byte[] data = DataConverter.get().convert( _getData(), byte[].class);</span>
<span class="fc" id="L3053">                _writeImgData(new DataBufferByte(data, data.length), image);</span>
<span class="fc" id="L3054">                return image;</span>
            }
            case BufferedImage.TYPE_INT_ARGB: {
<span class="fc" id="L3057">                _checkRankForImageConversion(type, Number.class, 0, 0, 1);</span>
<span class="fc" id="L3058">                BufferedImage image = new BufferedImage(shape(1), shape(0), type.bufferType);</span>
<span class="fc" id="L3059">                int[] data = DataConverter.get().convert( _getData(), int[].class);</span>
<span class="fc" id="L3060">                _writeImgData(new DataBufferInt(data, data.length), image);</span>
<span class="fc" id="L3061">                return image;</span>
            }
        }
<span class="nc" id="L3064">        throw new IllegalArgumentException(&quot;Image type '&quot;+type+&quot;' not supported.&quot;);</span>
    }

    private void _checkRankForImageConversion( ImageType type, Class&lt;?&gt; dataType, int... pattern ) {
<span class="fc" id="L3068">        int rank = pattern.length; // The expected rank!</span>
<span class="fc bfc" id="L3069" title="All 2 branches covered.">        if ( this.rank() != rank ) {</span>
<span class="fc" id="L3070">            throw new IllegalArgumentException(</span>
<span class="fc" id="L3071">                    &quot;Cannot create image of type '&quot; + type.name() + &quot;' from tensor of rank &quot; + this.rank() + &quot;. &quot; +</span>
                    &quot;Expected to receive tensor of rank &quot; + rank + &quot;.&quot;
                );
        }
<span class="fc bfc" id="L3075" title="All 2 branches covered.">        for ( int i = 0; i &lt; pattern.length; i++ ) {</span>
<span class="fc" id="L3076">            int axisSize = pattern[ i ]; // The expected axis size!</span>
<span class="fc bfc" id="L3077" title="All 2 branches covered.">            if ( axisSize &gt; 0 ) {</span>
<span class="fc bfc" id="L3078" title="All 2 branches covered.">                if ( axisSize != this.shape(i) ) {</span>
<span class="fc" id="L3079">                    String shape = this.shape().stream().map( a -&gt; a.toString() ).collect(Collectors.joining(&quot;x&quot;));</span>
<span class="fc" id="L3080">                    throw new IllegalArgumentException(</span>
<span class="fc" id="L3081">                        &quot;Cannot create image of type '&quot; + type.name() + &quot;' from tensor with shape (&quot; + shape + &quot;). &quot; +</span>
                        &quot;Axis &quot; + i + &quot; is expected to be of size &quot; + axisSize + &quot;.&quot;
                    );
                }
            }
        }
<span class="fc bfc" id="L3087" title="All 2 branches covered.">        if ( !dataType.isAssignableFrom(this.getValueClass()) )</span>
<span class="fc" id="L3088">            throw new IllegalArgumentException(</span>
<span class="fc" id="L3089">                    &quot;Cannot create image of type '&quot; + type.name() + &quot;' from tensor of type '&quot; + this.getValueClass().getSimpleName() + &quot;. &quot; +</span>
<span class="fc" id="L3090">                    &quot;Expected to receive a tensor whose type is at least a sub-type of '&quot; + dataType.getSimpleName() + &quot;'.&quot;</span>
            );
<span class="fc" id="L3092">    }</span>

    private static void _writeImgData(DataBuffer data, BufferedImage target ) {
<span class="fc" id="L3095">        target.setData(</span>
<span class="fc" id="L3096">            Raster.createRaster( target.getSampleModel(), data, new Point() )</span>
        );
<span class="fc" id="L3098">    }</span>

    /**
     *  This method takes the provided {@link Tsr} instance and adds its
     *  contents to the contents of the {@link Tsr} which is set as gradient of this very {@link Tsr}.
     *
     * @param error The error gradient which ought to be added to the gradient of this tensor.
     * @return This very tensor instance to enable method chaining.
     */
    public final Tsr&lt;V&gt; addToGradient( Tsr&lt;V&gt; error ) {
<span class="fc" id="L3108">        _guardSet(&quot;gradient&quot;);</span>
<span class="fc" id="L3109">        if (</span>
<span class="fc bfc" id="L3110" title="All 2 branches covered.">                !forComponent(</span>
                    Tsr.class,
                        gradient -&gt;
<span class="fc" id="L3113">                        this.set(</span>
<span class="fc" id="L3114">                            MemUtil.keep( gradient, error, () -&gt;</span>
<span class="fc" id="L3115">                                Neureka.get()</span>
<span class="fc" id="L3116">                                        .backend()</span>
<span class="fc" id="L3117">                                        .getFunction()</span>
<span class="fc" id="L3118">                                        .plusAssign()</span>
<span class="fc" id="L3119">                                        .call(gradient, error)</span>
                            )
                        )
                )
<span class="fc" id="L3123">        ) set( error ).forComponent( Device.class, device -&gt; {</span>
            try {
<span class="fc" id="L3125">                device.store( error ) ;</span>
<span class="nc" id="L3126">            } catch ( Exception exception ) {</span>
<span class="nc" id="L3127">                _LOG.error( &quot;Failed trying to store a given error to a device for gradient accumulation.&quot;, exception );</span>
<span class="nc" id="L3128">                throw exception;</span>
<span class="fc" id="L3129">            }</span>
<span class="fc" id="L3130">        });</span>
<span class="fc" id="L3131">        return this;</span>
    }

    /**
     * @param typeClass The class which is the target of the type conversion.
     * @param &lt;T&gt; The type parameter of the type that will be returned.
     * @return An instance of the supplied type class.
     */
    public &lt;T&gt; T asType( Class&lt;T&gt; typeClass )
    {
<span class="fc" id="L3141">        LogUtil.nullArgCheck( typeClass, &quot;typeClass&quot;, Class.class );</span>
<span class="fc bfc" id="L3142" title="All 2 branches covered.">        if ( typeClass == Tsr.class ) return (T) this;</span>
<span class="pc bpc" id="L3143" title="1 of 4 branches missed.">        if ( Number.class.isAssignableFrom(this.valueClass()) &amp;&amp; Number.class.isAssignableFrom(typeClass) ) {</span>
<span class="fc" id="L3144">            DataConverter converter = DataConverter.get();</span>
<span class="fc" id="L3145">            return converter.convert( mean().at(0).get(), typeClass );</span>
        }
<span class="fc bfc" id="L3147" title="All 2 branches covered.">        if ( typeClass == String.class )</span>
<span class="fc" id="L3148">            return (T) this.toString();</span>

<span class="fc" id="L3150">        throw new IllegalArgumentException(&quot;Failed to convert this tensor of type '&quot;+getDataType()+&quot;' to '&quot;+typeClass+&quot;'!&quot;);</span>
    }

    /**
     *  This method is an inline operation which changes the underlying data of this tensor.
     *  It converts the data types of the elements of this tensor to the specified type!&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;WARNING : The use of this method is discouraged for the following reasons: &lt;/b&gt;&lt;br&gt;
     *  &lt;br&gt;
     *  1. Inline operations are inherently error-prone for most use cases. &lt;br&gt;
     *  2. This inline operation in particular has no safety net,
     *     meaning that there is no implementation of version mismatch detection
     *     like there is for those operations present in the standard operation backend...
     *     No exceptions will be thrown during backpropagation! &lt;br&gt;
     *  3. This method has not yet been implemented to also handle instances which
     *     are slices of parent tensors!
     *     Therefore, there might be unexpected performance penalties or side effects
     *     associated with this method.&lt;br&gt;
     *     &lt;br&gt;
     *
     * @param typeClass The target type class for elements of this tensor.
     * @param &lt;T&gt; The type parameter for the returned tensor.
     * @return The same tensor instance whose data has been converted to hold a different type.
     */
    private &lt;T&gt; Tsr&lt;T&gt; _toType(Class&lt;T&gt; typeClass )
    {
<span class="fc bfc" id="L3176" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="fc" id="L3177">            _setDataType( DataType.of( typeClass ) );</span>
<span class="fc" id="L3178">            return (Tsr&lt;T&gt;) this;</span>
        }
        else {
<span class="fc" id="L3181">            Object newData = _convertedDataOfType( typeClass );</span>
<span class="fc" id="L3182">            _setData( null );</span>
<span class="fc" id="L3183">            _setDataType( DataType.of( typeClass ) );</span>
<span class="fc" id="L3184">            _setData( newData );</span>
        }
<span class="pc" id="L3186">        forComponent( Tsr.class, gradient -&gt; gradient._toType( typeClass ) );</span>
<span class="fc" id="L3187">        return (Tsr&lt;T&gt;) this;</span>
    }

    public &lt;A&gt; A getValueAs( Class&lt;A&gt; arrayTypeClass ) {
<span class="fc" id="L3191">        return DataConverter.get().convert( getValue(), arrayTypeClass );</span>
    }

    public &lt;A&gt; A getDataAs( Class&lt;A&gt; arrayTypeClass ) {
<span class="fc" id="L3195">        return DataConverter.get().convert( getData(), arrayTypeClass );</span>
    }

<span class="fc" id="L3198">    public String toString( String mode ) { return _toString( mode ); }</span>

    public String toString( TsrStringSettings config ) {
<span class="fc bfc" id="L3201" title="All 2 branches covered.">        if ( this.isDeleted() ) return &quot;deleted&quot;;</span>
<span class="pc bpc" id="L3202" title="1 of 2 branches missed.">        else if ( this.isEmpty() ) return &quot;empty&quot;;</span>
<span class="pc bpc" id="L3203" title="1 of 2 branches missed.">        else if ( this.isUndefined() ) return &quot;undefined&quot;;</span>
<span class="fc" id="L3204">        return TsrAsString.representing( this ).withConfig( config ).toString();</span>
    }

    /**
     *  This allows you to provide a lambda to configure how this tensor should be
     *  converted to {@link String} instances.
     *  The provided {@link Consumer} will receive a {@link TsrStringSettings} instance
     *  which allows you to change various settings with the help of method chaining.
     *
     * @param config A consumer of the {@link TsrStringSettings} ready to be configured.
     * @return The {@link String} representation of this tensor.
     */
    public String toString( Consumer&lt;TsrStringSettings&gt; config ) {
<span class="fc bfc" id="L3217" title="All 2 branches covered.">        if ( this.isDeleted() ) return &quot;deleted&quot;;</span>
<span class="fc" id="L3218">        TsrStringSettings defaults = Neureka.get().settings().view().getTensorSettings().clone();</span>
<span class="fc" id="L3219">        config.accept(defaults);</span>
<span class="fc" id="L3220">        return TsrAsString.representing( this ).withConfig( defaults ).toString();</span>
    }

    private String _toString( String config )
    {
<span class="pc bpc" id="L3225" title="1 of 2 branches missed.">        if ( this.isDeleted() ) return &quot;deleted&quot;;</span>
<span class="pc bpc" id="L3226" title="1 of 2 branches missed.">        else if ( this.isEmpty() ) return &quot;empty&quot;;</span>
<span class="pc bpc" id="L3227" title="1 of 2 branches missed.">        else if ( this.isUndefined() ) return &quot;undefined&quot;;</span>
<span class="fc" id="L3228">        return TsrAsString.representing( this ).withConfig( config ).toString();</span>
    }

    @Override
    public String toString()
    {
<span class="fc bfc" id="L3234" title="All 2 branches covered.">        if ( this.isDeleted() ) return &quot;deleted&quot;;</span>
<span class="pc bpc" id="L3235" title="1 of 2 branches missed.">        else if ( this.isEmpty() ) return &quot;empty&quot;;</span>
<span class="pc bpc" id="L3236" title="1 of 2 branches missed.">        else if ( this.isUndefined() ) return &quot;undefined&quot;;</span>
<span class="fc" id="L3237">        return TsrAsString.representing( this ).byDefaults().toString();</span>
    }

    /**
     *  The version number is tracking how often this tensor has been mutated.
     *  This is especially useful for checking the correcting of autp-grad!
     */
<span class="fc" id="L3244">    public final int getVersion() { return _version; }</span>

    /**
     *  Use this factory method to instantiate a new tensor with the same data type, shape
     *  and memory location ({@link Device} instance) as the provided template tensor.
     *
     * @param template The template tensor whose type, shape and location should be taken to construct a new tensor.
     * @param &lt;V&gt; The type parameter defining the value type of the provided as well as returned tensor.
     * @return A new {@link Tsr} instance with the same data type, shape and memory location as the provided template.
     */
    public static &lt;V&gt; IterByOrIterFromOrAll&lt;V&gt; like( Tsr&lt;V&gt; template ) {
<span class="nc" id="L3255">        return Tsr.of( template.getDataType().getValueTypeClass() )</span>
<span class="nc" id="L3256">                    .on( template.getDevice() )</span>
<span class="nc" id="L3257">                    .withShape( template.getNDConf().shape() );</span>
    }

    /**
     *  This factory method produces a randomly populated tensor of the provided
     *  type and shape using a hard coded default seed.
     *  If the provided type class is representing a
     *  floating point number type (like {@link Double} or {@link Float}) then the random numbers will
     *  be gaussian (&quot;normally&quot;) distributed values with mean {@code 0.0} and standard
     *  deviation {@code 1.0}.
     *
     * @param valueTypeClass The type class of the values stored by the returned tensor.
     * @param shape The shape of the tensor produced by this factory method.
     * @param &lt;V&gt; The type parameter of the values stored by the returned tensor.
     * @return A randomly filled tensor of the provided type.
     */
    public static &lt;V&gt; Tsr&lt;V&gt; ofRandom( Class&lt;V&gt; valueTypeClass, int... shape ) {
<span class="fc" id="L3274">        long seed = 8701252152903546L;</span>
<span class="fc" id="L3275">        return Tsr.of( valueTypeClass )</span>
<span class="fc" id="L3276">                    .withShape( shape )</span>
<span class="fc" id="L3277">                    .andSeed( seed );</span>
    }

    /**
     *  This method exposes an API for mutating the state of this tensor.
     *  The usage of methods exposed by this API is generally discouraged
     *  because the exposed state can easily lead to broken tensors and exceptions...&lt;br&gt;
     *  &lt;br&gt;
     *  Use this in performance critical situations only.
     */
    @Override
    public Unsafe&lt;V&gt; getUnsafe() {
<span class="fc" id="L3289">        _guardGet(&quot;unsafe API&quot;);</span>
<span class="fc" id="L3290">        return new Unsafe&lt;V&gt;() {</span>
            @Override
<span class="fc" id="L3292">            public Tsr&lt;V&gt; setNDConf(NDConfiguration configuration ) { Tsr.this._setNDConf( configuration ); return Tsr.this; }</span>
            @Override
<span class="fc" id="L3294">            public &lt;V&gt; Tsr&lt;V&gt; toType( Class&lt;V&gt; typeClass ) { return Tsr.this._toType( typeClass ); }</span>
            @Override
<span class="fc" id="L3296">            public &lt;V&gt; Tsr&lt;V&gt; setDataType( DataType&lt;V&gt; dataType ) { return (Tsr&lt;V&gt;) Tsr.this._setDataType(dataType); }</span>
            @Override
<span class="fc" id="L3298">            public Tsr&lt;V&gt; toLayout(NDConfiguration.Layout layout) { Tsr.this._toLayout( layout ); return Tsr.this; }</span>
            @Override
            public Tsr&lt;V&gt; incrementVersion(ExecutionCall&lt;?&gt; call ) {
<span class="fc" id="L3301">                _incrementVersionBecauseOf( call );</span>
<span class="fc" id="L3302">                return Tsr.this;</span>
            }
            @Override
            public Tsr&lt;V&gt; setIsIntermediate(boolean isIntermediate ) {
<span class="fc" id="L3306">                _setIsIntermediate( isIntermediate );</span>
<span class="fc" id="L3307">                return Tsr.this;</span>
            }
<span class="fc" id="L3309">            @Override public Tsr&lt;V&gt; delete() { return Tsr.this._delete(); }</span>
<span class="fc" id="L3310">            @Override public Object getData() { return _getData(); }</span>
            @Override
            public &lt;A&gt; A getDataAs( Class&lt;A&gt; arrayTypeClass ) {
<span class="fc" id="L3313">                return DataConverter.get().convert( _getData(false), arrayTypeClass );</span>
            }
            @Override
            public Tsr&lt;V&gt; setDataAt( int i, V o ) {
<span class="fc" id="L3317">                _guardMod(&quot;data object&quot;);</span>
<span class="fc" id="L3318">                _setDataAt( i, o );</span>
<span class="fc" id="L3319">                return Tsr.this;</span>
            }
        };
    }

<span class="fc" id="L3324">    public enum ImageType</span>
    {
<span class="fc" id="L3326">        RGB_1INT(1, UI32.class, 1),</span>
<span class="fc" id="L3327">        ARGB_1INT(2, UI32.class, 1),</span>
<span class="fc" id="L3328">        ARGB_PRE_1INT(3, UI32.class, 1),</span>
<span class="fc" id="L3329">        BGR_1INT(4, UI32.class, 1),</span>
<span class="fc" id="L3330">        BGR_3BYTE(5, UI8.class, 3),</span>
<span class="fc" id="L3331">        ABGR_4BYTE(6, UI8.class, 4),</span>
<span class="fc" id="L3332">        ABGR_PRE_4BYTE(7, UI8.class, 4),</span>
<span class="fc" id="L3333">        RGB_565_USHORT(8, UI16.class, 1),</span>
<span class="fc" id="L3334">        RGB_555_USHORT(9, UI16.class, 1),</span>
<span class="fc" id="L3335">        GRAY_BYTE(0, UI8.class, 1),</span>
<span class="fc" id="L3336">        GRAY_USHORT(1, UI16.class, 1);</span>

        public final int bufferType;
        public final DataType&lt;?&gt; dataType;
        public final int numberOfChannels;

<span class="fc" id="L3342">        ImageType( int bufferType, Class&lt;?&gt; valueTypeClass, int numberOfChannels ) {</span>
<span class="fc" id="L3343">            this.bufferType = bufferType;</span>
<span class="fc" id="L3344">            this.dataType = DataType.of( valueTypeClass );</span>
<span class="fc" id="L3345">            this.numberOfChannels = numberOfChannels;</span>
<span class="fc" id="L3346">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>