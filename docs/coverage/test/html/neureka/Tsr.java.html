<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tsr.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka</a> &gt; <span class="el_source">Tsr.java</span></div><h1>Tsr.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 __________
 \__    ___\
    |  |____ _ __
    | /  ___/ '___\
    | \___  \ |
     \/_____/_|         A long yet shallow class.

    This is the the core work-horse class of Neureka. The 'Tsr' class!
    It is a three-letter abbreviation of the word &quot;tensor&quot;!

------------------------------------------------------------------------------------------------------------------------

   'Any fool can write code that a computer can understand.
    Good programmers write code that humans can understand.'
    â€“ Martin Fowler

    Use the following as search keys :)

    $(1) : CONSTRUCTION
        $(1.0) : GENERIC CONSTRUCTION
        $(1.1) : SHAPE LIST BASED CONSTRUCTION
        $(1.2) : SHAPE ARRAY BASED CONSTRUCTION
        Â§(1.3) : LAMBDA BASED CONSTRUCTION
        Â§(1.4) : FUNCTION BASED CONSTRUCTION

    Â§(2) : FLAGS
        Â§(2.0) : GRADIENT REQUIREMENT
        Â§(2.1) : SOURCE LOCATION (DEVICE)
        Â§(2.2) : VIRTUAL / ACTUAL
        Â§(2.3) : GRADIENT APPLY REQUIREMENT

    Â§(3) : COMPONENT SYSTEM
        Â§(3.0) : SETTING / REJECTING
        Â§(3.1) : REMOVING / REJECTING
        Â§(3.2) : UPDATING

    Â§(4) : PROPERTIES
        $(4.0) : HIGH LEVEL PROPERTIES
        Â§(4.1) : COMPONENT PROPERTIES
        Â§(4.2) : INNER PROPERTIES

    Â§(5) : OBJECT STATE MODIFICATION

    Â§(6) : ND-ITERATOR LOGIC

    Â§(7) : COMPONENT SPECIFIC
        Â§(7.0) : AUTO-GRAD
        Â§(7.1) : FRAMING

    Â§(8) : (OVERLOADABLE) OPERATORS &amp; OPERATIONS
        Â§(8.0) : OPERATORS
        Â§(8.1) : OPERATIONS

    Â§(9) : SLICING, INDEXING &amp; INJECTING
        Â§(9.0) : SLICING
        Â§(9.1) : INJECTING
*/

package neureka;

import groovy.lang.IntRange;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;
import neureka.backend.api.ExecutionCall;
import neureka.backend.standard.operations.other.Reshape;
import neureka.devices.opencl.OpenCLDevice;
import neureka.dtype.DataType;
import neureka.dtype.custom.*;
import neureka.ndim.AbstractNDArray;
import neureka.devices.host.HostCPU;
import neureka.devices.Device;
import neureka.framing.IndexAlias;
import neureka.framing.Relation;
import neureka.calculus.Function;
import neureka.calculus.assembly.FunctionBuilder;
import neureka.autograd.GraphNode;
import neureka.autograd.JITProp;
import neureka.ndim.config.AbstractNDC;
import neureka.ndim.config.NDConfiguration;
import neureka.ndim.iterators.NDIterator;
import neureka.ndim.config.types.virtual.VirtualNDConfiguration;
import neureka.optimization.Optimizer;
import neureka.utility.DataConverter;
import neureka.utility.TsrAsString;
import org.jetbrains.annotations.NotNull;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;


/**
 *  This class name &quot;Tsr&quot; is a 3 letter abbreviation of the term &quot;tensor&quot;, a mathematical concept.
 *  A tensor is a type of multidimensional data-structure with certain transformation properties.
 *  Technically however, it is mostly a simple container / data-structure which can house data indexed by N dimensions.
 *  Therefore it is often also described as an nd-array.
 *  Elements of a tensor are also mostly numeric.&lt;br&gt;
 *  This means that: &lt;br&gt;
 *  &lt;i&gt;&lt;b&gt;...a tensor of rank 0 is a scalar, a tensor of rank 1 is a vector and a tensor of rank 2 is a matrix, etc...&lt;/b&gt;&lt;/i&gt;
 *  &lt;br&gt;&lt;br&gt;
 *  Consequently, tensors are a perfect fit for applying various operations on them.
 *  Such operations might be simple elementwise operations or more complex linear operations like
 *  the dot-product, matrix- or even tensor multiplications. &lt;br&gt;
 *  &lt;br&gt;
 * @param &lt;ValType&gt; The type parameter for the individual value items within this tensor.
 */
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">@Accessors( prefix = {&quot;_&quot;} )</span>
public class Tsr&lt;ValType&gt; extends AbstractNDArray&lt;Tsr&lt;ValType&gt;, ValType&gt; implements Component&lt;Tsr&lt;ValType&gt;&gt;
{
    static {
<span class="fc" id="L139">        _CPU = HostCPU.instance();</span>
<span class="fc" id="L140">        _LOG = LoggerFactory.getLogger( Tsr.class );</span>
<span class="fc" id="L141">    }</span>

    /**
     *  The default device is an instance of the &quot;HostCPU&quot; class. &lt;br&gt;
     *  This field is a reference to this default device implementation.
     */
    private static final Device&lt;Number&gt; _CPU;

    /**
     *  This field contains multiple flags.
     *  The bits of this integer are used to encode various states which a tensor can have.
     *  These bits are flipped by bitmasks which are defined below.
     */
<span class="pc" id="L154">    private int _flags = 0;</span>

    /**
     *  The following fields are bit masks used to store true / false values
     *  in a targeted bit inside the &quot;_flags&quot; variable.
     */
    private static final int RQS_GRADIENT_MASK = 1;
    private static final int IS_OUTSOURCED_MASK = 2;
    private static final int IS_VIRTUAL_MASK = 4;
    private static final int GRADIENT_APPLY_RQD_MASK = 8;

    /**
     *  The version of the data ( _data ) stored within this tensor.
     *  It gets incremented every time an inline operation occurs!
     *  GraphNode instances tied to this tensor (as component) store
     *  a reference version which is a copy of this field.
     *  If this version changes, despite there being a GraphNode which might
     *  perform auto-differentiation at some point, then an exception will be thrown for debugging.
     *  &lt;br&gt;
     *  The getter returns the version of the data (_data) stored within this tensor.
     */
<span class="pc" id="L175">    @Getter</span>
    private int _version = 0;


    /*==================================================================================================================
    |
    |       Â§(1) : CONSTRUCTION
    |   ---------------------------
    */
    /*
        -------------------------------------------
            Â§(1.0) : GENERIC CONSTRUCTION
        --------------------------------------------
    */

<span class="fc" id="L190">    public Tsr() {}</span>

    public Tsr( Object... args )
<span class="fc" id="L193">    {</span>
<span class="fc" id="L194">        _construct( args );</span>
<span class="fc" id="L195">    }</span>

    private void _construct( Object[] args )
    {
<span class="pc bpc" id="L199" title="2 of 4 branches missed.">        if ( args == null || args.length == 0 ) return;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if ( args.length == 1 ) {</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            if ( args[ 0 ] instanceof Object[] ) {</span>
<span class="nc" id="L202">                _construct( (Object[]) args[ 0 ] );</span>
<span class="nc" id="L203">                return;</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">            } else if ( args[ 0 ] instanceof BigDecimal ) {</span>
<span class="fc" id="L205">                _construct( new int[]{ 1 }, ( (BigDecimal) args[ 0 ] ).doubleValue());</span>
<span class="fc" id="L206">                return;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            } else if ( args[ 0 ] instanceof Integer ) {</span>
<span class="fc" id="L208">                _construct( new int[]{ 1 }, ( (Integer) args[ 0 ] ).doubleValue() );</span>
<span class="fc" id="L209">                return;</span>
            } else {
<span class="fc" id="L211">                String message = &quot;Cannot create tensor from argument of type '&quot; + args[ 0 ].getClass().getName() + &quot;'!&quot;;</span>
<span class="fc" id="L212">                _LOG.error( message );</span>
<span class="fc" id="L213">                throw new IllegalArgumentException( message );</span>
            }
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        args[ 0 ] = ( args[ 0 ] instanceof ArrayList ) ? ( (ArrayList) args[ 0 ] ).toArray() : args[ 0 ];</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        args[ 1 ] = ( args[ 1 ] instanceof ArrayList ) ? ( (ArrayList) args[ 1 ] ).toArray() : args[ 1 ];</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if ( args[ 0 ] instanceof Object[] ) {</span>
<span class="pc bpc" id="L219" title="3 of 4 branches missed.">            if ( ( (Object[]) args[ 0 ] )[ 0 ] instanceof Integer || ((Object[])args[ 0 ])[ 0 ] instanceof Double) {</span>
<span class="fc" id="L220">                args[ 0 ] = _intArray( (Object[]) args[ 0 ] );</span>
            }
        }
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if ( args[ 1 ] instanceof Object[] ) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if ( ((Object[]) args[ 1 ] )[ 0 ] instanceof Integer ) args[ 1 ] = _doubleArray( (Object[]) args[ 1 ] );</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            else if ( ( ( Object[] ) args[ 1 ] )[ 0 ] instanceof BigDecimal ) args[ 1 ] = _doubleArray( (Object[]) args[ 1 ] );</span>
        }
        //CASES:
<span class="fc bfc" id="L228" title="All 2 branches covered.">        if ( args[ 0 ] instanceof int[] ) {</span>
<span class="fc bfc" id="L229" title="All 4 branches covered.">            if ( args[ 1 ] instanceof Double || args[ 1 ] instanceof Integer ) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                args[ 1 ] = ( args[ 1 ] instanceof Integer ) ? ( (Integer) args[ 1 ] ).doubleValue() : args[ 1 ];</span>
<span class="fc" id="L231">                _construct( (int[]) args[ 0 ], (Double) args[ 1 ] );</span>
<span class="fc" id="L232">                return;</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            } else if ( args[ 1 ] instanceof double[] ) {</span>
<span class="nc" id="L234">                _constructForDoubles( (int[]) args[ 0 ], (double[]) args[ 1 ] );</span>
<span class="nc" id="L235">                return;</span>
            } else {
<span class="fc" id="L237">                this.setDataType( DataType.of( args[1].getClass() ) );</span>
<span class="fc" id="L238">                _construct( (int[]) args[0], true, true );</span>
<span class="fc" id="L239">                ((Object[])getData())[0] = args[1];</span>
<span class="fc" id="L240">                return;</span>
            }
        }
 
        /* EXPRESSION BASED CONSTRUCTION: 
            The following allows the creation of tensors based on passing an expression
            alongside input tensors to the constructor.
            An example would be:
            
                Tsr&lt;?&gt; t = new Tsr( &quot;tanh(&quot;, x, &quot;) * 7 ^&quot;, y );  
        */
<span class="fc" id="L251">        boolean containsString = false;</span>
<span class="fc" id="L252">        int numberOfTensors = 0;</span>
<span class="fc" id="L253">        ArrayList&lt;Tsr&lt;ValType&gt;&gt; tsrList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        for ( Object o : args ) {</span>
<span class="fc bfc" id="L255" title="All 4 branches covered.">            containsString = ( o instanceof String ) || containsString;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if ( o instanceof Tsr ) {</span>
<span class="fc" id="L257">                tsrList.add( (Tsr&lt;ValType&gt;) o );</span>
<span class="fc" id="L258">                numberOfTensors++;</span>
            }
        }
<span class="fc" id="L261">        boolean doAD = true;</span>
<span class="fc" id="L262">        Tsr&lt;?&gt;[] tensors = new Tsr[ numberOfTensors ];</span>
<span class="fc" id="L263">        StringBuilder f = new StringBuilder();</span>
<span class="fc" id="L264">        int ti = 0;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">        for ( Object o : args ) {</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">            if ( tsrList.contains( o ) ) {</span>
<span class="fc" id="L267">                tensors[ ti ] = ( (Tsr&lt;?&gt;) o );</span>
<span class="fc" id="L268">                f.append( &quot;I[&quot; ).append( ti ).append( &quot;]&quot; );</span>
<span class="fc" id="L269">                ti++;</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">            } else if ( o instanceof  String ) f.append( (String) o );</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">            else if ( o instanceof  Boolean ) doAD = (Boolean) o;</span>
        }
<span class="fc" id="L273">        _construct( tensors, f.toString(), doAD );</span>
<span class="fc" id="L274">    }</span>


    /*
        -------------------------------------------
            Â§(1.1) : SHAPE LIST BASED CONSTRUCTION
        --------------------------------------------
    */

<span class="fc" id="L283">    public Tsr( List&lt;Integer&gt; arg1, Object arg2 ) {</span>
<span class="fc" id="L284">        _construct( new Object[]{ arg1, arg2 } );</span>
<span class="fc" id="L285">    }</span>

    public Tsr( List&lt;?&gt; arg1, String arg2 )
<span class="fc" id="L288">    {</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        Predicate&lt;Class&lt;?&gt;&gt; isType = c -&gt; arg1.stream().allMatch( e -&gt; e.getClass() == c );</span>

<span class="fc bfc" id="L291" title="All 2 branches covered.">        if ( isType.test( Integer.class ) ) {</span>
<span class="fc" id="L292">            List&lt;Integer&gt; shape = (List&lt;Integer&gt;) arg1;</span>
<span class="fc" id="L293">            int[] shp = new int[ shape.size() ];</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">            for ( int i=0; i &lt; shp.length; i++ ) shp[ i ] = shape.get( i );</span>
<span class="fc" id="L295">            _construct( shp, arg2 );</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        } else if ( isType.test( Tsr.class ) ) {</span>
<span class="fc" id="L297">            _construct( arg1.toArray( new Tsr[ 0 ] ), arg2, true );</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        } else if ( arg1 != null ) {</span>
<span class="nc" id="L299">            _construct(</span>
<span class="nc" id="L300">                    ( (List&lt;Object&gt;) arg1 ).stream().map( Tsr::new ).toArray( Tsr[]::new ),</span>
                    arg2,
                    true
            );
        }
<span class="fc" id="L305">    }</span>

    public Tsr( List&lt;Integer&gt; shape, List&lt;ValType&gt; range )
<span class="fc" id="L308">    {</span>
        // Nested Groovy list should be unpacked:
<span class="pc bpc" id="L310" title="1 of 4 branches missed.">        if ( range.size() == 1 &amp;&amp; range.get( 0 ) instanceof IntRange ) range = (List&lt;ValType&gt;) range.get( 0 );</span>
<span class="fc" id="L311">        _constructForRange(</span>
<span class="fc" id="L312">                shape.stream().mapToInt( e -&gt; e ).toArray(),</span>
<span class="fc" id="L313">                DataType.of( F64.class ),</span>
<span class="fc" id="L314">                (ValType[]) range.toArray()</span>
        );
<span class="fc" id="L316">    }</span>

    public Tsr( int[] shape, List&lt;ValType&gt; range )
<span class="fc" id="L319">    {</span>
        // Nested Groovy list should be unpacked:
<span class="pc bpc" id="L321" title="3 of 4 branches missed.">        if ( range.size() == 1 &amp;&amp; range.get( 0 ) instanceof IntRange ) range = (List&lt;ValType&gt;) range.get( 0 );</span>
<span class="fc" id="L322">        _constructForRange(</span>
                shape,
<span class="fc" id="L324">                DataType.of( F64.class ),</span>
<span class="fc" id="L325">                (ValType[]) range.toArray()</span>
        );
<span class="fc" id="L327">    }</span>

    private void _constructForRange( int[] shape, DataType&lt;?&gt; dataType, ValType[] range )
    {
<span class="pc bpc" id="L331" title="1 of 4 branches missed.">        if ( range.length != 0 &amp;&amp; !( range[ 0 ] instanceof Number ) ) {</span>
<span class="fc" id="L332">            Class&lt;?&gt; givenClass = range[ 0 ].getClass();</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L334">            final ValType[] value = (ValType[]) Array.newInstance(</span>
                    givenClass,
<span class="fc" id="L336">                    NDConfiguration.Utility.szeOfShp( shape )</span>
            );
<span class="fc bfc" id="L338" title="All 2 branches covered.">            for ( int i = 0; i &lt; value.length; i++ ) value[ i ] = range[ i % range.length ];</span>
<span class="fc" id="L339">            setDataType( DataType.of( givenClass ) );</span>
<span class="fc" id="L340">            _setData( value );</span>
<span class="fc" id="L341">            _construct( shape, value );</span>
<span class="fc" id="L342">        } else {</span>
<span class="fc" id="L343">            setDataType( dataType );</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            if ( dataType.getTypeClass() == F64.class )</span>
<span class="fc" id="L345">                _constructForDoubles(</span>
                        shape,
<span class="fc" id="L347">                        DataConverter.Utility.objectsToDoubles( range, NDConfiguration.Utility.szeOfShp( shape ) )</span>
                );
<span class="fc bfc" id="L349" title="All 2 branches covered.">            else if ( dataType.getTypeClass() == F32.class  )</span>
<span class="fc" id="L350">                _constructForFloats(</span>
                        shape,
<span class="fc" id="L352">                        DataConverter.Utility.objectsToFloats( range, NDConfiguration.Utility.szeOfShp( shape ) )</span>
                );
<span class="fc bfc" id="L354" title="All 2 branches covered.">            else if ( dataType.getTypeClass() == I32.class )</span>
<span class="fc" id="L355">                _constructForInts(</span>
                        shape,
<span class="fc" id="L357">                        DataConverter.Utility.objectsToInts( range, NDConfiguration.Utility.szeOfShp( shape ) )</span>
                );
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">            else if ( dataType.getTypeClass() == I16.class )</span>
<span class="fc" id="L360">                _constructForShorts(</span>
                        shape,
<span class="fc" id="L362">                        DataConverter.Utility.objectsToShorts( range, NDConfiguration.Utility.szeOfShp( shape ) )</span>
                );
        }
<span class="fc" id="L365">    }</span>


<span class="fc" id="L368">    public Tsr( List&lt;Object&gt; conf ) {</span>
<span class="fc" id="L369">        boolean isMatrix = conf.stream().allMatch( e -&gt; e instanceof List );</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if ( isMatrix ) {</span>
<span class="fc" id="L371">            _construct( conf.stream().map( e -&gt; (List&lt;Object&gt;) e ).collect( Collectors.toList() ) );</span>
<span class="fc" id="L372">            return;</span>
        }
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        boolean isNatural = ( conf.size() &lt;= 64 );</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">        for( Object e : conf ) {</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">            if ( !isNatural ) break;</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">            double asNum = ( e instanceof BigDecimal ) ?</span>
<span class="fc" id="L378">                    ( (BigDecimal) e ).doubleValue()</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                    : ( e instanceof Double )</span>
<span class="fc" id="L380">                        ? (Double) e</span>
<span class="fc" id="L381">                        : (Integer) e;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">            isNatural = asNum % 1 == 0;</span>
<span class="fc" id="L383">        }</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if ( isNatural ) {</span>
<span class="fc" id="L385">            int[] shape = new int[ conf.size() ];</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            for ( int i = 0; i &lt; shape.length; i++ ) {</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">                shape[ i ] = ( conf.get( i ) instanceof BigDecimal )</span>
<span class="fc" id="L388">                        ? ( (BigDecimal) conf.get( i ) ).intValue() :</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                        ( conf.get( i ) instanceof Double )</span>
<span class="fc" id="L390">                                ? ( (Double) conf.get( i ) ).intValue()</span>
<span class="fc" id="L391">                                :( (Integer) conf.get( i ) );</span>
            }
<span class="fc" id="L393">            _construct( shape, false, false );</span>
<span class="fc" id="L394">        } else {</span>
<span class="fc" id="L395">            double[] value = new double[ conf.size() ];</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            for ( int i = 0; i &lt; value.length; i++ ) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                value[ i ] = ( conf.get( i ) instanceof BigDecimal )</span>
<span class="fc" id="L398">                        ? ( (BigDecimal) conf.get( i ) ).doubleValue() :</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">                        ( conf.get( i ) instanceof Double )</span>
<span class="nc" id="L400">                                ? ( (Double) conf.get( i ) ).doubleValue()</span>
<span class="fc" id="L401">                                : ( (Integer) conf.get( i ) );</span>
            }
<span class="fc" id="L403">            _constructForDoubles( new int[]{ conf.size() }, value );</span>
        }

<span class="fc" id="L406">    }</span>


    /**
     *  This method receives a list of lists which represents a matrix of objects.
     *  It parses this matrix into a 2D shape array and a double array.&lt;br&gt;
     *  &lt;br&gt;
     *
     * @param matrix A list of list which ought to resemble a matrix.
     */
    private void _construct( List&lt;List&lt;Object&gt;&gt; matrix ) {
<span class="fc" id="L417">        boolean isNumeric = matrix.stream().allMatch( e -&gt; e.stream().allMatch( ie -&gt; ie instanceof Number ) );</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        if ( isNumeric ) {</span>
<span class="fc" id="L419">            int n = matrix.get( 0 ).size();</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            boolean isHomogenous = matrix.stream().allMatch( e -&gt; e.size() == n );</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">            if ( isHomogenous ) {</span>
<span class="fc" id="L422">                int m = matrix.size();</span>
<span class="fc" id="L423">                double[] value = new double[ m * n ];</span>
<span class="fc" id="L424">                int[] shape = new int[]{ m, n };</span>

<span class="fc bfc" id="L426" title="All 2 branches covered.">                for ( int mi = 0; mi &lt; m; mi++ ) {</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">                    for ( int ni = 0; ni &lt; n; ni++ ) {</span>
<span class="fc" id="L428">                        int i = n * mi + ni;</span>
<span class="fc" id="L429">                        value[ i ] = DataConverter.instance().convert( matrix.get( mi ).get( ni ), Double.class );</span>
                    }
                }
<span class="fc" id="L432">                _constructForDoubles( shape, value );</span>
<span class="fc" id="L433">            } else {</span>
<span class="nc" id="L434">                String message = &quot;Provided nested list(s) do not form a regular matrix.&quot;;</span>
<span class="nc" id="L435">                _LOG.error( message );</span>
<span class="nc" id="L436">                throw new IllegalArgumentException( message );</span>
            }
        }
<span class="fc" id="L439">    }</span>

    /*
        -------------------------------------------
            Â§(1.2) : SHAPE ARRAY BASED CONSTRUCTION
        --------------------------------------------
    */

    public Tsr( double value )
<span class="fc" id="L448">    {</span>
<span class="fc" id="L449">        _construct( new int[]{ 1 }, value );</span>
<span class="fc" id="L450">    }</span>

    public Tsr( float[] value )
<span class="fc" id="L453">    {</span>
<span class="fc" id="L454">        _constructForFloats( new int[]{ value.length }, value );</span>
<span class="fc" id="L455">    }</span>

    public Tsr( int[] shape, String seed )
<span class="fc" id="L458">    {</span>
<span class="fc" id="L459">        _construct( shape, seed );</span>
<span class="fc" id="L460">    }</span>

    public Tsr( int[] shape )
<span class="fc" id="L463">    {</span>
<span class="fc" id="L464">        _construct( shape, true, true );</span>
<span class="fc" id="L465">    }</span>

    public Tsr( int[] shape, double value )
<span class="fc" id="L468">    {</span>
<span class="fc" id="L469">        _construct( shape, value );</span>
<span class="fc" id="L470">    }</span>


<span class="fc" id="L473">    public Tsr( int[] shape, double[] value ) {</span>
<span class="fc" id="L474">        _constructForDoubles( shape, value );</span>
<span class="fc" id="L475">    }</span>


    public Tsr( int[] shape, DataType&lt;?&gt; type )
<span class="fc" id="L479">    {</span>
<span class="fc" id="L480">        setDataType( DataType.of( type.getTypeClass() ) );</span>
<span class="fc" id="L481">        _construct( shape, true, true );</span>
<span class="fc" id="L482">    }</span>

    public Tsr( int[] shape, Class&lt;?&gt; typeClass, Object data )
<span class="fc" id="L485">    {</span>
<span class="fc" id="L486">        setDataType( DataType.of( typeClass ) );</span>
<span class="fc" id="L487">        _configureFromNewShape( shape, false, false );</span>
<span class="fc" id="L488">        setValue( data );</span>
<span class="fc" id="L489">    }</span>

    public &lt;T&gt; Tsr( List&lt;Integer&gt; shape, Class&lt;T&gt; typeClass, List&lt;T&gt; data )
<span class="fc" id="L492">    {</span>
<span class="fc" id="L493">        _constructForRange( shape.stream().mapToInt( e -&gt; e ).toArray(), DataType.of( typeClass ), (ValType[]) data.toArray());</span>
<span class="fc" id="L494">    }</span>

    public Tsr( int[] shape, DataType&lt;?&gt; dataType, Object data )
<span class="fc" id="L497">    {</span>
<span class="fc" id="L498">        setDataType( dataType );</span>
<span class="fc" id="L499">        _configureFromNewShape( shape, false, false );</span>
<span class="fc" id="L500">        _setData( data );</span>
<span class="fc" id="L501">    }</span>

    public &lt;T&gt; Tsr( List&lt;Integer&gt; shape, DataType&lt;T&gt; dataType, List&lt;T&gt; data )
<span class="fc" id="L504">    {</span>
<span class="fc" id="L505">        setDataType( dataType );</span>
<span class="fc" id="L506">        _configureFromNewShape( shape.stream().mapToInt( e -&gt; e ).toArray(), false, false );</span>
<span class="fc" id="L507">        _setData( data.toArray() );</span>
<span class="fc" id="L508">    }</span>

    // Inner construction layer:

    private void _construct( int[] shape, String seed )
    {
<span class="fc" id="L514">        _construct( shape, false, false );</span>
<span class="fc" id="L515">        _setData( DataConverter.Utility.seededDoubleArray( (double[]) getData(), seed ) );</span>
<span class="fc" id="L516">    }</span>

    private void _construct( int[] shape, boolean allocate, boolean virtual )
    {
<span class="fc bfc" id="L520" title="All 4 branches covered.">        if ( allocate ) _allocate( ( virtual ) ? 1 : NDConfiguration.Utility.szeOfShp( shape ) );</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">        if ( virtual ) setIsVirtual( true );</span>
<span class="fc" id="L522">        _configureFromNewShape( shape, virtual, true );</span>
<span class="fc" id="L523">    }</span>

    private void _construct( int[] shape, double value )
    {
<span class="fc" id="L527">        int size = NDConfiguration.Utility.szeOfShp( shape );</span>
<span class="fc" id="L528">        setDataType( DataType.of( F64.class ) );</span>
<span class="fc" id="L529">        _allocate( 1 );</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">        setIsVirtual( size &gt; 1 );</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">        _configureFromNewShape( shape, size &gt; 1, true );</span>
<span class="fc" id="L532">        ( (double[]) getData())[ 0 ] = value;</span>
<span class="fc" id="L533">    }</span>

    private void _constructForDoubles(int[] shape, double[] value )
    {
<span class="fc" id="L537">        int size = NDConfiguration.Utility.szeOfShp( shape );</span>
<span class="fc" id="L538">        setDataType( DataType.of( F64.class ) );</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">        if ( size != value.length ) {</span>
<span class="fc" id="L540">            _allocate( size );</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">            for ( int i = 0; i &lt; size; i++ ) ( (double[]) getData())[ i ]  = value[ i % value.length ];</span>
<span class="fc" id="L542">        } else _setData( value );</span>
<span class="fc" id="L543">        _configureFromNewShape( shape, false, true );</span>
<span class="fc" id="L544">    }</span>

    private void _constructForFloats(int[] shape, float[] value )
    {
<span class="fc" id="L548">        int size = NDConfiguration.Utility.szeOfShp( shape );</span>
<span class="fc" id="L549">        setDataType( DataType.of( F32.class ) );</span>
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">        if ( size != value.length ) {</span>
<span class="nc" id="L551">            _allocate( size );</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            for ( int i = 0; i &lt; size; i++ ) ( (float[]) getData())[ i ]  = value[ i % value.length ];</span>
<span class="fc" id="L553">        } else _setData( value );</span>
<span class="fc" id="L554">        _configureFromNewShape( shape, false, true );</span>
<span class="fc" id="L555">    }</span>

    private void _constructForInts( int[] shape, int[] value )
    {
<span class="fc" id="L559">        int size = NDConfiguration.Utility.szeOfShp( shape );</span>
<span class="fc" id="L560">        setDataType( DataType.of( I32.class ) );</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">        if ( size != value.length ) {</span>
<span class="nc" id="L562">            _allocate( size );</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            for ( int i = 0; i &lt; size; i++ ) ( (int[]) getData())[ i ]  = value[ i % value.length ];</span>
<span class="fc" id="L564">        } else _setData( value );</span>
<span class="fc" id="L565">        _configureFromNewShape( shape, false, true );</span>
<span class="fc" id="L566">    }</span>

    private void _constructForShorts( int[] shape, short[] value )
    {
<span class="fc" id="L570">        int size = NDConfiguration.Utility.szeOfShp( shape );</span>
<span class="fc" id="L571">        setDataType( DataType.of( I16.class ) );</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        if ( size != value.length ) {</span>
<span class="nc" id="L573">            _allocate( size );</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            for ( int i = 0; i &lt; size; i++ ) ( (short[]) getData())[ i ]  = value[ i % value.length ];</span>
<span class="fc" id="L575">        } else _setData( value );</span>
<span class="fc" id="L576">        _configureFromNewShape( shape, false, true );</span>
<span class="fc" id="L577">    }</span>

    private void _construct( int[] shape, ValType[] value ) {
<span class="fc" id="L580">        int size = NDConfiguration.Utility.szeOfShp( shape );</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">        if ( size != value.length ) {</span>
<span class="nc" id="L582">            Class&lt;?&gt; givenClass = value[ 0 ].getClass();</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L584">            final ValType[] newValue = (ValType[]) Array.newInstance(</span>
                    givenClass,
<span class="nc" id="L586">                    NDConfiguration.Utility.szeOfShp( shape )</span>
            );
<span class="nc bnc" id="L588" title="All 2 branches missed.">            for ( int i = 0; i &lt; newValue.length; i++ ) newValue[ i ] = value[ i % value.length ];</span>
<span class="nc" id="L589">            setDataType( DataType.of( givenClass ) );</span>
<span class="nc" id="L590">            _setData( newValue );</span>
<span class="nc" id="L591">        }</span>
<span class="fc" id="L592">        else _setData( value );</span>
<span class="fc" id="L593">        _configureFromNewShape( shape, false, true );</span>
<span class="fc" id="L594">    }</span>

    private int[] _intArray( Object[] arg ) {
<span class="fc" id="L597">        int length = arg.length;</span>
<span class="fc" id="L598">        int[] array = new int[ length ];</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">        for ( int i = 0; i &lt; length; i++ ) {</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if ( arg[ i ] instanceof Double ) array[ i ] = ( (Double) arg[ i ] ).intValue();</span>
<span class="fc" id="L601">            else array[ i ] = (Integer) arg[ i ];</span>
        }
<span class="fc" id="L603">        return array;</span>
    }

    private double[] _doubleArray( Object[] arg )
    {
<span class="nc" id="L608">        int length = arg.length;</span>
<span class="nc" id="L609">        double[] array = new double[ length ];</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">        for ( int i = 0; i &lt; length; i++ ) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if ( arg[ i ] instanceof Integer ) array[ i ] = (Integer) arg[ i ];</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            else if ( arg[ i ] instanceof Double ) array[ i ] = (Double) arg[ i ];</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">            else if ( arg[ i ] instanceof BigDecimal ) array[ i ] = ( (BigDecimal) arg[ i ] ).doubleValue();</span>
        }
<span class="nc" id="L615">        return array;</span>
    }

    /*
        -------------------------------------------
            Â§(1.3) : LAMBDA BASED CONSTRUCTION
        --------------------------------------------
    */

    /**
     *  This constructor allows the creation of tensors with an additional initialization
     *  lambda for filling the underlying data array with desired values.
     *  Besides regular numeric types it is also possible to initialize the
     *  tensor with regular Objects like String instances or custom data types like complex
     *  numbers for example... &lt;br&gt;
     *  Therefore the constructor requires not only a shape as argument but also
     *  the data type which ought to be allocated as well as the initialization
     *  lambda which will be called iteratively.
     *
     * @param shape The shape of this new tensor ought to have.
     * @param type The data type this tensor ought to have.
     * @param initializer The lambda Object which ought to fill this tensor with the appropriate data.
     * @param &lt;T&gt; The type parameter for the actual data array items.
     */
    public &lt;T&gt; Tsr( List&lt;Integer&gt; shape, DataType&lt;T&gt; type, Initializer&lt;T&gt; initializer )
<span class="fc" id="L640">    {</span>
<span class="fc" id="L641">        _constructFromInitializer( shape.stream().mapToInt(e -&gt; e ).toArray(), type, initializer );</span>
<span class="fc" id="L642">    }</span>

    /**
     *  This constructor allows the creation of tensors with an additional initialization
     *  lambda for filling the underlying data array with desired values.
     *  Besides regular numeric types it is also possible to initialize the
     *  tensor with regular Objects like String instances or custom data types like complex
     *  numbers for example... &lt;br&gt;
     *  Therefore the constructor requires not only a shape as argument but also
     *  the data type which ought to be allocated as well as the initialization
     *  lambda which will be called iteratively.
     *
     * @param shape The shape of this new tensor ought to have.
     * @param type The data type this tensor ought to have.
     * @param initializer The lambda Object which ought to fill this tensor with the appropriate data.
     * @param &lt;T&gt; The type parameter for the actual data array items.
     */
    public &lt;T&gt; Tsr( int[] shape, DataType&lt;T&gt; type, Initializer&lt;T&gt; initializer )
<span class="nc" id="L660">    {</span>
<span class="nc" id="L661">        _constructFromInitializer( shape, type, initializer );</span>
<span class="nc" id="L662">    }</span>

    /**
     * @param shape The shape of that this new tensor ought to have.
     * @param type The data type that this tensor ought to have.
     * @param initializer The lambda Object which ought to fill this tensor with the appropriate data.
     * @param &lt;T&gt; The type parameter for the actual data array items.
     */
    private &lt;T&gt; void _constructFromInitializer(int[] shape, DataType&lt;T&gt; type, Initializer&lt;T&gt; initializer )
    {
<span class="fc" id="L672">        setDataType( type );</span>
<span class="fc" id="L673">        _construct( shape, true, false );</span>
<span class="fc" id="L674">        _initData( initializer );</span>
<span class="fc" id="L675">    }</span>


    /*
        -------------------------------------------
            Â§(1.4) : FUNCTION BASED CONSTRUCTION
        --------------------------------------------
     */

    /**
     *  This constructor allows for the creation and execution of Function instances
     *  without actually instantiating them manually,
     *  where the result will then become this very tensor. &lt;br&gt;&lt;br&gt;
     *  The passed String will be parsed into a Function AST which will be cached
     *  using the expression as key in case it will be used in future constructor calls
     *  like this one, or elsewhere...
     *  The created / retrieved Function will then be called with the supplied input list
     *  in order to trigger an execution.
     *  The result of which will be used for the population of the fields of this
     *  very instance.                                                                      &lt;br&gt;
     *  An example would be the following :                                                 &lt;br&gt;
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = new Tsr( &quot;sin( I[0] ) / I[1]&quot;, List.of(b, c) )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param expression A String which will be used for parsing a Function AST.
     * @param inputs A list of inputs which can be tensors or numeric types.
     */
    public Tsr( String expression, List&lt;Object&gt; inputs )
<span class="fc" id="L704">    {</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if ( inputs.stream().allMatch( e -&gt; e instanceof Tsr ) )</span>
<span class="fc" id="L706">            _construct(</span>
<span class="fc" id="L707">                    inputs.stream().toArray( Tsr[]::new ),</span>
                    expression,
                    true
            );
        else
<span class="fc" id="L712">            _construct(</span>
<span class="fc" id="L713">                    inputs.stream().map( Tsr::new ).toArray( Tsr[]::new ),</span>
                    expression,
                    true
            );
<span class="fc" id="L717">    }</span>

    /**
     *  This method takes a tensor and a String expression describing
     *  operations which ought to be applied to said tensor.
     *  This expression will be parsed to a Function instance expecting one input,
     *  namely : &quot;I[0]&quot; &lt;br&gt;
     *  An example would be the following :
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = new Tsr( b, &quot;sin( I[0] ) * 2&quot; )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     *  Which takes the tensor 'b' and applies the function &quot;f(x) = sin(x) * 2&quot;
     *  elementwise to produce a new tensor 'a'! &lt;br&gt;
     *  &lt;br&gt;
     *
     * @param tensor A tensor which serves as input to the Function instance parsed from the given expression.
     * @param expression The expression describing operations applied to the provided tensor.
     */
<span class="fc" id="L736">    public Tsr( Tsr&lt;ValType&gt; tensor, String expression ) {</span>
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">        if ( tensor == null ) return;</span>
<span class="fc" id="L738">        _construct( new Tsr[]{ tensor }, expression, true );</span>
<span class="fc" id="L739">    }</span>

    /**
     *  This method takes an array of tensors and a String expression describing
     *  operations which ought to be applied to the tensors in said array.
     *  This expression will be parsed to a Function instance expecting as many inputs
     *  as there are array entries, namely : &quot;I[0]&quot;, &quot;I[1]&quot;, &quot;I[2]&quot;, ... &lt;br&gt;
     *  An example would be the following :
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = new Tsr( new Tsr[]{ b, c }, &quot;sin( I[0] ) / I[1]&quot; )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     *  Which takes the tensor 'b' and 'c' and applies the function &quot;f(x,y) = sin(x) / y&quot;
     *  elementwise to produce a new tensor 'a'! &lt;br&gt;
     *
     * @param tensors An array of tensors used as inputs to the Function instance parsed from the provided expression.
     * @param expression The expression describing operations applied to the provided tensors.
     */
<span class="fc" id="L757">    public Tsr( Tsr&lt;ValType&gt;[] tensors, String expression ) {</span>
<span class="fc" id="L758">        _construct( tensors, expression, true );</span>
<span class="fc" id="L759">    }</span>

    /**
     *  This method takes an array of tensors and a String expression describing
     *  operations which ought to be applied to the tensors in said array.
     *  This expression will be parsed to a Function instance expecting as many inputs
     *  as there are array entries, namely : &quot;I[0]&quot;, &quot;I[1]&quot;, &quot;I[2]&quot;, ...                    &lt;br&gt;
     *  An example would be the following :                                                 &lt;br&gt;
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;i&gt; 'Tsr a = new Tsr( new Tsr[]{ b, c }, &quot;sin( I[0] ) / I[1]&quot; )'&lt;/i&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *  Which takes the tensor 'b' and 'c' and applies the function &quot;f(x,y) = sin(x) / y&quot;
     *  elementwise to produce a new tensor 'a'!
     *  Additionally there is a helpful flag which allows one to specify if the
     *  parsed Function instance emerging from the provided expression
     *  should also allow the tracking of computations via a computation graph (GraphNode instances).
     *  This history tracking then enables auto-differentiation. &lt;br&gt;
     *
     * @param tensors An array of tensors used as inputs to the Function instance parsed from the provided expression.
     * @param expression The expression describing operations applied to the provided tensors.
     * @param doAD A flag which when set to true commands the creation of a computation graph during operation execution.
     */
    public Tsr( Tsr&lt;ValType&gt;[] tensors, String expression, boolean doAD )
<span class="fc" id="L782">    {</span>
<span class="fc" id="L783">        _construct( tensors, expression, doAD );</span>
<span class="fc" id="L784">    }</span>

    /**
     *  In essence tensors are merely fancy wrappers for some form of array of any type...
     *  This wrapper usually stays the same of a given data array.
     *  However, sometimes a tensor changes its identity, or rather the underlying
     *  data changes the wrapping tensor instance. 
     *
     *  This change currently only happens when tensors are being instantiated by
     *  passing inputs and a math expression to its constructor.
     *  This triggers the creation of a Function instance and execution on the provided
     *  input tensors. In that case the output tensor will be created somewhere
     *  along the execution call stack, however the result is expected to be
     *  stored within the tensor whose constructor initialized all of this.
     *  In that case this tensor will rip out the guts of the resulting output
     *  tensor and stuff onto its own field variables. &lt;br&gt;
     *  &lt;br&gt;
     *  
     * @param tensors The tensors which will be passed to the function.
     * @param expression The expression defining a function.
     * @param doAD The flag which will enable or disable autograd for the instantiated Function.
     */
    private void _construct( Tsr[] tensors, String expression, boolean doAD )
    {
<span class="pc bpc" id="L808" title="3 of 6 branches missed.">        if ( tensors == null || tensors.length == 0 || tensors[ 0 ] == null ) return; </span>
<span class="fc" id="L809">        _become( Function.Setup.commit( this, tensors, expression, doAD ) );</span>
<span class="fc" id="L810">    }</span>

    /**
     *  This method is responsible for instantiating and setting the _conf variable.
     *  The core requirement for instantiating NDConfiguration interface implementation s
     *  is a shape array of integers which is being passed to the method... &lt;br&gt;
     *  &lt;br&gt;
     *
     * @param newShape An array if integers which are all greater 0 and represent the tensor dimensions.
     */
    protected void _configureFromNewShape( int[] newShape, boolean makeVirtual, boolean autoAllocate )
    {
<span class="fc" id="L822">        int size = NDConfiguration.Utility.szeOfShp( newShape );</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        if ( size == 0 ) {</span>
<span class="nc" id="L824">            String shape = Arrays.stream( newShape ).mapToObj( String::valueOf ).collect( Collectors.joining( &quot;x&quot; ) );</span>
<span class="nc" id="L825">            String message = &quot;The provided shape '&quot;+shape+&quot;' must not contain zeros. Dimensions lower than 1 are not possible.&quot;;</span>
<span class="nc" id="L826">            _LOG.error( message );</span>
<span class="nc" id="L827">            throw new IllegalArgumentException( message );</span>
        }
<span class="fc bfc" id="L829" title="All 4 branches covered.">        if ( getData() == null &amp;&amp; autoAllocate ) _allocate( size );</span>
<span class="fc" id="L830">        int length = _dataLength();</span>
<span class="pc bpc" id="L831" title="2 of 8 branches missed.">        if ( length &gt;= 0 &amp;&amp; size != length &amp;&amp; ( !this.isVirtual() || !makeVirtual) ) {</span>
<span class="nc" id="L832">                String message = &quot;Size of shape does not match stored value64!&quot;;</span>
<span class="nc" id="L833">                _LOG.error( message );</span>
<span class="nc" id="L834">                throw new IllegalArgumentException( message );</span>
        }
<span class="fc bfc" id="L836" title="All 2 branches covered.">        if ( makeVirtual ) setNDConf( VirtualNDConfiguration.construct( newShape ) );</span>
        else {
<span class="fc" id="L838">            int[] newTranslation = NDConfiguration.Utility.newTlnOf( newShape );</span>
<span class="fc" id="L839">            int[] newSpread = new int[ newShape.length ];</span>
<span class="fc" id="L840">            Arrays.fill( newSpread, 1 );</span>
<span class="fc" id="L841">            int[] newOffset = new int[ newShape.length ];</span>
<span class="fc" id="L842">            setNDConf(</span>
<span class="fc" id="L843">                AbstractNDC.construct(</span>
                    newShape,
                    newTranslation,
                    newTranslation, // indicesMap
                    newSpread,
                    newOffset
                )
            );
        }
<span class="fc" id="L852">    }</span>


    /*==================================================================================================================
    |
    |       Â§(2) : FLAGS
    |   ----------------------
    */
    /*
        --------------------------------------------
            Â§(2.0) : GRADIENT REQUIREMENT  :
        --------------------------------------------
    */

    public Tsr&lt;ValType&gt; setRqsGradient( boolean rqsGradient ) {
<span class="fc bfc" id="L867" title="All 4 branches covered.">        if ( rqsGradient() != rqsGradient &amp;&amp; !rqsGradient ) this.remove( Tsr.class );</span>
<span class="fc" id="L868">        _setRqsGradient( rqsGradient );</span>
<span class="fc" id="L869">        return this;</span>
    }

    public boolean rqsGradient() {
<span class="fc bfc" id="L873" title="All 2 branches covered.">        return ( _flags &amp; RQS_GRADIENT_MASK ) == RQS_GRADIENT_MASK;</span>
    }

    protected void _setRqsGradient( boolean rqsGradient ) {
<span class="fc bfc" id="L877" title="All 2 branches covered.">        if ( rqsGradient() != rqsGradient ) {</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">            if ( rqsGradient ) _flags += RQS_GRADIENT_MASK;</span>
<span class="fc" id="L879">            else _flags -= RQS_GRADIENT_MASK;</span>
        }
<span class="fc" id="L881">    }</span>

    /*
    ---------------------------------------------
        Â§(2.1) : SOURCE LOCATION (DEVICE)  :
    ---------------------------------------------
    */

    public Tsr&lt;ValType&gt; setIsOutsourced( boolean isOutsourced ) {
<span class="fc" id="L890">        _setIsOutsourced( isOutsourced );</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">        if ( isOutsourced ) {</span>
<span class="fc" id="L892">            _setData( null );</span>
<span class="fc" id="L893">        } else if (</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">                !forComponent(</span>
                        Device.class,
                        device -&gt; {
                            try {
<span class="fc bfc" id="L898" title="All 2 branches covered.">                                if ( device.has( this ) ) device.restore( this );</span>
<span class="nc" id="L899">                            } catch ( Exception exception ) {</span>
<span class="nc" id="L900">                                _LOG.error(</span>
                                        &quot;Tensor could not be restored from device component when trying to migrate it back to RAM.&quot;,
                                        exception
                                );
<span class="nc" id="L904">                                throw exception;</span>
<span class="fc" id="L905">                            }</span>
<span class="fc" id="L906">                            this.remove( Device.class );</span>
<span class="fc" id="L907">                            forComponent(</span>
                                    Tsr.class,
                                    gradient -&gt;
<span class="nc" id="L910">                                            ( (Tsr&lt;ValType&gt;) gradient ).forComponent(</span>
                                                    Device.class,
                                                    gradDevice -&gt; {
                                                        try {
<span class="nc bnc" id="L914" title="All 2 branches missed.">                                                            if ( gradDevice.has( gradient ) ) gradDevice.restore( gradient );</span>
                                                        }
<span class="nc" id="L916">                                                        catch ( Exception exception ) {</span>
<span class="nc" id="L917">                                                            _LOG.error(</span>
                                                                    &quot;Gradient could not be restored from device component when trying to migrate it back to RAM.&quot;,
                                                                    exception
                                                            );
<span class="nc" id="L921">                                                            throw exception;</span>
<span class="nc" id="L922">                                                        }</span>
<span class="nc" id="L923">                                                        gradient.remove( Device.class );</span>
<span class="nc" id="L924">                                                    })</span>
                            );
<span class="fc" id="L926">                        }</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">                ) &amp;&amp; getData() == null</span>
        ) {
<span class="fc" id="L929">            setIsVirtual( true );</span>
        }
<span class="fc" id="L931">        return this;</span>
    }

    public boolean isOutsourced() {
<span class="fc bfc" id="L935" title="All 2 branches covered.">        return ( _flags &amp; IS_OUTSOURCED_MASK ) == IS_OUTSOURCED_MASK;</span>
    }

    protected void _setIsOutsourced( boolean isOutsourced ) {
<span class="fc bfc" id="L939" title="All 2 branches covered.">        if ( isOutsourced() != isOutsourced ) {</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">            if ( isOutsourced ) _flags += IS_OUTSOURCED_MASK;</span>
<span class="fc" id="L941">            else _flags -= IS_OUTSOURCED_MASK;</span>
        }
<span class="fc" id="L943">    }</span>

    /*
    --------------------------------------------
        Â§(2.2) : VIRTUAL / ACTUAL  :
    --------------------------------------------
    */

    /**
     *  Virtualizing is the opposite to actualizing a tensor.
     *  A tensor is virtual if the size of the underlying data is not actually equal to
     *  the number of elements which the tensor claims to store, aka its size.
     *  This is for example the case when initializing a tensor filled with a single
     *  value continuously. In that case the tensor will flag itself as virtual and only allocate the
     *  underlying data array to hold a single item even though the tensor might actually hold
     *  many more items.
     *  The reasons for this feature is that it greatly improves performance in certain cases.
     *  In essence this feature is a form of lazy loading.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param isVirtual The truth value determining if this tensor ought to be virtualized.
     * @return This very tensor to enable method chaining.
     */
    public Tsr&lt;ValType&gt; setIsVirtual( boolean isVirtual ) {
<span class="fc bfc" id="L967" title="All 2 branches covered.">        if ( isVirtual() != isVirtual ) {</span>
<span class="fc" id="L968">            Device device = this.find( Device.class );</span>
            try {
<span class="fc bfc" id="L970" title="All 2 branches covered.">                if ( device != null ) device.restore( this );</span>
<span class="nc" id="L971">            } catch ( Exception exception ) {</span>
<span class="nc" id="L972">                _LOG.error(</span>
                        &quot;Tensor could not be restored from device component when changing flag 'isVirtual' to &quot; + isVirtual + &quot;.&quot;
                        , exception
                );
<span class="nc" id="L976">                throw exception;</span>
<span class="fc" id="L977">            }</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">            if ( isVirtual ) {</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">                if ( getData() == null ) _allocate( 1 );</span>
<span class="fc" id="L980">                else _virtualize();</span>
<span class="fc" id="L981">                Relation&lt;ValType&gt; relation = find( Relation.class );</span>
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">                if ( relation!=null ) relation.foreachChild( c -&gt; c._setData( getData()) );</span>
<span class="fc" id="L983">            } else {</span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">                Tsr&lt;?&gt; parentTensor = ( this.isSlice() ) ? find(Relation.class).getParent() : null;</span>
<span class="pc bpc" id="L985" title="1 of 2 branches missed.">                if ( parentTensor != null ) parentTensor.find( Relation.class ).remove( this );</span>
<span class="fc" id="L986">                _actualize();</span>
            }
<span class="fc" id="L988">            _setIsVirtual( isVirtual ); //&gt; Changing the flag now!</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">            if ( getNDConf() != null ) _configureFromNewShape( getNDConf().shape(), isVirtual, true );</span>
            try {
<span class="fc bfc" id="L991" title="All 2 branches covered.">                if ( device != null ) device.store( this );</span>
<span class="nc" id="L992">            } catch ( Exception exception ) {</span>
<span class="nc" id="L993">                String message =</span>
                        &quot;Tensor could not be migrated back to host device after changing flag 'isVirtual' to &quot;+isVirtual+&quot;.&quot;;
<span class="nc" id="L995">                _LOG.error(</span>
                        message,
                        exception
                );
<span class="nc" id="L999">                throw new IllegalStateException( message );</span>
<span class="fc" id="L1000">            }</span>
<span class="pc bpc" id="L1001" title="1 of 4 branches missed.">        } else if ( isVirtual &amp;&amp; getData() == null ) _allocate( 1 ); //&gt; Only a single value representing the rest.</span>
<span class="fc" id="L1002">        return this;</span>
    }

    /**
     *  A tensor is virtual if the size of the underlying data is not actually equal to
     *  the number of elements which the tensor claims to store, aka its size.
     *  This is for example the case when initializing a tensor filled with a single
     *  value continuously. In that case the tensor will flag itself as virtual and only allocate the
     *  underlying data array to hold a single item even though the tensor might actually hold
     *  many more items.
     *  The reasons for this feature is that it greatly improves performance in certain cases.
     *  In essence this feature is a form of lazy loading.
     *  &lt;br&gt;&lt;br&gt;
     * @return The truth value determining if this tensor is virtual (and therefore not &quot;actual&quot;).
     */
    public boolean isVirtual() {
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        return ( _flags &amp; IS_VIRTUAL_MASK ) == IS_VIRTUAL_MASK;</span>
    }

    /**
     *  This method is the inner counterpart to the public &quot;setIsVirtual&quot; method.
     *  It actually performs the bit flipping by applying the corresponding bit mask. &lt;br&gt;
     *  &lt;br&gt;
     * @param isVirtual The truth value which ought to be applied.
     */
    protected void _setIsVirtual( boolean isVirtual ) {
<span class="fc bfc" id="L1028" title="All 2 branches covered.">        if ( isVirtual() != isVirtual ) {</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">            if ( isVirtual ) _flags += IS_VIRTUAL_MASK;</span>
<span class="fc" id="L1030">            else _flags -= IS_VIRTUAL_MASK;</span>
        }
<span class="fc" id="L1032">    }</span>

    /*
    --------------------------------------------
        Â§(2.3) : GRADIENT APPLY REQUIREMENT  :
    --------------------------------------------
    */

    /**
     *  This flag works alongside two autograd features which can be enables inside the library settings.
     *  They will come into effect when flipping their feature flags, &lt;br&gt;
     *  namely: &lt;i&gt;'isApplyingGradientWhenRequested'&lt;/i&gt; and &lt;i&gt;'isApplyingGradientWhenTensorIsUsed'&lt;/i&gt;&lt;br&gt;
     *  As the first flag name suggests gradients will be applied to their tensors when it is set to true,
     *  however this will only happened when the second flag is set to true as well, because otherwise gradients
     *  wouldn't be applied to their tensors automatically in the first place... &lt;br&gt;
     *  &lt;br&gt;
     *  Setting both flags to true will inhibit effect of the second setting &lt;i&gt;'isApplyingGradientWhenTensorIsUsed'&lt;/i&gt;
     *  unless a form of &quot;permission&quot; is being signaled to the autograd system.
     *  This signal comes in the form of a &quot;request&quot; flag which marks a tensor as &lt;b&gt;allowed to
     *  be updated by its gradient&lt;/b&gt;.&lt;br&gt;
     *  &lt;br&gt;
     * @param applyRequested The truth value determining if the application of the gradient of this tensor is requested.
     * @return This very tensor instance in order to enable method chaining.
     */
    public Tsr&lt;ValType&gt; setGradientApplyRequested( boolean applyRequested ) {
<span class="fc bfc" id="L1057" title="All 2 branches covered.">        if ( gradientApplyRequested() != applyRequested ) {</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">            if ( applyRequested ) {</span>
                if (
<span class="fc bfc" id="L1060" title="All 2 branches covered.">                        Neureka.instance().settings().autograd().isApplyingGradientWhenRequested() &amp;&amp;</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">                                !Neureka.instance().settings().autograd().isApplyingGradientWhenTensorIsUsed()</span>
                ) {
<span class="fc" id="L1063">                    this.applyGradient();</span>
<span class="fc" id="L1064">                } else _flags += GRADIENT_APPLY_RQD_MASK;</span>
            }
<span class="fc" id="L1066">            else _flags -= GRADIENT_APPLY_RQD_MASK;</span>
        }
<span class="fc" id="L1068">        return this;</span>
    }

    /**
     *  This flag works alongside two autograd features which can be enables inside the library settings.
     *  They will come into effect when flipping their feature flags, &lt;br&gt;
     *  namely: &lt;i&gt;'isApplyingGradientWhenRequested'&lt;/i&gt; and &lt;i&gt;'isApplyingGradientWhenTensorIsUsed'&lt;/i&gt;&lt;br&gt;
     *  As the first flag name suggests gradients will be applied to their tensors when it is set to true,
     *  however this will only happened when the second flag is set to true as well, because otherwise gradients
     *  wouldn't be applied to their tensors automatically in the first place... &lt;br&gt;
     *  &lt;br&gt;
     *  Setting both flags to true will inhibit effect of the second setting &lt;i&gt;'isApplyingGradientWhenTensorIsUsed'&lt;/i&gt;
     *  unless a form of &quot;permission&quot; is being signaled to the autograd system.
     *  This signal comes in the form of a &quot;request&quot; flag which marks a tensor as &lt;b&gt;allowed to
     *  be updated by its gradient&lt;/b&gt;.&lt;br&gt;
     *  &lt;br&gt;
     * @return The truth value determining if the application of the gradient of this tensor is requested.
     */
    public boolean gradientApplyRequested() {
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        return ( _flags &amp; GRADIENT_APPLY_RQD_MASK ) == GRADIENT_APPLY_RQD_MASK;</span>
    }

    /*==================================================================================================================
    |
    |       Â§(3) : COMPONENT SYSTEM
    |   --------------------------------
    */
    /*
    --------------------------------------------
        Â§(3.0) : SETTING / REJECTING  :
    --------------------------------------------
    */

    /**
     * This method is executed when a new Component is added to the tensor.
     * The public add method is implemented in the super class
     * 'AbstractComponentOwner' from which this class inherits.
     * In this super class the component logic is implemented.
     *
     * @param newComponent A component used to access features. (GraphNode, IndexAlias, Relation, int[], ...)
     * @return The unchanged object or maybe in future versions: null (component rejected)
     */
    @Override
    protected &lt; T extends Component&lt;Tsr&lt;ValType&gt;&gt; &gt; T _setOrReject(T newComponent )
    {
<span class="fc bfc" id="L1113" title="All 2 branches covered.">        if ( newComponent.getClass() == HostCPU.class ) return null;</span>
<span class="fc bfc" id="L1114" title="All 4 branches covered.">        if ( newComponent instanceof Device &amp;&amp; !( (Device) newComponent ).has( this ) )</span>
        {
<span class="fc bfc" id="L1116" title="All 2 branches covered.">            if ( this.has( Relation.class ) ) {</span>
<span class="fc" id="L1117">                Relation relation = find( Relation.class );</span>
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">                if ( relation.hasParent() ) { // Root needs to be found ! :</span>
<span class="nc" id="L1119">                    Tsr&lt;ValType&gt; root = relation.findRootTensor();</span>
                    try {
<span class="nc" id="L1121">                        ((Device)newComponent).store( root );</span>
<span class="nc" id="L1122">                    } catch ( Exception exception ) {</span>
<span class="nc" id="L1123">                        _LOG.error( &quot;Could not store tensor on device '&quot; + newComponent.toString() +&quot;'.&quot;, exception );</span>
<span class="nc" id="L1124">                        throw exception;</span>
<span class="nc" id="L1125">                    }</span>
<span class="nc" id="L1126">                    root.find( Relation.class ).foreachChild( c -&gt; ((Tsr)c).setIsOutsourced( true ) );</span>
<span class="nc" id="L1127">                } else { // This is root ! :</span>
<span class="fc" id="L1128">                    relation.foreachChild( c -&gt; ((Tsr&lt;?&gt;)c).setIsOutsourced( true ) );</span>
                    try {
<span class="fc" id="L1130">                        ((Device)newComponent).store( this );</span>
<span class="nc" id="L1131">                    } catch ( Exception exception ) {</span>
<span class="nc" id="L1132">                        _LOG.error( &quot;Could not store tensor on device '&quot; + newComponent.toString() +&quot;'.&quot;, exception );</span>
<span class="nc" id="L1133">                        throw exception;</span>
<span class="fc" id="L1134">                    }</span>
                }
<span class="fc" id="L1136">            } else {</span>
                try {
<span class="fc" id="L1138">                    ((Device)newComponent).store( this );</span>
<span class="nc" id="L1139">                } catch ( Exception exception ) {</span>
<span class="nc" id="L1140">                    _LOG.error( &quot;Could not store tensor on device '&quot; + newComponent.toString() +&quot;'.&quot;, exception );</span>
<span class="nc" id="L1141">                    throw exception;</span>
<span class="fc" id="L1142">                }</span>
            }
<span class="fc bfc" id="L1144" title="All 2 branches covered.">            if ( ((Device)newComponent).has( this ) ) setIsOutsourced( true );</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">        } else if ( newComponent instanceof Tsr ) {</span>
<span class="fc" id="L1146">            if (</span>
<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">                    ((Tsr)newComponent).shape().hashCode() != this.shape().hashCode() ||</span>
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">                            Arrays.hashCode(((Tsr)newComponent).getNDConf().shape()) != Arrays.hashCode( getNDConf().shape() )</span>
<span class="nc" id="L1149">            ) newComponent = null;</span>
        }
<span class="fc" id="L1151">        return newComponent;</span>
    }

    /*
    --------------------------------------------
        Â§(3.1) : REMOVING / REJECTING  :
    --------------------------------------------
    */
    /**
     * This method is executed when a component is being removed from the tensor.
     * The public remove method is implemented in the super class
     * 'AbstractComponentOwner' from which this class inherits.
     * In this super class the component logic is implemented.
     *
     * @param newComponent A component used to access features. (GraphNode, IndexAlias, Relation, int[], ...)
     * @return The unchanged object or when rejected: null (component rejected)
     */
    @Override
    protected &lt;T extends Component&lt;Tsr&lt;ValType&gt;&gt;&gt; T _removeOrReject( T newComponent )
    {
<span class="fc bfc" id="L1171" title="All 2 branches covered.">        if ( newComponent instanceof Device ) {</span>
<span class="fc" id="L1172">            Device&lt;ValType&gt; device = (Device&lt;ValType&gt;) newComponent;</span>
            /*
                The following seems like a redundant check, however often times a tensor
                will be removed from a Device implementation inside the &quot;restore&quot; method
                when the tensor has already been removed from the device...
                With out the condition below a stack overflow would occur!
             */
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">            if ( device.has( this ) ) {</span>
                try {
<span class="nc" id="L1181">                    device.restore( this );</span>
<span class="nc" id="L1182">                } catch ( Exception exception ) {</span>
<span class="nc" id="L1183">                    _LOG.error(</span>
                            &quot;Removing device from tensor / tensor from device failed.\n&quot; +
                            &quot;Restoring tensor from device threw exception.\n&quot;,
                            exception
                    );
<span class="nc" id="L1188">                    throw exception;</span>
<span class="nc" id="L1189">                }</span>
            }


        }
<span class="fc" id="L1194">        return newComponent;</span>
    }

    /*
    ----------------------------
        Â§(3.2) : UPDATING  :
    ----------------------------
    */
    /**
     *  Important : Components of type Tsr are simply gradients!
     *  This method does not need to have an implementation in this case.
     *  (A gradient tensor &quot;does not mind&quot; an owner change...)
     *
     * @param oldOwner The previous owner type instance.
     * @param newOwner The new owner type instance.
     */
    @Override
    public void update( Tsr&lt;ValType&gt; oldOwner, Tsr&lt;ValType&gt; newOwner ) {
        // This is means that this tensor is a gradient that is being
        // transferred to another tensor to serve as gradient...
        // No update task needs to occur. (This might change in the future...)
<span class="nc" id="L1215">    }</span>


    /*==================================================================================================================
    |
    |       Â§(4) : PROPERTIES :
    |   ---------------------------------------
    */
    /*
    --------------------------------------------
        Â§(4.0) : HIGH LEVEL PROPERTIES  :
    --------------------------------------------
    */

    /**
     *  A tensor is empty if their is neither data set within the tensor directly
     *  or within a device to which the tensor might belong.
     *
     * @return The truth value determining if this tensor has data.
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1236" title="All 4 branches covered.">        return getData() == null &amp;&amp; !this.isOutsourced(); // Outsourced means that the tensor is stored on a device.</span>
    }

    public boolean isUndefined() {
<span class="pc bpc" id="L1240" title="2 of 4 branches missed.">        return getNDConf() == null || getNDConf().shape() == null;</span>
    }

    /**
     *  If this tensor is a slice of a parent tensor then this method will yield true.
     *  Slices can be created by calling the variations of the &quot;getAt&quot; method.
     *
     * @return The truth value determining if this tensor is a slice of another tensor.
     */
    public boolean isSlice() {
<span class="fc" id="L1250">        Relation&lt;ValType&gt; child = find( Relation.class );</span>
<span class="fc bfc" id="L1251" title="All 4 branches covered.">        return ( child != null &amp;&amp; child.hasParent() );</span>
    }

    /**
     *  This method returns the number of slices which have been
     *  created from this very tensor.
     *  It does so by accessing the Relation component if present
     *  which internally keeps track of slices via weak references.
     *
     * @return The number of slices derived from this tensor.
     */
    public int sliceCount() {
<span class="fc" id="L1263">        Relation&lt;ValType&gt; child = find( Relation.class );</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">        return ( child != null ) ? child.childCount() : 0;</span>
    }

    /**
     *  If slices have been derived from this tensor then it is a &quot;slice parent&quot;.
     *  This is what this method will determine, in which case, it will return true.
     *
     * @return The truth value determining if slices have been derived from this tensor.
     */
    public boolean isSliceParent() {
<span class="fc" id="L1274">        Relation&lt;ValType&gt; parent = find( Relation.class );</span>
<span class="pc bpc" id="L1275" title="1 of 4 branches missed.">        return ( parent != null &amp;&amp; parent.hasChildren() );</span>
    }

    /**
     *  Tensors which are used or produced by the autograd system will have a GraphNode component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  This autograd system however, will only be triggered by Function implementations which
     *  are not &quot;detached&quot;, meaning they have their &quot;doAD&quot; flags set to true! &lt;br&gt;
     *  Detached functions (like those pre-instantiated in Function.Detached.*) will not attach GraphNode
     *  instances to involved tensors which will prevent the formation of a computation graph.
     *
     * @return The truth value determining if this tensor belongs to a recorded computation graph.
     */
    public boolean belongsToGraph() {
<span class="fc" id="L1289">        return this.has( GraphNode.class );</span>
    }

    /**
     *  Tensors which are used or produced by the autograd system will have a GraphNode component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  This autograd system however, will only be triggered by Function implementations which
     *  are not &quot;detached&quot;, meaning they have their &quot;doAD&quot; flags set to true! &lt;br&gt;
     *  A tensor is a leave if it is attached to a computation graph in which it is not an intermediate / branch node
     *  but input / branch node.
     *
     * @return The truth value determining if this tensor is attached to a computation graph as leave node.
     */
    public boolean isLeave() {
<span class="pc bpc" id="L1303" title="1 of 4 branches missed.">        return (!this.has( GraphNode.class )) || this.find( GraphNode.class ).isLeave();</span>
    }

    /**
     *  Tensors which are used or produced by the autograd system will have a GraphNode component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  This autograd system however, will only be triggered by Function implementations which
     *  are not &quot;detached&quot;, meaning they have their &quot;doAD&quot; flags set to true! &lt;br&gt;
     *  A tensor is a branch if it is attached to a computation graph in which it is not an input / leave node
     *  but intermediate / branch node.
     *
     * @return The truth value determining if this tensor is attached to a computation graph as branch node.
     */
    public boolean isBranch() {
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        return !this.isLeave();</span>
    }

    /**
     *  Tensors can be components of other tensors which makes the
     *  implicitly their gradients.
     *
     * @return The truth value determining if this tensor has another tensor attached to it (which is its gradient).
     */
    public boolean hasGradient() {
<span class="fc" id="L1327">        return this.has( Tsr.class );</span>
    }

    /*
        ----------------------------------------------
            Â§(4.1) : COMPONENT BASED PROPERTIES :
        ----------------------------------------------
     */

    /**
     * @return The gradient of this tensor which is internally stored as component.
     */
    public Tsr&lt;ValType&gt; getGradient() {
<span class="fc" id="L1340">        return this.find( Tsr.class );</span>
    }

    /**
     * @return The device on which this tensor is stored or 'CPU' if it is not outsourced.
     */
    public Device&lt;ValType&gt; getDevice() {
<span class="fc bfc" id="L1347" title="All 2 branches covered.">        if ( this.isOutsourced() ) return this.find( Device.class );</span>
<span class="fc" id="L1348">        return (Device&lt;ValType&gt;) _CPU;</span>
    }

    /**
     * @return The graph node of the computation graph to which this tensor belongs or null if not part of a graph.
     */
    public GraphNode&lt;ValType&gt; getGraphNode() {
<span class="fc" id="L1355">        return find( GraphNode.class );</span>
    }

    /**
     *
     * @return Custom IndexAlias object.
     */
    public IndexAlias&lt;ValType&gt; index() {
<span class="fc" id="L1363">        return find( IndexAlias.class );</span>
    }


    /*
        ---------------------------------------
            Â§(4.2) : INNER PROPERTIES :
        ---------------------------------------
     */

    private int _dataLength()
    {
<span class="fc bfc" id="L1375" title="All 4 branches covered.">        if ( !(getData() instanceof float[]) &amp;&amp; !(getData() instanceof double[]) ) {</span>
<span class="fc bfc" id="L1376" title="All 2 branches covered.">            if ( getData() instanceof Object[] ) return ((Object[]) getData()).length;</span>
<span class="fc" id="L1377">            else return -1;</span>
        } 
<span class="fc bfc" id="L1379" title="All 2 branches covered.">        else if ( getData() instanceof double[] ) return ( (double[]) getData()).length;</span>
<span class="fc" id="L1380">        else return ( (float[]) getData()).length;</span>
    }

    /*==================================================================================================================
    |
    |       Â§(5) : OBJECT STATE MODIFICATION :
    |   ------------------------------------------
    */
    /**
     *  This method is responsible for incrementing
     *  the &quot;_version&quot; field variable which represents the version of the data of this tensor.
     *  Meaning :
     *  Every time the underlying data (_value) changes this version ought to increment alongside.
     *  The method is called during the execution procedure.
     *
     * @param call The context object containing all relevent informatin that defines a call for tensor execution.
     * @return This very tensor instance. (factory pattern)
     */
    public Tsr&lt;ValType&gt; incrementVersionBecauseOf( ExecutionCall call ) {
<span class="fc bfc" id="L1399" title="All 2 branches covered.">        if ( Neureka.instance().settings().autograd().isPreventingInlineOperations() ) {</span>
<span class="fc" id="L1400">            _version++;</span>
<span class="fc" id="L1401">            GraphNode&lt;?&gt; node = find( GraphNode.class );</span>
<span class="pc bpc" id="L1402" title="1 of 4 branches missed.">            if ( node != null &amp;&amp; node.getPayloadReferenceVersion() != _version ) {</span>
<span class="pc bpc" id="L1403" title="1 of 4 branches missed.">                if ( node.usesAD() || node.isUsedAsDerivative() ) {</span>
<span class="fc" id="L1404">                    String error = &quot;Inline operation occurred on tensor which is part of a computation graph node with autograd support!\n&quot; +</span>
<span class="fc" id="L1405">                            &quot;The following OperationType caused an internal version mismatch: '&quot;+call.getOperation().getFunction()+&quot;'&quot;;</span>
<span class="fc" id="L1406">                    _LOG.error( error );</span>
<span class="fc" id="L1407">                    throw new IllegalStateException( error );</span>
                }
            }
        }
<span class="fc" id="L1411">        return this;</span>
    }

    /**
     *  Although tensors will be garbage collected when they are not strongly referenced,
     *  there is also the option to manually free up the tensor and its associated data.
     *  This is especially useful when tensors are stored on a device like the OpenCLDevice.
     *  In that case calling the &quot;delete&quot; method will free the memory reserved for this tensor.
     *  This manual memory freeing through this method can be faster than waiting for
     *  the garbage collector to kick in... &lt;br&gt;
     *  &lt;br&gt;
     *      
     * @return This very tensor instance to allow for method chaining.
     */
    public Tsr&lt;ValType&gt; delete() 
    {
<span class="fc" id="L1427">        forComponent( GraphNode.class, n -&gt; {</span>
<span class="fc bfc" id="L1428" title="All 2 branches covered.">            if ( n.isUsedAsDerivative() ) {</span>
<span class="fc" id="L1429">                String message = &quot;Cannot delete a tensor which is used as derivative by the AD computation graph!&quot;;</span>
<span class="fc" id="L1430">                _LOG.error( message );</span>
<span class="fc" id="L1431">                throw new IllegalStateException( message );</span>
            }
<span class="fc" id="L1433">        });</span>
<span class="fc" id="L1434">        forComponent( Device.class, device -&gt; device.free( this ) );</span>
<span class="fc" id="L1435">        _flags = -1;</span>
<span class="fc" id="L1436">        _setData( null );</span>
<span class="fc" id="L1437">        setNDConf( null );</span>
<span class="fc" id="L1438">        forComponent( Tsr.class, Tsr::delete );</span>
<span class="fc" id="L1439">        _delComps();</span>
<span class="fc" id="L1440">        return this;</span>
    }

    /**
     *  In essence tensors are merely fancy wrapper for some form of array of any type... 
     *  This wrapper usually stays the same of a given data array.
     *  However, sometimes a tensor changes its identity, or rather the underlying
     *  data changes the wrapping tensor instance. &lt;br&gt;
     *  &lt;br&gt;
     *  This change currently only happens when tensors are being instantiated by
     *  certain constructors to which input tensors and a math expression is passed.
     *  This triggers the creation of a Function instance and execution on the provided
     *  input tensors. In that case the output tensor will be created somewhere
     *  along the execution call stack, however the result is expected to be 
     *  stored within the tensor whose constructor initialized all of this.
     *  In that case this tensor will rip out the guts of the resulting output
     *  tensor and stuff onto its own field variables.
     * 
     * @param tensor The tensor whose identity should be stolen.
     * @return This very tensor instance in order to enable method chaining.
     */
    protected Tsr&lt;ValType&gt; _become( Tsr&lt;ValType&gt; tensor )
    {
<span class="fc bfc" id="L1463" title="All 2 branches covered.">        if ( tensor == null ) return this;</span>
<span class="fc" id="L1464">        this.setDataType( tensor.getDataType() );</span>
<span class="fc" id="L1465">        _setData( tensor.getData() );</span>
<span class="fc" id="L1466">        setNDConf( tensor.getNDConf() );</span>
<span class="fc" id="L1467">        _flags = tensor._flags;</span>
<span class="fc" id="L1468">        _transferFrom( tensor );</span>
<span class="fc" id="L1469">        tensor._setData( null );</span>
<span class="fc" id="L1470">        tensor.setDataType( null );</span>
<span class="fc" id="L1471">        tensor.setNDConf( null );</span>
<span class="fc" id="L1472">        tensor._flags = -1;</span>
<span class="fc" id="L1473">        return this;</span>
    }



    /*==================================================================================================================
    |
    |       Â§(6) : ND-ITERATOR LOGIC :
    |   ---------------------------------------
    */

    /**
     * This method returns an iterator over the elements of this tensor. &lt;br&gt;
     *
     * @return An iterator over elements of type ValType.
     */
    @NotNull
    @Override
    public Iterator&lt;ValType&gt; iterator()
    {
<span class="fc" id="L1493">        NDIterator _ndi = NDIterator.of( this );</span>
<span class="fc" id="L1494">        return new Iterator&lt;ValType&gt;() </span>
<span class="fc" id="L1495">        {</span>
<span class="fc" id="L1496">            private int _count = 0;</span>
<span class="fc" id="L1497">            private final int _size = size();</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L1501" title="All 2 branches covered.">                return _count != _size;</span>
            }

            @Override
            public ValType next() {
<span class="fc" id="L1506">                Object o = getDataAt( _ndi.i() );</span>
<span class="fc" id="L1507">                _ndi.increment();</span>
<span class="fc" id="L1508">                _count ++;</span>
<span class="fc" id="L1509">                return (ValType) o;</span>
            }
        };
    }


    /*==================================================================================================================
    |
    |       Â§(7) : COMPONENT SPECIFIC :
    |   ---------------------------------------
    */
    /*
        -------------------------------
            Â§(7.0) : AUTO-GRAD :
        -------------------------------
        ... for more context see package 'autograd' ...
     */

    /**
     *  Tensors which are used or produced by the autograd system will have a GraphNode component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  If this tensor is part of a computation graph then this method
     *  will traverse an error backward in the recorded history towards tensors which require
     *  the accumulation of gradients.
     *
     * @param error A tensor which is back-propagated to gradients. Must match the size og this tensor.
     * @return The tensor on which this method was called. (factory pattern)
     */
    public Tsr&lt;ValType&gt; backward( Tsr&lt;ValType&gt; error ) {
<span class="pc bpc" id="L1538" title="1 of 4 branches missed.">        if ( !forComponent( GraphNode.class, node -&gt; node.backward( error ) ) &amp;&amp; this.rqsGradient() ) {</span>
<span class="fc" id="L1539">            addToGradient( error );</span>
        }
<span class="fc" id="L1541">        return this;</span>
    }

    /**
     *  Tensors which are used or produced by the autograd system will have a GraphNode component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  If this tensor is part of a computation graph then this method
     *  will traverse an error backward in the recorded history towards tensors which require
     *  the accumulation of gradients.&lt;br&gt;
     *  &lt;br&gt;
     *  This method turns the given scalar value and
     *  turns it into a matching tensor ( with the same shape)
     *  which will then be back-propagated through the
     *  recorded computation graph.
     *
     * @param value A scalar which is back-propagated to gradients. Must match the size og this tensor.
     * @return The tensor on which this method was called. (factory pattern)
     */
    public Tsr&lt;ValType&gt; backward( double value )
    {
<span class="fc" id="L1561">        backward( new Tsr( getNDConf().shape(), value ) );</span>
<span class="fc" id="L1562">        return this;</span>
    }

    /**
     *  Tensors which are used or produced by the autograd system will have a GraphNode component attached to them.
     *  This is because autograd requires recording a computation graph for back-prop traversal.
     *  If this tensor is part of a computation graph then this method
     *  will traverse an error backward in the recorded history towards tensors which require
     *  the accumulation of gradients. &lt;br&gt;
     *  &lt;br&gt;
     *  This method assumes that the user wants to back-propagate
     *  an error of &quot;1&quot; having the same shape as
     *  this tensor.
     *
     * @return The tensor on which this method was called. (factory pattern)
     */
    public Tsr&lt;ValType&gt; backward()
    {
<span class="fc" id="L1580">        backward( 1 );</span>
<span class="fc" id="L1581">        return this;</span>
    }

    /**
     *  If this tensor owns a gradient tensor as component, then it can be applied by this method. &lt;br&gt;
     *  &quot;Applying&quot; a gradient to a tensor simply means adding the values inside the gradient element-wise
     *  to the owning host tensor via an inline operation. &lt;br&gt;
     */
    public void applyGradient()
    {
        /*
           If the tensor has a JITProp component then it will triggers the continuation of the back-propagation which
           has been put on hold by saving the pending graph nodes inside the component. &lt;br&gt;
           This is because the gradient most likely has not yet been fully calculated.
         */
<span class="fc" id="L1596">        forComponent( JITProp.class, JITProp::execute );</span>
        // Afterwards the JITProp component is not needed anymore!
<span class="fc" id="L1598">        remove( JITProp.class );</span>
        // Now the gradient can be applied (Gradients are also tensors, which is why we provide its class).
<span class="fc" id="L1600">        forComponent(</span>
                Tsr.class,
                g -&gt; {
                    // If an optimizer is present then we also optimize the gradient first!
<span class="fc" id="L1604">                    forComponent( Optimizer.class, o -&gt; o.optimize( this ) );</span>
                    // And then we remove the gradient becuase it is no longer needed.
<span class="fc" id="L1606">                    remove( Tsr.class );</span>
                    // We are now ready to apply the gradient to the tensor. This is an inline operation!
                    // Therefore we need to turn off the inline operation safety net:
<span class="fc" id="L1609">                    boolean inlineSafety = Neureka.instance().settings().autograd().isPreventingInlineOperations();</span>
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">                    if ( inlineSafety ) Neureka.instance().settings().autograd().setIsPreventingInlineOperations( false );</span>
                    // INLINE OPERATION :
<span class="fc" id="L1612">                    Function.Detached.PLUS_ASSIGN.call( new Tsr[]{ this, g } ); //-&gt; Finally applying the gradient!</span>
                    // INLINE END ! -&gt; We can now revert to the previous setting:
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">                    if ( inlineSafety ) Neureka.instance().settings().autograd().setIsPreventingInlineOperations( true );</span>
<span class="fc" id="L1615">                }</span>
        );
<span class="fc" id="L1617">    }</span>

    /**
     *  &lt;b&gt;This method detaches this tensor from its underlying computation-graph
     *  or simply does nothing if no graph is present.&lt;/b&gt; &lt;br&gt;
     *  Nodes within a computation graph are instances of the &quot;GraphNode&quot; class which are also
     *  simple components of the tensors they represent in the graph. &lt;br&gt;
     *  Therefore, &quot;detaching&quot; this tensor from the graph simply means removing its GraphNode component.
     */
    public void detach()
    {
<span class="fc" id="L1628">        this.remove( GraphNode.class );</span>
<span class="fc" id="L1629">    }</span>

    /*
        ----------------------------
            Â§(7.1) : FRAMING :
        ----------------------------
        ... for more context see package 'framing'...
     */

    /**
     *  This method receives a nested String array which
     *  ought to contain a label for the index of this tensor.
     *  The index for a single element of this tensor would be an array
     *  of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows:    &lt;br&gt;
     *                                                              &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                      &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                                 &lt;br&gt;
     *                                                              &lt;br&gt;
     *
     * @param labels A nested String array containing labels for indexes of the tensor dimensions.
     * @return This tensor (method chaining).
     */
    public Tsr&lt;ValType&gt; label( String[][] labels )
    {
<span class="fc" id="L1657">        _label( null, labels );</span>
<span class="fc" id="L1658">        return this;</span>
    }

    /**
     *  This method receives a label for this tensor and a
     *  nested String array which ought to contain a
     *  label for the index of this tensor.
     *  The index for a single element of this tensor would be an array
     *  of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows:    &lt;br&gt;
     *                                                              &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                      &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                                 &lt;br&gt;
     *                                                              &lt;br&gt;
     *
     * @param tensorName A label for this tensor itself.
     * @param labels A nested String array containing labels for indexes of the tensor dimensions.
     * @return This tensor (method chaining).
     */
    public Tsr&lt;ValType&gt; label( String tensorName, String[][] labels )
    {
<span class="fc" id="L1682">        _label( tensorName, labels );</span>
<span class="fc" id="L1683">        return this;</span>
    }

    private void _label( String tensorName, String[][] labels )
    {
<span class="fc" id="L1688">        IndexAlias&lt;ValType&gt; indexAlias = find( IndexAlias.class );</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">        if ( indexAlias == null ) {</span>
<span class="fc" id="L1690">            indexAlias = new IndexAlias( this.rank(), tensorName );</span>
<span class="fc" id="L1691">            set( indexAlias );</span>
        }
<span class="pc bpc" id="L1693" title="2 of 4 branches missed.">        assert labels.length &lt;= this.rank();</span>
<span class="fc bfc" id="L1694" title="All 2 branches covered.">        for( int i = 0; i &lt; labels.length; i++ ) {</span>
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">            if ( labels[ i ] != null ) {</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">                for ( int ii = 0; ii &lt; labels[ i ].length; ii++ ) {</span>
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">                    if ( labels[ i ][ ii ] != null ) indexAlias.set( i, labels[ i ][ ii ], ii );</span>
                }
            }
        }
<span class="fc" id="L1701">    }</span>

    /**
     *  This method receives a nested String list which
     *  ought to contain a label for the index of this tensor.
     *  The index for a single element of this tensor would be an array
     *  of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows: &lt;br&gt;
     *                                                           &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                   &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                              &lt;br&gt;
     *                                                           &lt;br&gt;
     * @param labels A nested String list containing labels for indexes of the tensor dimensions.
     * @return This tensor (method chaining).
     */
    public Tsr&lt;ValType&gt; label( List&lt;List&lt;Object&gt;&gt; labels )
    {
<span class="fc" id="L1721">        IndexAlias&lt;ValType&gt; indexAlias = find( IndexAlias.class );</span>
<span class="pc bpc" id="L1722" title="1 of 2 branches missed.">        if ( indexAlias == null ) set( new IndexAlias( labels, null ) );</span>
<span class="fc" id="L1723">        return this;</span>
    }

    /**
     *  This method receives a label for this tensor and a nested
     *  String list which ought to contain a label for the index of
     *  this tensor The index for a single element of this tensor would
     *  be an array of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows: &lt;br&gt;
     *                                                           &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                   &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                              &lt;br&gt;
     *                                                           &lt;br&gt;
     * @param tensorName A label for this tensor itself.
     * @param labels A nested String list containing labels for indexes of the tensor dimensions.
     * @return This tensor (method chaining).
     */
    public Tsr&lt;ValType&gt; label( String tensorName, List&lt;List&lt;Object&gt;&gt; labels )
    {
<span class="fc" id="L1745">        IndexAlias&lt;ValType&gt; indexAlias = find( IndexAlias.class );</span>
<span class="pc bpc" id="L1746" title="1 of 2 branches missed.">        if ( indexAlias == null ) set( new IndexAlias( labels, tensorName ) );</span>
<span class="fc" id="L1747">        return this;</span>
    }

    /**
     *  This method provides the ability to
     *  label not only the indices of the shape of this tensor, but also
     *  the dimension of the shape.
     *  The first and only argument of the method expects a map instance
     *  where keys are the objects which ought to act as dimension labels
     *  and the values are lists of labels for the indices of said dimensions.
     *  For example the shape (2,3) could be labeled as follows:            &lt;br&gt;
     *  [                                                                   &lt;br&gt;
     *      &quot;dim 0&quot; : [&quot;A&quot;, &quot;B&quot;],                                           &lt;br&gt;
     *      &quot;dim 1&quot; : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                                       &lt;br&gt;
     *  ]                                                                   &lt;br&gt;
     *                                                                      &lt;br&gt;
     * @param labels A map in which the keys are dimension labels and the values are lists of index labels for the dimension.
     * @return This tensor (method chaining).
     */
    public Tsr&lt;ValType&gt; label( Map&lt;Object, List&lt;Object&gt;&gt; labels )
    {
<span class="fc" id="L1768">        this.set( new IndexAlias&lt;&gt;( labels, this, null ) );</span>
<span class="fc" id="L1769">        return this;</span>
    }

    public Tsr&lt;ValType&gt; label( String tensorName, Map&lt;Object, List&lt;Object&gt;&gt; labels )
    {
<span class="nc" id="L1774">        this.set( new IndexAlias&lt;&gt;( labels, this, tensorName ) );</span>
<span class="nc" id="L1775">        return this;</span>
    }

    /*==================================================================================================================
    |
    |       Â§(8) : (OVERLOADABLE) OPERATORS &amp; OPERATIONS :
    |   -----------------------------------------------------
    |       ...for more context see package 'calculus'...
    |*/
    /*
        -----------------------------
            Â§(8.0) : OPERATORS :
        -----------------------------
     */

    public Tsr&lt;ValType&gt; plus( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1791">        return Function.PLUS.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; plusAssign( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1795">        return Function.Detached.PLUS_ASSIGN.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; plus( Double value ) {
<span class="fc" id="L1799">        return plus( new Tsr&lt;&gt;( this.shape(), value ) );</span>
    }

    public Tsr&lt;ValType&gt; minus( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1803">        return Function.MINUS.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; minusAssign( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1807">        return Function.Detached.MINUS_ASSIGN.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; negative() {
<span class="fc" id="L1811">        return Function.NEG.call( new Tsr[]{ this } );</span>
    }

    public Tsr&lt;ValType&gt; multiply( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1815">        return Function.MUL.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; timesAssign( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1819">        return Function.Detached.MUL_ASSIGN.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; multiply( Double value ) {
<span class="fc" id="L1823">        return multiply( new Tsr&lt;&gt;( this.shape(), value ) );</span>
    }

    public Tsr&lt;ValType&gt; div( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1827">        return Function.DIV.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; div( Double value ) {
<span class="fc" id="L1831">        return div( new Tsr&lt;&gt;( this.shape(), value ) );</span>
    }

    public Tsr&lt;ValType&gt; divAssign( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1835">        return Function.Detached.DIV_ASSIGN.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; mod( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1839">        return Function.MOD.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; modAssign( Tsr&lt;ValType&gt; other ) {
<span class="nc" id="L1843">        return Function.Detached.MOD_ASSIGN.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; power( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1847">        return Function.POW.call( new Tsr[]{ this, other } );</span>
    }

    public Tsr&lt;ValType&gt; power( Double value ) {
<span class="fc" id="L1851">        return power( new Tsr&lt;&gt;( this.shape(), value ) );</span>
    }

    public Tsr&lt;ValType&gt; xor( Tsr&lt;ValType&gt; other ) {
<span class="fc" id="L1855">        return Function.POW.call( new Tsr[]{ this, other} );</span>
    }

    public Tsr&lt;ValType&gt; xor( Double value ) {
<span class="fc" id="L1859">        return xor( new Tsr&lt;&gt;( this.shape(), value ) );</span>
    }

    /*
        -----------------------------
            Â§(8.1) : OPERATIONS :
        -----------------------------
     */

    /**
     * @return A new transposed tensor with the same underlying data as this tensor.
     */
    public Tsr&lt;ValType&gt; T() // Transposed!
    {
<span class="fc" id="L1873">        StringBuilder operation = new StringBuilder();</span>
<span class="fc bfc" id="L1874" title="All 4 branches covered.">        for ( int i = rank() - 1; i &gt;= 0; i-- ) operation.append( i ).append( ( i == 0 ) ? &quot;&quot; : &quot;, &quot; );</span>
<span class="fc" id="L1875">        operation = new StringBuilder( &quot;[&quot; + operation + &quot;]:(I[ 0 ])&quot; );</span>
<span class="fc" id="L1876">        return new Tsr&lt;&gt;( this, operation.toString() );</span>
    }

    /**
     *  This method performs various operations by calling Function instances
     *  in order to ultimately calculate the mean value of all values
     *  of this very tensor!
     *  This scalar tensor is then returned.
     *
     * @return A scalar tensor which is the mean value of all values of this very tensor.
     */
    public Tsr&lt;ValType&gt; mean() {
<span class="fc" id="L1888">        Tsr&lt;ValType&gt; ones = new Tsr&lt;&gt;( this.getNDConf().shape(), 1 );</span>
<span class="fc" id="L1889">        Tsr&lt;ValType&gt; sum = Function.X.call( new Tsr[]{ this, ones } );</span>
<span class="fc" id="L1890">        return Function.DIV.call( new Tsr[]{ sum, new Tsr( this.size() ) } );</span>
        //TODO :Function.DIV.call(new Tsr[]{sum, new Tsr(this.size())});
    }

    /**
     *  This method performs a dot product between the last dimension of this tensor
     *  and the first dimension of the passed tensor.
     *
     * @param b The tensor which is the right part of the dot product operation.
     * @return A new tensor which is the dot product of this tensor and the passed one.
     */
    public Tsr&lt;ValType&gt; dot( Tsr&lt;ValType&gt; b ) {
<span class="fc" id="L1902">        Tsr&lt;ValType&gt; a = this;</span>
<span class="fc" id="L1903">        int[][] fitter = AbstractNDArray.Utility.Indexing.makeFit( a.getNDConf().shape(), b.getNDConf().shape() );</span>
<span class="fc" id="L1904">        boolean doReshape = false;</span>
<span class="fc bfc" id="L1905" title="All 6 branches covered.">        for ( int i = 0; i &lt; fitter[ 0 ].length &amp;&amp; !doReshape; i++ ) if ( fitter[ 0 ][ i ] != i ) doReshape = true;</span>
<span class="pc bpc" id="L1906" title="1 of 6 branches missed.">        for ( int i = 0; i &lt; fitter[ 1 ].length &amp;&amp; !doReshape; i++ ) if ( fitter[ 1 ][ i ] != i ) doReshape = true;</span>
<span class="fc bfc" id="L1907" title="All 2 branches covered.">        if ( doReshape ) {</span>
<span class="fc" id="L1908">            a = Function.create( AbstractNDArray.Utility.Stringify.strConf( fitter[ 0 ] ) + &quot;:(I[ 0 ])&quot; ).call( a );</span>
<span class="fc" id="L1909">            b = Function.create( AbstractNDArray.Utility.Stringify.strConf( fitter[ 1 ] ) + &quot;:(I[ 0 ])&quot; ).call( b );</span>
        }
<span class="fc" id="L1911">        return Function.X.call( new Tsr[]{ a, b } ).dimtrim();</span>
    }

    /**
     *  This method creates a new tensor sharing the same data and whose shape is trimmed.
     *  A trimmed shape is simply a shape without preceding and trailing ones.
     *  For example the shape (1x4x1x2x1) would be trimmed to (4x1x2).
     *  The underlying operation does not perform a removal of redundant ones all together.
     *  Only ones at the start and the beginning will be removed.
     *  A scalar tensor will not be affected by this operation.
     *
     * @return A tensor with the same underlying data but possibly trimmed shape without preceding or trailing ones.
     */
    public Tsr&lt;ValType&gt; dimtrim() {
<span class="fc" id="L1925">        return Function.DIMTRIM.call( this );</span>
    }

    /**
     *  This method name translates to the &quot;in&quot; keyword in Groovy!
     *  The same is true for the &quot;contains&quot; method in Kotlin.
     *  Both methods do the exact same thing, however they exist
     *  for better language support.
     *
     * @param t The tensor which will be checked.
     * @return The answer to the following question: Is the data of the provided tensor a subset of the data of this tensor?
     */
    public boolean isCase( Tsr&lt;ValType&gt; t ) {
<span class="fc" id="L1938">        boolean[] found = { false };</span>
<span class="fc" id="L1939">        this.forComponent( Relation.class, r -&gt; r.foreachChild( c -&gt; {</span>
<span class="fc bfc" id="L1940" title="All 2 branches covered.">                if ( c.equals( t ) ) found[ 0 ] = true;</span>
<span class="fc" id="L1941">            }));</span>
<span class="fc" id="L1942">        return found[ 0 ];</span>
    }

    /**
     *  This method name translates to the &quot;in&quot; keyword in Kotlin!
     *  The same is true for the &quot;isCase&quot; method in Groovy.
     *  Both methods do the exact same thing, however they exist
     *  for better language support.
     *
     * @param t The tensor which will be checked.
     * @return The answer to the following question: Is the data of the provided tensor a subset of the data of this tensor?
     */
    public boolean contains( Tsr&lt;ValType&gt; t ) {
<span class="fc" id="L1955">        return isCase( t );</span>
    }


    /*==================================================================================================================
    |
    |       Â§(9) : SLICING, INDEXING &amp; INJECTING :
    |   -----------------------------------------------------
    |       ...for more context see package 'ndim.config'...
    */
    /*
        -----------------------------
            Â§(9.0) : SLICING :
        -----------------------------
     */

    /**
     *  The following method enables access to specific elements within the tensor.
     *  The method name also translates to the subscript operator in Groovy.
     *
     * @param indices The index array of the element which should be returned.
     * @return An element located at the provided index.
     */
    public Object getAt( int[] indices ) {
<span class="nc" id="L1979">        return getDataAt( getNDConf().indexOfIndices( indices ) );</span>
    }

    /**
     *  The following method enables access to scalar values.
     *  The method name also translates to the subscript operator in Groovy.
     *
     * @param idx The index of the element which should be returned.
     * @return A scalar value located at the provided index.
     */
    public double getF64( int[] idx ) {
<span class="nc" id="L1990">        return value64( indexOfIndices( idx ) );</span>
    }


    /**
     *  The following method enables the creation of tensor slices which access
     *  the same underlying data (possibly from a different view).
     *  The method name also translates to the subscript operator in Groovy.
     *
     * @param args An arbitrary number of arguments which can be used for slicing.
     * @return A slice tensor created based on the passed keys.
     */
    public Tsr&lt;ValType&gt; getAt( Object... args ) {
<span class="fc" id="L2003">        List&lt;Object&gt; argsList = Arrays.asList( args );</span>
<span class="fc" id="L2004">        return getAt( argsList );</span>
    }

    /**
     *  This getter method creates and returns a slice of the original tensor.
     *  The returned slice is a scalar tensor wrapping a single value element which
     *  is being targeted by the provided integer index.
     *
     * @param i The index of the value item which should be returned as a tensor instance.
     * @return A tensor holding a single value element which is internally still residing in the original tensor.
     */
    public Tsr&lt;ValType&gt; getAt( int i ) {
<span class="fc" id="L2016">        return getAt( new Object[]{ i, i } );</span>
    }

    /**
     *  The following method returns a raw value item within this tensor
     *  targeted by a scalar index.
     *
     * @param i The scalar index of the value item which should be returned by the method.
     * @return The value item found at the targeted index.
     */
    public ValType getValueAt( int i ) {
<span class="fc" id="L2027">        return (ValType) getDataAt( getNDConf().indexOfIndex( i ) );</span>
    }

    /**
     *  This method returns a raw value item within this tensor
     *  targeted by an index array which is expect to hold an index for
     *  every dimension of the shape of this tensor.
     *  So the provided array must have the same length as the
     *  rank of this tensor!
     *
     * @param indices The index array which targets a single value item within this tensor.
     * @return The found raw value item targeted by the provided index array.
     */
    public ValType getValueAt( int[] indices ) {
<span class="fc" id="L2041">        return (ValType) getDataAt( getNDConf().indexOfIndices( indices ) );</span>
    }

    /**
     *  Individual entries for value items in this tensor can be set
     *  via this method.
     *
     * @param i The scalar index targeting a specific value position within this tensor
     *          which ought to be replaced by the one provided by the second parameter
     *          of this method.
     *
     * @param o The item which ought to be placed at the targeted position.
     * @return This very tensor in order to enable method chaining...
     */
    public Tsr&lt;ValType&gt; setAt( int i, ValType o ) {
<span class="fc" id="L2056">        setDataAt( getNDConf().indexOfIndex( i ), o );</span>
<span class="fc" id="L2057">        return this;</span>
    }

    public Tsr&lt;ValType&gt; getAt( double i ) {
<span class="nc" id="L2061">        return getAt( Arrays.asList( getNDConf().indicesOfIndex( (int) Math.floor( i ) ) ).toArray() );</span>
    }

    public Tsr&lt;ValType&gt; getAt( BigDecimal i ) {
<span class="fc" id="L2065">        return getAt( Arrays.asList( getNDConf().indicesOfIndex(( i ).intValue()) ).toArray() );</span>
    }

    public Object getAt( Map&lt;?,?&gt; rangToStrides )
    {
<span class="pc bpc" id="L2070" title="1 of 2 branches missed.">        if ( rangToStrides == null ) return this;</span>
<span class="fc" id="L2071">        int[] newOffset = new int[ this.rank() ]; // ...not a simple slice... Advanced:</span>
<span class="fc" id="L2072">        int[] newSpread = new int[ this.rank() ];</span>
<span class="fc" id="L2073">        int[] newShape = new int[ this.rank() ];</span>
<span class="fc" id="L2074">        Object[] ranges = rangToStrides.keySet().toArray();</span>
<span class="fc" id="L2075">        _configureSubsetFromRanges( ranges, newOffset, newSpread, newShape, 0 );</span>
<span class="fc" id="L2076">        Object[] steps = rangToStrides.values().toArray();</span>
<span class="fc bfc" id="L2077" title="All 2 branches covered.">        for ( int i = 0; i &lt; this.rank(); i++ ) {</span>
<span class="fc" id="L2078">            newSpread[ i ] = (Integer) steps[ i ];</span>
<span class="fc" id="L2079">            newShape[ i ] /= (Integer) steps[ i ];</span>
        }
<span class="fc" id="L2081">        return _sliceOf( newShape, newOffset, newSpread );</span>
    }

    public Tsr&lt;ValType&gt; shallowCopy()
    {
<span class="pc bpc" id="L2086" title="1 of 4 branches missed.">        if ( this.isEmpty() || this.isUndefined() ) return this;</span>
<span class="fc" id="L2087">        List&lt;List&lt;Integer&gt;&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2088" title="All 2 branches covered.">        for ( int e : this.shape() ) {</span>
<span class="fc" id="L2089">            List&lt;Integer&gt; rangeAsList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2090" title="All 2 branches covered.">            for ( int i = 0; i &lt; e; i++ ) rangeAsList.add( i );</span>
<span class="fc" id="L2091">            ranges.add( rangeAsList);</span>
<span class="fc" id="L2092">        }</span>
<span class="fc" id="L2093">        return getAt( ranges.toArray() );</span>
    }

    /**
     *  This method enables tensor slicing!
     *  It takes a key of various types and configures a slice
     *  tensor which shares the same underlying data as the original tensor.
     *
     * @param key This object might be a wide range of objects including maps, lists or arrays...
     * @return A slice tensor or scalar value.
     */
    public Tsr&lt;ValType&gt; getAt( Object key ) {
<span class="pc bpc" id="L2105" title="1 of 2 branches missed.">        if ( key == null ) return this;</span>
<span class="pc bpc" id="L2106" title="3 of 4 branches missed.">        if ( key instanceof Object[] &amp;&amp; ((Object[]) key).length == 0 ) key = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2107" title="All 4 branches covered.">        if ( key instanceof List &amp;&amp; ( (List&lt;?&gt;) key ).isEmpty() ) {</span>
            /*
                An empty List instance is being interpreted as
                the request to create an identical slice, meaning that the
                resulting tensor views the same data as its parent while not
                being the same instance. (In a sense, its a shallow copy!)
             */
<span class="fc" id="L2114">            return shallowCopy();</span>
        }

<span class="fc" id="L2117">        int[] newOffset = new int[ this.rank() ];</span>
<span class="fc" id="L2118">        int[] newSpread = new int[ this.rank() ];</span>
<span class="fc" id="L2119">        int[] newShape = new int[ this.rank() ];</span>
<span class="fc bfc" id="L2120" title="All 2 branches covered.">        key = ( key instanceof List ) ? ((List&lt;?&gt;) key).toArray() : key;</span>

<span class="fc bfc" id="L2122" title="All 2 branches covered.">        if ( key instanceof Object[] ) {</span>
<span class="fc" id="L2123">            boolean allInt = true;</span>
<span class="fc bfc" id="L2124" title="All 6 branches covered.">            for ( Object o : (Object[]) key ) allInt = allInt &amp;&amp; o instanceof Integer;</span>
<span class="fc bfc" id="L2125" title="All 4 branches covered.">            if ( allInt &amp;&amp; ((Object[]) key).length == rank() ) {</span>
<span class="fc" id="L2126">                newOffset = _intArray((Object[]) key);</span>
<span class="pc bpc" id="L2127" title="1 of 2 branches missed.">                if ( newOffset != null ) {</span>
<span class="fc bfc" id="L2128" title="All 2 branches covered.">                    for ( int i = 0; i &lt; this.rank(); i++ )</span>
<span class="fc bfc" id="L2129" title="All 2 branches covered.">                        newOffset[i] = ( newOffset[i] &lt; 0 ) ? getNDConf().shape( i ) + newOffset[ i ] : newOffset[ i ];</span>
<span class="fc bfc" id="L2130" title="All 2 branches covered.">                    for ( int i = 0; i &lt; this.rank(); i++ )</span>
<span class="fc" id="L2131">                        ((Object[])key)[i] = newOffset[i];</span>
<span class="fc" id="L2132">                    allInt = false;</span>
                }
            }
<span class="fc" id="L2135">            boolean hasScale = false;</span>
<span class="pc bpc" id="L2136" title="1 of 6 branches missed.">            for ( Object o : (Object[]) key ) hasScale = hasScale || o instanceof Map;</span>
<span class="fc bfc" id="L2137" title="All 2 branches covered.">            if ( allInt ) _configureSubsetFromRanges(</span>
<span class="fc" id="L2138">                    new Object[]{ _intArray( (Object[]) key ) },</span>
                    newOffset, newSpread,
                    newShape,
                    0
            );
<span class="fc" id="L2143">            else _configureSubsetFromRanges( (Object[]) key, newOffset, newSpread, newShape, 0 );</span>
<span class="fc" id="L2144">        } else {</span>
<span class="fc" id="L2145">            String message = &quot;Cannot create tensor slice from key of type '&quot; + key.getClass().getName() + &quot;'!&quot;;</span>
<span class="fc" id="L2146">            _LOG.error( message );</span>
<span class="fc" id="L2147">            throw new IllegalArgumentException( message );</span>
        }
<span class="fc" id="L2149">        return _sliceOf( newShape, newOffset, newSpread );</span>
    }

    private Tsr&lt;ValType&gt; _sliceOf( int[] newShape, int[] newOffset, int[] newSpread )
    {
<span class="fc" id="L2154">        this.setIsVirtual( false );</span>
<span class="fc" id="L2155">        Tsr&lt;ValType&gt; subset = new Tsr&lt;&gt;();</span>
<span class="fc" id="L2156">        subset.setDataType( this.getDataType() );</span>
<span class="fc" id="L2157">        subset._setData( this.getData() );</span>
<span class="fc" id="L2158">        int[] newTranslation = getNDConf().translation();</span>
<span class="fc" id="L2159">        int[] newIdxmap = NDConfiguration.Utility.newTlnOf( newShape );</span>

<span class="fc bfc" id="L2161" title="All 2 branches covered.">        for ( int i = 0; i &lt; this.rank(); i++ )</span>
<span class="fc bfc" id="L2162" title="All 2 branches covered.">            newSpread[ i ] = ( newSpread[i] == 0 ) ? 1 : newSpread[ i ];</span>

<span class="fc bfc" id="L2164" title="All 2 branches covered.">        for ( int i = 0; i &lt; newOffset.length; i++ )</span>
<span class="fc" id="L2165">            newOffset[ i ] = newOffset[ i ] + getNDConf().offset( i ); // Offset is being inherited!</span>

<span class="fc bfc" id="L2167" title="All 2 branches covered.">        Tsr&lt;?&gt; rootTensor = ( this.isSlice() ) ? find( Relation.class ).findRootTensor() : this;</span>
<span class="fc bfc" id="L2168" title="All 2 branches covered.">        Tsr&lt;?&gt; parentTensor = ( this.isSlice() ) ? find( Relation.class ).getParent() : this;</span>
        /*
            The following code check the validity of the slice shape ranges with
            respect to the 'parentTensor' of this new slice.
         */
<span class="fc bfc" id="L2173" title="All 4 branches covered.">        if( parentTensor.rank() != newShape.length || rootTensor != parentTensor ) {</span>
            // TODO! This requires some more thought about how to check this!
            // THIS CASE HAS NOT YET BEEN THOUGHT TROUGH!
        } else {
            /*
                1. We know that inside this else branch 'this' tensor is a first order slice!
                (So it is not a slice of a slice... reason : 'rootTensor == parentTensor' )

                2. There is however uncertainty about the 'true shape' of this parent tensor!
                Meaning : It might have been reshaped and could therefore be distorted with
                respect to the slice that is currently being prepared!
                -&gt; This means we have to take this possible reshaping into account!
                Like so:

                The following uses an int array also called 'reshapeRelation'.
                This is simply the 'reshape array' which has been recorded inside the 'Relation' component
                by the 'Reshape' operation! ( Hopefully! :) ... custom shape operations need to consider this as well! )

                The following would occur when : &quot;new Tsr(...).T().gatAt(...);&quot;
                Transposing a tensor performs an inline reshaping of an identical
                slice of the original tensor! Then again slicing this tensor
                via the 'getAt(...)' method leads us to a situation where
                the following variable is NOT NULL! :
             */
<span class="fc bfc" id="L2197" title="All 2 branches covered.">            int[] reshaped = ( this.isSlice() ) ? parentTensor.find( Relation.class ).getReshapeRelationFor( this ) : null;</span>
<span class="fc bfc" id="L2198" title="All 2 branches covered.">            reshaped = ( reshaped != null ) ? Reshape.invert( reshaped ) : null;</span>
<span class="fc bfc" id="L2199" title="All 2 branches covered.">            for ( int i = 0; i &lt; parentTensor.rank(); i++ ) {</span>
<span class="fc bfc" id="L2200" title="All 2 branches covered.">                int ii = ( reshaped != null ) ? reshaped[ i ] : i;</span>
<span class="fc" id="L2201">                int top = newOffset[ i ] + newShape[ i ];</span>
<span class="fc bfc" id="L2202" title="All 2 branches covered.">                if ( top &gt; parentTensor.shape( ii ) ) {</span>
<span class="fc" id="L2203">                    String message =</span>
                            &quot;Cannot create slice because ranges are out of the bounds of the targeted tensor.\n&quot; +
                                    &quot;At index '&quot; + i + &quot;' : offset '&quot; + newOffset[ i ] + &quot;' + shape '&quot; + newShape[ i ] + &quot;' = '&quot; + top + &quot;',\n&quot; +
<span class="fc" id="L2206">                                    &quot;which is larger than the target shape '&quot; + parentTensor.shape( ii ) + &quot;' at the same index!&quot;;</span>
<span class="fc" id="L2207">                    Exception exception = new IllegalArgumentException( message );</span>
<span class="fc" id="L2208">                    _LOG.error( message, exception );</span>
<span class="fc" id="L2209">                    throw new IllegalArgumentException( exception );</span>
                }
            }
        }

<span class="fc" id="L2214">        subset.setNDConf( AbstractNDC.construct( newShape, newTranslation, newIdxmap, newSpread, newOffset ) );</span>

<span class="fc bfc" id="L2216" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="fc" id="L2217">            Device&lt;ValType&gt; device = this.find( Device.class );</span>
<span class="fc" id="L2218">            device.store( subset, this );</span>
<span class="fc" id="L2219">            subset.setIsOutsourced( true );</span>
        }
<span class="pc bpc" id="L2221" title="1 of 2 branches missed.">        if ( this.isVirtual() ) subset.setIsVirtual( true );</span>
<span class="fc" id="L2222">        subset.set( new Relation().addParent( this ) );</span>
<span class="fc" id="L2223">        Relation&lt;ValType&gt; parent = find( Relation.class );</span>
<span class="fc bfc" id="L2224" title="All 2 branches covered.">        parent = ( parent != null ) ? parent : new Relation&lt;&gt;();</span>
<span class="fc" id="L2225">        parent.addChild( subset );</span>
<span class="fc" id="L2226">        this.set( parent );</span>
<span class="fc" id="L2227">        return subset;</span>
    }


    /**
     *
     * @param ranges Elements of this array are either one of:
     *               &lt;ul style=&quot;margin-left: 60px;&quot;&gt;
     *                  &lt;li&gt; A map whose first entry represents a mapping between range and steps.
     *                  &lt;li&gt; A list from which a first and last entry will be interpreted as range.
     *                  &lt;li&gt; Any other object which might bew found in a 'IndexAlias' component.
     *              &lt;/ul&gt;
     *
     * @param offset Start index for every rank.
     * @param newShape New shape of the new sub-tensor.
     * @param dimIndex Dimension index/offset, incremented according to recursive calls.
     * @return A new rank index.
     */
    private int _configureSubsetFromRanges(
            Object[] ranges,
            int[] offset,  int[] spread,
            int[] newShape,
            int dimIndex
    ) {
<span class="fc bfc" id="L2251" title="All 2 branches covered.">        for ( int i = 0; i &lt; ranges.length; i++ ) {</span>
<span class="fc" id="L2252">            int first = 0;</span>
<span class="fc" id="L2253">            int last = 0;</span>
<span class="fc bfc" id="L2254" title="All 2 branches covered.">            if ( ranges[ i ] instanceof int[] ) {</span>
<span class="fc" id="L2255">                List&lt;Integer&gt; intList = new ArrayList&lt;&gt;( ( (int[]) ranges[ i ] ).length );</span>
<span class="fc bfc" id="L2256" title="All 2 branches covered.">                for ( int ii : (int[]) ranges[ i ] ) intList.add( ii );</span>
<span class="fc" id="L2257">                ranges[ i ] = intList;</span>
<span class="fc bfc" id="L2258" title="All 2 branches covered.">            } else if ( ranges[ i ] instanceof String[] ) {</span>
<span class="fc" id="L2259">                List&lt;String&gt; strList = new ArrayList&lt;&gt;( ( (String[]) ranges[ i ] ).length);</span>
<span class="fc bfc" id="L2260" title="All 2 branches covered.">                for ( String ii : (String[]) ranges[ i ] ) strList.add( ii );</span>
<span class="fc" id="L2261">                ranges[ i ] = strList;</span>
            }
<span class="fc bfc" id="L2263" title="All 2 branches covered.">            if ( !( ranges[ i ] instanceof  List ) ) {</span>
<span class="fc bfc" id="L2264" title="All 2 branches covered.">                if ( ranges[ i ] instanceof Map ) {</span>
<span class="fc" id="L2265">                    Object[] ks = ( (Map&lt;?,?&gt;) ranges[ i ] ).keySet().toArray();</span>
<span class="fc" id="L2266">                    Object[] steps = ( (Map&lt;?,?&gt;) ranges[ i ]).values().toArray();</span>
<span class="fc" id="L2267">                    int newI = _configureSubsetFromRanges( ks, offset, spread, newShape, i + dimIndex );</span>
<span class="fc bfc" id="L2268" title="All 2 branches covered.">                    for ( int ii = 0; ii &lt; steps.length; ii++ ) {</span>
<span class="fc" id="L2269">                        spread[ ii + i + dimIndex ] = (Integer) steps[ ii ];</span>
<span class="fc" id="L2270">                        newShape[ ii + i + dimIndex ] /= spread[ ii + i + dimIndex ];</span>
                    }
<span class="fc" id="L2272">                    i = newI;</span>
<span class="fc" id="L2273">                    continue;</span>
<span class="fc bfc" id="L2274" title="All 2 branches covered.">                } else if ( ranges[ i ] instanceof Integer ) {</span>
<span class="fc" id="L2275">                    first = (Integer) ranges[ i ];</span>
<span class="fc" id="L2276">                    last = (Integer) ranges[ i ];</span>
                } else {
<span class="fc" id="L2278">                    IndexAlias&lt;?&gt; indexAlias = find( IndexAlias.class );</span>
<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">                    if ( indexAlias != null ) {</span>
<span class="fc" id="L2280">                        int position = indexAlias.get( ranges[ i ], i + dimIndex );</span>
<span class="fc" id="L2281">                        first = position;</span>
<span class="fc" id="L2282">                        last = position;</span>
<span class="fc" id="L2283">                    } else {</span>
<span class="nc" id="L2284">                        String message = &quot;Given indexAlias key at axis &quot; + ( i + dimIndex ) + &quot; not found!&quot;;</span>
<span class="nc" id="L2285">                        _LOG.error( message );</span>
<span class="nc" id="L2286">                        throw new IllegalStateException( message );</span>
                    }
<span class="fc" id="L2288">                }</span>
            } else {
<span class="fc" id="L2290">                ranges[ i ] = ( (List&lt;?&gt;) ranges[ i ] ).toArray();</span>
<span class="fc bfc" id="L2291" title="All 2 branches covered.">                ranges[ i ] = ( ( (Object[]) ranges[ i ] )[ 0 ] instanceof List )</span>
<span class="fc" id="L2292">                        ? ( (List&lt;?&gt;) ( (Object[]) ranges[ i ] )[ 0 ] ).toArray()</span>
<span class="fc" id="L2293">                        : ( (Object[]) ranges[ i ] );</span>
<span class="pc bpc" id="L2294" title="1 of 4 branches missed.">                if (</span>
                        !( ( (Object[]) ( ranges[ i ] ) )[ 0 ] instanceof Integer )
                                || !( ( (Object[]) ranges[ i ] )[ ( (Object[]) ( ranges[ i ] ) ).length - 1 ] instanceof Integer )
                ) {
<span class="fc" id="L2298">                    IndexAlias&lt;?&gt; indexAlias = find( IndexAlias.class );</span>
<span class="pc bpc" id="L2299" title="1 of 2 branches missed.">                    if ( !( ( (Object[]) (ranges[ i ]) )[ 0 ] instanceof Integer ) ) {</span>
<span class="pc bpc" id="L2300" title="1 of 2 branches missed.">                        if ( indexAlias != null ) {</span>
<span class="fc" id="L2301">                            first = indexAlias.get( ( (Object[]) ranges[ i ])[ 0 ], i + dimIndex );</span>
                        }
                    }
<span class="nc" id="L2304">                    else first = (Integer) ( (Object[]) ranges[ i ] )[ 0 ];</span>

<span class="pc bpc" id="L2306" title="1 of 2 branches missed.">                    if ( !( ( (Object[]) ranges[ i ] )[ ( (Object[]) ranges[ i ] ).length - 1 ] instanceof Integer )  ) {</span>
<span class="pc bpc" id="L2307" title="1 of 2 branches missed.">                        if ( indexAlias != null ) {</span>
<span class="fc" id="L2308">                            last = indexAlias.get(</span>
                                    ( (Object[]) ranges[ i ] )[ ( (Object[]) ranges[ i ] ).length - 1 ],
<span class="fc" id="L2310">                                    i + dimIndex</span>
                            );
                        }
                    }
<span class="nc" id="L2314">                    else last = (Integer) ( (Object[]) ranges[ i ] )[ ( (Object[]) ranges[ i ] ).length - 1 ];</span>

<span class="fc" id="L2316">                } else {</span>
<span class="fc" id="L2317">                    first = (Integer)( (Object[]) ranges[ i ] )[ 0 ];</span>
<span class="fc" id="L2318">                    last = (Integer) ( (Object[]) ranges[ i ] )[ ( (Object[]) ranges[ i ] ).length - 1 ];</span>
                }
            }
<span class="pc bpc" id="L2321" title="1 of 6 branches missed.">            if ( first &lt; 0 &amp;&amp; last &lt; 0 &amp;&amp; first &gt; last ) {</span>
<span class="fc" id="L2322">                int temp = first;</span>
<span class="fc" id="L2323">                first = last;</span>
<span class="fc" id="L2324">                last = temp;</span>
            }
<span class="fc bfc" id="L2326" title="All 2 branches covered.">            first = ( first &lt; 0 ) ? getNDConf().shape( i ) + first : first;</span>
<span class="fc bfc" id="L2327" title="All 2 branches covered.">            last = ( last &lt; 0 ) ? getNDConf().shape( i ) + last : last;</span>
<span class="fc" id="L2328">            newShape[ i + dimIndex ] = ( last - first ) + 1;</span>
<span class="fc" id="L2329">            offset[ i + dimIndex ] = first;</span>
        }
<span class="fc" id="L2331">        return ranges.length + dimIndex - 1;</span>
    }


    /*
        -----------------------------
            Â§(9.1) : INJECTING :
        -----------------------------
     */

    /**
     *  This method enables injecting slices of tensor to be assigned into this tensor!
     *  It takes a key of various types which is used to configure a slice
     *  tensor sharing the same underlying data as the original tensor.
     *  This slice is then used to assign the second argument to it, namely
     *  the &quot;value&quot; argument.
     *
     * @param key This object is a list defining a targeted index or range of indices...
     * @return A slice tensor or scalar value.
     */
    public Tsr&lt;ValType&gt; putAt( List&lt;?&gt; key, Tsr&lt;ValType&gt; value ) {
<span class="fc" id="L2352">        _putAtCheckFor( value );</span>
<span class="pc bpc" id="L2353" title="1 of 2 branches missed.">        Tsr&lt;ValType&gt; slice = ( key == null ) ? this : (Tsr) getAt( key );</span>
<span class="fc" id="L2354">        return _putAt( slice, value );</span>
    }

    /**
     *  This method enables injecting slices of tensor to be assigned into this tensor!
     *  It takes a key which is used to configure a slice
     *  tensor sharing the same underlying data as the original tensor.
     *  This slice is then used to assign the second argument to it, namely
     *  the &quot;value&quot; argument.
     *
     * @param key This object is a map defining a stride and a targeted index or range of indices...
     * @return A slice tensor or scalar value.
     */
    public Tsr&lt;ValType&gt; putAt( Map&lt;?,?&gt; key, Tsr&lt;ValType&gt; value ) {
<span class="fc" id="L2368">        _putAtCheckFor( value );</span>
<span class="pc bpc" id="L2369" title="1 of 2 branches missed.">        Tsr&lt;ValType&gt; slice = ( key == null ) ? this : (Tsr&lt;ValType&gt;) getAt( key );</span>
<span class="fc" id="L2370">        return _putAt( slice, value );</span>
    }

    private void _putAtCheckFor( Tsr&lt;?&gt; value ) {
<span class="fc bfc" id="L2374" title="All 2 branches covered.">        if ( value.isEmpty() ) {</span>
<span class="fc" id="L2375">            String message = &quot;Provided tensor is empty! Empty tensors cannot be injected.&quot;;</span>
<span class="fc" id="L2376">            _LOG.error( message );</span>
<span class="fc" id="L2377">            throw new IllegalArgumentException( message );</span>
        }
<span class="fc" id="L2379">    }</span>

    private Tsr&lt;ValType&gt; _putAt( Tsr&lt;ValType&gt; slice, Tsr&lt;ValType&gt; value )
    {
<span class="fc" id="L2383">        boolean valueIsDeviceVisitor = false;</span>
<span class="fc bfc" id="L2384" title="All 4 branches covered.">        if ( slice.isOutsourced() &amp;&amp; !value.isOutsourced() ) {</span>
<span class="fc" id="L2385">            Device&lt;ValType&gt; device = slice.find( Device.class );</span>
            try {
<span class="fc" id="L2387">                device.store( value );</span>
<span class="nc" id="L2388">            } catch ( Exception exce ) {</span>
<span class="nc" id="L2389">                _LOG.error( &quot;Trying to migrate target slice tensor to device failed.&quot;, exce );</span>
<span class="nc" id="L2390">                throw exce;</span>
<span class="fc" id="L2391">            }</span>
<span class="fc" id="L2392">            valueIsDeviceVisitor = true;</span>
        }
<span class="pc bpc" id="L2394" title="2 of 6 branches missed.">        if ( this.isEmpty() &amp;&amp; slice.isEmpty() || slice.size() != value.size() ) _become( value ); // TODO: Rethink this a little</span>
<span class="fc" id="L2395">        else new Tsr( new Tsr[]{ slice, value }, &quot;I[ 0 ] &lt;- I[ 1 ]&quot;, false );</span>
        try {
<span class="fc bfc" id="L2397" title="All 2 branches covered.">            if ( valueIsDeviceVisitor ) value.find( Device.class ).restore( value );</span>
<span class="nc" id="L2398">        } catch ( Exception exception ) {</span>
<span class="nc" id="L2399">            _LOG.error( &quot;Trying to migrate source tensor back to original location failed.&quot;, exception );</span>
<span class="nc" id="L2400">            throw exception;</span>
<span class="fc" id="L2401">        }</span>
<span class="fc" id="L2402">        return this;</span>
    }

    /**
     *  This is a static nested utility class
     *  which is used to allow for fast access to
     *  tensors storing doubles.
     */
<span class="nc" id="L2410">    @NoArgsConstructor</span>
    public static class IO
    {
        public static double getFrom( Tsr&lt;?&gt; t, int i ) {
<span class="pc bpc" id="L2414" title="2 of 4 branches missed.">            if ( t.isEmpty() || t.isUndefined() ) return 0;</span>
<span class="fc bfc" id="L2415" title="All 2 branches covered.">            else if ( t.isVirtual() ) return t.value64()[ 0 ];</span>
<span class="fc" id="L2416">            return t.value64()[ t.indexOfIndex( i ) ];</span>
        }

        public static double getFrom( Tsr&lt;?&gt; t, int[] idx ) {
<span class="fc" id="L2420">            t.setIsVirtual( false );</span>
<span class="fc" id="L2421">            return t.value64()[ t.indexOfIndices( idx ) ];</span>
        }

        public static void setInto( Tsr&lt;?&gt; t, int i, double value ) {
<span class="fc" id="L2425">            t.setIsVirtual( false );</span>
<span class="fc" id="L2426">            t.value64()[ t.indexOfIndex( i ) ] = value;</span>
<span class="fc" id="L2427">        }</span>

        public static void setInto( Tsr&lt;?&gt; t, int[] idx, double value ) {
<span class="fc" id="L2430">            t.setIsVirtual( false );</span>
<span class="fc" id="L2431">            t.value64()[ t.indexOfIndices( idx ) ] = value;</span>
<span class="fc" id="L2432">        }</span>

        public static void addInto( Tsr&lt;?&gt; t, int i, double value ) {
<span class="fc" id="L2435">            t.setIsVirtual( false );</span>
<span class="fc" id="L2436">            t.value64()[ t.indexOfIndex( i ) ] += value;</span>
<span class="fc" id="L2437">        }</span>

        public static void addInto( Tsr&lt;?&gt; t, int[] idx, double value ) {
<span class="fc" id="L2440">            t.setIsVirtual( false );</span>
<span class="fc" id="L2441">            t.value64()[ t.indexOfIndices( idx ) ] += value;</span>
<span class="fc" id="L2442">        }</span>

        public static Tsr&lt;?&gt; addInto( Tsr&lt;?&gt; t, Tsr&lt;?&gt; source ) {
<span class="pc bpc" id="L2445" title="3 of 4 branches missed.">            if ( t.isVirtual() &amp;&amp; source.isVirtual() ) t.value64()[ 0 ] += source.value64()[ 0 ];</span>
<span class="fc" id="L2446">            else FunctionBuilder.build( &quot;I[ 0 ]&lt;-(I[ 0 ]+I[ 1 ])&quot;, false ).call( new Tsr[]{ t, source } );</span>
<span class="fc" id="L2447">            return source;</span>
        }

        public static void subInto( Tsr&lt;?&gt; t, int i, double value ) {
<span class="fc" id="L2451">            t.setIsVirtual( false );</span>
<span class="fc" id="L2452">            t.value64()[ t.indexOfIndex( i ) ] -= value;</span>
<span class="fc" id="L2453">        }</span>

        public static void subInto( Tsr&lt;?&gt; t, int[] idx, double value ) {
<span class="fc" id="L2456">            t.setIsVirtual( false );</span>
<span class="fc" id="L2457">            t.value64()[ t.indexOfIndices( idx ) ] -= value;</span>
<span class="fc" id="L2458">        }</span>

        public static void subInto( Tsr&lt;?&gt; t, Tsr&lt;?&gt; source ) {
<span class="pc bpc" id="L2461" title="3 of 4 branches missed.">            if ( t.isVirtual() &amp;&amp; source.isVirtual() ) {</span>
<span class="nc" id="L2462">                t.value64()[ 0 ] -= source.value64()[ 0 ];</span>
            } else {
<span class="pc bpc" id="L2464" title="1 of 2 branches missed.">                if ( t.isVirtual() ) t.setIsVirtual( false );</span>
<span class="fc" id="L2465">                int[] index = new int[ t.getNDConf().shape().length ];</span>
<span class="fc" id="L2466">                int size = t.size();</span>
<span class="fc bfc" id="L2467" title="All 2 branches covered.">                for ( int i = 0; i &lt; size; i++ ) {</span>
<span class="fc" id="L2468">                    IO.subInto( t, index, IO.getFrom( source, index ) );</span>
<span class="fc" id="L2469">                    NDConfiguration.Utility.increment( index, t.getNDConf().shape() );</span>
                }
            }
<span class="fc" id="L2472">        }</span>

        public static void mulInto( Tsr&lt;?&gt; t, int i, double value ) {
<span class="fc" id="L2475">            t.setIsVirtual( false );</span>
<span class="fc" id="L2476">            t.value64()[ t.indexOfIndex( i ) ] *= value;</span>
<span class="fc" id="L2477">        }</span>

        public static void mulInto( Tsr&lt;?&gt; t, int[] idx, double value ) {
<span class="fc" id="L2480">            t.setIsVirtual( false );</span>
<span class="fc" id="L2481">            t.value64()[ t.indexOfIndices( idx ) ] *= value;</span>
<span class="fc" id="L2482">        }</span>

    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     *  A tensor ought to have some way to access its underlying data array.
     *  This method simple returns an element within this data array sitting at position &quot;i&quot;.
     * @param i The position of the targeted item within the raw data array of the tensor.
     * @return The found object sitting at the specified index position.
     */
    @Override
    public Object getDataAt( int i )
    {
<span class="fc bfc" id="L2497" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="fc" id="L2498">            Device&lt;ValType&gt; device = this.find( Device.class );</span>
<span class="pc bpc" id="L2499" title="1 of 2 branches missed.">            if ( device instanceof OpenCLDevice ) {</span>
<span class="fc" id="L2500">                return ( (OpenCLDevice) device ).value64f( (Tsr&lt;Number&gt;) this, i );</span>
            }
<span class="nc" id="L2502">        }</span>
<span class="fc bfc" id="L2503" title="All 2 branches covered.">        else if ( getData() instanceof float[] ) return ( (float[]) getData())[ i ];</span>
<span class="fc bfc" id="L2504" title="All 2 branches covered.">        else if ( getData() instanceof double[] ) return ( (double[]) getData())[ i ];</span>
<span class="fc bfc" id="L2505" title="All 2 branches covered.">        else if ( getData() instanceof short[] ) return ( (short[]) getData())[ i ];</span>
<span class="pc bpc" id="L2506" title="1 of 2 branches missed.">        else if ( getData() instanceof int[] ) return ( (int[]) getData())[ i ];</span>
<span class="pc bpc" id="L2507" title="1 of 2 branches missed.">        else if ( getData() instanceof byte[] ) return ( (byte[]) getData())[ i ];</span>
<span class="pc bpc" id="L2508" title="1 of 2 branches missed.">        else if ( getData() instanceof long[] ) return ( (long[]) getData())[ i ];</span>
<span class="fc" id="L2509">        else return ( (ValType[]) getData())[ i ];</span>
<span class="nc" id="L2510">        return null;</span>
    }

    /**
     *  A tensor ought to have some way to selectively modify its underlying data array.
     *  This method simply returns an element within this data array sitting at position &quot;i&quot;.
     * @param i The index of the data array entry which ought to be addressed.
     * @param o The object which ought to be placed at the requested position.
     * @return This very tensor in order to enable method chaining.
     */
    @Override
    public Tsr&lt;ValType&gt; setDataAt( int i, ValType o ) {
<span class="pc bpc" id="L2522" title="1 of 2 branches missed.">        if ( getData() instanceof Object[] ) ( (Object[]) getData() )[ i ] = o;</span>
<span class="nc bnc" id="L2523" title="All 2 branches missed.">        else if ( getData() instanceof float[]  ) ( (float[])  getData() )[ i ] = (float)  o;</span>
<span class="nc bnc" id="L2524" title="All 2 branches missed.">        else if ( getData() instanceof double[] ) ( (double[]) getData() )[ i ] = (double) o;</span>
<span class="nc bnc" id="L2525" title="All 2 branches missed.">        else if ( getData() instanceof int[]    ) ( (int[])    getData() )[ i ] = (int)    o;</span>
<span class="nc bnc" id="L2526" title="All 2 branches missed.">        else if ( getData() instanceof long[]   ) ( (long[])   getData() )[ i ] = (long)   o;</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">        else if ( getData() instanceof short[]  ) ( (short[])  getData() )[ i ] = (short)  o;</span>
<span class="nc bnc" id="L2528" title="All 2 branches missed.">        else if ( getData() instanceof byte[]   ) ( (byte[])   getData() )[ i ] = (byte)   o;</span>
<span class="fc" id="L2529">        return this;</span>
    }

    public Tsr&lt;ValType&gt; setValue64( double[] value ) {
<span class="fc bfc" id="L2533" title="All 2 branches covered.">        if ( this.isOutsourced() ) this.find( Device.class ).overwrite64( this, value );</span>
<span class="fc bfc" id="L2534" title="All 2 branches covered.">        else if ( getData() == null ) {</span>
<span class="fc" id="L2535">            setDataType( DataType.of( F64.class ) );</span>
<span class="fc" id="L2536">            _setData( value );</span>
        }
<span class="fc bfc" id="L2538" title="All 2 branches covered.">        else if ( getData() instanceof float[] )</span>
<span class="fc bfc" id="L2539" title="All 2 branches covered.">            for ( int i = 0; i &lt; value.length; i++ ) ( (float[]) getData())[ i ] = (float) value[ i ];</span>
<span class="pc bpc" id="L2540" title="1 of 2 branches missed.">        else if ( getData() instanceof double[] )</span>
<span class="fc bfc" id="L2541" title="All 2 branches covered.">            for ( int i = 0; i &lt; value.length; i++ ) ( (double[]) getData())[ i ] = value[ i ];</span>
<span class="fc" id="L2542">        return this;</span>
    }

    public Tsr&lt;ValType&gt; setValue32( float[] value ) {
<span class="fc bfc" id="L2546" title="All 2 branches covered.">        if ( this.isOutsourced() ) this.find( Device.class ).overwrite32( this, value );</span>
<span class="pc bpc" id="L2547" title="1 of 2 branches missed.">        else if ( getData() == null ) {</span>
<span class="nc" id="L2548">            setDataType( DataType.of( F32.class ) );</span>
<span class="nc" id="L2549">            _setData( value );</span>
        }
<span class="pc bpc" id="L2551" title="1 of 2 branches missed.">        else if ( getData() instanceof float[] )</span>
<span class="nc bnc" id="L2552" title="All 2 branches missed.">            for ( int i = 0; i &lt; value.length; i++ ) ( (float[]) getData())[ i ] = value[ i ];</span>
<span class="pc bpc" id="L2553" title="1 of 2 branches missed.">        else if ( getData() instanceof double[] )</span>
<span class="fc bfc" id="L2554" title="All 2 branches covered.">            for ( int i = 0; i &lt; value.length; i++ ) ( (double[]) getData())[ i ] = value[ i ];</span>
<span class="fc" id="L2555">        return this;</span>
    }

    public Tsr&lt;ValType&gt; setValue( Object value )
    {
<span class="fc bfc" id="L2560" title="All 2 branches covered.">        if ( value instanceof float[] ) this.setValue32( (float[]) value );</span>
<span class="fc bfc" id="L2561" title="All 2 branches covered.">        else if ( value instanceof  double[] ) this.setValue64( (double[]) value );</span>
<span class="fc bfc" id="L2562" title="All 2 branches covered.">        else if ( value instanceof Float ) {</span>
<span class="fc" id="L2563">            this.setIsVirtual( true );</span>
<span class="pc bpc" id="L2564" title="1 of 2 branches missed.">            if ( this.is32() ) ( (float[]) getData())[ 0 ] = (Float) value;</span>
<span class="fc" id="L2565">            else ( (double[]) getData())[ 0 ] = ( (Float) value ).doubleValue();</span>
<span class="fc bfc" id="L2566" title="All 2 branches covered.">        } else if ( value instanceof Double ) {</span>
<span class="fc" id="L2567">            this.setIsVirtual( true );</span>
<span class="pc bpc" id="L2568" title="1 of 2 branches missed.">            if ( this.is64() ) ( (double[]) getData())[ 0 ] = (Double) value;</span>
<span class="nc" id="L2569">            else ( (float[]) getData())[ 0 ] = ( (Double) value ).floatValue();</span>
<span class="pc bpc" id="L2570" title="1 of 2 branches missed.">        } else if ( value instanceof int[] ) {</span>
<span class="nc" id="L2571">            setDataType( DataType.of(I32.class) );</span>
<span class="nc" id="L2572">            _setData( value );</span>
<span class="nc" id="L2573">            setIsVirtual( false );</span>
<span class="pc bpc" id="L2574" title="1 of 2 branches missed.">        } else if ( value instanceof short[] ) {</span>
<span class="fc" id="L2575">            setDataType( DataType.of(I16.class) );</span>
<span class="fc" id="L2576">            _setData( value );</span>
<span class="fc" id="L2577">            setIsVirtual( false );</span>
        }
<span class="fc" id="L2579">        return this;</span>
    }

    public Object getValue() { // TODO : Make this what it is supposed to be!!! (returning a copy of the targeted data)
<span class="fc bfc" id="L2583" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="fc" id="L2584">            Device device = find( Device.class );</span>
<span class="fc bfc" id="L2585" title="All 2 branches covered.">            if ( device != null ) {</span>
<span class="fc" id="L2586">                return device.valueFor( this );</span>
            }
<span class="fc" id="L2588">            else return getData();</span>
        }
<span class="fc bfc" id="L2590" title="All 2 branches covered.">        else if ( !this.isVirtual() ) return getData();</span>
<span class="fc" id="L2591">        else return getDataType().actualize( getData(), this.size() );</span>
    }

    @Deprecated
    public double[] gradient64() {
<span class="fc" id="L2596">        Tsr&lt;ValType&gt; gradient = this.getGradient();</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">        if ( gradient == null ) return new double[ 0 ];</span>
<span class="pc bpc" id="L2598" title="1 of 2 branches missed.">        return ( this.is32() )</span>
<span class="nc" id="L2599">                ? DataConverter.Utility.floatToDouble( gradient.value32() )</span>
<span class="fc" id="L2600">                : gradient.value64();</span>
    }

    @Deprecated
    public float[] gradient32() {
<span class="nc" id="L2605">        Tsr&lt;ValType&gt; gradient = this.getGradient();</span>
<span class="nc bnc" id="L2606" title="All 2 branches missed.">        if ( gradient == null ) return new float[ 0 ];</span>
<span class="nc bnc" id="L2607" title="All 2 branches missed.">        return ( this.is64() )</span>
<span class="nc" id="L2608">                ? DataConverter.Utility.doubleToFloat( gradient.value64() )</span>
<span class="nc" id="L2609">                : gradient.value32();</span>
    }


    public Tsr&lt;ValType&gt; addToGradient( Tsr&lt;ValType&gt; error ) {
<span class="fc" id="L2614">        if (</span>
<span class="fc bfc" id="L2615" title="All 2 branches covered.">                !forComponent(</span>
                    Tsr.class,
                        gradient -&gt;
<span class="fc" id="L2618">                        this.set(</span>
<span class="fc" id="L2619">                                Function.Detached.PLUS_ASSIGN.call( new Tsr[]{ gradient, error } )</span>
                        )
                )
<span class="fc" id="L2622">        ) set( error ).forComponent( Device.class, device -&gt; {</span>
            try {
<span class="fc" id="L2624">                device.store( error ) ;</span>
<span class="nc" id="L2625">            } catch ( Exception exception ) {</span>
<span class="nc" id="L2626">                _LOG.error( &quot;Failed trying to store a given error to a device for gradient accumulation.&quot;, exception );</span>
<span class="nc" id="L2627">                throw exception;</span>
<span class="fc" id="L2628">            }</span>
<span class="fc" id="L2629">        });</span>
<span class="fc" id="L2630">        return this;</span>
    }

    /**
     *  This method constitutes a pure operation producing a new tensor instance
     *  which is a deep copy of this original tensor and contains data whose
     *  elements have been converted to a new data type, namely :&lt;br&gt;
     *  The type specified by the argument &lt;br&gt;
     *  &lt;br&gt;
     *  The method does not change this tensor, which is why the operation is pure.
     *  Important to note is that the method will return instances of the specified
     *  type but merely another tensor containing elements of that type...
     *  The name of this method for example translates to the &quot;as&quot; operator
     *  found in Groovy, so the following code : &lt;i&gt;&quot; myTensor as Double &quot;&lt;/i&gt; &lt;br&gt;
     *  would not return a Double instance!&lt;br&gt;
     *  &lt;br&gt;
     *
     * @param typeClass The class which is the target of the underlying type conversion...
     * @param &lt;T&gt; The value type of the tensor that will be returned.
     * @return A new tensor which hosting the supplied type.
     */
    public &lt;T&gt; Tsr&lt;T&gt; asType( Class&lt;T&gt; typeClass )
    {
<span class="nc" id="L2653">        DataType newDT = DataType.of( typeClass );</span>
        Object newData;
<span class="nc bnc" id="L2655" title="All 2 branches missed.">        if ( this.isOutsourced() ) {</span>
<span class="nc" id="L2656">            Device device = find( Device.class );</span>
<span class="nc" id="L2657">            device.restore( this );</span>
<span class="nc" id="L2658">            newData = _convertedDataOfType( typeClass );</span>
<span class="nc" id="L2659">            device.store( this );</span>
<span class="nc" id="L2660">        }</span>
<span class="nc" id="L2661">        else newData = _convertedDataOfType( typeClass );</span>
<span class="nc" id="L2662">        return (Tsr&lt;T&gt;) new Tsr( this.getNDConf().shape(), newDT, newData );</span>
    }

    /**
     *  This method is an inline operation which changes the underlying data of this tensor.
     *  It converts the data types of the elements of this tensor to the specified type!&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;WARNING : The use of this method is discouraged for the following reasons: &lt;/b&gt;&lt;br&gt;
     *  &lt;br&gt;
     *  1. Inline operations are inherently error prone for most use cases. &lt;br&gt;
     *  2. This inline operation in particular has no safety net,
     *     meaning that there is no implementation of version mismatch detection
     *     like there is for those operations present in the standard operation backend...
     *     No exceptions will be thrown during backpropagation! &lt;br&gt;
     *  3. This method has not yet been implemented to also handle instances which
     *     are slices of parent tensors!
     *     Therefore there might be unexpected performance penalties or side effects
     *     associated with this method.&lt;br&gt;
     *     &lt;br&gt;
     *
     * @param typeClass The target type class for elements of this tensor.
     * @param &lt;T&gt; The type parameter for the returned tensor.
     * @return The same tensor instance whose data has been converted to hold a different type.
     */
    public &lt;T&gt; Tsr&lt;T&gt; toType( Class&lt;T&gt; typeClass )
    {
<span class="fc bfc" id="L2688" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="fc" id="L2689">            setDataType( DataType.of( typeClass ) );</span>
<span class="fc" id="L2690">            return (Tsr&lt;T&gt;) this;</span>
        }
        else {
<span class="fc" id="L2693">            Object newData = _convertedDataOfType( typeClass );</span>
<span class="fc" id="L2694">            _setData( null );</span>
<span class="fc" id="L2695">            setDataType( DataType.of( typeClass ) );</span>
<span class="fc" id="L2696">            _setData( newData );</span>
        }
<span class="pc" id="L2698">        forComponent( Tsr.class, gradient -&gt; gradient.toType( typeClass ) );</span>
<span class="fc" id="L2699">        return (Tsr&lt;T&gt;) this;</span>
    }

    public double value64( int i ) {
<span class="fc bfc" id="L2703" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="pc bpc" id="L2704" title="1 of 2 branches missed.">            if ( find( Device.class ) instanceof OpenCLDevice )</span>
<span class="fc" id="L2705">                return find( OpenCLDevice.class ).value64f( (Tsr&lt;Number&gt;) this, i );</span>
<span class="nc" id="L2706">            else return 0.0;</span>
        }
<span class="fc bfc" id="L2708" title="All 2 branches covered.">        if ( this.isVirtual() ) {</span>
<span class="pc bpc" id="L2709" title="1 of 2 branches missed.">            if ( this.is64() ) return ( (double[]) getData() )[ 0 ];</span>
<span class="nc" id="L2710">            else return ( (float[]) getData() )[ 0 ];</span>
        } else {
<span class="fc bfc" id="L2712" title="All 2 branches covered.">            if ( this.is64() ) return ( (double[]) getData() )[ i ];</span>
<span class="fc" id="L2713">            else return ( (float[]) getData() )[ i ];</span>
        }
    }

    public double[] value64() {
<span class="fc" id="L2718">        Device&lt;ValType&gt; found = this.find( Device.class );</span>
<span class="pc bpc" id="L2719" title="1 of 6 branches missed.">        if ( getData() == null &amp;&amp; this.isOutsourced() &amp;&amp; found != null ) {</span>
<span class="pc bpc" id="L2720" title="1 of 2 branches missed.">            if ( found instanceof OpenCLDevice )</span>
<span class="fc" id="L2721">                return ( (OpenCLDevice) found).value64f( (Tsr&lt;Number&gt;) this );</span>
<span class="nc" id="L2722">            else return null;</span>
        }
<span class="fc" id="L2724">        double[] newValue = DataConverter.instance().convert( getData(), double[].class );</span>

<span class="fc bfc" id="L2726" title="All 6 branches covered.">        if ( this.isVirtual() &amp;&amp; newValue != null &amp;&amp; this.size() &gt; 1 ) {</span>

<span class="fc" id="L2728">           double[] value = new double[ this.size() ];</span>
<span class="fc" id="L2729">           Arrays.fill( value, newValue[ 0 ] );</span>
<span class="fc" id="L2730">           return value;</span>
        }
<span class="fc" id="L2732">        return newValue;</span>
    }

    public float value32( int i ) {
<span class="fc bfc" id="L2736" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="pc bpc" id="L2737" title="1 of 2 branches missed.">            if ( find( Device.class ) instanceof OpenCLDevice )</span>
<span class="fc" id="L2738">                return find( OpenCLDevice.class ).value32f( (Tsr&lt;Number&gt;) this, i );</span>
<span class="nc" id="L2739">            else return 0.0f;</span>
        }
<span class="pc bpc" id="L2741" title="1 of 2 branches missed.">        if ( this.isVirtual() ) {</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">            if ( this.is64() ) return (float) ( (double[]) getData() )[ 0 ];</span>
<span class="nc" id="L2743">            else return ( (float[]) getData())[ 0 ];</span>
        } else {
<span class="fc bfc" id="L2745" title="All 2 branches covered.">            if ( this.is64() ) return (float) ( (double[]) getData() )[ i ];</span>
<span class="fc" id="L2746">            else return ( (float[]) getData() )[ i ];</span>
        }
    }

    public float[] value32() {
<span class="fc" id="L2751">        Device&lt;ValType&gt; found = this.find( Device.class );</span>
<span class="pc bpc" id="L2752" title="1 of 6 branches missed.">        if ( getData() == null &amp;&amp; this.isOutsourced() &amp;&amp; found != null ) {</span>
<span class="pc bpc" id="L2753" title="1 of 2 branches missed.">            if ( found instanceof OpenCLDevice )</span>
<span class="fc" id="L2754">                return ( (OpenCLDevice) found ).value32f( (Tsr&lt;Number&gt;) this);</span>
        }
<span class="fc" id="L2756">        float[] newValue = DataConverter.instance().convert( getData(), float[].class );</span>
<span class="fc bfc" id="L2757" title="All 4 branches covered.">        if ( this.isVirtual() &amp;&amp; newValue != null ) {</span>
<span class="fc" id="L2758">            newValue = new float[ this.size() ];</span>
<span class="fc" id="L2759">            Arrays.fill( newValue, newValue[ 0 ] );</span>
        }
<span class="fc" id="L2761">        return newValue;</span>
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    //DISPLAY :
    //=========================
    public String toString( String mode ) {
<span class="fc bfc" id="L2769" title="All 2 branches covered.">        return _toString( mode, ( mode.contains( &quot;f&quot; ) ) ? &quot;    &quot; : null );</span>
    }

    public String toString( Map&lt;TsrAsString.Should, Object&gt; config, String indent ) {
<span class="fc" id="L2773">        return new TsrAsString( this, config ).toString( indent );</span>
    }

    public String toString( Map&lt;TsrAsString.Should, Object&gt; config ) {
<span class="fc" id="L2777">        return new TsrAsString( this, config ).toString();</span>
    }


    protected String _toString( String mode, String deep )
    {
<span class="fc" id="L2783">        return new TsrAsString( this, mode ).toString( deep );</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L2789">        return new TsrAsString( this ).toString();</span>
    }


    public static void makeFit( Tsr[] tensors, boolean doesAD )
    {
<span class="fc" id="L2795">        int largest = -1;</span>
<span class="fc" id="L2796">        int[] shape = null;</span>
<span class="fc bfc" id="L2797" title="All 4 branches covered.">        for ( Tsr t : tensors ) if ( t.rank() &gt; largest ) {</span>
<span class="fc" id="L2798">            largest = t.rank();</span>
<span class="fc" id="L2799">            shape = t.getNDConf().shape();</span>
        }
<span class="fc" id="L2801">        int prefix = 0;</span>
<span class="pc bpc" id="L2802" title="2 of 4 branches missed.">        assert shape != null;</span>
<span class="fc bfc" id="L2803" title="All 4 branches covered.">        for ( int s : shape ) if ( s == 1 ) prefix++; else break;</span>
<span class="fc" id="L2804">        int postfix = 0;</span>
<span class="fc bfc" id="L2805" title="All 4 branches covered.">        for ( int i = shape.length-1; i&gt;=0; i-- ) if ( shape[ i ] == 1 ) postfix++; else break;</span>
<span class="fc bfc" id="L2806" title="All 2 branches covered.">        for ( int i = 0; i &lt; tensors.length; i++ ) {</span>
<span class="fc bfc" id="L2807" title="All 2 branches covered.">            if ( tensors[ i ].rank() != largest ) {</span>
<span class="fc" id="L2808">                int[] oldShape = tensors[ i ].getNDConf().shape();</span>
<span class="fc" id="L2809">                int[] newReshape = new int[ largest ];</span>
<span class="fc" id="L2810">                int padding = largest - oldShape.length;</span>

<span class="fc bfc" id="L2812" title="All 2 branches covered.">                int handle = ( postfix &lt;= prefix ) ? padding : largest - padding;</span>
<span class="fc bfc" id="L2813" title="All 4 branches covered.">                for ( int ii = 0; ii &lt; handle; ii++ ) newReshape[ ii ] = ( postfix &lt;= prefix ) ? -1 : ii;</span>
<span class="fc bfc" id="L2814" title="All 4 branches covered.">                for ( int ii = handle; ii &lt; largest; ii++ ) newReshape[ ii ] = ( postfix &lt;= prefix ) ? ii - padding : -1;</span>

<span class="fc" id="L2816">                Function f = Function.create(</span>
<span class="fc" id="L2817">                    AbstractNDArray.Utility.Stringify.strConf( newReshape ) + &quot;:(I[ 0 ])&quot;,</span>
                        doesAD
                );
<span class="fc" id="L2820">                tensors[ i ] = f.call( tensors[ i ] );</span>
            }
        }

<span class="fc" id="L2824">    }</span>

    /**
     *  This is a nested static utility class which is used
     *  to create tensor instances.
     */
<span class="nc" id="L2830">    @NoArgsConstructor</span>
    public static class Create
    {
        public  static Tsr&lt;?&gt; E( List&lt;Integer&gt; shape ) {
<span class="nc" id="L2834">            return E( shape.stream().mapToInt( e -&gt; e ).toArray() );</span>
        }

        public  static Tsr&lt;?&gt; E( int[] shape ) {
<span class="nc" id="L2838">            return new Tsr( shape, 2.7182818284590452353602874713527 );</span>
        }

        public static Tsr&lt;?&gt; newRandom( int[] shape ) {
<span class="fc" id="L2842">            return newRandom( shape, 8701252152903546L );</span>
        }

        public static Tsr&lt;?&gt; newRandom( int[] shape, long seed ) {
<span class="fc" id="L2846">            int size = NDConfiguration.Utility.szeOfShp( shape );</span>
<span class="fc" id="L2847">            return new Tsr&lt;&gt;( shape, DataConverter.Utility.newSeededDoubleArray( seed, size ) );</span>
        }

        public static Tsr&lt;?&gt; newTsrLike( Tsr&lt;?&gt; template, double value ) {
<span class="fc" id="L2851">            Tsr&lt;Object&gt; t = (Tsr&lt;Object&gt;) _newEmptyLike( template );</span>
<span class="pc bpc" id="L2852" title="1 of 2 branches missed.">            if ( template.is32() ) t.setValue( (float) value );</span>
<span class="fc" id="L2853">            else t.setValue( value );</span>
            try {
<span class="fc bfc" id="L2855" title="All 2 branches covered.">                if ( template.isOutsourced() ) ( (Device&lt;Object&gt;) template.find( Device.class ) ).store( t );</span>
<span class="nc" id="L2856">            } catch ( Exception exception ) {</span>
<span class="nc" id="L2857">                _LOG.error( &quot;Failed storing a newly created tensor from a template tensor to its host device.&quot;, exception );</span>
<span class="nc" id="L2858">                throw exception;</span>
<span class="fc" id="L2859">            }</span>
<span class="fc" id="L2860">            return t;</span>
        }

        public static Tsr&lt;?&gt; newTsrLike( Tsr&lt;?&gt; template ) { // The output tensor will not have gradients!
<span class="fc" id="L2864">            Tsr t = _newEmptyLike( template );</span>
<span class="pc bpc" id="L2865" title="1 of 2 branches missed.">            if ( template.is32() ) t.setValue32( new float[ template.size() ] );</span>
<span class="fc" id="L2866">            else t.setValue64( new double[ template.size() ] );</span>
            try {
<span class="fc bfc" id="L2868" title="All 2 branches covered.">                if ( template.isOutsourced() ) ( (Device&lt;Object&gt;) template.find( Device.class ) ).store( t );</span>
<span class="nc" id="L2869">            } catch ( Exception exception ) {</span>
<span class="nc" id="L2870">                _LOG.error( &quot;Failed storing a newly created tensor from a template tensor to its host device.&quot;, exception );</span>
<span class="nc" id="L2871">                throw exception;</span>
<span class="fc" id="L2872">            }</span>
<span class="fc" id="L2873">            return t;</span>
        }

        private static Tsr&lt;?&gt; _newEmptyLike( Tsr&lt;?&gt; template ) {
<span class="fc" id="L2877">            Tsr&lt;?&gt; t = new Tsr&lt;&gt;();</span>
<span class="fc" id="L2878">            t._configureFromNewShape( template.getNDConf().shape(), false, true );</span>
<span class="fc" id="L2879">            return t;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>