<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Neureka.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka</a> &gt; <span class="el_source">Neureka.java</span></div><h1>Neureka.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   _   _                     _
  | \ | |                   | |
  |  \| | ___ _   _ _ __ ___| | ____ _
  | . ` |/ _ \ | | | '__/ _ \ |/ / _` |
  | |\  |  __/ |_| | | |  __/   &lt; (_| |
  |_| \_|\___|\__,_|_|  \___|_|\_\__,_|

    This is a central singleton class used to configure the Neureka library.

*/

package neureka;

import lombok.ToString;
import lombok.experimental.Accessors;
import neureka.dtype.custom.F64;
import neureka.utility.SettingsLoader;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

@Accessors( prefix = {&quot;_&quot;} )
<span class="nc" id="L49">@ToString</span>
public class Neureka
{
    private static final ThreadLocal&lt;Neureka&gt; _INSTANCES;

    private static String _VERSION;

    private static final boolean _OPENCL_AVAILABLE;

    static
    {
<span class="fc" id="L60">        _INSTANCES = new ThreadLocal&lt;&gt;();</span>
<span class="fc" id="L61">        _OPENCL_AVAILABLE = Utility.isPresent( &quot;org.jocl.CL&quot; );</span>
<span class="fc" id="L62">    }</span>

    private final Settings _settings;
    private final Utility _utility;

<span class="fc" id="L67">    private Neureka() {</span>
<span class="fc" id="L68">        _settings = new Settings();</span>
<span class="fc" id="L69">        _utility = new Utility();</span>
<span class="fc" id="L70">    }</span>

    public static Neureka instance() {
<span class="fc" id="L73">        Neureka n = _INSTANCES.get();</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">        if ( n == null ) {</span>
<span class="fc" id="L75">            n = new Neureka();</span>
<span class="fc" id="L76">            synchronized ( Neureka.class ) {</span>
<span class="fc" id="L77">                setContext( n );</span>
<span class="fc" id="L78">                n.reset(); // Initial reset must be synchronized because of dependency issues!</span>
<span class="fc" id="L79">            }</span>
        }
<span class="fc" id="L81">        return n;</span>
    }

    public static void setContext( Neureka instance ) {
<span class="fc" id="L85">        _INSTANCES.set(instance);</span>
<span class="fc" id="L86">    }</span>

    public static Neureka instance(Object closure) {
<span class="fc" id="L89">        Object o = SettingsLoader.tryGroovyClosureOn(closure, Neureka.instance());</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (o instanceof String) _VERSION = (String) o;</span>
<span class="fc" id="L91">        return Neureka.instance();</span>
    }

    public boolean canAccessOpenCL() {
<span class="fc" id="L95">        return _OPENCL_AVAILABLE;</span>
    }

    public Settings settings() {
<span class="fc" id="L99">        return _settings;</span>
    }

    public Settings settings(Object closure) {
<span class="fc" id="L103">        SettingsLoader.tryGroovyClosureOn(closure, _settings);</span>
<span class="fc" id="L104">        return _settings;</span>
    }

    public Utility utility() {
<span class="fc" id="L108">        return _utility;</span>
    }

    public static String version() {
<span class="fc" id="L112">        return _VERSION;</span>
    }

    public void reset() {
        try {
<span class="fc" id="L117">            SettingsLoader.tryGroovyScriptsOn(this);</span>
<span class="nc" id="L118">        } catch ( Exception e ) {</span>
<span class="nc" id="L119">            settings().autograd().setIsRetainingPendingErrorForJITProp( true );</span>
<span class="nc" id="L120">            settings().autograd().setIsApplyingGradientWhenTensorIsUsed( true );</span>
<span class="nc" id="L121">            settings().autograd().setIsApplyingGradientWhenRequested( true );</span>
<span class="nc" id="L122">            settings().indexing().setIsUsingLegacyIndexing( false );</span>
<span class="nc" id="L123">            settings().indexing().setIsUsingArrayBasedIndexing( true );</span>
<span class="nc" id="L124">            settings().debug().setIsKeepingDerivativeTargetPayloads( false );</span>
<span class="nc" id="L125">            settings().view().setIsUsingLegacyView( false );</span>
<span class="fc" id="L126">        }</span>
<span class="fc" id="L127">    }</span>

    private boolean _currentThreadIsAuthorized() {
<span class="fc" id="L130">        return this.equals( _INSTANCES.get() );</span>
    }

    @Accessors( prefix = {&quot;_&quot;} )
<span class="nc" id="L134">    @ToString</span>
    public class Settings
    {
        private final Debug _debug;
        private final AutoGrad _autograd;
        private final Indexing _indexing;
        private final View _view;
        private final NDim _ndim;
        private final DType _dtype;

<span class="fc" id="L144">        private boolean _isLocked = false;</span>

<span class="fc" id="L146">        private Settings() {</span>
<span class="fc" id="L147">            _debug = new Debug();</span>
<span class="fc" id="L148">            _autograd = new AutoGrad();</span>
<span class="fc" id="L149">            _indexing = new Indexing();</span>
<span class="fc" id="L150">            _view = new View();</span>
<span class="fc" id="L151">            _ndim = new NDim();</span>
<span class="fc" id="L152">            _dtype = new DType();</span>
<span class="fc" id="L153">        }</span>

        public Debug debug() {
<span class="fc" id="L156">            return _debug;</span>
        }

        public Debug debug(Object closure) {
<span class="fc" id="L160">            SettingsLoader.tryGroovyClosureOn(closure, _debug);</span>
<span class="fc" id="L161">            return _debug;</span>
        }

        public AutoGrad autograd() {
<span class="fc" id="L165">            return _autograd;</span>
        }

        public AutoGrad autograd( Object closure ) {
<span class="fc" id="L169">            SettingsLoader.tryGroovyClosureOn( closure, _autograd );</span>
<span class="fc" id="L170">            return _autograd;</span>
        }

        public Indexing indexing() {
<span class="fc" id="L174">            return _indexing;</span>
        }

        public Indexing indexing( Object closure ) {
<span class="fc" id="L178">            SettingsLoader.tryGroovyClosureOn( closure, _indexing );</span>
<span class="fc" id="L179">            return _indexing;</span>
        }

        public View view() {
<span class="fc" id="L183">            return _view;</span>
        }

        public View view( Object closure ) {
<span class="fc" id="L187">            SettingsLoader.tryGroovyClosureOn( closure, _view );</span>
<span class="fc" id="L188">            return _view;</span>
        }

        public NDim ndim() {
<span class="fc" id="L192">            return _ndim;</span>
        }

        public NDim ndim( Object closure ) {
<span class="fc" id="L196">            SettingsLoader.tryGroovyClosureOn( closure, _ndim );</span>
<span class="fc" id="L197">            return _ndim;</span>
        }

        public DType dtype() {
<span class="fc" id="L201">            return _dtype;</span>
        }

        public DType dtype( Object closure ) {
<span class="fc" id="L205">            SettingsLoader.tryGroovyClosureOn( closure, _dtype );</span>
<span class="fc" id="L206">            return _dtype;</span>
        }

        public boolean isLocked() {
<span class="fc" id="L210">            return  _isLocked;</span>
        }

        public void setIsLocked(boolean locked) {
<span class="nc" id="L214">            _isLocked = locked;</span>
<span class="nc" id="L215">        }</span>

        @Accessors( prefix = {&quot;_&quot;} )
<span class="nc" id="L218">        @ToString</span>
<span class="fc" id="L219">        public class Debug</span>
        {
            /**
             * Every derivative is calculated with respect to some graph node.
             * Graph nodes contain payload tensors.
             * A tensor might not always be used for backpropagation.
             * Therefore it will be deleted if possible.
             * Targeted tensors are either leave tensors (They require gradients)
             * or they are angle points between forward- and reverse-mode-AutoDiff!
             * In this case:
             * If the tensor is not needed for backpropagation it will be deleted.
             * The graph node will dereference the tensor either way.
             *
             * The flag determines this behavior with respect to target nodes.
             * It is used in the test suit to validate that the right tensors were calculated.
             * This flag should not be modified in production! (memory leak)
             */
<span class="fc" id="L236">            private boolean _isKeepingDerivativeTargetPayloads = false;</span>

            public boolean isKeepingDerivativeTargetPayloads() {
<span class="fc" id="L239">                return _isKeepingDerivativeTargetPayloads;</span>
            }

            public void setIsKeepingDerivativeTargetPayloads(boolean keep) {
<span class="pc bpc" id="L243" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L244">                _isKeepingDerivativeTargetPayloads = keep;</span>
<span class="fc" id="L245">            }</span>

        }

        @Accessors( prefix = {&quot;_&quot;} )
<span class="nc" id="L250">        @ToString</span>
<span class="fc" id="L251">        public class AutoGrad // Auto-Grad/Differentiation</span>
        {
            /**
             *  Inline operations are operations where the data of a tensor passed into an operation
             *  is being modified.
             *  Usually the result of an operation is stored inside a new tensor.
             */
<span class="fc" id="L258">            private boolean _isPreventingInlineOperations = true;</span>

            /**
             * This flag enables an optimization technique which only propagates error values to
             * gradients if needed by a tensor (the tensor is used again) and otherwise accumulate them
             * at divergent differentiation paths within the computation graph.&lt;br&gt;
             * If the flag is set to true &lt;br&gt;
             * then error values will accumulate at such junction nodes.
             * This technique however uses more memory but will
             * improve performance for some networks substantially.
             * The technique is termed JIT-Propagation.
             */
<span class="fc" id="L270">            private boolean _isRetainingPendingErrorForJITProp = true;</span>

            /**
             * Gradients will automatically be applied (or JITed) to tensors as soon as
             * they are being used for calculation (GraphNode instantiation).
             * This feature works well with JIT-Propagation.
             */
<span class="fc" id="L277">            private boolean _isApplyingGradientWhenTensorIsUsed = true;</span>

            /**
             * Gradients will only be applied if requested.
             * Usually this happens immediately, however
             * if the flag 'applyGradientWhenTensorIsUsed' is set
             * to true, then the tensor will only be updated by its
             * gradient if requested AND the tensor is used fo calculation! (GraphNode instantiation).
             */
<span class="fc" id="L286">            private boolean _isApplyingGradientWhenRequested = true;</span>

            public boolean isPreventingInlineOperations() {
<span class="fc" id="L289">                return _isPreventingInlineOperations;</span>
            }

            public void setIsPreventingInlineOperations(boolean prevent) {
<span class="pc bpc" id="L293" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L294">                _isPreventingInlineOperations = prevent;</span>
<span class="fc" id="L295">            }</span>

            public boolean isRetainingPendingErrorForJITProp() {
<span class="fc" id="L298">                return _isRetainingPendingErrorForJITProp;</span>
            }

            public void setIsRetainingPendingErrorForJITProp(boolean retain) {
<span class="pc bpc" id="L302" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L303">                _isRetainingPendingErrorForJITProp = retain;</span>
<span class="fc" id="L304">            }</span>

            public boolean isApplyingGradientWhenTensorIsUsed() {
<span class="fc" id="L307">                return _isApplyingGradientWhenTensorIsUsed;</span>
            }

            public void setIsApplyingGradientWhenTensorIsUsed(boolean apply) {
<span class="pc bpc" id="L311" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L312">                _isApplyingGradientWhenTensorIsUsed = apply;</span>
<span class="fc" id="L313">            }</span>

            public boolean isApplyingGradientWhenRequested() {
<span class="fc" id="L316">                return _isApplyingGradientWhenRequested;</span>
            }

            public void setIsApplyingGradientWhenRequested(boolean apply) {
<span class="pc bpc" id="L320" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L321">                _isApplyingGradientWhenRequested = apply;</span>
<span class="fc" id="L322">            }</span>

        }

        @Accessors( prefix = {&quot;_&quot;} )
<span class="nc" id="L327">        @ToString</span>
<span class="fc" id="L328">        public class Indexing</span>
        {
<span class="fc" id="L330">            private boolean _isUsingLegacyIndexing = false;</span>

<span class="fc" id="L332">            private boolean _isUsingArrayBasedIndexing = true;</span>



            public boolean isUsingLegacyIndexing() {
<span class="fc" id="L337">                return _isUsingLegacyIndexing;</span>
            }

            public void setIsUsingLegacyIndexing(boolean enabled) {
<span class="pc bpc" id="L341" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L342">                _isUsingLegacyIndexing = enabled; // NOTE: gpu code must recompiled! (in OpenCLPlatform)</span>
<span class="fc" id="L343">            }</span>

            public boolean isUsingArrayBasedIndexing() {
<span class="fc" id="L346">                return _isUsingArrayBasedIndexing;</span>
            }

            public void setIsUsingArrayBasedIndexing( boolean thorough ) {
<span class="pc bpc" id="L350" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L351">                _isUsingArrayBasedIndexing = thorough;</span>
<span class="fc" id="L352">            }</span>

        }

        @Accessors( prefix = {&quot;_&quot;} )
<span class="nc" id="L357">        @ToString</span>
<span class="fc" id="L358">        public class View</span>
        {
<span class="fc" id="L360">            private boolean _isUsingLegacyView = false;</span>

            public boolean isUsingLegacyView() {
<span class="fc" id="L363">                return _isUsingLegacyView;</span>
            }

            public void setIsUsingLegacyView(boolean enabled) {
<span class="pc bpc" id="L367" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L368">                _isUsingLegacyView = enabled;</span>
<span class="fc" id="L369">            }</span>

        }

        @Accessors( prefix = {&quot;_&quot;} )
<span class="nc" id="L374">        @ToString</span>
<span class="fc" id="L375">        public class NDim</span>
        {
            /**
             *  The DefaultNDConfiguration class stores shape, translation...
             *  as cached int arrays.
             *  Disabling this flag allows for custom 1D, 2D, 3D classes to be loaded. (Improves memory locality)
             */
<span class="fc" id="L382">            private boolean _isOnlyUsingDefaultNDConfiguration = false;</span>

            public boolean isOnlyUsingDefaultNDConfiguration() {
<span class="fc" id="L385">                return _isOnlyUsingDefaultNDConfiguration;</span>
            }

            public void setIsOnlyUsingDefaultNDConfiguration(boolean enabled) {
<span class="pc bpc" id="L389" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L390">                _isOnlyUsingDefaultNDConfiguration = enabled;</span>
<span class="fc" id="L391">            }</span>

        }

        @Accessors( prefix = {&quot;_&quot;} )
<span class="nc" id="L396">        @ToString</span>
<span class="fc" id="L397">        public class DType {</span>

<span class="fc" id="L399">            private Class&lt;?&gt; _defaultDataTypeClass = F64.class;</span>

<span class="fc" id="L401">            private boolean _isAutoConvertingExternalDataToJVMTypes = true;</span>

            public Class&lt;?&gt; getDefaultDataTypeClass() {
<span class="fc" id="L404">                return _defaultDataTypeClass;</span>
            }

            public void setDefaultDataTypeClass( Class dtype ) {
<span class="pc bpc" id="L408" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L409">                _defaultDataTypeClass = dtype;</span>
<span class="fc" id="L410">            }</span>

            public boolean getIsAutoConvertingExternalDataToJVMTypes() {
<span class="fc" id="L413">                return _isAutoConvertingExternalDataToJVMTypes;</span>
            }

            public void setIsAutoConvertingExternalDataToJVMTypes( boolean autoConvert ) {
<span class="pc bpc" id="L417" title="2 of 4 branches missed.">                if ( _isLocked || !_currentThreadIsAuthorized()) return;</span>
<span class="fc" id="L418">                _isAutoConvertingExternalDataToJVMTypes = autoConvert;</span>
<span class="fc" id="L419">            }</span>

        }

    }

<span class="fc" id="L425">    public static class Utility</span>
    {
        /**
         * Helper method which reads the file with the given name and returns
         * the contents of this file as a String. Will exit the application
         * if the file can not be read.
         *
         * @param path The path to the jar resource.
         * @return The contents of the file
         */
        public String readResource( String path ) {
<span class="fc" id="L436">            InputStream stream = getClass().getClassLoader().getResourceAsStream( path );</span>
            try {
<span class="fc" id="L438">                BufferedReader br = new BufferedReader(new InputStreamReader( stream ));</span>
<span class="fc" id="L439">                StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L440">                String line = &quot;&quot;;</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">                while ( line != null ) {</span>
<span class="fc" id="L442">                    line = br.readLine();</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">                    if ( line != null ) sb.append( line ).append( &quot;\n&quot; );</span>
                }
<span class="fc" id="L445">                return sb.toString();</span>
<span class="nc" id="L446">            } catch ( IOException e ) {</span>
<span class="nc" id="L447">                e.printStackTrace();</span>
<span class="nc" id="L448">                System.exit( 1 );</span>
<span class="nc" id="L449">                return null;</span>
            }
        }

        public static boolean isPresent( String className ) {
<span class="fc" id="L454">            boolean found = false;</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">            String groovyInfo = ( (className.toLowerCase().contains(&quot;groovy&quot;) ) ? &quot; Neureka settings uninitialized!&quot; : &quot;&quot; );</span>
<span class="fc" id="L456">            String cause = &quot; unknown &quot;;</span>
            try {
<span class="fc" id="L458">                Class.forName( className );</span>
<span class="fc" id="L459">                found = true;</span>
<span class="nc" id="L460">            } catch ( Throwable ex ) {// Class or one of its dependencies is not present...</span>
<span class="nc" id="L461">                cause = ex.getMessage();</span>
            } finally {
<span class="pc bpc" id="L463" title="5 of 6 branches missed.">                if ( !found ) {</span>
<span class="nc" id="L464">                    System.out.println(</span>
                            &quot;[Info]: '&quot;+className+&quot;' dependencies not found!&quot;+groovyInfo+&quot;\n[Cause]: &quot;+cause
                    );
                }
<span class="pc" id="L468">                return found;</span>
            }
        }

    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>