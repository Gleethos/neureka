<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Nda.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka</a> &gt; <span class="el_source">Nda.java</span></div><h1>Nda.java</h1><pre class="source lang-java linenums">package neureka;

import neureka.common.utility.DataConverter;
import neureka.common.utility.LogUtil;
import neureka.fluent.building.NdaBuilder;
import neureka.fluent.building.states.WithShapeOrScalarOrVector;
import neureka.fluent.slicing.SliceBuilder;
import neureka.fluent.slicing.states.AxisOrGet;
import neureka.framing.NDFrame;
import neureka.framing.Relation;
import neureka.ndim.NDimensional;
import neureka.view.NDPrintSettings;
import neureka.view.NdaAsString;

import java.math.BigDecimal;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.*;

/**
 *  {@link Nda}, which is an abbreviation of &lt;b&gt;'N-Dimensional-Array'&lt;/b&gt;, represents
 *  a multidimensional, homogeneously filled fixed-size array of items.
 *  &lt;p&gt;
 *  {@link Nda}s should be constructed using the fluent builder API exposed by {@link #of(Class)}.
 *
 * @param &lt;V&gt; The type of the items stored in the {@link Nda}.
 */
public interface Nda&lt;V&gt; extends NDimensional, Iterable&lt;V&gt;
{
    /**
     *  This is the entry point to the fluent nd-array builder API for building
     *  {@link Nda} instances in a readable and type safe fashion.
     *  The returned {@link WithShapeOrScalarOrVector} is the next step in the
     *  fluent {@link Nda} builder API which will lead to the creation
     *  of an nd-array storing values defined by the provided type class.
     *  A simple usage example would be:
     *   &lt;pre&gt;{@code
     *      Nda.of(Double.class)
     *            .withShape( 2, 3, 4 )
     *            .andFill( 5, 3, 5 )
     *   }&lt;/pre&gt;
     *
     *   It is also possible to define a range using the API to populate the nd-array with values:
     *   &lt;pre&gt;{@code
     *      Nda.of(Double.class)
     *            .withShape( 2, 3, 4 )
     *            .andFillFrom( 2 ).to( 9 ).step( 2 )
     *   }&lt;/pre&gt;
     *
     *   If one needs a simple scalar then the following shortcut is possible:
     *   &lt;pre&gt;{@code
     *      Nda.of(Float.class).scalar( 3f )
     *   }&lt;/pre&gt;
     *
     *   This principle works for vectors as well:
     *   &lt;pre&gt;{@code
     *       Nda.of(Byte.class).vector( 2, 5, 6, 7, 8 )
     *   }&lt;/pre&gt;
     *   For more fine-grained control over the initialization one can
     *   pass an initialization lambda to the API:
     *   &lt;pre&gt;{@code
     *       Nda.of(Byte.class).withShape(2, 3).andWhere( (i, indices) -&gt; i * 5 - 30 )
     *   }&lt;/pre&gt;
     *
     *
     * @param type The type class of the items stored by the nd-array built by the exposed builder API.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L72">    static &lt;V&gt; WithShapeOrScalarOrVector&lt;V&gt; of( Class&lt;V&gt; type ) { return new NdaBuilder&lt;&gt;( type ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(String.class)}
     * used to build {@link Nda}s storing {@link String}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L79">    static WithShapeOrScalarOrVector&lt;String&gt; ofStrings() { return of( String.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(Integer.class)}
     * used to build {@link Nda}s storing {@link Integer}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L86">    static WithShapeOrScalarOrVector&lt;Integer&gt; ofInts() { return of( Integer.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(Double.class)}
     * used to build {@link Nda}s storing {@link Double}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L93">    static WithShapeOrScalarOrVector&lt;Double&gt; ofDoubles() { return of( Double.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(Float.class)}
     * used to build {@link Nda}s storing {@link Float}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L100">    static WithShapeOrScalarOrVector&lt;Float&gt; ofFloats() { return of( Float.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(Long.class)}
     * used to build {@link Nda}s storing {@link Long}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L107">    static WithShapeOrScalarOrVector&lt;Long&gt; ofLongs() { return of( Long.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(Boolean.class)}
     * used to build {@link Nda}s storing {@link Boolean}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L114">    static WithShapeOrScalarOrVector&lt;Boolean&gt; ofBooleans() { return of( Boolean.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(Character.class)}
     * used to build {@link Nda}s storing {@link Character}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L121">    static WithShapeOrScalarOrVector&lt;Character&gt; ofChars() { return of( Character.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(Byte.class)}
     * used to build {@link Nda}s storing {@link Byte}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L128">    static WithShapeOrScalarOrVector&lt;Byte&gt; ofBytes() { return of( Byte.class ); }</span>

    /**
     * This is a &lt;b&gt;short&lt;/b&gt;cut method for {@code Nda.of(Short.class)}
     * used to build {@link Nda}s storing {@link Short}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L135">    static WithShapeOrScalarOrVector&lt;Short&gt; ofShorts() { return of( Short.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(Object.class)}
     * used to build {@link Nda}s storing {@link Object}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L142">    static WithShapeOrScalarOrVector&lt;Object&gt; ofObjects() { return of( Object.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(Number.class)}
     * used to build {@link Nda}s storing {@link Number}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L149">    static WithShapeOrScalarOrVector&lt;Number&gt; ofNumbers() { return of( Number.class ); }</span>

    /**
     * This is a shortcut method for {@code Nda.of(BigDecimal.class)}
     * used to build {@link Nda}s storing {@link BigDecimal}s.
     * @return The next step of the {@link Nda} builder API which exposes methods for defining shapes.
     */
<span class="fc" id="L156">    static WithShapeOrScalarOrVector&lt;BigDecimal&gt; ofBigDecimals() { return of( BigDecimal.class ); }</span>

    /**
     * @param value The scalar value which ought to be represented as nd-array.
     * @return A scalar double nd-array.
     */
<span class="fc" id="L162">    static Nda&lt;Double&gt; of( double value ) { return Tsr.of( Double.class, Shape.of( 1 ), value ); }</span>

    /**
     *  Constructs a vector of floats based on the provided array.
     *
     * @param value The array of floats from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of floats.
     */
<span class="nc" id="L170">    static Nda&lt;Float&gt; of( float... value ) { return Tsr.of( Float.class, Shape.of( value.length ), value ); }</span>

    /**
     *  Constructs a vector of doubles based on the provided array.
     *
     * @param value The array of doubles from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of doubles.
     */
<span class="fc" id="L178">    static Nda&lt;Double&gt; of( double... value ) { return Tsr.of( Double.class, Shape.of( value.length ), value ); }</span>

    /**
     *  Constructs a vector of bytes based on the provided array.
     *
     * @param value The array of bytes from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of bytes.
     */
<span class="nc" id="L186">    static Nda&lt;Byte&gt; of( byte... value ) { return Tsr.of( Byte.class, Shape.of( value.length ), value ); }</span>

    /**
     *  Constructs a vector of ints based on the provided array.
     *
     * @param value The array of ints from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of ints.
     */
<span class="fc" id="L194">    static Nda&lt;Integer&gt; of( int... value ) { return Tsr.of( Integer.class, Shape.of( value.length ), value ); }</span>

    /**
     *  Constructs a vector of longs based on the provided array.
     *
     * @param value The array of longs from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of longs.
     */
<span class="nc" id="L202">    static Nda&lt;Long&gt; of( long... value ) { return Tsr.of( Long.class, Shape.of( value.length ), value ); }</span>

    /**
     *  Constructs a vector of shorts based on the provided array.
     *
     * @param value The array of shorts from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of shorts.
     */
<span class="nc" id="L210">    static Nda&lt;Short&gt; of( short... value ) { return Tsr.of( Short.class, Shape.of( value.length ), value ); }</span>

    /**
     *  Constructs a vector of booleans based on the provided array.
     *
     * @param value The array of booleans from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of shorts.
     */
<span class="fc" id="L218">    static Nda&lt;Boolean&gt; of( boolean... value ) { return Tsr.of( Boolean.class, Shape.of( value.length ), value ); }</span>

    /**
     * Constructs a vector of objects based on the provided array.
     *
     * @param values The array of objects from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of objects.
     */
    @SafeVarargs
<span class="fc" id="L227">    static &lt;T&gt; Nda&lt;T&gt; of( T... values ) { return Tsr.of(values); }</span>

    /**
     *  Use this to construct and return a double based nd-array of the specified shape and initial values.
     *  The length of the provided array does not have to match the number of elements
     *  defined by the provided shape, the nd-array will be populated based on repeated iteration over the
     *  provided double array.
     *
     * @param shape The shape of the resulting nd-array consisting of any number of axis-sizes.
     * @param values The values which ought to be used to populate the tensor.
     */
<span class="nc" id="L238">    static Nda&lt;Double&gt; of( Shape shape, double... values ) { return Tsr.ofAny( Double.class, shape, values ); }</span>

    /**
     *  Use this to construct and return a float based nd-array of the specified shape and initial values.
     *  The length of the provided array does not have to match the number of elements
     *  defined by the provided shape, the nd-array will be populated based on repeated iteration over the
     *  provided float array.
     *
     * @param shape The shape of the resulting nd-array consisting of any number of axis-sizes.
     * @param values The values which ought to be used to populate the tensor.
     */
<span class="nc" id="L249">    static Nda&lt;Float&gt; of( Shape shape, float... values ) { return Tsr.ofAny( Float.class, shape, values ); }</span>

    /**
     *  Use this to construct and return a byte based nd-array of the specified shape and initial values.
     *  The length of the provided array does not have to match the number of elements
     *  defined by the provided shape, the nd-array will be populated based on repeated iteration over the
     *  provided byte array.
     *
     * @param shape The shape of the resulting nd-array consisting of any number of axis-sizes.
     * @param values The values which ought to be used to populate the tensor.
     */
<span class="nc" id="L260">    static Nda&lt;Byte&gt; of( Shape shape, byte... values ) { return Tsr.ofAny( Byte.class, shape, values ); }</span>

    /**
     *  Use this to construct and return a int based nd-array of the specified shape and initial values.
     *  The length of the provided array does not have to match the number of elements
     *  defined by the provided shape, the nd-array will be populated based on repeated iteration over the
     *  provided int array.
     *
     * @param shape The shape of the resulting nd-array consisting of any number of axis-sizes.
     * @param values The values which ought to be used to populate the tensor.
     */
<span class="nc" id="L271">    static Nda&lt;Integer&gt; of( Shape shape, int... values ) { return Tsr.ofAny( Integer.class, shape, values ); }</span>

    /**
     *  Use this to construct and return a long based nd-array of the specified shape and initial values.
     *  The length of the provided array does not have to match the number of elements
     *  defined by the provided shape, the nd-array will be populated based on repeated iteration over the
     *  provided long array.
     *
     * @param shape The shape of the resulting nd-array consisting of any number of axis-sizes.
     * @param values The values which ought to be used to populate the tensor.
     */
<span class="nc" id="L282">    static Nda&lt;Long&gt; of( Shape shape, long... values ) { return Tsr.ofAny( Long.class, shape, values ); }</span>

    /**
     *  Use this to construct and return a short based nd-array of the specified shape and initial values.
     *  The length of the provided array does not have to match the number of elements
     *  defined by the provided shape, the nd-array will be populated based on repeated iteration over the
     *  provided short array.
     *
     * @param shape The shape of the resulting nd-array consisting of any number of axis-sizes.
     * @param values The values which ought to be used to populate the tensor.
     */
<span class="nc" id="L293">    static Nda&lt;Short&gt; of( Shape shape, short... values ) { return Tsr.ofAny( Short.class, shape, values ); }</span>

    /**
     *  Use this to construct and return a boolean based nd-array of the specified shape and initial values.
     *  The length of the provided array does not have to match the number of elements
     *  defined by the provided shape, the nd-array will be populated based on repeated iteration over the
     *  provided boolean array.
     *
     * @param shape The shape of the resulting nd-array consisting of any number of axis-sizes.
     * @param values The values which ought to be used to populate the tensor.
     */
<span class="nc" id="L304">    static Nda&lt;Boolean&gt; of( Shape shape, boolean... values ) { return Tsr.ofAny( Boolean.class, shape, values ); }</span>

    /**
     *  Use this to construct and return an object based nd-array of the specified shape and initial values.
     *  The length of the provided array does not have to match the number of elements
     *  defined by the provided shape, the nd-array will be populated based on repeated iteration over the
     *  provided object array.
     *
     * @param shape The shape of the resulting nd-array consisting of any number of axis-sizes.
     * @param values The values which ought to be used to populate the tensor.
     */
    @SafeVarargs
<span class="nc" id="L316">    static &lt;T&gt; Nda&lt;T&gt; of( Shape shape, T... values ) { return (Nda&lt;T&gt;) Tsr.of( values ).reshape( shape.toIntArray() ); }</span>

    /**
     * Constructs a vector of objects based on the provided iterable.
     *
     * @param values The iterable of objects from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of objects.
     */
<span class="nc" id="L324">    static &lt;T&gt; Nda&lt;T&gt; of( Iterable&lt;T&gt; values ) { return Tsr.of(values); }</span>

    /**
     * Constructs a vector of objects based on the provided list.
     *
     * @param values The list of objects from which a 1D nd-array ought to be constructed.
     * @return A vector / 1D nd-array of objects.
     */
<span class="fc" id="L332">    static &lt;T&gt; Nda&lt;T&gt; of( List&lt;T&gt; values ) { return TsrImpl._of(values); }</span>

    /**
     *  A nd-array can have a label. This label is used for example when printing the nd-array.
     *  When loading a CSV file for example the label of the nd-array
     *  will be taken from the cell where the header row and the first column intersect.
     *  @return The label/name of the nd-array.
     */
<span class="fc" id="L340">    default String getLabel() { return ((TsrImpl&lt;?&gt;) this).find(NDFrame.class).map(NDFrame::getLabel).orElse(&quot;&quot;); }</span>

    /**
     *  A nd-array can have a label. This label is used for example when printing the nd-array.
     *  When loading a CSV file for example the label of the nd-array
     *  will be taken from the cell where the header row and the first column intersect.
     *  This is a shorter version of {@link #getLabel()}.
     *  @return The label/name of the nd-array.
     */
<span class="fc" id="L349">    default String label() { return this.getLabel(); }</span>

    /**
     *  If this nd-array is a slice of a parent nd-array then this method will yield true.
     *  Slices can be created by calling the variations of the &quot;{@link Nda#getAt}&quot; method.
     *
     * @return The truth value determining if this nd-array is a slice of another nd-array.
     * @see Nda#getAt(int...)
     * @see Nda#slice()
     */
    boolean isSlice();

    /**
     * If this nd-array is a shallow copy of a parent nd-array then this method will yield true.
     * Shallow copies can be created by calling the &quot;{@link Nda#shallowCopy()}&quot; method.
     * @return The truth value determining if this nd-array is a shallow copy of another nd-array.
     * @see Nda#shallowCopy()
     */
    boolean isShallowCopy();

    /**
     *  If this nd-array is a partial slice of a parent nd-array then this method will yield true.
     *  A partial slice is a slice which does not view all the parents items.
     *  Partial slices can be created by calling the variations of the &quot;{@link Nda#getAt}&quot; method.
     *  This is the inverse of {@link Nda#isFullSlice()}.
     * @return The truth value determining if this nd-array is a partial slice of another nd-array.
     */
    boolean isPartialSlice();

    /**
     *  If this nd-array is a full slice of a parent nd-array then this method will yield true.
     *  A full slice is a slice which views all the parents items.
     *  Full slices can be created by calling the variations of the &quot;{@link Nda#getAt}&quot; method.
     *  This is the inverse of {@link Nda#isPartialSlice()}.
     * @return The truth value determining if this nd-array is a full slice of another nd-array.
     */
<span class="pc bpc" id="L385" title="2 of 4 branches missed.">    default boolean isFullSlice() { return isSlice() &amp;&amp; !isPartialSlice(); }</span>

    /**
     *  This method returns the number of slices which have been
     *  created from this nd-array.
     *  It does so by accessing the {@link Relation} component if present
     *  which internally keeps track of slices via weak references.
     *
     * @return The number of slices derived from this nd-array.
     */
    int sliceCount();

    /**
     *  If slices have been derived from this nd-array then it is a &quot;slice parent&quot;.
     *  This is what this method will determine, in which case, it will return true.
     *
     * @return The truth value determining if slices have been derived from this nd-array.
     */
    boolean isSliceParent();

    /**
     * @return The type class of individual value items within this nd-array.
     */
    Class&lt;V&gt; getItemType();

    /**
     * @return The type class of individual value items within this nd-array.
     */
<span class="fc" id="L413">    default Class&lt;V&gt; itemType() { return getItemType(); }</span>

    /**
     * @return A new nd-array which is a shallow copy of this nd-array but with a different label.
     */
    Nda&lt;V&gt; withLabel( String label );

    /**
     *  This method receives a nested {@link String} array which
     *  ought to contain a label for the index of this nd-array.
     *  The index for a single element of this nd-array would be an array
     *  of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows:    &lt;br&gt;
     *                                                              &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                      &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                                 &lt;br&gt;
     *                                                              &lt;br&gt;
     *
     * @param labels A nested String array containing labels for indexes of the nd-array dimensions.
     * @return This nd-array (method chaining).
     */
    Nda&lt;V&gt; withLabels( String[]... labels );

    /**
     *  This method receives a nested {@link String} list which
     *  ought to contain a label for the index of this nd-array.
     *  The index for a single element of this nd-array would be an array
     *  of numbers as long as the rank where every number is
     *  in the range of the corresponding shape dimension...
     *  Labeling an index means that for every dimension there
     *  must be a label for elements in this range array! &lt;br&gt;
     *  For example the shape (2,3) could be labeled as follows: &lt;br&gt;
     *                                                           &lt;br&gt;
     *      dim 0 : [&quot;A&quot;, &quot;B&quot;]                                   &lt;br&gt;
     *      dim 1 : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                              &lt;br&gt;
     *                                                           &lt;br&gt;
     * @param labels A nested String list containing labels for indexes of the nd-array dimensions.
     * @return This nd-array (method chaining).
     */
    Nda&lt;V&gt; withLabels( List&lt;List&lt;Object&gt;&gt; labels );

    /**
     *  This method provides the ability to
     *  label not only the indices of the shape of this nd-array, but also
     *  the dimension of the shape.
     *  The first and only argument of the method expects a map instance
     *  where keys are the objects which ought to act as dimension labels
     *  and the values are lists of labels for the indices of said dimensions.
     *  For example the shape (2,3) could be labeled as follows:            &lt;br&gt;
     *  [                                                                   &lt;br&gt;
     *      &quot;dim 0&quot; : [&quot;A&quot;, &quot;B&quot;],                                           &lt;br&gt;
     *      &quot;dim 1&quot; : [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]                                       &lt;br&gt;
     *  ]                                                                   &lt;br&gt;
     *                                                                      &lt;br&gt;
     * @param labels A map in which the keys are dimension labels and the values are lists of index labels for the dimension.
     * @return This nd-array (method chaining).
     */
    Nda&lt;V&gt; withLabels( Map&lt;Object, List&lt;Object&gt;&gt; labels );


    /*==================================================================================================================
    |
    |       ยง(6) : ND-ITERATOR LOGIC :
    |   ---------------------------------------
    */

    /**
     *  @return A {@link Stream} of the items in this {@link Nda}.
     */
    default Stream&lt;V&gt; stream() {
<span class="fc" id="L486">        Object rawItems = getRawItems();</span>
        Stream&lt;V&gt; stream;
<span class="fc bfc" id="L488" title="All 2 branches covered.">        if ( rawItems instanceof double[] )</span>
<span class="fc" id="L489">            stream = (Stream&lt;V&gt;) DoubleStream.of( (double[]) rawItems ).boxed();</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">        else if ( rawItems instanceof int[] )</span>
<span class="fc" id="L491">            stream = (Stream&lt;V&gt;) IntStream.of( (int[]) rawItems ).boxed();</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">        else if ( rawItems instanceof long[] )</span>
<span class="fc" id="L493">            stream = (Stream&lt;V&gt;) LongStream.of( (long[]) rawItems ).boxed();</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">        else if ( rawItems instanceof float[] )</span>
<span class="fc" id="L495">            stream = IntStream.range(0,size()).mapToObj(i -&gt; (V) Float.valueOf( ((float[]) rawItems)[i] ) );</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        else if ( rawItems instanceof byte[] )</span>
<span class="fc" id="L497">            stream = IntStream.range(0,size()).mapToObj(i -&gt; (V) Byte.valueOf( ((byte[]) rawItems)[i] ) );</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        else if ( rawItems instanceof short[] )</span>
<span class="fc" id="L499">            stream = IntStream.range(0,size()).mapToObj(i -&gt; (V) Short.valueOf( ((short[]) rawItems)[i] ) );</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">        else if ( rawItems instanceof boolean[] )</span>
<span class="fc" id="L501">            stream = IntStream.range(0,size()).mapToObj(i -&gt; (V) Boolean.valueOf( ((boolean[]) rawItems)[i] ) );</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">        else if ( rawItems instanceof char[] )</span>
<span class="fc" id="L503">            stream = IntStream.range(0,size()).mapToObj(i -&gt; (V) Character.valueOf( ((char[]) rawItems)[i] ) );</span>
        else
<span class="fc" id="L505">            stream = (Stream&lt;V&gt;) Arrays.stream( (Object[]) rawItems );</span>

<span class="fc bfc" id="L507" title="All 2 branches covered.">        boolean executeInParallel = ( this.size() &gt; 1_000 );</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        return executeInParallel ? stream.parallel() : stream;</span>
    }

    /**
     *  A convenience method for {@code stream().filter( predicate )}.
     *
     * @param predicate The predicate to filter the items of this {@link Nda}.
     * @return A {@link Stream} of the items in this {@link Nda} which match the predicate.
     */
<span class="fc" id="L517">    default Stream&lt;V&gt; filter( Predicate&lt;V&gt; predicate ) { return stream().filter( predicate ); }</span>

    /**
     *  A convenience method for {@code nda.stream().flatMap( mapper )},
     *  which turns this {@link Nda} into a {@link Stream} of its items. &lt;br&gt;
     *  Here an example of how to use this method : &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var nda = Nda.of( -2, -1, 0, 1, 2 );
     *    var list = nda.flatMap( i -&gt; Stream.of( i * 2, i * 3 ) ).toList();
     *    // list = [-4, -6, -2, -3, 0, 0, 2, 3, 4, 6, 6, 9]
     *  }&lt;/pre&gt;
     *
     * @param mapper The mapper to map the items of this {@link Nda}.
     * @return A {@link Stream} of the items in this {@link Nda} which match the predicate.
     */
    default &lt;R&gt; Stream&lt;R&gt; flatMap( Function&lt;V, Stream&lt;R&gt;&gt; mapper ) {
<span class="fc" id="L533">        return stream().flatMap( v -&gt; {</span>
<span class="fc" id="L534">            Object o = mapper.apply( v );</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">            if ( o instanceof Iterable )</span>
<span class="fc" id="L536">                return (Stream&lt;R&gt;) StreamSupport.stream( ((Iterable) o).spliterator(), false );</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">            else if ( o instanceof Stream )</span>
<span class="nc" id="L538">                return (Stream&lt;R&gt;) o;</span>
            else
<span class="nc" id="L540">                return Stream.of( (R) o );</span>
        });
    }

    /**
     * Returns a {@code Collector} that accumulates the input elements into a
     * new {@link Nda} with the specified shape. &lt;br&gt;
     * Usage example : &lt;br&gt;
     * &lt;pre&gt;{@code
     *    var nda = Stream.of( 1, 2, 3, 4, 5, 6 )
     *                      .collect( Nda.shaped( 2, 3 ) );
     * }&lt;/pre&gt;
     *
     * @param shape The shape of the nd-array to be returned.
     * @param &lt;T&gt; the type of the input elements
     * @return a {@code Collector} which collects all the input elements into a
     *          {@link Nda}, in encounter order.
     */
    static &lt;T&gt; Collector&lt;T, ?, Nda&lt;T&gt;&gt; shaped( int... shape ) {
<span class="fc" id="L559">        return Collector.of(</span>
                (Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new,
                List::add,
<span class="nc" id="L562">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L563">                list -&gt; Tsr.of( Shape.of(shape), list )</span>
            );
    }

    /**
     * Iterates over every element of this nd-array, and checks whether all
     * elements are &lt;code&gt;true&lt;/code&gt; according to the provided lambda.
     * @param predicate The lambda to check each element against.
     * @return true if every item in the nd-array matches the predicate, false otherwise.
     */
    default boolean every( Predicate&lt;V&gt; predicate ) {
<span class="fc bfc" id="L574" title="All 2 branches covered.">        if ( ((Tsr&lt;V&gt;)this).isVirtual() ) return predicate.test( this.item() );</span>
<span class="fc" id="L575">        return stream().allMatch(predicate);</span>
    }

    /**
     * Iterates over every element of this nd-array, and checks whether any
     * element matches the provided lambda.
     * @param predicate The lambda to check each element against.
     * @return true if any item in the nd-array matches the predicate, false otherwise.
     */
    default boolean any( Predicate&lt;V&gt; predicate ) {
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">        if ( ((Tsr&lt;V&gt;)this).isVirtual() ) return predicate.test( this.item() );</span>
<span class="fc" id="L586">        return stream().anyMatch(predicate);</span>
    }

    /**
     * Iterates over every element of this nd-array, and checks whether none
     * of the elements match the provided lambda.
     * @param predicate The lambda to check each element against.
     * @return true if none of the items in the nd-array match the predicate, false otherwise.
     */
    default boolean none( Predicate&lt;V&gt; predicate ) {
<span class="pc bpc" id="L596" title="3 of 4 branches missed.">        if ( ((Tsr&lt;V&gt;)this).isVirtual() ) return !predicate.test( this.item() );</span>
<span class="fc" id="L597">        return stream().noneMatch(predicate);</span>
    }

    /**
     *  Iterates over every element of this nd-array, and counts the number of
     *  times the provided lambda matches the items of this array.
     *  &lt;p&gt;
     *  Here is an example of counting the number of items in the array that are
     *  greater than 5 :
     *  &lt;pre&gt;{@code
     *    var nda = Nda.of( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 );
     *    var count = nda.count( i -&gt; i &gt; 5 );
     *    System.out.println( count ); // prints 5
     *  }&lt;/pre&gt;
     *
     *
     * @param predicate The lambda to check each element against.
     * @return The number of items in the nd-array that match the predicate.
     */
    default int count( Predicate&lt;V&gt; predicate ) {
<span class="pc bpc" id="L617" title="3 of 4 branches missed.">        if ( ((Tsr&lt;V&gt;)this).isVirtual() ) return predicate.test( this.item() ) ? this.size() : 0;</span>
<span class="fc" id="L618">        return (int) stream().filter(predicate).count();</span>
    }

    /**
     * Returns the minimum item of this nd-array according to the provided
     * {@link Comparator}.  This is a special case of a reduction.
     *
     * @param comparator The {@link Comparator} to use to determine the order of the items in the nd-array.
     * @return The minimum value in the nd-array.
     */
    default V minItem( Comparator&lt;V&gt; comparator ) {
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">        if ( ((Tsr&lt;V&gt;)this).isVirtual() ) return this.item();</span>
<span class="fc" id="L630">        return stream().min( comparator ).orElse(null);</span>
    }

    /**
     * Returns the maximum item of this nd-array according to the provided
     * {@link Comparator}.  This is a special case of a reduction.
     *
     * @param comparator The {@link Comparator} to use to determine the order of the items in the nd-array.
     * @return The maximum value in the nd-array.
     */
    default V maxItem( Comparator&lt;V&gt; comparator ) {
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if ( ((Tsr&lt;V&gt;)this).isVirtual() ) return this.item();</span>
<span class="fc" id="L642">        return stream().max( comparator ).orElse(null);</span>
    }

    /**
     *  This returns an unprocessed version of the underlying data of this nd-array.
     *  If this nd-array is outsourced (stored on a device), then the data will be loaded
     *  into an array and returned by this method.
     *  Do not expect the returned array to be actually stored within the nd-array itself!
     *  Contrary to the {@link #getItems()} method, this one will
     *  return the data in an unbiased form, where for example a virtual (see {@link Tsr#isVirtual()})
     *  nd-array will have this method return an array of length 1.
     *
     * @return An unbiased copy of the underlying data of this nd-array.
     */
    Object getRawData();

    /**
     *  Use this to access elements of the underlying data array without any index
     *  transformation applied to it. This is usually similar to the {@link #item} method,
     *  however for nd-arrays which are sliced or permuted views of the data of another nd-array,
     *  this method will always be unbiased access of the raw data...
     *
     * @param i The position of the targeted item within the raw data array of an NDArray implementation.
     * @return The found object sitting at the specified index position.
     */
    V getDataAt( int i );

    /**
     *  A more verbose version of the {@link #items()} method (best used by JVM languages with property support).
     * @return A list of the items in this nd-array.
     */
<span class="fc" id="L673">    default List&lt;V&gt; getItems() { return stream().collect( Collectors.toList() ); }</span>

    /**
     *  A more concise version of the {@link #getItems()} method.
     * @return A list of the items in this nd-array.
     */
<span class="fc" id="L679">    default List&lt;V&gt; items() { return getItems(); }</span>

    /**
     * @return The items of this nd-array as a (if possible) primitive array.
     */
    Object getRawItems();

    /**
     *  The following method returns a single item within this nd-array
     *  targeted by the provided integer index.
     *
     * @param i The scalar index of the item which should be returned by the method.
     * @return The item found at the targeted index.
     */
<span class="fc" id="L693">    default V item( int i ) { return getDataAt( indexOfIndex( i ) ); }</span>

    /**
     *  This method returns a raw value item within this nd-array
     *  targeted by an index array which is expected to hold an index for
     *  every dimension of the shape of this nd-array.
     *  So the provided array must have the same length as the
     *  rank of this nd-array!
     *
     * @param indices The index array which targets a single value item within this nd-array.
     * @return The found raw value item targeted by the provided index array.
     */
    default V item( int... indices ) {
<span class="fc" id="L706">        LogUtil.nullArgCheck( indices, &quot;indices&quot;, int[].class, &quot;Cannot find nd-array value without indices!&quot; );</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if ( indices.length == 0 ) throw new IllegalArgumentException(&quot;Index array may not be empty!&quot;);</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">        if ( indices.length &lt; this.rank() ) {</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            if ( indices.length == 1 ) return getDataAt( getNDConf().indexOfIndex( indices[0] ) );</span>
            else {
<span class="fc" id="L711">                int[] allIndices = new int[this.rank()]; // We do some 0 padding to make sure we have the correct number of indices.</span>
<span class="fc" id="L712">                System.arraycopy( indices, 0, allIndices, 0, indices.length );</span>
<span class="fc" id="L713">                return getDataAt( getNDConf().indexOfIndices( allIndices ) );</span>
            }
        }
<span class="fc" id="L716">        return getDataAt( getNDConf().indexOfIndices( indices ) );</span>
    }

    /**
     *  Equivalent to the {@code #item(0)} and {@link #getItem()}.
     *
     * @return The first item of this nd-array.
     */
<span class="fc" id="L724">    default V item() { return item( 0 ); }</span>

    /**
     *  Equivalent to the {@code #item(0)} and {@link #item()}.
     *
     * @return The first item of this nd-array.
     */
<span class="fc" id="L731">    default V getItem() { return item(); }</span>

    /**
     * Use this to get the items of this nd-array as a primitive array
     * of the specified type.
     * @param arrayTypeClass The class of the array type to return.
     * @param &lt;A&gt; The type of the array to return.
     * @return The items of this nd-array as a primitive array of the specified type.
     */
    default &lt;A&gt; A getItemsAs( Class&lt;A&gt; arrayTypeClass ) {
<span class="fc" id="L741">        return DataConverter.get().convert( getRawItems(), arrayTypeClass );</span>
    }

    /**
     * Use this to get the items of the underlying {@link Data} buffer
     * of this nd-array as a primitive array
     * of the specified type.
     * Note that the length of the returned array may be different from the
     * size of this nd-array. This is the case if this nd-array is a slice
     * of another larger nd-array.
     * @param arrayTypeClass The class of the array type to return.
     * @param &lt;A&gt; The type of the array to return.
     * @return The items of this nd-array as a primitive array of the specified type.
     */
    default  &lt;A&gt; A getDataAs( Class&lt;A&gt; arrayTypeClass ) {
<span class="nc" id="L756">        return DataConverter.get().convert( getRawData(), arrayTypeClass );</span>
    }

    /**
     *  This method returns a {@link SliceBuilder} instance exposing a simple builder API
     *  which enables the configuration of a slice of the current nd-array via method chaining.    &lt;br&gt;
     *  The following code snippet slices a 3-dimensional nd-array into a nd-array of shape (2x1x3)  &lt;br&gt;
     * &lt;pre&gt;{@code
     *  myArray.slice()
     *          .axis(0).from(0).to(1)
     *          .axis(1).at(5) // equivalent to '.from(5).to(5)'
     *          .axis().from(0).to(2)
     *          .get();
     * }&lt;/pre&gt;
     *
     * @return An instance of the {@link SliceBuilder} class exposing a readable builder API for creating slices.
     */
    AxisOrGet&lt;V&gt; slice();

    /**
     * This method concatenates the provided nd-arrays together with this nd-array along a specified axis.
     * The provided nd-arrays must have the same shape and data type as the current nd-array, except for the specified axis.
     *
     * @param axis The axis along which the provided nd-arrays should be concatenated.
     *             The axis must be within the range of the rank of the current nd-array.
     * @param other The other nd-arrays which should be concatenated with this nd-array.
     * @param ndArrays The non-null, non-empty nd-arrays which should be concatenated together with this and the other nd-array.
     *                 The nd-arrays all must have the same shape as this nd-array, except for the specified axis.
     *                 Also, it must have the same data type as the current nd-array.
     * @return A new nd-array which is the concatenation of the current nd-array and the provided nd-arrays.
     */
    Nda&lt;V&gt; concatAt( int axis, Nda&lt;V&gt; other, Nda&lt;V&gt;... ndArrays );

    /**
     * This method concatenates the provided nd-array together with this nd-array along a specified axis.
     * The provided nd-array must have the same shape and data type as this nd-array, except for the specified axis.
     *
     * @param axis The axis along which the provided nd-arrays should be concatenated.
     *             The axis must be within the range of the rank of the current nd-array.
     * @param other The other nd-arrays which should be concatenated with this nd-array.
     * @return A new nd-array which is the concatenation of the current nd-array and the provided nd-arrays.
     */
    Nda&lt;V&gt; concatAt( int axis, Nda&lt;V&gt; other );

    /**
     *  The following method enables access to specific scalar elements within the nd-array.
     *  The method name also translates to the subscription operator in Groovy.
     *
     * @param indices The index array of the element which should be returned.
     * @return An element located at the provided index.
     */
    Nda&lt;V&gt; getAt( int... indices );

    /**
     *  This getter method creates and returns a slice of the original nd-array.
     *  The returned slice is a scalar nd-array wrapping a single value element which
     *  is being targeted by the provided integer index.
     *
     * @param i The index of the value item which should be returned as a nd-array instance.
     * @return A nd-array holding a single value element which is internally still residing in the original nd-array.
     */
    Nda&lt;V&gt; getAt( Number i );

    /**
     *  The following method enables access to specific scalar elements within the nd-array.
     *  The method name also translates to the subscription operator in Groovy.
     *
     * @param indices The index array of the element which should be returned.
     * @return An element located at the provided index.
     */
    Nda&lt;V&gt; get( int... indices );

    /**
     *  The following method enables the creation of nd-array slices which access
     *  the same underlying data (possibly from a different view).
     *  The method name also translates to the subscription operator in Groovy.
     *
     * @param args An arbitrary number of arguments which can be used for slicing.
     * @return A slice nd-array created based on the passed keys.
     */
    Nda&lt;V&gt; getAt( Object... args );

    /**
     *  The following method enables the creation of nd-array slices which access
     *  the same underlying data (possibly from a different view).
     *  The method name also translates to the subscription operator in Groovy.
     *
     * @param args An arbitrary number of arguments which can be used for slicing.
     * @return A slice nd-array created based on the passed keys.
     */
    Nda&lt;V&gt; get( Object... args );

    /**
     *  This getter method creates and returns a slice of the original nd-array.
     *  The returned slice is a scalar nd-array wrapping a single value element which
     *  is being targeted by the provided integer index.
     *
     * @param i The index of the value item which should be returned as a nd-array instance.
     * @return A nd-array holding a single value element which is internally still residing in the original nd-array.
     */
    Nda&lt;V&gt; getAt( int i );

    /**
     *  This getter method creates and returns a slice of the original nd-array.
     *  The returned slice is a scalar nd-array wrapping a single value element which
     *  is being targeted by the provided integer index.
     *
     * @param i The index of the value item which should be returned as a nd-array instance.
     * @return A nd-array holding a single value element which is internally still residing in the original nd-array.
     */
    Nda&lt;V&gt; get( int i );

    /**
     *  This getter method creates and returns a slice of the original nd-array.
     *  The returned slice is a scalar nd-array wrapping a single value element which
     *  is being targeted by the provided integer index.
     *
     * @param i The index of the value item which should be returned as a nd-array instance.
     * @return A nd-array holding a single value element which is internally still residing in the original nd-array.
     */
    Nda&lt;V&gt; get( Number i );

    /**
     *  This method enables nd-array slicing!
     *  It takes a key of various types and configures a slice
     *  nd-array which shares the same underlying data as the original nd-array.
     *
     * @param key This object might be a wide range of objects including maps, lists or arrays...
     * @return A slice nd-array or scalar value.
     */
    Nda&lt;V&gt; get( Object key );

    /**
     *  This method is most useful when used in Groovy
     *  where defining maps is done through square brackets,
     *  making it possible to slice nd-arrays like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      var b = a[[[0..0]:1, [0..0]:1, [0..3]:2]]
     *  }&lt;/pre&gt;
     *  Here a single argument with the format '[i..j]:k' is equivalent
     *  to Pythons 'i:j:k' syntax for indexing! (numpy)                            &lt;br&gt;
     *  i... start indexAlias.                                                      &lt;br&gt;
     *  j... end indexAlias. (inclusive!)                                           &lt;br&gt;
     *  k... step size.
     *
     * @param rangToSteps A map where the keys define where axes should be sliced and values which define the steps for the specific axis.
     * @return A nd-array slice with an offset based on the provided map keys and
     *         steps based on the provided map values.
     */
    Nda&lt;V&gt; getAt( Map&lt;?,Integer&gt; rangToSteps );

    /**
     *  This method enables nd-array slicing!
     *  It takes a key of various types and configures a slice
     *  nd-array which shares the same underlying data as the original nd-array.
     *
     * @param key This object might be a wide range of objects including maps, lists or arrays...
     * @return A slice nd-array or scalar value.
     */
    Nda&lt;V&gt; getAt( List&lt;?&gt; key );

    /**
     * &lt;p&gt;
     *     This is a convenience method for mapping a nd-array to a nd-array of new type
     *     based on a provided target item type and mapping lambda.
     *     Here a simple example:
     * &lt;/p&gt;
     * &lt;pre&gt;{@code
     *     Nda&lt;String&gt;  a = Nda.of(String.class).vector(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
     *     Nda&lt;Integer&gt; b = a.mapTo(Integer.class, s -&gt; Integer.parseInt(s));
     * }&lt;/pre&gt;
     * &lt;p&gt;
     *     Note: &lt;br&gt;
     *     The provided lambda cannot be executed anywhere else but the CPU.
     *     This is a problem if this nd-array lives somewhere other than the JVM.
     *     So, therefore, this method will temporally transfer this nd-array from
     *     where ever it may reside back to the JVM, execute the mapping lambda, and
     *     then transfer the result back to the original location.
     * &lt;/p&gt;
     * @param typeClass The class of the item type to which the items of this nd-array should be mapped.
     * @param mapper The lambda which maps the items of this nd-array to a new one.
     * @param &lt;T&gt; The type parameter of the items of the returned nd-array.
     * @return A new nd-array of type {@code T}.
     */
    &lt;T&gt; Nda&lt;T&gt; mapTo(
        Class&lt;T&gt; typeClass,
        java.util.function.Function&lt;V,T&gt; mapper
    );

    /**
     * &lt;p&gt;
     *     This method is a convenience method for mapping the items of this nd-array to another
     *     nd-array of the same type based on the provided lambda function, which will be applied
     *     to all items of this nd-array individually (element-wise).
     * &lt;/p&gt;
     *  Here a simple example:
     *  &lt;pre&gt;{@code
     *  Nda&lt;String&gt; a = Nda.of(String.class).vector(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
     *  Nda&lt;String&gt; b = a.map( s -&gt; s + &quot;!&quot; );
     *  }&lt;/pre&gt;
     *  Note: &lt;br&gt;
     *  The provided lambda cannot be executed anywhere else but the CPU.
     *  This is a problem if this nd-array lives somewhere other than the JVM.
     *  So, therefore, this method will temporally transfer this nd-array from where ever it may reside
     *  back to the JVM, execute the mapping lambda, and then transfer the result back to the original location.
     *
     * @param mapper The lambda which maps the items of this nd-array to a new one.
     * @return A new nd-array of type {@code V}.
     */
    Nda&lt;V&gt; map( java.util.function.Function&lt;V,V&gt; mapper );

    /**
     *  This method creates and returns a new nd-array instance
     *  which is not only a copy of the configuration of this nd-array but also a copy of
     *  the underlying data array. &lt;br&gt;
     *  (Note: the underlying nd-array will not be attached to any kind of computation graph)
     *
     * @return A new nd-array instance which is a deep copy of this nd-array.
     */
    Nda&lt;V&gt; deepCopy();

    /**
     *  This creates a copy where the underlying data is still the same. &lt;br&gt;
     *  (Note: the underlying nd-array will not be attached to any kind of computation graph)
     *
     * @return A shallow copy where the underlying data is shared with this nd-array.
     */
    Nda&lt;V&gt; shallowCopy();

    /**
     *  This method exposes an API for mutating the state of this tensor.
     *  The usage of methods exposed by this API is generally discouraged
     *  because the exposed state can easily lead to broken tensors and exceptional situations!&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;p&gt;&lt;b&gt;
     *  Only use this if you know what you are doing and
     *  performance is critical! &lt;br&gt;
     *  &lt;/b&gt;
     *  (Like in custom backend extensions for example)
     *
     * @return The unsafe API exposes methods for mutating the state of the tensor.
     */
    MutateNda&lt;V&gt; getMut();

    /**
     *  This method exposes an API for mutating the state of this tensor.
     *  The usage of methods exposed by this API is generally discouraged
     *  because the exposed state can easily lead to broken tensors and exceptional situations!&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;p&gt;&lt;b&gt;
     *  Only use this if you know what you are doing and
     *  performance is critical! &lt;br&gt;
     *  &lt;/b&gt;
     *  (Like custom backend extensions for example)
     *
     * @return The unsafe API exposes methods for mutating the state of the tensor.
     */
<span class="nc" id="L1013">    default MutateNda&lt;V&gt; mut() { return getMut(); }</span>

    /**
     *  Returns a nd-array with the same data and number of elements as this nd-array, but with the specified shape.
     *  When possible, the returned nd-array will be a view of this nd-array.
     *
     *  A single dimension may be -1, in which case itโs inferred from the remaining
     *  dimensions and the number of elements in input.
     *
     *  Keep in mind that the new shape must have the same number of elements as the original shape. &lt;br&gt;
     *  &lt;br&gt;
     *  This operation supports autograd.
     *
     * @param shape The new shape of the returned nd-array.
     * @return A new nd-array instance with the same underlying data (~shallow copy) but with a different shape.
     */
    Nda&lt;V&gt; reshape( int... shape );

    /**
     *  Returns a view of the original tensor input with its dimensions permuted.&lt;br&gt;
     *  Consider a 3-dimensional tensor x with shape (2ร3ร5),
     *  then calling x.permute(1, 0, 2) will return a 3-dimensional tensor of shape (3ร2ร5). &lt;br&gt;
     *
     * @param dims The desired ordering of dimensions
     * @return A new nd-array instance with the same underlying data (~shallow copy) but with a different shape.
     */
    Nda&lt;V&gt; permute( int... dims );

    /**
     * Returns a view of the original tensor input the targeted
     * axes are swapped / transposed.&lt;br&gt;
     *
     * @param dim1 The first dimension to be swapped.
     * @param dim2 The second dimension to be swapped.
     * @return A new nd-array instance with the same underlying data (~shallow copy) but with a different shape.
     */
    Nda&lt;V&gt; transpose( int dim1, int dim2 );

    /**
     *  This method exposes the {@link Item} API which allows you to get or set
     *  individual items within this nd-array targeted by an array of provided indices.
     * @param indices An array of indices targeting a particular position in this nd-array...
     * @return An object which allows you to get or set individual items within this nd-array.
     */
    Item&lt;V&gt; at( int... indices );

    /**
     *  Instances of this are being returned by the {@link #at(int...)} method,
     *  and they allow you to get individual nd-array items
     * @param &lt;V&gt; The type of the items of this nd-array.
     */
    interface Item&lt;V&gt;
    {
        /**
         *  Get the value at the targeted position or throw an exception if the item does not exist.
         *
         * @return The value at the targeted position.
         */
        default V get() {
<span class="fc" id="L1072">            V item = orElseNull();</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">            if ( item == null )</span>
<span class="fc" id="L1074">                throw new IllegalArgumentException(&quot;No item at the targeted position!&quot;);</span>
<span class="fc" id="L1075">            return item;</span>
        }

        /**
         *  Get the value at the targeted position or return the provided default value if the item does not exist.
         *
         * @param defaultValue The default value to return if the item does not exist.
         * @return The value at the targeted position or the provided default value.
         * @throws IllegalArgumentException If the provided default value is {@code null}.
         */
        default V orElse( V defaultValue ) {
<span class="fc bfc" id="L1086" title="All 2 branches covered.">            if ( defaultValue == null )</span>
<span class="fc" id="L1087">                throw new IllegalArgumentException(&quot;The provided default value must not be null! (Use orElseNull() instead)&quot;);</span>
<span class="fc" id="L1088">            V item = orElseNull();</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">            return item == null ? defaultValue : item;</span>
        }

        /**
         *  Get the value at the targeted position or return {@code null} if the item does not exist.
         *
         * @return The value at the targeted position or {@code null}.
         */
        V orElseNull();

        /**
         *  Converts this item into an optional value.
         *  If the item exists, the resulting optional will contain the value.
         *  Otherwise, the resulting optional will be empty.
         * @return An optional value.
         */
        default Optional&lt;V&gt; toOptional() {
<span class="fc" id="L1106">            V item = orElseNull();</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">            return item == null ? Optional.empty() : Optional.of( item );</span>
        }

        /**
         *  Maps this item to an optional value based on the provided lambda.
         *  The lambda will be executed if the item exists.
         *  If the lambda returns {@code null} the resulting optional will be empty.
         *  Otherwise, the resulting optional will contain the value returned by the lambda.
         *
         *  @param mapper The lambda which maps the item to an optional value.
         *  @return An optional value based on the provided lambda.
         */
        default Optional&lt;V&gt; map( Function&lt;V,V&gt; mapper ) {
<span class="nc" id="L1120">            V item = orElseNull();</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">            return item == null ? Optional.empty() : Optional.ofNullable( mapper.apply( item ) );</span>
        }

        /**
         * @return {@code true} if the item exists, {@code false} otherwise.
         */
        default boolean exists() {
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">            return orElseNull() != null;</span>
        }

        /**
         * @return {@code true} if the item does not exist, {@code false} otherwise.
         */
        default boolean doesNotExist() {
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">            return orElseNull() == null;</span>
        }
    }

    /**
     *  Use this to turn this nd-array into a {@link String} instance based on the provided
     *  {@link NDPrintSettings} instance, which allows you to configure things
     *  like the number of chars per entry, delimiters, the number of items per line, etc.
     */
    default String toString( NDPrintSettings config ) {
<span class="fc" id="L1145">        return NdaAsString.representing( this ).withConfig( config ).toString();</span>
    }

    /**
     *  This allows you to provide a lambda which configures how this nd-array should be
     *  converted to {@link String} instances.
     *  The provided {@link Consumer} will receive a {@link NDPrintSettings} instance
     *  which allows you to change various settings with the help of method chaining.&lt;br&gt;
     *  Here is an example:
     *  &lt;pre&gt;{@code
     *       t.toString(it -&gt;
     *           it.setHasSlimNumbers(false)
     *             .setIsScientific(true)
     *             .setIsCellBound(true)
     *             .setIsMultiline(true)
     *             .setCellSize(15)
     *          );
     *  }&lt;/pre&gt;
     *
     * @param config A consumer of the {@link NDPrintSettings} ready to be configured.
     * @return The {@link String} representation of this nd-array.
     */
    default String toString( Consumer&lt;NDPrintSettings&gt; config ) {
<span class="fc" id="L1168">        NDPrintSettings defaults = Neureka.get().settings().view().getNDPrintSettings().clone();</span>
<span class="fc" id="L1169">        config.accept(defaults);</span>
<span class="fc" id="L1170">        return NdaAsString.representing( this ).withConfig( defaults ).toString();</span>
    }

    /**
     *  This method returns a {@link String} representation of this nd-array.
     *  The default settings are used for the conversion.
     * @return The {@link String} representation of this nd-array.
     */
    String toString();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>