<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TsrImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka</a> &gt; <span class="el_source">TsrImpl.java</span></div><h1>TsrImpl.java</h1><pre class="source lang-java linenums">/*
MIT License

Copyright (c) 2019 Gleethos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 __________
 \__    ___\
    |  |____ _ __
    | /  ___/ '___\
    | \___  \ |
     \/_____/_|Impl      A long yet shallow class.

    This is the the core work-horse class of Neureka. The 'Tsr' class!
    It is a three-letter abbreviation of the word &quot;Tensor&quot;!

------------------------------------------------------------------------------------------------------------------------

   'Any fool can write code that a computer can understand.
    Good programmers write code that humans can understand.'
    â€“ Martin Fowler

    Use the following as search keys :)

    Â§(1) : CONSTRUCTION
    Â§(2) : FLAGS
    Â§(3) : COMPONENT SYSTEM
    Â§(4) : PROPERTIES
    Â§(5) : OBJECT STATE MODIFICATION
    Â§(6) : ND-ITERATOR LOGIC
    Â§(7) : COMPONENT SPECIFIC
    Â§(8) : (OVERLOADABLE) OPERATORS &amp; OPERATIONS
    Â§(9) : SLICING, INDEXING &amp; INJECTING
    Â§(10) : MAPPING
*/

package neureka;

import neureka.autograd.GraphNode;
import neureka.backend.api.ExecutionCall;
import neureka.backend.main.memory.MemUtil;
import neureka.calculus.Function;
import neureka.common.composition.AbstractComponentOwner;
import neureka.common.composition.Component;
import neureka.common.utility.DataConverter;
import neureka.common.utility.LogUtil;
import neureka.devices.Device;
import neureka.devices.host.CPU;
import neureka.dtype.DataType;
import neureka.fluent.slicing.SliceBuilder;
import neureka.fluent.slicing.SmartSlicer;
import neureka.fluent.slicing.states.AxisOrGetTsr;
import neureka.framing.NDFrame;
import neureka.framing.Relation;
import neureka.framing.fluent.AxisFrame;
import neureka.ndim.Filler;
import neureka.ndim.NDConstructor;
import neureka.ndim.config.NDConfiguration;
import neureka.ndim.iterator.NDIterator;
import neureka.view.NdaAsString;
import org.slf4j.LoggerFactory;

import java.awt.*;
import java.awt.image.*;
import java.util.List;
import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;


/**
 *  The implementation for the {@link Tsr} API.
 *
 * @param &lt;V&gt; The type parameter for the individual value items within this tensor.
 */
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">final class TsrImpl&lt;V&gt; extends AbstractNda&lt;Tsr&lt;V&gt;, V&gt;</span>
{
    static {
<span class="fc" id="L97">        _LOG = LoggerFactory.getLogger( TsrImpl.class );</span>
<span class="fc" id="L98">    }</span>

    /**
     *  This field contains multiple flags.
     *  The bits of this integer are used to encode various states which a tensor can have.
     *  These bits are flipped by bitmasks which are defined below.
     */
<span class="fc" id="L105">    private byte _flags = 0;</span>

    /**
     *  The following fields are bit masks used to store true / false values
     *  in a targeted bit inside the {@link #_flags} variable.
     */
    private static final byte RQS_GRADIENT_MASK       = 1;
    private static final byte IS_VIRTUAL_MASK         = 2;
    private static final byte GRADIENT_APPLY_RQD_MASK = 4;
    private static final byte IS_DELETED_MASK         = 8;
    private static final byte IS_INTERMEDIATE_MASK    = 16;

    /*==================================================================================================================
    |
    |       Â§(1) : CONSTRUCTION
    |   ---------------------------
    */

    static &lt;T&gt; Tsr&lt;T&gt; _of( Object... args )
    {
<span class="pc bpc" id="L125" title="2 of 4 branches missed.">        if ( args == null || args.length == 0 ) return new TsrImpl&lt;&gt;();</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if ( args.length == 1 ) {</span>
<span class="fc" id="L127">            TsrImpl&lt;T&gt; t = new TsrImpl&lt;&gt;();</span>
<span class="fc" id="L128">            boolean success = t.constructFor(CPU.get(), NDConstructor.of(new int[]{ 1 })).newPopulatedFromOne( args[ 0 ], args[ 0 ].getClass() );</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">            if ( !success ) {</span>
<span class="nc" id="L130">                String message = &quot;Cannot create tensor from argument of type '&quot; + args[ 0 ].getClass().getName() + &quot;'!&quot;;</span>
<span class="nc" id="L131">                _LOG.error( message );</span>
<span class="nc" id="L132">                throw new IllegalArgumentException( message );</span>
            }
<span class="fc" id="L134">            return t;</span>
        }
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        args[ 0 ] = ( args[ 0 ] instanceof ArrayList ) ? ( (List&lt;?&gt;) args[ 0 ] ).toArray() : args[ 0 ];</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        args[ 1 ] = ( args[ 1 ] instanceof ArrayList ) ? ( (List&lt;?&gt;) args[ 1 ] ).toArray() : args[ 1 ];</span>

<span class="fc" id="L139">        Class&lt;?&gt; commonType = _extractCommonType(args);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if ( commonType != null ) {</span>
<span class="fc" id="L141">            TsrImpl&lt;T&gt; t = new TsrImpl&lt;&gt;();</span>
<span class="fc" id="L142">            t.constructFor(CPU.get(), NDConstructor.of(new int[]{args.length}))</span>
<span class="fc" id="L143">                .tryConstructing(</span>
<span class="fc" id="L144">                    DataType.of(commonType),</span>
                    args
                );
<span class="fc" id="L147">            return t;</span>
        }

        /* EXPRESSION BASED CONSTRUCTION:
            The following allows the creation of tensors based on passing an expression
            alongside input tensors to the constructor.
            An example would be:

                Tsr&lt;?&gt; t = Tsr.of( &quot;tanh(&quot;, x, &quot;) * 7 **&quot;, y );
        */
<span class="fc" id="L157">        boolean containsString = false;</span>
<span class="fc" id="L158">        int numberOfTensors = 0;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        for ( Object o : args ) {</span>
<span class="fc bfc" id="L160" title="All 4 branches covered.">            containsString = ( o instanceof String ) || containsString;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            if ( o instanceof TsrImpl)</span>
<span class="fc" id="L162">                numberOfTensors++;</span>
        }
<span class="fc" id="L164">        TsrImpl&lt;T&gt;[] tensors = new TsrImpl[ numberOfTensors ];</span>
<span class="fc" id="L165">        StringBuilder f = new StringBuilder();</span>
<span class="fc" id="L166">        int ti = 0;</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        for ( Object o : args ) {</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            if ( o instanceof TsrImpl) {</span>
<span class="fc" id="L169">                tensors[ ti ] = ( (TsrImpl&lt;T&gt;) o );</span>
<span class="fc" id="L170">                f.append( &quot;I[&quot; ).append( ti ).append( &quot;]&quot; );</span>
<span class="fc" id="L171">                ti++;</span>
            }
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            else if ( o instanceof String ) f.append( (String) o );</span>
            else
<span class="nc" id="L175">                _LOG.debug(</span>
<span class="nc" id="L176">                    &quot;Unexpected tensor construction argument of type '&quot;+o.getClass().getSimpleName()+&quot;'&quot;</span>
                );
        }
<span class="pc bpc" id="L179" title="2 of 4 branches missed.">        if ( tensors.length == 0 || tensors[0] == null) return new TsrImpl&lt;&gt;();</span>
<span class="fc" id="L180">        return Function.of( f.toString(), true ).call( tensors );</span>
    }

    /**
     * @param args The objects which should be checked.
     * @return A common type or null if they are not all of the same type.
     */
    private static Class&lt;?&gt; _extractCommonType( Object... args ) {
<span class="fc" id="L188">        Class&lt;?&gt; commonType = null;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        for ( Object o : args ) {</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">            if ( commonType == null ) commonType = o.getClass();</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            else if ( !commonType.equals( o.getClass() ) ) return null;</span>
        }
<span class="fc" id="L193">        return commonType;</span>
    }

    // Constructors:

    /**
     *  This constructor creates a completely empty tensor which is void of any contents and meaning.
     *  The use case for this would be to use the produced {@link Tsr}
     *  instance as a target for an inline operation which fills this instance with an actual value. &lt;br&gt;
     *  An example of this approach would be to call the {@link #putAt(List, Nda)} method with an empty list as key.
     *  This will be interpreted as an inline copy of the contents of the
     *  second parameter into this {@link Tsr} instance.
     *  This constructor will be called by the {@link Tsr#newInstance()} factory method.
     */
<span class="fc" id="L207">    TsrImpl() {}</span>

<span class="fc" id="L209">    TsrImpl( NDConstructor ndConstructor, DataType&lt;?&gt; dataType, Object data ) {</span>
<span class="fc" id="L210">        constructFor(CPU.get(), ndConstructor).tryConstructing( dataType, data );</span>
<span class="fc" id="L211">    }</span>

<span class="fc" id="L213">    TsrImpl( NDConstructor ndConstructor, DataType&lt;?&gt; dataType, Data data ) {</span>
<span class="fc" id="L214">        constructFor(CPU.get(), ndConstructor).constructTrusted( dataType, data );</span>
<span class="fc" id="L215">    }</span>

    /**
     *  see {@link Tsr#of(DataType, int[], Filler)}
     */
<span class="fc" id="L220">    &lt;T&gt; TsrImpl( NDConstructor ndConstructor, DataType&lt;T&gt; type, Filler&lt;T&gt; filler ) {</span>
<span class="fc" id="L221">        _constructFromInitializer(ndConstructor, type, filler);</span>
<span class="fc" id="L222">    }</span>

    /**
     *  See {@link Tsr#of(Class, int[], String)} and {@link #of(List, String)}
     */
<span class="fc" id="L227">    TsrImpl( Class&lt;V&gt; valueType, NDConstructor ndConstructor, String seed ) {</span>
<span class="fc" id="L228">        constructFor(CPU.get(), ndConstructor).newSeeded( valueType, seed );</span>
<span class="fc" id="L229">    }</span>

<span class="fc" id="L231">    TsrImpl( NDConstructor ndConstructor, DataType&lt;?&gt; type ) {</span>
<span class="fc" id="L232">        _setDataType( DataType.of( type.getRepresentativeType() ) );</span>
<span class="fc" id="L233">        _constructAndAllocate(ndConstructor, true );</span>
<span class="fc" id="L234">    }</span>


    /**
     * @param ndConstructor The {@link NDConfiguration} producer of that this new tensor ought to have.
     * @param type The data type that this tensor ought to have.
     * @param filler The lambda Object which ought to fill this tensor with the appropriate data.
     * @param &lt;T&gt; The type parameter for the actual data array items.
     */
    private &lt;T&gt; void _constructFromInitializer(NDConstructor ndConstructor, DataType&lt;T&gt; type, Filler&lt;T&gt; filler ) {
<span class="fc" id="L244">        LogUtil.nullArgCheck(ndConstructor, &quot;ndcProducer&quot;, NDConstructor.class );</span>
<span class="fc" id="L245">        LogUtil.nullArgCheck( type, &quot;type&quot;, DataType.class );</span>
<span class="fc" id="L246">        LogUtil.nullArgCheck( type, &quot;filler&quot;, Filler.class );</span>
<span class="fc" id="L247">        _setDataType( type );</span>
<span class="fc" id="L248">        _constructAndAllocate(ndConstructor, false );</span>
<span class="fc" id="L249">        _initDataArrayFrom( filler );</span>
<span class="fc" id="L250">    }</span>

    private void _constructAndAllocate( NDConstructor ndConstructor, boolean virtual ) {
<span class="fc" id="L253">        constructFor(CPU.get(), ndConstructor).newUnpopulated( virtual, true, getDataType() );</span>
<span class="fc" id="L254">    }</span>


    /*==================================================================================================================
    |
    |       Â§(2) : FLAGS
    |   ----------------------
    */

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; setRqsGradient(boolean rqsGradient ) {
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if ( rqsGradient() != rqsGradient ) {</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if ( !rqsGradient ) this.remove( TsrImpl.class );</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            else if ( has(GraphNode.class) ) {</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">                if ( getGraphNode().getMode() == 0 )</span>
<span class="fc" id="L270">                    remove(GraphNode.class);</span>
                else
<span class="nc" id="L272">                    throw new IllegalArgumentException(</span>
                        &quot;This tensor is already part of a gradient dependent graph as &quot; +
                        &quot;branch node and therefore cannot be removed from it.&quot;
                    );
            }
        }
<span class="fc" id="L278">        _setRqsGradient( rqsGradient );</span>
<span class="fc" id="L279">        return this;</span>
    }

    /** {@inheritDoc} */
<span class="fc bfc" id="L283" title="All 2 branches covered.">    @Override public boolean rqsGradient() { return ( _flags &amp; RQS_GRADIENT_MASK ) == RQS_GRADIENT_MASK; }</span>

    private void _setRqsGradient(boolean rqsGradient) {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if ( rqsGradient() != rqsGradient ) {</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">            if ( rqsGradient ) _flags += RQS_GRADIENT_MASK;</span>
<span class="fc" id="L288">            else               _flags -= RQS_GRADIENT_MASK;</span>
        }
<span class="fc" id="L290">    }</span>

    /** {@inheritDoc} */
<span class="fc bfc" id="L293" title="All 2 branches covered.">    @Override public boolean isIntermediate() { return ( _flags &amp; IS_INTERMEDIATE_MASK ) == IS_INTERMEDIATE_MASK; }</span>

    /**
     *  Intermediate tensors are internal non-user tensors which may be eligible
     *  for deletion when further consumed by a {@link Function}.
     *  For the casual user of Neureka, this flag should always be false!
     *
     * @param isIntermediate The truth value determining if this tensor is not a user tensor but an internal
     *                       tensor which may be eligible for deletion by {@link Function}s consuming it.
     */
    private Tsr&lt;V&gt; _setIsIntermediate(boolean isIntermediate) {
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if ( isIntermediate() != isIntermediate ) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">            if ( isIntermediate ) _flags += IS_INTERMEDIATE_MASK;</span>
<span class="fc" id="L306">            else                  _flags -= IS_INTERMEDIATE_MASK;</span>
        }
<span class="fc" id="L308">        return this;</span>
    }

    /** {@inheritDoc} */
    @Override
<span class="fc bfc" id="L313" title="All 2 branches covered.">    public boolean isVirtual() { return ( _flags &amp; IS_VIRTUAL_MASK ) == IS_VIRTUAL_MASK; }</span>

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; setIsVirtual( boolean isVirtual )
    {
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        if ( getNDConf() == null )</span>
<span class="nc" id="L320">            throw new IllegalStateException(</span>
                &quot;Cannot set the virtual flag of a tensor which has not been constructed yet!&quot;
            );

<span class="fc bfc" id="L324" title="All 2 branches covered.">        if ( isVirtual() != isVirtual ) {</span>
            // Currently, we avoid offloading the virtualization by restoring outsourced tensors into RAM...
<span class="fc" id="L326">            Device&lt;V&gt; device = this.get( Device.class );</span>
            try {
                // TODO: Fix this im-performant mess below:
<span class="fc bfc" id="L329" title="All 2 branches covered.">                if ( device != null ) device.restore( this );</span>
<span class="nc" id="L330">            } catch ( Exception exception ) {</span>
<span class="nc" id="L331">                _LOG.error(</span>
                    &quot;Tensor could not be restored from device component when changing flag 'isVirtual' to &quot; + isVirtual + &quot;.&quot;,
                    exception
                );
<span class="nc" id="L335">                throw exception;</span>
<span class="fc" id="L336">            }</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            if ( isVirtual )</span>
<span class="fc" id="L338">                _virtualize();</span>
            else
<span class="fc" id="L340">                _actualize();</span>
            // Virtual and actual tensors require a different mapping from a given index to the underlying data..
            // Therefore, we need to re-initialize the NDConfiguration object:
<span class="fc" id="L343">            constructFor(CPU.get(),NDConstructor.of(getNDConf().shape())).newUnpopulated( isVirtual, false, getDataType() );</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            if ( isVirtual ) {</span>
<span class="fc" id="L345">                Relation&lt;V&gt; relation = get( Relation.class );</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">                if ( relation!=null )</span>
<span class="nc" id="L347">                    relation.foreachChild( c -&gt; {</span>
<span class="nc" id="L348">                                ((TsrImpl&lt;V&gt;)c)._setData( _getData() );</span>
<span class="nc" id="L349">                                c.setIsVirtual( true );</span>
<span class="nc" id="L350">                            });</span>
<span class="fc" id="L351">            } else {</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">                Tsr&lt;?&gt; parentTensor = ( this.isSlice() ) ? get(Relation.class).getParent() : null;</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">                if ( parentTensor != null ) parentTensor.get( Relation.class ).remove( this );</span>
            }

            try {
<span class="fc bfc" id="L357" title="All 2 branches covered.">                if ( device != null ) device.store( this );</span>
<span class="nc" id="L358">            } catch ( Exception exception ) {</span>
<span class="nc" id="L359">                String message =</span>
                        &quot;Tensor could not be migrated back to host device after changing flag 'isVirtual' to &quot;+isVirtual+&quot;.&quot;;
<span class="nc" id="L361">                _LOG.error(</span>
                        message,
                        exception
                );
<span class="nc" id="L365">                throw new IllegalStateException( message );</span>
<span class="fc" id="L366">            }</span>
<span class="fc" id="L367">        }</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        else if ( isVirtual ) _allocate( 1 ); //&gt; Only a single value representing the rest.</span>
<span class="fc" id="L369">        return this;</span>
    }

    /**
     *  This method is the inner counterpart to the public &quot;{@link Tsr#setIsVirtual}&quot; method.
     *  It actually performs the bit flipping by applying the corresponding bit mask. &lt;br&gt;
     *  &lt;br&gt;
     * @param isVirtual The truth value which ought to be applied.
     */
    @Override
    protected void _setIsVirtual( boolean isVirtual ) {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if ( isVirtual() != isVirtual ) {</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">            if ( isVirtual ) _flags += IS_VIRTUAL_MASK;</span>
<span class="fc" id="L382">            else             _flags -= IS_VIRTUAL_MASK;</span>
        }
<span class="fc" id="L384">    }</span>

    /**  {@inheritDoc} */
    @Override
<span class="fc bfc" id="L388" title="All 2 branches covered.">    public boolean isDeleted() { return ( _flags &amp; IS_DELETED_MASK ) == IS_DELETED_MASK; }</span>

    /** {@inheritDoc} */
    @Override
<span class="fc bfc" id="L392" title="All 2 branches covered.">    public boolean gradientApplyRequested() { return ( _flags &amp; GRADIENT_APPLY_RQD_MASK ) == GRADIENT_APPLY_RQD_MASK; }</span>

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; setGradientApplyRequested(boolean applyRequested ) {
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if ( gradientApplyRequested() != applyRequested ) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            if ( applyRequested ) {</span>
                if (
<span class="fc bfc" id="L400" title="All 2 branches covered.">                    Neureka.get().settings().autograd().isApplyingGradientWhenRequested() &amp;&amp;</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                    !Neureka.get().settings().autograd().isApplyingGradientWhenTensorIsUsed()</span>
                )
<span class="fc" id="L403">                    this.applyGradient();</span>
                else
<span class="fc" id="L405">                    _flags += GRADIENT_APPLY_RQD_MASK;</span>
            }
<span class="fc" id="L407">            else _flags -= GRADIENT_APPLY_RQD_MASK;</span>
        }
<span class="fc" id="L409">        return this;</span>
    }

    /**
     *  Although tensors will be garbage collected when they are not strongly referenced,
     *  there is also the option to manually free up the tensor and its associated data.
     *  This is especially useful when tensors are stored on a device like the OpenCLDevice.
     *  In that case calling the &quot;{@link Tsr.Unsafe#delete()}&quot; method will free the memory reserved for this tensor.
     *  This manual memory freeing through this method can be faster than waiting for
     *  the garbage collector to kick in... &lt;br&gt;
     *  &lt;br&gt;
     *
     * @return This very tensor instance to allow for method chaining.
     */
    private Tsr&lt;V&gt; _delete()
    {
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if ( isDeleted() ) return this;</span>
<span class="fc" id="L426">        forComponent( GraphNode.class, n -&gt; {</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">            if ( n.isUsedAsDerivative() ) {</span>
<span class="fc" id="L428">                String message = &quot;Cannot delete a tensor which is used as derivative by the AD computation graph!&quot;;</span>
<span class="fc" id="L429">                _LOG.error( message );</span>
<span class="fc" id="L430">                throw new IllegalStateException( message );</span>
            }
<span class="fc" id="L432">        });</span>
<span class="fc" id="L433">        forComponent( Device.class, device -&gt; device.free( this ) );</span>
<span class="fc" id="L434">        _setData( null );</span>
<span class="fc" id="L435">        _setNDConf( null );</span>
<span class="fc" id="L436">        _flags = 0;</span>
<span class="fc" id="L437">        forComponent( TsrImpl.class, t -&gt; t.getUnsafe().delete() );</span>
<span class="fc" id="L438">        _deleteComponents();</span>
<span class="fc" id="L439">        _flags += IS_DELETED_MASK;</span>

<span class="fc" id="L441">        return this;</span>
    }

    /*==================================================================================================================
    |
    |       Â§(3) : COMPONENT SYSTEM
    |   --------------------------------
    */

    /** {@inheritDoc} */
    @Override public &lt;T extends Component&lt;?&gt;&gt; T get( Class&lt;T&gt; componentClass )
    {
<span class="fc" id="L453">        LogUtil.nullArgCheck( componentClass, &quot;componentClass&quot;, Class.class );</span>

<span class="fc bfc" id="L455" title="All 2 branches covered.">        if ( GraphNode.class.isAssignableFrom(componentClass) )</span>
<span class="fc" id="L456">            _guardGet(componentClass.getSimpleName());</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        else if ( NDFrame.class.isAssignableFrom(componentClass) )</span>
<span class="fc" id="L458">            _guardGet(componentClass.getSimpleName());</span>

<span class="fc" id="L460">        return super.get(componentClass);</span>
    }

    /**
     * This method is executed when a new Component is added to the tensor.
     * The public add method is implemented in the super class
     * '{@link AbstractComponentOwner}' from which this class inherits.
     * In this super class the component logic is implemented.
     *
     * @param newComponent A component used to access features. ({@link GraphNode}, {@link NDFrame}, {@link Relation}, int[], ...)
     * @return The unchanged object or maybe in future versions: null (component rejected)
     */
    @Override
<span class="fc" id="L473">    protected &lt; T extends Component&lt;Tsr&lt;V&gt;&gt; &gt; T _setOrReject(T newComponent ) { return newComponent; }</span>

    /**
     * This method is executed when a component is being removed from the tensor.
     * The public remove method is implemented in the super class
     * '{@link AbstractComponentOwner}' from which this class inherits.
     * In this super class the component logic is implemented.
     *
     * @param newComponent A component used to access features. ({@link GraphNode}, {@link NDFrame}, {@link Relation}, int[], ...)
     * @return The unchanged object or when rejected: null (component rejected)
     */
    @Override
    protected &lt;T extends Component&lt;Tsr&lt;V&gt;&gt;&gt; T _removeOrReject(T newComponent )
    {
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if ( newComponent instanceof Device ) {</span>
<span class="fc" id="L488">            Device&lt;V&gt; device = (Device&lt;V&gt;) newComponent;</span>
            /*
                The following seems like a redundant check, however often times a tensor
                will be removed from a Device implementation inside the &quot;restore&quot; method
                when the tensor has already been removed from the device...
                Without the condition below a stack overflow would occur!
             */
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">            if ( device.has( this ) ) {</span>
                try {
<span class="nc" id="L497">                    device.restore( this );</span>
<span class="nc" id="L498">                } catch ( Exception exception ) {</span>
<span class="nc" id="L499">                    _LOG.error(</span>
                        &quot;Removing device from tensor / tensor from device failed.\n&quot; +
                        &quot;Restoring tensor from device threw exception.\n&quot;,
                        exception
                    );
<span class="nc" id="L504">                    throw exception;</span>
<span class="nc" id="L505">                }</span>
            }
        }
<span class="fc" id="L508">        return newComponent;</span>
    }


    /*==================================================================================================================
    |
    |       Â§(4) : PROPERTIES :
    |   ---------------------------------------
    */

    /**
     *  {@inheritDoc}
     */
    @Override
<span class="fc" id="L522">    public int getVersion() { return _version; }</span>


    /*==================================================================================================================
    |
    |       Â§(5) : OBJECT STATE MODIFICATION :
    |   ------------------------------------------
    */

    private void _toLayout( NDConfiguration.Layout target )
    {
<span class="fc bfc" id="L533" title="All 2 branches covered.">        if ( target == this.getNDConf().getLayout() ) return;</span>

<span class="fc" id="L535">        NDConfiguration old = this.getNDConf();</span>

<span class="fc bfc" id="L537" title="All 2 branches covered.">        if ( target == NDConfiguration.Layout.ROW_MAJOR )</span>
<span class="fc" id="L538">            _fromCMToRM();</span>
        else
<span class="fc" id="L540">            _fromRMToCM();</span>

<span class="fc" id="L542">        _checkLayoutConversion( this.getNDConf(), old, target );</span>
<span class="fc" id="L543">    }</span>

    /**
     *  Converts this tensor from column major to column major layout.
     */
    private void _fromCMToRM() {
<span class="fc bfc" id="L549" title="All 2 branches covered.">        if ( this.getNDConf().isVirtual() ) {</span>
<span class="fc" id="L550">            this.setIsVirtual( false ); // We actualized the tensor before conversion!</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">            if ( this.getNDConf().getLayout() == NDConfiguration.Layout.ROW_MAJOR )</span>
<span class="fc" id="L552">                return;</span>
        }
<span class="fc" id="L554">        TsrImpl&lt;V&gt; clone = deepCopy(); // A clone will have by default a row major layout.</span>
<span class="fc" id="L555">        _setNDConf( clone.getNDConf() );</span>
<span class="fc" id="L556">        _assignIfActual( () -&gt; clone );</span>
<span class="fc" id="L557">    }</span>

    /**
     *  Converts this tensor from row major to column major layout.
     */
    private void _fromRMToCM() {
<span class="fc" id="L563">        _assignIfActual( () -&gt; TsrImpl.this.T().deepCopy().getUnsafe().detach() );</span>
<span class="fc" id="L564">        NDConfiguration old = this.getNDConf();</span>
<span class="fc" id="L565">        int[] newTranslation = NDConfiguration.Layout.COLUMN_MAJOR.newTranslationFor(old.shape());</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">        if ( old.isVirtual() ) {</span>
<span class="fc" id="L567">            this.setIsVirtual(false);</span>
<span class="fc" id="L568">            old = this.getNDConf();</span>
        }
<span class="fc" id="L570">        _setNDConf( _createNewNDCFrom( old, newTranslation, old.translation() ) );</span>
<span class="fc" id="L571">    }</span>

    /**
     *  This will only call the supplier and copy its result into this tensor
     *  if this tensor is not virtual (meaning this is an actual tensor).
     */
    private void _assignIfActual( Supplier&lt;Tsr&lt;?&gt;&gt; provider ) {
<span class="fc bfc" id="L578" title="All 2 branches covered.">        if ( !this.isVirtual() ) {</span>
<span class="fc" id="L579">            Tsr&lt;?&gt; toBeAssigned = provider.get();</span>
<span class="fc" id="L580">            MemUtil.keep(this, toBeAssigned,</span>
<span class="fc" id="L581">                () -&gt; Neureka.get().backend().getFunction().idy().execute( this, toBeAssigned )</span>
            );
        }
<span class="fc" id="L584">    }</span>

    private static NDConfiguration _createNewNDCFrom(
        NDConfiguration old, int[] newTranslation, int[] indicesMap
    ) {
<span class="pc bpc" id="L589" title="2 of 4 branches missed.">        assert !old.isVirtual();</span>
<span class="fc" id="L590">        return NDConfiguration.of(</span>
<span class="fc" id="L591">            old.shape(), newTranslation, indicesMap, old.spread(), old.offset()</span>
        );
    }

    private static void _checkLayoutConversion(
            NDConfiguration newConf,
            NDConfiguration oldConf,
            NDConfiguration.Layout targetLayout
    ) {
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if ( newConf.isVirtual() )</span>
<span class="nc" id="L601">            throw new IllegalStateException(&quot;Layout conversion produced a virtual nd-configuration!&quot;);</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if ( !newConf.getLayout().isCompatible(targetLayout) )</span>
<span class="nc" id="L603">            throw new IllegalArgumentException(</span>
<span class="nc" id="L604">                &quot;Failed to convert this tensor from its original layout '&quot;+oldConf.getLayout()+&quot;' &quot; +</span>
<span class="nc" id="L605">                &quot;to target layout '&quot;+targetLayout+&quot;'. Instead this tensor has layout '&quot;+newConf.getLayout()+&quot;'.&quot;</span>
            );
<span class="fc" id="L607">    }</span>

    /**
     * This method is responsible for incrementing
     * the &quot;_version&quot; field variable which represents the version of the data of this tensor.
     * Meaning :
     * Every time the underlying data (_value) changes this version ought to increment alongside.
     * The method is called during the execution procedure.
     *
     * @param call The context object containing all relevant information that defines a call for tensor execution.
     */
    private void _incrementVersionBecauseOf( ExecutionCall&lt;?&gt; call ) {
<span class="fc bfc" id="L619" title="All 2 branches covered.">        if ( Neureka.get().settings().autograd().isPreventingInlineOperations() ) {</span>
<span class="fc" id="L620">            _version++; // Autograd must be warned!</span>
<span class="fc" id="L621">            GraphNode&lt;?&gt; node = get( GraphNode.class );</span>
<span class="pc bpc" id="L622" title="1 of 4 branches missed.">            if ( node != null &amp;&amp; node.getPayloadReferenceVersion() != _version ) {</span>
<span class="pc bpc" id="L623" title="1 of 4 branches missed.">                if ( node.usesAD() || node.isUsedAsDerivative() ) {</span>
<span class="fc" id="L624">                    String error = &quot;Inline operation occurred on tensor which is part of a computation graph node with autograd support!\n&quot; +</span>
<span class="fc" id="L625">                                   &quot;The following OperationType caused an internal version mismatch: '&quot;+call.getOperation().getIdentifier()+&quot;'&quot;;</span>
<span class="fc" id="L626">                    _LOG.error( error );</span>
<span class="fc" id="L627">                    throw new IllegalStateException( error );</span>
                }
            }
        }
<span class="fc" id="L631">    }</span>

    /**
     *  In essence tensors are merely fancy wrapper for some form of array of any type... 
     *  This wrapper usually stays the same of a given data array.
     *  However, sometimes a tensor changes its identity, or rather the underlying
     *  data changes the wrapping tensor instance. &lt;br&gt;
     *  &lt;br&gt;
     * @param tensor The tensor whose identity should be stolen.
     */
    private void _become( TsrImpl&lt;V&gt; tensor )
    {
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        if ( tensor == null ) return;</span>
<span class="fc" id="L644">        _setDataType( tensor.getDataType() );</span>
<span class="fc" id="L645">        _setData( tensor.getUnsafe().getData() );</span>
<span class="fc" id="L646">        _setNDConf( tensor.getNDConf() );</span>
<span class="fc" id="L647">        _flags = tensor._flags;</span>
<span class="fc" id="L648">        _transferFrom( tensor );</span>
<span class="fc" id="L649">        tensor._setData( null );</span>
<span class="fc" id="L650">        tensor._setDataType( null );</span>
<span class="fc" id="L651">        tensor._setNDConf( null );</span>
<span class="fc" id="L652">        tensor._flags = 0;</span>
<span class="fc" id="L653">    }</span>

    /**
     *  {@inheritDoc}
     */
    @Override
    public Unsafe&lt;V&gt; getUnsafe() {
<span class="fc" id="L660">        _guardGet(&quot;unsafe API&quot;);</span>
<span class="fc" id="L661">        return new Unsafe&lt;V&gt;() {</span>
            @Override
<span class="fc" id="L663">            public Tsr&lt;V&gt; setNDConf(NDConfiguration configuration ) { TsrImpl.this._setNDConf( configuration ); return TsrImpl.this; }</span>
            @Override
            public &lt;V&gt; Tsr&lt;V&gt; toType( Class&lt;V&gt; typeClass ) {
<span class="fc" id="L666">                LogUtil.nullArgCheck( typeClass, &quot;typeClass&quot;, Class.class, &quot;Cannot convert tensor to 'null' data type.&quot; );</span>
<span class="fc" id="L667">                return TsrImpl.this._toType( typeClass );</span>
            }

            @Override
            public &lt;U&gt; Tsr&lt;U&gt; upcast( Class&lt;U&gt; superType ) {
<span class="fc" id="L672">                LogUtil.nullArgCheck( superType, &quot;superType&quot;, Class.class );</span>
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">                if ( superType.isAssignableFrom(TsrImpl.this.itemType()) )</span>
<span class="fc" id="L674">                    return (Tsr&lt;U&gt;) TsrImpl.this;</span>
                else
<span class="nc" id="L676">                    throw new IllegalArgumentException(&quot;Provided type '&quot;+superType+&quot;' is not a super type of '&quot;+ TsrImpl.this.itemType()+&quot;'.&quot;);</span>
            }

            @Override
<span class="fc" id="L680">            public &lt;T&gt; Tsr&lt;T&gt; setDataType( DataType&lt;T&gt; dataType ) { return (TsrImpl&lt;T&gt;) TsrImpl.this._setDataType(dataType); }</span>
            @Override
<span class="fc" id="L682">            public Tsr&lt;V&gt; toLayout(NDConfiguration.Layout layout) { TsrImpl.this._toLayout( layout ); return TsrImpl.this; }</span>
            @Override
            public Tsr&lt;V&gt; incrementVersion( ExecutionCall&lt;?&gt; call ) {
<span class="fc" id="L685">                LogUtil.nullArgCheck( call, &quot;call&quot;, ExecutionCall.class );</span>
<span class="fc" id="L686">                _incrementVersionBecauseOf( call );</span>
<span class="fc" id="L687">                return TsrImpl.this;</span>
            }
            @Override
<span class="fc" id="L690">            public Tsr&lt;V&gt; setIsIntermediate( boolean isIntermediate ) { return _setIsIntermediate( isIntermediate ); }</span>
<span class="fc" id="L691">            @Override public Tsr&lt;V&gt; delete() { return TsrImpl.this._delete(); }</span>
<span class="fc" id="L692">            @Override public Data&lt;V&gt; getData() { return _getData(); }</span>
            @Override
            public &lt;A&gt; A getDataAs( Class&lt;A&gt; arrayTypeClass ) {
<span class="fc" id="L695">                return DataConverter.get().convert( _getData(false), arrayTypeClass );</span>
            }
            @Override
            public Tsr&lt;V&gt; setDataAt( int i, V o ) {
<span class="fc" id="L699">                _guardMod(&quot;data object&quot;);</span>
<span class="fc" id="L700">                _setDataAt( i, o );</span>
<span class="fc" id="L701">                return TsrImpl.this;</span>
            }

            @Override
            public Tsr&lt;V&gt; setData( Data&lt;V&gt; data ) {
<span class="fc" id="L706">                TsrImpl.this._setData( data );</span>
<span class="fc" id="L707">                return TsrImpl.this;</span>
            }

<span class="fc" id="L710">            @Override public Tsr&lt;V&gt; detach() { TsrImpl.this.remove( GraphNode.class ); return TsrImpl.this; }</span>
        };
    }

    /*==================================================================================================================
    |
    |       Â§(6) : ND-ITERATOR LOGIC :
    |   ---------------------------------------
    */

    /**
     * This method returns an iterator over the elements of this tensor. &lt;br&gt;
     *
     * @return An iterator over elements of type ValType.
     */

    @Override
    public Iterator&lt;V&gt; iterator()
    {
<span class="fc" id="L729">        NDIterator _ndi = NDIterator.of( this );</span>
<span class="fc" id="L730">        return new Iterator&lt;V&gt;()</span>
<span class="fc" id="L731">        {</span>
<span class="fc" id="L732">            private final int _size = TsrImpl.this.size();</span>
<span class="fc" id="L733">            private int _count = 0;</span>

<span class="fc bfc" id="L735" title="All 2 branches covered.">            @Override public boolean hasNext() { return _count != _size; }</span>

            @Override
            public V next() {
<span class="fc" id="L739">                V value = TsrImpl.this.getDataAt( _ndi.i() );</span>
<span class="fc" id="L740">                _ndi.increment();</span>
<span class="fc" id="L741">                _count ++;</span>
<span class="fc" id="L742">                return value;</span>
            }
        };
    }


    /*==================================================================================================================
    |
    |       Â§(7) : COMPONENT SPECIFIC :
    |   ---------------------------------------
    */

    /**
     *  {@inheritDoc}
     */
    @Override
<span class="fc" id="L758">    public Tsr&lt;V&gt; to( Device&lt;?&gt; device ){ super._set( device ); return this; }</span>

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; label( String tensorName, String[][] labels )
    {
<span class="fc" id="L764">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, String[][].class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="fc" id="L765">        NDFrame&lt;V&gt; frame = get( NDFrame.class );</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">        if ( frame == null ) {</span>
<span class="fc" id="L767">            frame = new NDFrame( this.rank(), tensorName );</span>
<span class="fc" id="L768">            set(frame);</span>
        }
<span class="pc bpc" id="L770" title="2 of 4 branches missed.">        assert labels.length &lt;= this.rank();</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">        for( int i = 0; i &lt; labels.length; i++ ) {</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">            if ( labels[ i ] != null ) {</span>
<span class="fc" id="L773">                AxisFrame&lt;Integer, V&gt; atAxis = frame.atAxis( i );</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">                for ( int ii = 0; ii &lt; labels[ i ].length; ii++ ) {</span>
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">                    if ( labels[ i ][ ii ] != null )</span>
<span class="fc" id="L776">                        atAxis.atIndexAlias( labels[ i ][ ii ] ).setIndex( ii );</span>
                }
            }
        }
<span class="fc" id="L780">        return this;</span>
    }

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; label(List&lt;List&lt;Object&gt;&gt; labels ) {
<span class="fc" id="L786">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, List.class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="fc" id="L787">        NDFrame&lt;V&gt; frame = get( NDFrame.class );</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">        if ( frame == null ) set( new NDFrame( labels, null ) );</span>
<span class="fc" id="L789">        return this;</span>
    }

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; label( String tensorName, List&lt;List&lt;Object&gt;&gt; labels ) {
<span class="fc" id="L795">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, List.class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="fc" id="L796">        NDFrame&lt;V&gt; frame = get( NDFrame.class );</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        if ( frame == null ) set( new NDFrame&lt;&gt;( labels, tensorName ) );</span>
<span class="fc" id="L798">        return this;</span>
    }

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; label( Map&lt;Object, List&lt;Object&gt;&gt; labels )
    {
<span class="fc" id="L805">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, Map.class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="fc" id="L806">        this.set( new NDFrame&lt;&gt;( labels, this, null ) );</span>
<span class="fc" id="L807">        return this;</span>
    }

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; label(String tensorName, Map&lt;Object, List&lt;Object&gt;&gt; labels )
    {
<span class="nc" id="L814">        LogUtil.nullArgCheck(labels, &quot;labels&quot;, Map.class, &quot;Tensors cannot be labeled 'null'!&quot;);</span>
<span class="nc" id="L815">        this.set( new NDFrame&lt;&gt;( labels, this, tensorName ) );</span>
<span class="nc" id="L816">        return this;</span>
    }

    /*==================================================================================================================
    |
    |       Â§(8) : (OVERLOADABLE) OPERATORS &amp; OPERATIONS :
    |   -----------------------------------------------------
    |       ...for more context see package 'calculus'...
    |*/

    /** {@inheritDoc} */
    @Override
    public boolean isCase( Tsr&lt;V&gt; other ) {
<span class="fc" id="L829">        LogUtil.nullArgCheck(other, &quot;other&quot;, Tsr.class, &quot;Cannot perform 'is case' operation when second oprand is 'null'!&quot;);</span>
<span class="fc" id="L830">        boolean[] found = { false };</span>
<span class="fc" id="L831">        this.forComponent( Relation.class, r -&gt; r.foreachChild( c -&gt; {</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">                if ( c.equals( other ) ) found[ 0 ] = true;</span>
<span class="fc" id="L833">            }));</span>
<span class="fc" id="L834">        return found[ 0 ];</span>
    }

    /*==================================================================================================================
    |
    |       Â§(9) : SLICING, INDEXING &amp; INJECTING :
    |   -----------------------------------------------------
    |       ...for more context see package 'ndim.config'...
    */

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; getAt( int... indices ) {
<span class="fc" id="L847">        LogUtil.nullArgCheck(indices, &quot;indices&quot;, int[].class, &quot;Indices array must not be 'null'!&quot;);</span>
<span class="fc" id="L848">        return getAt( Arrays.stream( indices ).boxed().toArray() );</span>
    }

    /** {@inheritDoc} */
    @Override
    public Tsr&lt;V&gt; getAt( Map&lt;?,Integer&gt; rankToStrides ) {
<span class="fc" id="L854">        LogUtil.nullArgCheck(rankToStrides, &quot;rankToStrides&quot;, Map.class, &quot;Rank-to-strides map must not be 'null'!&quot;);</span>
        // ...not a simple slice... Advanced:
<span class="fc" id="L856">        return SmartSlicer.slice(new Object[]{rankToStrides}, this);</span>
    }

    /**
     *  {@inheritDoc}
     */
    @Override
    public Tsr&lt;V&gt; getAt( List&lt;?&gt; key ) {
<span class="fc" id="L864">        LogUtil.nullArgCheck( key, &quot;key&quot;, List.class );</span>
<span class="fc bfc" id="L865" title="All 4 branches covered.">        if ( key.stream().anyMatch( i -&gt; i == null ) )</span>
<span class="fc" id="L866">            throw new IllegalArgumentException(&quot;List of indices/ranges may not contain entries which are null!&quot;);</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">        if ( key.isEmpty() ) {</span>
            /*
                An empty List instance is being interpreted as
                the request to create an identical slice, meaning that the
                resulting tensor views the same data as its parent while not
                being the same instance. (In a sense, its a shallow copy!)
             */
<span class="fc" id="L874">            return shallowCopy();</span>
        }

<span class="fc" id="L877">        Object[] indices = key.toArray();</span>

<span class="fc" id="L879">        boolean allInt = true;</span>
<span class="fc bfc" id="L880" title="All 6 branches covered.">        for ( Object o : indices ) allInt = allInt &amp;&amp; o instanceof Integer;</span>
<span class="fc bfc" id="L881" title="All 4 branches covered.">        if ( allInt &amp;&amp; indices.length == rank() ) {</span>
<span class="fc" id="L882">            int[] newOffset = DataConverter.get().convert(indices, int[].class);</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">            for ( int i = 0; i &lt; this.rank(); i++ )</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">                newOffset[ i ] = ( newOffset[ i ] &lt; 0 ) ? getNDConf().shape( i ) + newOffset[ i ] : newOffset[ i ];</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">            for ( int i = 0; i &lt; this.rank(); i++ )</span>
<span class="fc" id="L886">                indices[ i ] = newOffset[ i ];</span>
<span class="fc" id="L887">            allInt = false;</span>
        }
<span class="fc" id="L889">        boolean hasScale = false;</span>
<span class="pc bpc" id="L890" title="1 of 6 branches missed.">        for ( Object o : indices ) hasScale = hasScale || o instanceof Map;</span>
<span class="fc" id="L891">        return SmartSlicer.slice(</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">                ( allInt ? new Object[]{ DataConverter.get().convert(indices, int[].class) } : indices ),</span>
                this
            );
    }

    /** {@inheritDoc} */
     @Override
    public TsrImpl&lt;V&gt; deepCopy() {
<span class="fc" id="L900">        Function cloner = Neureka.get().backend().getFunction().idy();</span>
<span class="fc" id="L901">        boolean thisIsIntermediate = this.isIntermediate();</span>
<span class="fc" id="L902">        _setIsIntermediate( false );</span>
<span class="fc" id="L903">        Tsr&lt;V&gt; clone = Tsr.like( this )</span>
<span class="fc" id="L904">                            .all( (V) Double.valueOf(0.0) );</span>

<span class="pc bpc" id="L906" title="1 of 2 branches missed.">        if ( clone.itemType() != this.itemType() )</span>
<span class="nc" id="L907">            throw new IllegalStateException(&quot;Item type of clone must be the same as the item type of the original!&quot;);</span>

<span class="fc" id="L909">        clone = cloner.call( clone, this );</span>
<span class="fc" id="L910">        clone.getUnsafe().setIsIntermediate( thisIsIntermediate );</span>
<span class="fc" id="L911">        _setIsIntermediate( thisIsIntermediate );</span>
<span class="fc" id="L912">        return (TsrImpl&lt;V&gt;) clone;</span>
    }

    /**
     *  {@inheritDoc}
     */
    @Override
<span class="fc" id="L919">    public AxisOrGetTsr&lt;V&gt; slice() { return new SliceBuilder&lt;&gt;( this ); }</span>


    /**
     *  {@inheritDoc}
     */
    @Override
    public Tsr&lt;V&gt; putAt( List&lt;?&gt; key, Nda&lt;V&gt; value ) {
<span class="fc" id="L927">        _putAtCheckFor( (Tsr&lt;?&gt;) value );</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">        Tsr&lt;V&gt; slice = ( key == null ) ? this : getAt( key );</span>
<span class="fc" id="L929">        return _putAt( slice, (Tsr&lt;V&gt;) value );</span>
    }

    /**
     *  {@inheritDoc}
     */
    @Override
    public Tsr&lt;V&gt; putAt(int[] indices, V item ) {
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">        if ( indices == null )</span>
<span class="nc" id="L938">            throw new IllegalArgumentException( &quot;Provided indices are null!&quot; );</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">        if ( indices.length &gt; this.rank() ) {</span>
<span class="nc" id="L940">            int[] correct = new int[rank()];</span>
<span class="nc" id="L941">            System.arraycopy( indices, 0, correct, 0, indices.length );</span>
<span class="nc" id="L942">            indices = correct;</span>
        }
<span class="fc bfc" id="L944" title="All 2 branches covered.">        if ( this.isVirtual() ) this.setIsVirtual( false );</span>
<span class="fc" id="L945">        int i = getNDConf().indexOfIndices(indices);</span>
<span class="fc" id="L946">        getUnsafe().setDataAt( i, item );</span>
<span class="fc" id="L947">        return this;</span>
    }

    /**
     *  {@inheritDoc}
     */
    @Override
    public Tsr&lt;V&gt; putAt( Map&lt;?,Integer&gt; key, Nda&lt;V&gt; value ) {
<span class="fc" id="L955">        _putAtCheckFor((Tsr&lt;?&gt;) value);</span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        Tsr&lt;V&gt; slice = ( key == null ) ? this : getAt( key );</span>
<span class="fc" id="L957">        return _putAt( slice, (Tsr&lt;V&gt;) value);</span>
    }

    private void _putAtCheckFor( Tsr&lt;?&gt; value ) {
<span class="fc bfc" id="L961" title="All 2 branches covered.">        if ( value.isEmpty() ) {</span>
<span class="fc" id="L962">            String message = &quot;Provided tensor is empty! Empty tensors cannot be injected.&quot;;</span>
<span class="fc" id="L963">            _LOG.error( message );</span>
<span class="fc" id="L964">            throw new IllegalArgumentException( message );</span>
        }
<span class="fc" id="L966">    }</span>

    private Tsr&lt;V&gt; _putAt( Tsr&lt;V&gt; slice, Tsr&lt;V&gt; value )
    {
<span class="fc" id="L970">        boolean valueIsDeviceVisitor = false;</span>
<span class="fc bfc" id="L971" title="All 4 branches covered.">        if ( slice.isOutsourced() &amp;&amp; !value.isOutsourced() ) {</span>
<span class="fc" id="L972">            Device&lt;V&gt; device = slice.getDevice();</span>
            try {
<span class="fc" id="L974">                device.store( value );</span>
<span class="nc" id="L975">            } catch ( Exception e ) {</span>
<span class="nc" id="L976">                _LOG.error( &quot;Trying to migrate target slice tensor to device failed.&quot;, e );</span>
<span class="nc" id="L977">                throw e;</span>
<span class="fc" id="L978">            }</span>
<span class="fc" id="L979">            valueIsDeviceVisitor = true;</span>
        }
<span class="pc bpc" id="L981" title="2 of 6 branches missed.">        if ( this.isEmpty() &amp;&amp; slice.isEmpty() || slice.size() != value.size() ) _become((TsrImpl&lt;V&gt;) value); // TODO: Rethink this a little</span>
<span class="fc" id="L982">        else Neureka.get().backend().getFunction().idy().call(  slice, value  );</span>
        try {
<span class="fc bfc" id="L984" title="All 2 branches covered.">            if ( valueIsDeviceVisitor ) value.getDevice().restore( value );</span>
<span class="nc" id="L985">        } catch ( Exception exception ) {</span>
<span class="nc" id="L986">            _LOG.error( &quot;Trying to migrate source tensor back to original location failed.&quot;, exception );</span>
<span class="nc" id="L987">            throw exception;</span>
<span class="fc" id="L988">        }</span>
<span class="fc" id="L989">        return this;</span>
    }

    /**
     *  {@inheritDoc}
     */
    @Override
<span class="fc" id="L996">    public V getDataAt( int i ) { return getDevice().access( this ).readAt( i ); }</span>

    /**
     *  {@inheritDoc}
     */
    @Override
    public Tsr&lt;V&gt; setItemAt( int i, V o ) {
<span class="fc" id="L1003">        _guardMod(&quot;data object&quot;);</span>
<span class="fc" id="L1004">        NDConfiguration ndc = this.getNDConf();</span>
<span class="fc" id="L1005">        _setDataAt( ndc.indexOfIndex( i ), o );</span>
<span class="fc" id="L1006">        return this;</span>
    }

    private void _setDataAt( int i, V o ) {
<span class="pc bpc" id="L1010" title="1 of 4 branches missed.">        if ( this.isVirtual() &amp;&amp; i &gt; 0 )</span>
<span class="nc" id="L1011">            throw new IllegalArgumentException(&quot;There is no data item at index &quot;+i+&quot; for this virtual tensor!&quot;);</span>

<span class="fc" id="L1013">        getDevice().access( this ).write( o ).at( i );</span>
<span class="fc" id="L1014">        _version++; // Autograd must be warned!</span>
<span class="fc" id="L1015">    }</span>

    /**
     *  {@inheritDoc}
     */
    @Override
    public Tsr&lt;V&gt; setItems( Object value )
    {
<span class="fc" id="L1023">        LogUtil.nullArgCheck( value, &quot;value&quot;, Object.class );</span>
<span class="fc" id="L1024">        boolean success = true;</span>
<span class="fc bfc" id="L1025" title="All 2 branches covered.">        if ( Number.class.isAssignableFrom(value.getClass()) ) { // A virtual tensor!</span>
<span class="fc" id="L1026">            this.setIsVirtual( true );</span>
<span class="fc" id="L1027">            value = DataConverter.get().convert( value, this.itemType() );</span>
<span class="fc" id="L1028">            this.getUnsafe().setDataAt( 0, (V) value );</span>
<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">        } else if ( value.getClass().isArray() ) {</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">            if ( this.isOutsourced() ) getDevice().access(this).writeFrom( value );</span>
            else {
                // This usually happens when a tensor was just freed from a device.
<span class="fc" id="L1033">                getDevice().access(this).writeFrom(value);</span>
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">                if ( this.isOutsourced() ) setIsVirtual(false);</span>
            }
        }
<span class="nc" id="L1037">        else success = false;</span>

<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">        if ( !success )</span>
<span class="nc" id="L1040">            _LOG.warn( &quot;Failed to set value of type '&quot;+value.getClass().getSimpleName()+&quot;'!&quot; );</span>

<span class="fc" id="L1042">        return this;</span>
    }

    /**
     *  {@inheritDoc}
     */
    @Override
    public Object getData() {
<span class="fc" id="L1050">        _guardGet(&quot;data object&quot;);</span>
<span class="fc" id="L1051">        return _getData( true );</span>
    }

    private Object _getData( boolean clone ) {
<span class="fc" id="L1055">        Device&lt;V&gt; device = this.getDevice();</span>
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">        if ( device == null ) return null;</span>
<span class="fc" id="L1057">        else return device.access( this ).readAll( clone );</span>
    }

    /**
     *  {@inheritDoc}
     */
    @Override
    public Object getRawItems() {
<span class="fc" id="L1065">        _guardGet(&quot;value object&quot;);</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">        if ( this.isVirtual() )</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">            return this.isOutsourced()</span>
<span class="fc" id="L1068">                    ? getDevice().access( this.deepCopy().setIsVirtual( false ) ).readAll(false)</span>
<span class="fc" id="L1069">                    : getDevice().access(this).actualize().getRef(); // Todo: make data access more consistent!</span>
<span class="fc bfc" id="L1070" title="All 4 branches covered.">        else if ( this.getNDConf().isSimple() &amp;&amp; !this.isSlice() )</span>
<span class="fc bfc" id="L1071" title="All 2 branches covered.">            return getDevice().access(this).readAll(!this.isOutsourced());</span>
        else
<span class="fc" id="L1073">            return getDevice().access( this.deepCopy().setIsVirtual( false ) ).readAll(false);</span>
    }

    /*==================================================================================================================
    |
    |       Â§(10) : Mapping :
    |   -----------------------------------------------------
    |       ...transformation and modification...
    */

    /**
     *  {@inheritDoc}
     */
    @Override
    public BufferedImage asImage( ImageType type )
    {
<span class="pc bpc" id="L1089" title="1 of 4 branches missed.">        switch ( type.bufferType )</span>
        {
            case BufferedImage.TYPE_3BYTE_BGR: {
<span class="fc" id="L1092">                _checkRankForImageConversion(type, Number.class, 0, 0, 3);</span>
                // We expect a tensor of shape (height x width x 3)!
<span class="fc" id="L1094">                BufferedImage image = new BufferedImage(shape(1), shape(0), type.bufferType);</span>
<span class="fc" id="L1095">                byte[] data = DataConverter.get().convert( _getRawData(), byte[].class);</span>
<span class="fc" id="L1096">                _writeImgData(new DataBufferByte(data, data.length), image);</span>
<span class="fc" id="L1097">                return image;</span>
            }
            case BufferedImage.TYPE_4BYTE_ABGR:
            case BufferedImage.TYPE_4BYTE_ABGR_PRE:
            {
<span class="fc" id="L1102">                _checkRankForImageConversion(type, Number.class, 0, 0, 4);</span>
<span class="fc" id="L1103">                BufferedImage image = new BufferedImage(shape(1), shape(0), type.bufferType);</span>
<span class="fc" id="L1104">                byte[] data = DataConverter.get().convert( _getRawData(), byte[].class);</span>
<span class="fc" id="L1105">                _writeImgData(new DataBufferByte(data, data.length), image);</span>
<span class="fc" id="L1106">                return image;</span>
            }
            case BufferedImage.TYPE_INT_ARGB: {
<span class="fc" id="L1109">                _checkRankForImageConversion(type, Number.class, 0, 0, 1);</span>
<span class="fc" id="L1110">                BufferedImage image = new BufferedImage(shape(1), shape(0), type.bufferType);</span>
<span class="fc" id="L1111">                int[] data = DataConverter.get().convert( _getRawData(), int[].class);</span>
<span class="fc" id="L1112">                _writeImgData(new DataBufferInt(data, data.length), image);</span>
<span class="fc" id="L1113">                return image;</span>
            }
        }
<span class="nc" id="L1116">        throw new IllegalArgumentException(&quot;Image type '&quot;+type+&quot;' not supported.&quot;);</span>
    }

    private void _checkRankForImageConversion( ImageType type, Class&lt;?&gt; dataType, int... pattern ) {
<span class="fc" id="L1120">        int rank = pattern.length; // The expected rank!</span>
<span class="fc bfc" id="L1121" title="All 2 branches covered.">        if ( this.rank() != rank ) {</span>
<span class="fc" id="L1122">            throw new IllegalArgumentException(</span>
<span class="fc" id="L1123">                    &quot;Cannot create image of type '&quot; + type.name() + &quot;' from tensor of rank &quot; + this.rank() + &quot;. &quot; +</span>
                    &quot;Expected to receive tensor of rank &quot; + rank + &quot;.&quot;
                );
        }
<span class="fc bfc" id="L1127" title="All 2 branches covered.">        for ( int i = 0; i &lt; pattern.length; i++ ) {</span>
<span class="fc" id="L1128">            int axisSize = pattern[ i ]; // The expected axis size!</span>
<span class="fc bfc" id="L1129" title="All 2 branches covered.">            if ( axisSize &gt; 0 ) {</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">                if ( axisSize != this.shape(i) ) {</span>
<span class="fc" id="L1131">                    String shape = this.shape().stream().map( a -&gt; a.toString() ).collect(Collectors.joining(&quot;x&quot;));</span>
<span class="fc" id="L1132">                    throw new IllegalArgumentException(</span>
<span class="fc" id="L1133">                        &quot;Cannot create image of type '&quot; + type.name() + &quot;' from tensor with shape (&quot; + shape + &quot;). &quot; +</span>
                        &quot;Axis &quot; + i + &quot; is expected to be of size &quot; + axisSize + &quot;.&quot;
                    );
                }
            }
        }
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        if ( !dataType.isAssignableFrom(this.getItemType()) )</span>
<span class="fc" id="L1140">            throw new IllegalArgumentException(</span>
<span class="fc" id="L1141">                &quot;Cannot create image of type '&quot; + type.name() + &quot;' from tensor of type '&quot; + this.getItemType().getSimpleName() + &quot;. &quot; +</span>
<span class="fc" id="L1142">                &quot;Expected to receive a tensor whose type is at least a sub-type of '&quot; + dataType.getSimpleName() + &quot;'.&quot;</span>
            );
<span class="fc" id="L1144">    }</span>

    private static void _writeImgData( DataBuffer data, BufferedImage target ) {
<span class="fc" id="L1147">        target.setData(</span>
<span class="fc" id="L1148">            Raster.createRaster( target.getSampleModel(), data, new Point() )</span>
        );
<span class="fc" id="L1150">    }</span>

    /**
     *  {@inheritDoc}
     */
    @Override
    public Tsr&lt;V&gt; addToGradient( Tsr&lt;V&gt; error ) {
<span class="fc" id="L1157">        _guardSet(&quot;gradient&quot;);</span>
<span class="fc" id="L1158">        if (</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">            !forComponent(</span>
                Tsr.class,
                    gradient -&gt;
<span class="fc" id="L1162">                    this.set(</span>
<span class="fc" id="L1163">                        MemUtil.keep( gradient, error, () -&gt;</span>
<span class="fc" id="L1164">                            Neureka.get()</span>
<span class="fc" id="L1165">                                    .backend()</span>
<span class="fc" id="L1166">                                    .getFunction()</span>
<span class="fc" id="L1167">                                    .plusAssign()</span>
<span class="fc" id="L1168">                                    .call(gradient, error)</span>
                        )
                    )
            )
        ) {
<span class="fc" id="L1173">            this.set( error );</span>
<span class="fc" id="L1174">            this.forComponent( Device.class, device -&gt; {</span>
                try {
<span class="fc" id="L1176">                    device.store( error ) ;</span>
<span class="nc" id="L1177">                } catch ( Exception exception ) {</span>
<span class="nc" id="L1178">                    _LOG.error( &quot;Failed trying to store a given error to a device for gradient accumulation.&quot;, exception );</span>
<span class="nc" id="L1179">                    throw exception;</span>
<span class="fc" id="L1180">                }</span>
<span class="fc" id="L1181">            });</span>
        }
<span class="fc" id="L1183">        return this;</span>
    }

    /**
     *  {@inheritDoc}
     */
    @Override
    public &lt;T&gt; T asType( Class&lt;T&gt; typeClass )
    {
<span class="fc" id="L1192">        LogUtil.nullArgCheck( typeClass, &quot;typeClass&quot;, Class.class );</span>
<span class="fc bfc" id="L1193" title="All 2 branches covered.">        if ( typeClass == Tsr.class ) return (T) this;</span>
<span class="pc bpc" id="L1194" title="1 of 4 branches missed.">        if ( Number.class.isAssignableFrom( this.itemType()) &amp;&amp; Number.class.isAssignableFrom(typeClass) ) {</span>
<span class="fc" id="L1195">            DataConverter converter = DataConverter.get();</span>
<span class="fc" id="L1196">            return converter.convert( mean().at(0).get(), typeClass );</span>
        }
<span class="fc bfc" id="L1198" title="All 2 branches covered.">        if ( typeClass == String.class )</span>
<span class="fc" id="L1199">            return (T) this.toString();</span>

<span class="fc" id="L1201">        throw new IllegalArgumentException(&quot;Failed to convert this tensor of type '&quot;+getDataType()+&quot;' to '&quot;+typeClass+&quot;'!&quot;);</span>
    }

    /**
     *  This method is an inline operation which changes the underlying data of this tensor.
     *  It converts the data types of the elements of this tensor to the specified type!&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;WARNING : The use of this method is discouraged for the following reasons: &lt;/b&gt;&lt;br&gt;
     *  &lt;br&gt;
     *  1. Inline operations are inherently error-prone for most use cases. &lt;br&gt;
     *  2. This inline operation in particular has no safety net,
     *     meaning that there is no implementation of version mismatch detection
     *     like there is for those operations present in the standard operation backend...
     *     No exceptions will be thrown during backpropagation! &lt;br&gt;
     *  3. This method has not yet been implemented to also handle instances which
     *     are slices of parent tensors!
     *     Therefore, there might be unexpected performance penalties or side effects
     *     associated with this method.&lt;br&gt;
     *     &lt;br&gt;
     *
     * @param typeClass The target type class for elements of this tensor.
     * @param &lt;T&gt; The type parameter for the returned tensor.
     * @return The same tensor instance whose data has been converted to hold a different type.
     */
    private &lt;T&gt; Tsr&lt;T&gt; _toType( Class&lt;T&gt; typeClass )
    {
<span class="fc bfc" id="L1227" title="All 2 branches covered.">        if ( this.isOutsourced() ) {</span>
<span class="fc" id="L1228">            _setDataType( DataType.of( typeClass ) );</span>
<span class="fc" id="L1229">            return (Tsr&lt;T&gt;) this;</span>
        }
        else {
<span class="fc" id="L1232">            Object newData = _convertedDataOfType( typeClass );</span>
<span class="fc" id="L1233">            _setData( null );</span>
<span class="fc" id="L1234">            _setDataType( DataType.of( typeClass ) );</span>
<span class="fc" id="L1235">            _setData( CPU.get().allocate(newData) );</span>
        }
<span class="pc" id="L1237">        forComponent( TsrImpl.class, gradient -&gt; gradient._toType( typeClass ) );</span>
<span class="fc" id="L1238">        return (Tsr&lt;T&gt;) this;</span>
    }

    @Override
    public String toString()
    {
<span class="fc bfc" id="L1244" title="All 2 branches covered.">        if ( this.isDeleted() ) return &quot;deleted&quot;;</span>
<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">        else if ( this.isEmpty() ) return &quot;empty&quot;;</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">        else if ( this.isUndefined() ) return &quot;undefined&quot;;</span>
<span class="fc" id="L1247">        return NdaAsString.representing( this ).byDefaults().toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>