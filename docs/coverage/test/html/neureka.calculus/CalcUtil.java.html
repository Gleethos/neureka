<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CalcUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">neureka</a> &gt; <a href="index.source.html" class="el_package">neureka.calculus</a> &gt; <span class="el_source">CalcUtil.java</span></div><h1>CalcUtil.java</h1><pre class="source lang-java linenums">package neureka.calculus;

import neureka.Neureka;
import neureka.Tsr;
import neureka.backend.api.Algorithm;
import neureka.backend.api.ExecutionCall;
import neureka.backend.api.ImplementationFor;
import neureka.backend.api.Operation;
import neureka.backend.standard.algorithms.Activation;
import neureka.backend.standard.operations.JunctionUtil;
import neureka.calculus.args.Arg;
import neureka.calculus.assembly.FunctionBuilder;
import neureka.calculus.implementations.FunctionConstant;
import neureka.devices.Device;
import neureka.utility.Messages;
import org.jetbrains.annotations.Contract;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.IntStream;

/**
 *  This is a utility class which helps with orchestrating the execution of classical operations
 *  from calculus like the operators '*', '-', '+', '/', as well as linear operations
 *  like matrix multiplication, broadcasting and convolution.
 *  This orchestration refers to the way an {@link ExecutionCall} alongside its caller, a {@link Function},
 *  should be handles to produce a correct result.
 */
<span class="pc bpc" id="L31" title="1 of 2 branches missed.">public class CalcUtil</span>
{
<span class="fc" id="L33">    private static final Logger _LOG = LoggerFactory.getLogger( CalcUtil.class );</span>

    @Contract( pure = true )
    public static Tsr&lt;?&gt; defaultRecursiveExecution(
            final Function caller,
            final ExecutionCall&lt;? extends Device&lt;?&gt;&gt; call
    ) {
<span class="fc" id="L40">        return executeFor( caller, call, null );</span>
    }

    @Contract( pure = true )
    public static Tsr&lt;?&gt; executeFor(
            final Function caller,
            final ExecutionCall&lt;? extends Device&lt;?&gt;&gt; call,
            final RecursiveExecutor executor
    ) {
<span class="fc" id="L49">        Function[] nodes = caller.getSubFunctions().toArray(new Function[0]);</span>
<span class="fc" id="L50">        Operation operation = caller.getOperation();</span>
<span class="fc" id="L51">        boolean isFlat = caller.isFlat();</span>
<span class="fc" id="L52">        boolean isDoingAD = caller.isDoingAD();</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">        if ( call.getValOf( Arg.DerivIdx.class ) &lt; 0 )</span>
<span class="fc" id="L54">            return _deepActivation( call, nodes, operation, isFlat, isDoingAD, executor );</span>
        else
<span class="fc" id="L56">            return _deepDerivative( call, nodes, operation, executor );</span>
    }

    @Contract( pure = true )
    private static Tsr&lt;?&gt; _deepActivation(
            final ExecutionCall&lt;? extends Device&lt;?&gt;&gt; call,
            final Function[] nodes,
            final Operation operation,
            final boolean isFlat,
            final boolean isDoingAD,
            final RecursiveExecutor executor
    ) {
<span class="fc" id="L68">        Tsr&lt;?&gt;[] inputs = call.getTensors();</span>
<span class="fc" id="L69">        Device&lt;?&gt; device = call.getDevice();</span>
<span class="fc" id="L70">        int j = call.getJ();</span>
<span class="pc bpc" id="L71" title="2 of 4 branches missed.">        assert call.getValOf( Arg.DerivIdx.class ) == -1;</span>

        Tsr&lt;?&gt;[] tensors;
<span class="fc bfc" id="L74" title="All 2 branches covered.">        if ( operation.isIndexer() ) tensors = new Tsr[ 1 + inputs.length ];</span>
<span class="fc" id="L75">        else tensors = new Tsr[ 1 + nodes.length ];</span>

<span class="fc bfc" id="L77" title="All 2 branches covered.">        if ( operation.isIndexer() ) {</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">            for ( int i = 1; i &lt; tensors.length; i++ ) tensors[ i ] = nodes[ 0 ].execute( inputs, i - 1 );</span>
<span class="pc bpc" id="L79" title="1 of 4 branches missed.">        } else if (</span>
                !isFlat &amp;&amp; j &lt; 0 &amp;&amp; (
<span class="pc bpc" id="L81" title="1 of 4 branches missed.">                        operation.isOperator() || operation.supportsAlgorithm(Activation.class)</span>
                )
        ) {/*   '+', '-', 'x', '*', '%', 'Â«', 'Â»', ',', ...   */
<span class="fc" id="L84">            tensors = srcActivation(inputs, j, -1, 0, nodes);</span>
<span class="fc" id="L85">            String asStr = operation.stringify(</span>
<span class="fc" id="L86">                    IntStream.range(0, nodes.length).mapToObj( i -&gt; &quot;I[&quot; + i + &quot;]&quot; ).toArray(String[]::new)</span>
            );
<span class="fc" id="L88">            return new FunctionBuilder( Neureka.get().backend() ).build( asStr, isDoingAD ).execute( tensors );</span>
        } else
<span class="fc" id="L90">            tensors = srcActivation( inputs, j, -1, 1, nodes );</span>

<span class="fc" id="L92">        CalcUtil.recursiveExecution(</span>
<span class="fc" id="L93">                ExecutionCall.of( tensors )</span>
<span class="fc" id="L94">                        .andArgs( Arg.DerivIdx.of(-1) )</span>
<span class="fc" id="L95">                        .running( operation )</span>
<span class="fc" id="L96">                        .on( device ),</span>
                executor
        );
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if ( tensors[ 0 ] == null )</span>
<span class="fc" id="L100">            _LOG.warn(&quot;Executing operation '&quot;+operation.getFunction()+&quot;' did not yield a proper return value.&quot;);</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">        return ( tensors[ 0 ] == null ? tensors[ 1 ] : tensors[ 0 ] );</span>
    }

    /**
     *  This method return the index of the tensor
     *  in the given tensor array which is virtual and contains &quot;1.0&quot;.
     *  However, if not all tensors are virtual or their values are not all &quot;0.0&quot; except one
     *  whose value is &quot;1.0&quot; then it returns -1, because the optimization cannot
     *  be made...
     *
     * @param tensors An array of tensors which ought to be analyzed.
     * @return The index of the tensor whose value is &quot;1.0&quot; (if all others are &quot;0.0&quot;), otherwise : -1
     */
    @Contract( pure = true )
    private static int _indexOfFoundDerivative( Tsr&lt;?&gt;[] tensors )
    {
<span class="fc" id="L118">        boolean allVirtual = true;</span>
<span class="fc bfc" id="L119" title="All 6 branches covered.">        for ( Tsr&lt;?&gt; t : tensors ) if ( t != null &amp;&amp; !t.isVirtual() ) allVirtual = false;</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if ( allVirtual ) {</span>
<span class="fc" id="L121">            int index = -1;</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            for ( int i = 0; i &lt; tensors.length; i++ ) {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">                double value = ( tensors[ i ] == null ) ? 0.0 : tensors[ i ].value64( 0 );</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">                if ( value == 1.0 ) {</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                    if ( index &gt;= 0 ) return -1;</span>
<span class="fc" id="L126">                    index = i;</span>
                }
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">                else if ( value != 0.0 ) return -1;</span>
            }
<span class="fc" id="L130">            return index;</span>
        }
<span class="fc" id="L132">        return -1;</span>
    }

    @Contract( pure = true )
    private static Tsr&lt;?&gt; _deepDerivative(
            final ExecutionCall&lt;? extends Device&lt;?&gt;&gt; call,
            final Function[] nodes,
            final Operation operation,
            final RecursiveExecutor executor
    ) {
<span class="fc" id="L142">        Supplier&lt;Tsr&lt;?&gt;&gt; actor = () -&gt; {</span>
<span class="fc" id="L143">            Tsr&lt;?&gt;[] inputs = call.getTensors();</span>
<span class="fc" id="L144">            Device&lt;?&gt; device = call.getDevice();</span>
<span class="fc" id="L145">            int d = call.getValOf( Arg.DerivIdx.class );</span>
<span class="fc" id="L146">            int j = call.getJ();</span>
<span class="pc bpc" id="L147" title="2 of 4 branches missed.">            assert d &gt;= 0;</span>

            Tsr&lt;?&gt;[] tensors;
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if ( operation.isIndexer() ) tensors = new Tsr[ 1 + inputs.length ];</span>
<span class="fc" id="L151">            else tensors = new Tsr[ 1 + nodes.length ];</span>

            // Chain-rule (forward AutoDiff):
            // inner times outer means:
            // first derive source!
            // like so:
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if ( operation.isIndexer() ) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                for ( int i = 1; i &lt; tensors.length; i++ ) {</span>
<span class="fc" id="L159">                    tensors[ i ] = nodes[ 0 ].executeDerive( inputs, d, i - 1 );</span>
                }
            } else {
<span class="fc bfc" id="L162" title="All 2 branches covered.">                for ( int i = 1; i &lt; tensors.length; i++ ) {</span>
<span class="fc" id="L163">                    tensors[ i ] =</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">                            ( j &gt;= 0 )</span>
<span class="fc" id="L165">                                    ? nodes[ i - 1 ].executeDerive( inputs, d, j )</span>
<span class="fc" id="L166">                                    : nodes[ i - 1 ].executeDerive( inputs, d );</span>
                }
            }
            //...then add them all together! (is possible because of linearity...)
            Tsr&lt;?&gt; inner;
<span class="fc bfc" id="L171" title="All 2 branches covered.">            if ( tensors.length &gt; 2 ) {// Optimization: Finds index of &quot;1.0&quot; among otherwise all &quot;0.0&quot; virtual tensors!</span>
<span class="fc" id="L172">                int index = _indexOfFoundDerivative( tensors );</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">                if ( index &gt;= 0 ) inner = tensors[ index ];</span>
                else {
                    // Optimization above did not apply, so we accumulate all the derivatives!
<span class="fc" id="L176">                    CalcUtil.recursiveExecution(</span>
<span class="fc" id="L177">                            ExecutionCall.of( tensors )</span>
<span class="fc" id="L178">                                    .andArgs( Arg.DerivIdx.of( -1 ) )</span>
<span class="fc" id="L179">                                    .running( Neureka.get().backend().getOperation(&quot;+&quot;) )</span>
<span class="fc" id="L180">                                    .on( device ),</span>
                            JunctionUtil::forAdditions
                    );
<span class="fc" id="L183">                    inner = tensors[ 0 ];//-&gt; this is now the inner derivative!</span>
                }
<span class="fc" id="L185">            }</span>
<span class="fc" id="L186">            else inner = tensors[ 1 ];</span>

<span class="fc" id="L188">            tensors[ 0 ] = null;</span>
            //...then activate (No differentiation!) the source like so:
<span class="fc bfc" id="L190" title="All 2 branches covered.">            if ( operation.isIndexer() ) { // Indexer pass an index j of course!</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                for ( int i = 1; i &lt; tensors.length; i++ ) {</span>
<span class="fc" id="L192">                    tensors[ i ] = nodes[ 0 ].execute( inputs, i - 1 ); // i - 1 := j</span>
                }
            } else {
<span class="fc bfc" id="L195" title="All 2 branches covered.">                for ( int i = 1; i &lt; tensors.length; i++ ) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                    tensors[ i ] = ( j &gt;= 0 ) ? nodes[ i - 1 ].execute( inputs, j ) : nodes[ i - 1 ].execute( inputs );</span>
                }
            }
            //...get derivative index within src list:
<span class="fc bfc" id="L200" title="All 2 branches covered.">            for ( int i = 0; i &lt; nodes.length; i++ ) {</span>
<span class="fc bfc" id="L201" title="All 4 branches covered.">                if ( nodes[ i ].dependsOn( d ) &amp;&amp; !operation.isIndexer() ) {</span>
<span class="fc" id="L202">                    d = i;</span>
<span class="fc" id="L203">                    break;</span>
                }
            }
            // Use those tensors for the outer derivative:
<span class="fc" id="L207">            CalcUtil.recursiveExecution(</span>
<span class="fc" id="L208">                    ExecutionCall.of( tensors )</span>
<span class="fc" id="L209">                            .andArgs( Arg.DerivIdx.of( d ) )</span>
<span class="fc" id="L210">                            .running( operation )</span>
<span class="fc" id="L211">                            .on( device ),</span>
                    executor
            );
            // At the end:
            //...multiply inner times outer: ( if inner is not 1 entirely... )
<span class="fc bfc" id="L216" title="All 6 branches covered.">            if ( !( ( inner.isVirtual() || inner.size() == 1 ) &amp;&amp; inner.value64( 0 ) == 1.0 ) ) {</span>
<span class="fc" id="L217">                tensors = new Tsr[]{ null, inner, tensors[ 0 ] };</span>
<span class="fc" id="L218">                CalcUtil.recursiveExecution(</span>
<span class="fc" id="L219">                        ExecutionCall.of( tensors )</span>
<span class="fc" id="L220">                                .andArgs( Arg.DerivIdx.of( -1 ) )</span>
<span class="fc" id="L221">                                .running( Neureka.get().backend().getOperation(&quot;*&quot;) )</span>
<span class="fc" id="L222">                                .on( device ),</span>
                        null
                );
            } // done!
<span class="fc" id="L226">            return tensors[ 0 ];</span>
        };

<span class="fc" id="L229">        Device&lt;?&gt; device = call.getDevice();</span>
<span class="fc" id="L230">        int d = call.getValOf( Arg.DerivIdx.class );</span>
<span class="fc" id="L231">        Tsr&lt;?&gt; out = null;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        for ( int i = 0; i &lt; nodes.length; i++ ) { // constants need to be figured out!</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            int di = ( nodes[ i ].dependsOn( d ) ) ? i : -1;</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if ( di &gt;= 0 ) {</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">                if ( out == null ) out = actor.get();</span>
                else
<span class="fc" id="L237">                    CalcUtil.recursiveExecution(</span>
<span class="fc" id="L238">                            ExecutionCall.of( null, actor.get(), out )</span>
<span class="fc" id="L239">                                    .andArgs( Arg.DerivIdx.of( -1 ) )</span>
<span class="fc" id="L240">                                    .running( Neureka.get().backend().getOperation( &quot;+&quot; ) )</span>
<span class="fc" id="L241">                                    .on( device ),</span>
                            null
                    );
            }
        }
<span class="fc" id="L246">        return out;</span>
    }

    public static void recursiveExecution(
            ExecutionCall&lt;? extends Device&lt;?&gt;&gt; executionCall,
            RecursiveExecutor executor
    ) {
<span class="fc" id="L253">        executionCall = executionCall.getAlgorithm().prepare( executionCall );</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        for ( Tsr&lt;?&gt; t : executionCall.getTensors() ) {</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if ( t == null ) throw new IllegalArgumentException(</span>
                    &quot;Device arguments may not be null!\n&quot; +
                            &quot;One or more tensor arguments within the given ExecutionCall instance is null.&quot;
            );
        }
<span class="fc" id="L260">        _recursiveReductionOf(</span>
                executionCall,
                call -&gt; {
<span class="fc bfc" id="L263" title="All 2 branches covered.">                    for ( Tsr&lt;?&gt; t : call.getTensors() ) {</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                        if ( t == null ) throw new IllegalArgumentException(</span>
                                &quot;Device arguments may not be null!\n&quot; +
                                        &quot;One or more tensor arguments within the given ExecutionCall instance is null.&quot;
                        );
                    }
<span class="fc" id="L269">                    call = (ExecutionCall&lt;? extends Device&lt;?&gt;&gt;) ExecutionCall.of( call.getTensors() )</span>
<span class="fc" id="L270">                                                                    .andArgs( Arg.DerivIdx.of( call.getValOf( Arg.DerivIdx.class ) ) )</span>
<span class="fc" id="L271">                                                                    .running( call.getOperation() )</span>
<span class="fc" id="L272">                                                                    .on( call.getDevice() )</span>
<span class="fc" id="L273">                                                                    .forDeviceType( call.getDevice().getClass() );</span>
<span class="fc" id="L274">                    Device&lt;?&gt; device = call.getDevice();</span>
<span class="fc" id="L275">                    device.approve( call );</span>
<span class="fc" id="L276">                    call.getTensors()[ 0 ].setIsVirtual( false );</span>

<span class="fc" id="L278">                    Algorithm&lt;?&gt; algorithm = call.getAlgorithm();</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                    if ( algorithm == null ) {</span>
<span class="nc" id="L280">                        String message = Messages.Devices.couldNotFindSuitableAlgorithmFor( device.getClass() );</span>
<span class="nc" id="L281">                        _LOG.error( message );</span>
<span class="nc" id="L282">                        throw new IllegalStateException( message );</span>
                    } else {
<span class="fc" id="L284">                        ImplementationFor&lt;Device&lt;?&gt;&gt; implementation = algorithm.getImplementationFor( device );</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">                        if ( implementation == null ) {</span>
<span class="fc" id="L286">                            String message = Messages.Devices.couldNotFindSuitableImplementationFor( algorithm, device.getClass() );</span>
<span class="fc" id="L287">                            _LOG.error( message );</span>
<span class="fc" id="L288">                            throw new IllegalStateException( message );</span>
                        }
<span class="fc" id="L290">                        else implementation.run( (ExecutionCall&lt;Device&lt;?&gt;&gt;) call );</span>
                    }
<span class="fc" id="L292">                },</span>
                executor
        );
<span class="fc" id="L295">    }</span>

    /**
     *  The following method can be used to split one big execution call into many
     *  grouped execution calls which will be executed recursively.
     *  This method receives a the call which ought to be broken down as well as two lambdas
     *  which contain implementations to perform this task.
     *  The first lambda, namely {@param finalExecution}, will be called at the end of the
     *  recursion dive, whereas the second lambda {@param executor} will be called for
     *  every recursive call in order to perform the grouping.
     *  The {@param executor} will actually receive the recursive call as lambda, which
     *  then may or may not be called by implementations of the lambda...
     *
     * @param call The {@link ExecutionCall} whose arguments ought to be executed in groups.
     * @param finalExecution The actual execution whose implementation is provided by the caller.
     * @param executor The traversing algorithm, which decides how to group arguments and when
     *                 the {@param finalExecution} ought to be called.
     *
     * @return The execution result of the provided {@param call}.
     */
    @Contract( pure = true )
    private static Tsr&lt;?&gt; _recursiveReductionOf(
            final ExecutionCall&lt;? extends Device&lt;?&gt;&gt; call,
            final Consumer&lt;ExecutionCall&lt;? extends Device&lt;?&gt;&gt;&gt; finalExecution,
            final RecursiveExecutor executor
    ) {
<span class="fc" id="L321">        Device&lt;Object&gt; device = call.getDeviceFor(Object.class);</span>
<span class="fc" id="L322">        Tsr&lt;Object&gt;[] tensors = (Tsr&lt;Object&gt;[]) call.getTensors();</span>
<span class="fc" id="L323">        int d = call.getValOf( Arg.DerivIdx.class );</span>
<span class="fc" id="L324">        Operation type = call.getOperation();</span>

<span class="fc" id="L326">        Consumer&lt;Tsr&lt;Object&gt;&gt;[] rollbacks = new Consumer[ tensors.length ];</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for ( int i = 0; i &lt; tensors.length; i++ ) {</span>
<span class="pc bpc" id="L328" title="1 of 4 branches missed.">            if ( tensors[ i ] != null &amp;&amp; !tensors[ i ].isOutsourced() ) {</span>
                try {
<span class="fc" id="L330">                    device.store( tensors[ i ] );</span>
<span class="nc" id="L331">                } catch ( Exception e ) {</span>
<span class="nc" id="L332">                    e.printStackTrace();</span>
<span class="fc" id="L333">                }</span>

<span class="fc" id="L335">                rollbacks[ i ] = tensor -&gt; {</span>
                    try {
<span class="fc" id="L337">                        device.restore( tensor );</span>
<span class="nc" id="L338">                    } catch ( Exception e ) {</span>
<span class="nc" id="L339">                        e.printStackTrace();</span>
<span class="fc" id="L340">                    }</span>
<span class="fc" id="L341">                };</span>
            }
<span class="fc" id="L343">            else rollbacks[ i ] = t -&gt; {};</span>
        }
        /* For the following operations with the correct arity RJAgent should do: ...
            case (&quot;s&quot; + ((char) 187)): tsrs = new Tsr[]{tsrs[ 2 ], tsrs[ 1 ], tsrs[ 0 ]};
            case (&quot;d&quot; + ((char) 187)): tsrs = new Tsr[]{tsrs[ 2 ], tsrs[ 1 ], tsrs[ 0 ]};
            case (&quot;p&quot; + ((char) 187)): tsrs = new Tsr[]{tsrs[ 2 ], tsrs[ 1 ], tsrs[ 0 ]};
            case (&quot;m&quot; + ((char) 187)): tsrs = new Tsr[]{tsrs[ 2 ], tsrs[ 1 ], tsrs[ 0 ]};
            case &quot;&gt;&quot;: tsrs = new Tsr[]{tsrs[ 1 ], tsrs[ 0 ]};
         */
        /*
            Below is the core lambda of recursive preprocessing
            which is defined for each Algorithm individually :
         */
<span class="fc" id="L356">        Tsr&lt;?&gt; result = null;</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if ( executor != null )</span>
<span class="fc" id="L358">            result = executor.execute( // This is where the recursion occurs:</span>
                                call,
                                innerCall -&gt; // This lambda performs the recursive call, implementations decide if they want to dive deeper.
<span class="fc" id="L361">                                        _recursiveReductionOf( innerCall, finalExecution, executor )</span>
                            );

<span class="fc bfc" id="L364" title="All 2 branches covered.">        if ( result == null ) {</span>
<span class="fc" id="L365">            finalExecution.accept(</span>
<span class="fc" id="L366">                    ExecutionCall.of( call.getTensors() )</span>
<span class="fc" id="L367">                            .andArgs( Arg.DerivIdx.of(d) )</span>
<span class="fc" id="L368">                            .running( type )</span>
<span class="fc" id="L369">                            .on( device )</span>
            );
        }
<span class="fc" id="L372">        else return result;</span>

<span class="fc bfc" id="L374" title="All 2 branches covered.">        for ( int i = 0; i &lt; tensors.length; i++ ) {</span>
<span class="pc bpc" id="L375" title="2 of 4 branches missed.">            if ( tensors[ i ] != null &amp;&amp; !tensors[ i ].isUndefined() ) rollbacks[ i ].accept(tensors[ i ]);</span>
        }
<span class="fc" id="L377">        return tensors[ 0 ];</span>
    }

    /**
     *  This method performs a classical execution of a {@link Function} alongside an array of provided
     *  arguments and an offset used to make room in the output array returned by this method.
     */
    @Contract( pure = true )
    public static Tsr&lt;?&gt;[] srcActivation(
            Tsr&lt;?&gt;[] inputs, int j, int d, int offset, Function[] src
    ) {
<span class="fc" id="L388">        int[] tempShape = null;</span>
<span class="fc" id="L389">        Tsr&lt;?&gt;[] tensors = new Tsr[ src.length + offset ];</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        for ( int i = offset; i &lt; tensors.length; i++ ) {//constants need to be figured out!</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">            if ( !( src[ i - offset ] instanceof FunctionConstant ) ) {</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">                if ( d &lt; 0 ) // Not deriving this!</span>
<span class="fc" id="L393">                    tensors[ i ] =</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                            ( j &gt;= 0 )</span>
<span class="fc" id="L395">                                    ? src[ i - offset ].execute( inputs, j )</span>
<span class="fc" id="L396">                                    : src[ i - offset ].execute( inputs );</span>
                else // ...deriving at specified index...
<span class="nc" id="L398">                    tensors[ i ] =</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                            ( j &gt;= 0 )</span>
<span class="nc" id="L400">                                    ? src[ i - offset ].executeDerive( inputs, d, j )</span>
<span class="nc" id="L401">                                    : src[ i - offset ].executeDerive( inputs, d );</span>

<span class="fc bfc" id="L403" title="All 2 branches covered.">                tempShape = ( tempShape == null ? tensors[ i ].getNDConf().shape() : tempShape );</span>
            }
        }
<span class="fc bfc" id="L406" title="All 2 branches covered.">        for ( int i = offset; i &lt; tensors.length; i++ ) {</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">            if ( tensors[ i ] == null )</span>
<span class="fc" id="L408">                tensors[ i ] =</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">                        ( j &lt; 0 )</span>
<span class="fc" id="L410">                            ? Tsr.of( tempShape, ((FunctionConstant) src[ i - offset ]).value() )</span>
<span class="fc" id="L411">                            : Tsr.of( tempShape, src[ i - offset ].call(new double[]{}, j) );</span>
        }
<span class="fc" id="L413">        return tensors;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>