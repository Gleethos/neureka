<!DOCTYPE html><html>
<head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'></meta>
<style>
body {
    font-family: Helvetica, Arial, sans-serif;
    font-weight: 300;
}

h2 {
    font-weight: 400;
}

hr {
    margin-bottom: 1.5em;
}

h3 {
    font-weight: 200;
}

table {
    margin: 7px;
    -webkit-box-shadow: 0px 0px 3px 1px rgba(0,0,0,0.75);
    -moz-box-shadow: 0px 0px 3px 1px rgba(0,0,0,0.75);
    box-shadow: 0px 0px 3px 1px rgba(0,0,0,0.75);
}

.ignored {
    color: gray;
}

div.project-header {
    margin-bottom: 10px;
    font-size: large;
}

div.project-header &gt; span.project-name {

                        }

div.project-header &gt; span.project-version {
                            padding-left: 20px;
                        }

div.date-test-ran {
    font-size: small;
    font-style: italic;
}

div.spec-title {
    padding: 10px 0px 5px 0px;
}

tr.error td, td.error {
    background-color: #F89A4F !important;
}

tr.failure td, td.failure {
    color: red;
}

div.footer {
    text-align: center;
    font-size: small;
}






.back-link {
    font-size: small;
    font-weight: bold;
}


div.date-test-ran {
    font-size: small;
    font-style: italic;
}

table.features-table {
    width: 99%;
    text-align: left;
}

table.summary-table {
    width: 99%;

    font-weight: bold;
    font-size: small;
}

table.summary-table tbody {
    width: 99%;
    text-align: left;
}

table.summary-table th {
    background: lightblue;
    padding: 6px;
}

table.summary-table td {
    background: #E0E0E0;
    padding: 6px;
}

pre.title {
    font-family: inherit;
    font-size: 24px;
    line-height: 28px;
    letter-spacing: -1px;
    color: #333;
}

pre.narrative {
    font-family: inherit;
    font-size: 18px;
    font-style: italic;
    line-height: 23px;
    letter-spacing: -1px;
    color: #333;
}

.feature-description {
    font-size: large;
    background: lightblue;
    padding: 12px;
}

.feature-toc-error {
    color: #F89A4F;
}

.feature-toc-failure {
    color: #FF8080;
}

.feature-toc-ignored {
    color: lightgray;
}

.feature-toc-pass {
    color: green;
}

.feature-description.error {
    background: #F89A4F;
}

.feature-description.failure {
    background: #FF8080;
}

.feature-description.ignored {
    background: lightgray;
}

.feature-description.ignored .reason {
    color: black;
    font-style: italic;
    font-size: small;
}

div.extra-info {
    font-size: small;
}

div.spec-headers {
    margin: 4px;
    font-style: italic;
}

div.spec-header {
}

div.issues {
    margin-top: 6px;
    padding: 10px 5px 5px 5px;
    background-color: lemonchiffon;
    color: black;
    font-weight: 500;
    font-size: small;
    max-width: 50%;
}

div.pending-feature {
    background-color: dodgerblue;
    color: white;
    margin-top: 6px;
    padding: 5px;
    text-align: center;
    font-size: small;
    max-width: 120px;
}

div.problem-description {
    padding: 10px;
    background: pink;
    border-radius: 10px;
}

div.problem-header {
    font-weight: bold;
    color: red;
}

div.problem-list {

}

table.ex-table{
    width: 98%;
}

table.ex-table th {
    background: lightblue;
    padding: 5px;
}

table.ex-table td {
    background: #E0E0E0;
    padding: 2px 5px 2px 5px;
}

table td {
    min-width: 50px;
}

col.block-kind-col {
    width: 70px;
}

span.spec-header {
    font-weight: bold;
}

div.spec-text {
    /*color: green;*/
}

div.spec-status {
    font-style: italic;
}

.ignored {
    color: gray;
}

td.ex-result {
    text-align: center;
    background: white !important;
}

.ex-pass {
    color: darkgreen;
}

.ex-fail {
    color: red;
    font-weight: bold;
}

div.block-kind {
    margin: 2px;
    font-style: italic;
}

div.block-text {

}

pre.block-source {
    background-color: whitesmoke;
    padding: 10px;
}

pre.block-source.error {
    background-color: pink;
    color: red;
    font-weight: bold;
}

pre.block-source.pre-error {

}

pre.block-source.before-error {
    margin-bottom: -14px;
}

pre.block-source.after-error {
    color: gray;
    margin-top: -14px;
}

pre.block-source.post-error {
    color: gray;
}

div.footer {
    text-align: center;
    font-size: small;
}</style>
</head>
<body>
<h2>Report for ut.tensors.Tensor_IO_Spec</h2>
<hr></hr>
<div class='back-link'>
<a href='index.html'>&lt;&lt; Back</a>
</div>
<div class='summary-report'>
<h3>Summary:</h3>
<div class='date-test-ran'>Created on Fri Feb 25 23:22:23 CET 2022 by Daglemino</div>
<table class='summary-table'>
<thead>
<tr>
<th>Executed features</th>
<th>Passed</th>
<th>Failures</th>
<th>Errors</th>
<th>Skipped</th>
<th>Success rate</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>14</td>
<td>14</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>100.0%</td>
<td>0.388 seconds</td>
</tr>
</tbody>
</table>
</div>
<pre class='title'>The Tensor state Input and Output Specification</pre>
<pre class='narrative'>Tensors are complicated data structures with a wide range of different possible states.
    They can host elements of different types residing on many kinds of different devices.
    Here we want to define some basic stuff about how a tensor can be instantiated
    and how we can read from and write to the state of a tensor.
    Here we also specify how a tensor can be converted to another tensor of a different data type!</pre>
<div class='spec-headers'>
<div class='spec-header'>
            <h2>Tensor Instantiation and IO Tests</h2>
            <p>
                This specification covers some basic behaviour related to
                tensor instantiation and modification.
                This includes the instantiation of tensors with custom seeds, shapes and values...
                Included are also tests covering static factory methods.
            </p>
        </div>
</div>
<h3>Features:</h3>
<table class='features-table'>
<colgroup>
<col class='block-kind-col'></col>
<col class='block-text-col'></col>
</colgroup>
<tbody>
<ul id='toc'>
<li>
<a href='#-23914743' class='feature-toc-pass'>Tensors can be instantiated with String seed.</a>
</li>
<li>
<a href='#583974159' class='feature-toc-pass'>Tensor initialization lambdas produce expected tensors.</a>
</li>
<li>
<a href='#-1820313073' class='feature-toc-pass'>Tensor mapping lambdas produce expected tensors.</a>
</li>
<li>
<a href='#-856932970' class='feature-toc-pass'>Smart tensor constructors yield expected results.</a>
</li>
<li>
<a href='#-1672288881' class='feature-toc-pass'>Indexing after reshaping works as expected.</a>
</li>
<li>
<a href='#-1191863392' class='feature-toc-pass'>Passing String seed to tensor produces expected values.</a>
</li>
<li>
<a href='#-910161422' class='feature-toc-pass'>Tensor value type can not be changed by passing float or double arrays to it.</a>
</li>
<li>
<a href='#-243874795' class='feature-toc-pass'>Tensors value type can be changed by calling "toType(...)".</a>
</li>
<li>
<a href='#1676866944' class='feature-toc-pass'>Vector tensors can be instantiated via factory methods.</a>
</li>
<li>
<a href='#-394051891' class='feature-toc-pass'>A tensor produced by a function has expected properties.</a>
</li>
<li>
<a href='#-1387689204' class='feature-toc-pass'>A tensor produced by the static "Tsr.Create.newRandom(shape)" has expected "random" value.</a>
</li>
<li>
<a href='#643822857' class='feature-toc-pass'>Tensor values can be manipulated via static method calls within the "Tsr.IO" class.</a>
</li>
<li>
<a href='#881628368' class='feature-toc-pass'>The tensor data array can be modified by targeting them with an index.</a>
</li>
<li>
<a href='#1787019054' class='feature-toc-pass'>Adding OpenCL device to tensor makes tensor be "outsourced" and contain the Device instance as component.</a>
</li>
</ul>
<tr>
<td colspan='10'>
<div class='feature-description' id='-23914743'>
<span>Tensors can be instantiated with String seed.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>Three seeded 2D tensors are being instantiated.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr t1 = Tsr.of([2, 3], "I am a seed! :)")
Tsr t2 = Tsr.of([2, 3], "I am a seed! :)")
Tsr t3 = Tsr.of([2, 3], "I am also a seed! But different. :)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Expect:</div>
</td>
<td>
<div class='block-text'>Equal seeds produce equal values.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t1.toString() == t2.toString()
t1.toString() != t3.toString()</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='583974159'>
<span>Tensor initialization lambdas produce expected tensors.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Instantiating a tensor using an initializer lambda...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr t = Tsr.of(
        DataType.of( Integer.class ),
        [ 2, 3 ],
        ( int i, int[] indices ) -&gt; { i - 2 }
)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>The tensor has been initialized with the expected values:</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t.toString() == "(2x3):[-2.0, -1.0, 0.0, 1.0, 2.0, 3.0]"</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of(
        DataType.of( String.class ),
        [ 2, 3 ],
        ( int i, int[] indices ) -&gt; { i + ':' + indices.toString() }
)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString() == "(2x3):[0:[0, 0], 1:[0, 1], 2:[0, 2], 3:[1, 0], 4:[1, 1], 5:[1, 2]]"</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-1820313073'>
<span>Tensor mapping lambdas produce expected tensors.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Instantiating a tensor using an initializer lambda...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr t = Tsr.of(
        DataType.of( Double.class ),
        [ 2, 3 ],
        ( int i, int[] indices ) -&gt; { (i - 2) as Double }
)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>The tensor has been initialized with the expected values:</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t.toString() == "(2x3):[-2.0, -1.0, 0.0, 1.0, 2.0, 3.0]"</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>We want to perform an element wise mapping to a new tensor...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>def b = t.mapTo(String, (it) -&gt; {"&lt;$it&gt;".replace(".0", "")})</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>We expect the returned tensor to be a String container whose Strings are formatted according to our mapping lambda.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>b.toString() == "(2x3):[&lt;-2&gt;, &lt;-1&gt;, &lt;0&gt;, &lt;1&gt;, &lt;2&gt;, &lt;3&gt;]"
b.valueClass == String.class</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The original tensor should not have changed because no inline operation occurred.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t.toString() == "(2x3):[-2.0, -1.0, 0.0, 1.0, 2.0, 3.0]"</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-856932970'>
<span>Smart tensor constructors yield expected results.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>Three scalar tensors.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr a = Tsr.of(3)
Tsr b = Tsr.of(2)
Tsr c = Tsr.of(-1)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>Tsr t = Tsr.of("1+", a, "*", b)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("7.0")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of("1", "+", a, "*", b)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("7.0")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of("(","1+", a,")", "*", b)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("8.0")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of("(","1", "+", a,")", "*", b)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("8.0")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of("(", c, "*3)+", "(","1+", a,")", "*", b)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("5.0")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of("(", c, "*","3)+", "(","1+", a,")", "*", b)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("5.0")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of("(", c, "*","3", ")+", "(","1+", a,")", "*", b)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("5.0")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of([2, 2], [2, 4, 4])</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("(2x2):[2.0, 4.0, 4.0, 2.0]")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of([2], [3, 5, 7])</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("(2):[3.0, 5.0]")
t.getValueAs( double[].class ).length==2</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of(new int[]{2, 2}, new double[]{2, 4, 4})</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("(2x2):[2.0, 4.0, 4.0, 2.0]")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of(new int[]{2}, new double[]{3, 5, 7})</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("(2):[3.0, 5.0]")
t.getValueAs( double[].class ).length==2</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-1672288881'>
<span>Indexing after reshaping works as expected.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>We are using the legacy view for tensors where bracket types are swapped, just because...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Neureka.get().settings().view().getTensorSettings().setIsLegacy(true)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>A new tensor instance with the shape (4x3).</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr t1 = Tsr.of([4, 3], 1d..12d)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Recording the index behavior before and after a reshape operation...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>def t1_ioi_1 = t1.indexOfIndices(new int[]{2, 1})
def t1_ioi_2 = t1.indexOfIndices(new int[]{1, 2})
def t1_indices = t1.indicesOfIndex(5)
Tsr t2 = Function.of(" [ 1, 0 ]:( I[0] ) ")(t1)
def t2_ioi_1 = t2.indexOfIndices(new int[]{1, 2})
def t2_idx = t2.indicesOfIndex(7)
def t1_ioi_3 = t1.indexOfIndices(t1.indicesOfIndex(7))
def t2_ioi_2 =  t2.indexOfIndices(t2.indicesOfIndex(7))</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>These recorded values are as one would expect.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t1_ioi_1 == 7
t1_ioi_2 == 5
t1_indices[0] == 1
t1_indices[1] == 2
t2_ioi_1 == 7
t2_idx[0] == 1
t2_idx[1] == 3
t1_ioi_3 == 7
t2_ioi_2 == 10
t1.toString().contains("[4x3]:(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)")
t2.toString().contains("[3x4]:(1.0, 4.0, 7.0, 10.0, 2.0, 5.0, 8.0, 11.0, 3.0, 6.0, 9.0, 12.0)")</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-1191863392'>
<span>Passing String seed to tensor produces expected values.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>Tsr r = Tsr.of([2, 2], "jnrejn")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>r.toString().contains("0.02600E0, -2.06129E0, -0.48373E0, 0.94884E0")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>r = Tsr.of([2, 2], "jnrejn2")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>!r.toString().contains("0.02600E0, -2.06129E0, -0.48373E0, 0.94884E0")</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-910161422'>
<span>Tensor value type can not be changed by passing float or double arrays to it.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>We are using the legacy view for tensors where bracket types are swapped, just because...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Neureka.get().settings().view().getTensorSettings().setIsLegacy(true)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>A new tensor instance.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr x = Tsr.of(3)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Setting the value of the tensor...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>float[] value32 = new float[1]
value32[0] = 5
x.setValue(value32)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>...the tensor will change as expected.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>!(x.getValue() instanceof float[])
!(x.data instanceof float[])
x.getValueAs( float[].class )[ 0 ]==5.0f
x.getValueAs( double[].class )[0]==5.0d</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Doing the same with double array...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>double[] value64 = new double[1]
value64[0] = 4.0
x.setValue(value64)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>...once again the tensor changes as expected.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>x.getValue() instanceof double[]
x.data instanceof double[]
x.getValueAs( float[].class )[ 0 ]==4.0f
x.getValueAs( double[].class )[0]==4.0d
x.isLeave()
!x.isBranch()
!x.isOutsourced()
!x.isVirtual()
!x.isSlice()
!x.isSliceParent()
!x.belongsToGraph()
x.getDevice() !=null
x.getDevice() instanceof CPU
x.rank()==1
!x.rqsGradient()
x.size()==1</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>x.unsafe.toType( Float.class )</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>x.value instanceof float[]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>value64 = new double[1]
value64[0] = 7.0
x.setValue(value64)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>!(x.getValue() instanceof double[])
!(x.data instanceof double[])
x.getValueAs( float[].class )[ 0 ]==7.0f
x.getValueAs( double[].class )[0]==7.0d</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-243874795'>
<span>Tensors value type can be changed by calling "toType(...)".</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>We are using the legacy view for tensors where bracket types are swapped, just because...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Neureka.get().settings().view().getTensorSettings().setIsLegacy(true)
Tsr x = Tsr.of(3)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>x.unsafe.toType( Float.class )</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>x.getValue() instanceof float[]
x.data instanceof float[]
x.getValueAs( float[].class )[ 0 ]==3.0f</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>x.unsafe.toType( Double.class )</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>x.getValue() instanceof double[]
x.data instanceof double[]
x.getValueAs( float[].class )[ 0 ]==3.0f</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='1676866944'>
<span>Vector tensors can be instantiated via factory methods.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<pre class='block-source'>Tsr&lt;?&gt; t = Tsr.of(data)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Expect:</div>
</td>
<td>
<pre class='block-source'>t.valueClass == type</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<pre class='block-source'>t.shape() == shape</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<pre class='block-source'>t.data == data</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<pre class='block-source'>t.value == data</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Examples:</div>
</td>
<td>
<div class='spec-examples'>
<table class='ex-table'>
<thead>
<tr>
<th class='ex-header'>data</th>
<th class='ex-header'>type</th>
<th class='ex-header'>shape</th>
</tr>
</thead>
<tbody>
<tr class='ex-pass'>
<td class='ex-value'>[1.1, 2.2, 3.3]</td>
<td class='ex-value'>class java.lang.Double</td>
<td class='ex-value'>[3]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>[-0.21, 543.3]</td>
<td class='ex-value'>class java.lang.Float</td>
<td class='ex-value'>[2]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>[true, false]</td>
<td class='ex-value'>class java.lang.Boolean</td>
<td class='ex-value'>[2]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>[1, 2, 99, -123]</td>
<td class='ex-value'>class java.lang.Short</td>
<td class='ex-value'>[4]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>[3, 8, 4, 2, 3, 0]</td>
<td class='ex-value'>class java.lang.Long</td>
<td class='ex-value'>[6]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>[66, 1, 4, 42, -40]</td>
<td class='ex-value'>class java.lang.Integer</td>
<td class='ex-value'>[5]</td>
<td class='ex-result'>OK</td>
</tr>
</tbody>
</table>
</div>
</td>
<td>
<div class='spec-status'>6/6 passed</div>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-394051891'>
<span>A tensor produced by a function has expected properties.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>We are using the legacy view for tensors where bracket types are swapped, just because...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Neureka.get().settings().view().getTensorSettings().setIsLegacy(true)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>A simple scalar tensor containing the number "4".</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr x = Tsr.of(4)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>Tsr y = Tsr.of("th(I[0])", x)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>y.isBranch()
!y.isLeave()
y.belongsToGraph()
x.belongsToGraph()
y.toString().contains("[1]:(0.97014E0)")</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-1387689204'>
<span>A tensor produced by the static "Tsr.Create.newRandom(shape)" has expected "random" value.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>We are using the legacy view for tensors where bracket types are swapped, just because...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Neureka.get().settings().view().getTensorSettings().setIsLegacy(true)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Creating a simple shape array...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>int[] shape = new int[1]
shape[0] = 4</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>...and passing it to the "newRandom" factory method to produce tensor x...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr x = Tsr.ofRandom(Double, shape)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>...the newly created variable x is as expected!</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>x.toString().contains("[4]:(-1.04829E0, -0.40245E0, -0.04347E0, -1.4921E0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Again using the "andSeed" method with a long seed...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>x = Tsr.ofDoubles().withShape(shape).andSeed(106605040595L)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>...the newly created variable x is as expected!</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>x.toString().contains("[4]:(0.22266E0, 0.65678E0, -0.83154E0, 0.68019E0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Again using the "andSeed" method with a long seed and with float as data type...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>x = Tsr.ofFloats().withShape(shape).andSeed(106605040595L)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>...the newly created variable x is as expected!</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>x.toString().contains("[4]:(0.22266E0, 0.65678E0, -0.83154E0, 0.68019E0)")</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='643822857'>
<span>Tensor values can be manipulated via static method calls within the "Tsr.IO" class.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>We are using the legacy view for tensors where bracket types are swapped, just because...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Neureka.get().settings().view().getTensorSettings().setIsLegacy(true)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>Two tensors which will be used for testing IO.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>def t = Tsr.of([2, 2], [
        1.0d, 4.0d,
        2.0d, 7.0d,
])
def v = Tsr.of([2, 2], [
        1.0d, -1.0d,
        1.0d, -1.0d
])</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t += v</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(2.0, 3.0, 3.0, 6.0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t.setValueAt( 2, 6.0 as double )</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(2.0, 3.0, 6.0, 6.0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>int[] indices = new int[2]
indices[1] = 1
t.setValueAt(t.indexOfIndices(indices), -6.0 as double)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(2.0, -6.0, 6.0, 6.0)")
t.getValueAt(indices) ==-6.0d</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>indices[0] = 1
t[indices].timesAssign(-1d)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(2.0, -6.0, 6.0, -6.0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t[3].timesAssign(-2d)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(2.0, -6.0, 6.0, 12.0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t[indices] = 0d</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(2.0, -6.0, 6.0, 0.0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t[2] = 99d</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(2.0, -6.0, 99.0, 0.0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t[2].minusAssign(99d)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(2.0, -6.0, 0.0, 0.0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Modifying the first index of the indices array...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>indices[0] = 0</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>Using this new indices array for IO...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t[indices].minusAssign(-9d)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>The underlying data will have changed.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(2.0, 3.0, 0.0, 0.0)")</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t -= Tsr.of([2, 2], [1d, 2d, 3d, 4d])</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString().contains("[2x2]:(1.0, 1.0, -3.0, -4.0)")</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='881628368'>
<span>The tensor data array can be modified by targeting them with an index.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<pre class='block-source'>var t = Tsr.of(type).withShape(shape).andFill(data)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t.setDataAt( 1, element )</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.getDataAt( 1 ) == element</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<pre class='block-source'>t.data == expected</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t = Tsr.of(type).withShape(shape).andFill(data)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<pre class='block-source'>t.setValueAt( 1, element )</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.getValueAt( 1 ) == element</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<pre class='block-source'>t.data == expected</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Examples:</div>
</td>
<td>
<div class='spec-examples'>
<table class='ex-table'>
<thead>
<tr>
<th class='ex-header'>type</th>
<th class='ex-header'>shape</th>
<th class='ex-header'>data</th>
<th class='ex-header'>element</th>
<th class='ex-header'>expected</th>
</tr>
</thead>
<tbody>
<tr class='ex-pass'>
<td class='ex-value'>class java.lang.Float</td>
<td class='ex-value'>[2, 2]</td>
<td class='ex-value'>[-42.0, 24.0, 9.0, 3.0, -34.0]</td>
<td class='ex-value'>0.032</td>
<td class='ex-value'>[-42.0, 0.032, 9.0, 3.0]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>class java.lang.Double</td>
<td class='ex-value'>[2, 2]</td>
<td class='ex-value'>[-42.0, 24.0, 9.0, 3.0, -34.0]</td>
<td class='ex-value'>0.032</td>
<td class='ex-value'>[-42.0, 0.032, 9.0, 3.0]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>class java.lang.Byte</td>
<td class='ex-value'>[2, 2]</td>
<td class='ex-value'>[-42, 24, 9, 3, -34]</td>
<td class='ex-value'>1</td>
<td class='ex-value'>[-42, 1, 9, 3]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>class java.lang.Short</td>
<td class='ex-value'>[2, 2]</td>
<td class='ex-value'>[-42, 24, 9, 3, -34]</td>
<td class='ex-value'>1</td>
<td class='ex-value'>[-42, 1, 9, 3]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>class java.lang.Long</td>
<td class='ex-value'>[2, 2]</td>
<td class='ex-value'>[-42, 24, 9, 3, -34]</td>
<td class='ex-value'>1</td>
<td class='ex-value'>[-42, 1, 9, 3]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>class java.lang.Integer</td>
<td class='ex-value'>[2, 2]</td>
<td class='ex-value'>[-42, 24, 9, 3, -34]</td>
<td class='ex-value'>1</td>
<td class='ex-value'>[-42, 1, 9, 3]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>class java.lang.Boolean</td>
<td class='ex-value'>[2, 1]</td>
<td class='ex-value'>[false, true, false]</td>
<td class='ex-value'>false</td>
<td class='ex-value'>[false, false]</td>
<td class='ex-result'>OK</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>class java.lang.Character</td>
<td class='ex-value'>[2, 1]</td>
<td class='ex-value'>abc</td>
<td class='ex-value'>x</td>
<td class='ex-value'>ax</td>
<td class='ex-result'>OK</td>
</tr>
</tbody>
</table>
</div>
</td>
<td>
<div class='spec-status'>8/8 passed</div>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='1787019054'>
<span>Adding OpenCL device to tensor makes tensor be "outsourced" and contain the Device instance as component.</span>
<span style='float: right; font-size: 60%;'>
<a href='#toc'>Return</a>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>Neureka can access OpenCL (JOCL).</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Expect:</div>
</td>
<td>
<div class='block-text'>The following is to be expected with respect to the given :</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>The tensor is being added to the OpenCL device...</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>The now "outsourced" tensor has a reference to the device and vice versa!</div>
</td>
</tr>
</tbody>
</table>
<hr></hr>
<div class='footer'>Generated by <a href='https://github.com/renatoathaydes/spock-reports'>Athaydes Spock Reports</a></div>
</body>
</html>