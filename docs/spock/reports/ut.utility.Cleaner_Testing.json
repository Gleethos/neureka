{
  "className":"ut.utility.Cleaner_Testing",
  "title":"How Neureka Cleans Up",
  "narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role",
  "subjects":[],
  "statistics":{
    "runs":"1",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"0.391 seconds"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"The DeviceCleaner triggers registersd cleaner actions when things are eligable for GC.",
      "result":"PASS",
      "duration":"0.389 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["def cleaner = DeviceCleaner.getInstance()","def refCount = 10","def r1 =  Tsr.ofDoubles().withShape( 2, 4 ).all(0)","def r2 =  Tsr.ofDoubles().withShape( 2, 4 ).all(0)","def r3 =  Tsr.ofDoubles().withShape( 2, 4 ).all(0)","def r4 =  Tsr.ofDoubles().withShape( 2, 4 ).all(0)","def r5 =  Tsr.ofDoubles().withShape( 2, 4 ).all(0)","def r6 =  Tsr.ofDoubles().withShape( 2, 4 ).all(0)","def r7 =  Tsr.ofDoubles().withShape( 2, 4 ).all(0)","def r8 =  Tsr.ofDoubles().withShape( 2, 4 ).all(0)","def r9 =  Tsr.ofDoubles().withShape( 2, 4 ).all(0)","def r10 = Tsr.ofDoubles().withShape( 2, 4 ).all(0)","cleaner.register( r1, {refCount--} )","cleaner.register( r2, {refCount--} )","cleaner.register( r3, {refCount--} )","cleaner.register( r4, {refCount--} )","cleaner.register( r5, {refCount--} )","cleaner.register( r6, {refCount--} )","cleaner.register( r7, {refCount--} )","cleaner.register( r8, {refCount--} )","cleaner.register( r9, {refCount--} )","cleaner.register( r10,{refCount--} )"]},

        {"kind":"when","text":"","code":["r1 = null","r3 = null","System.gc()","Sleep.until(250, {","    refCount == 8 && cleaner._registered == 8","})","System.gc()","Sleep.until(250, {","    refCount == 8 && cleaner._registered == 8","})"]},

        {"kind":"then","text":"","code":["refCount == 8","cleaner._registered == 8"]},

        {"kind":"when","text":"","code":["r2 = null","r4 = null","System.gc()","Sleep.until(250, {","    refCount == 6 && cleaner._registered == 6","})","System.gc()","Sleep.until(250, {","    refCount == 6 && cleaner._registered == 6","})"]},

        {"kind":"then","text":"","code":["refCount == 6","cleaner._registered == 6"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}