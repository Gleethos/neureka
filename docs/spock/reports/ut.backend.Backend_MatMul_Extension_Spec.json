{
  "className":"ut.backend.Backend_MatMul_Extension_Spec",
  "statistics":{
    "runs":"3",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"0.073 seconds"
  },

  "title":"",
  "narrative":"",
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.",
      "result":"PASS",
      "duration":"0.061 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["BackendContext oldContext = Neureka.get().backend()","BackendContext testContext = oldContext.clone()"]},
        {"kind":"when","text":"","code":["def run = testContext.runner()"]},
        {"kind":"then","text":"","code":["run { testContext == Neureka.get().backend() }"]},
        {"kind":"when","text":"","code":["Tsr t1 = Tsr.of([row_sze, com_sze], -3d..8d)","Tsr t2 = Tsr.of([com_sze, col_sze], -7d..4d)","run {","                Neureka.get().backend()","                    .addOperation(","                            Operation","                                .builder()","                                .setIdentifier('test_function')","                                .setOperator('test_function')","                                .setArity(-1)","                                .setIsIndexer(false)","                                .setIsOperator(false)","                                .setIsDifferentiable(true)","                                .setIsInline(false)","                                .setStringifier(","                                        children -> {","                                            String expression = String.join(\", \", children);","                                            if (expression.charAt(0) == '(' && expression.charAt(expression.length() - 1) == ')') {","                                                return \"test_function\" + expression;","                                            }","                                            return \"test_function\" + \"(\" + expression + \")\";","                                        }","                                )","                                .build()","                                .setAlgorithm(","                                        DeviceAlgorithm.withName(\"my_algorithm\")","                                            .setIsSuitableFor(call -> SuitabilityPredicate.GOOD  )","                                            .setAutogradModeFor(call -> AutoDiffMode.BACKWARD_ONLY )","                                            .setDeviceExecution(","                                                (context, callback) -> AbstractDeviceAlgorithm.executeDeviceAlgorithm(context.call(), callback),","                                                (ADAgentSupplier){ Function f, ExecutionCall<? extends Device<?>> adCall, boolean forward ->","                                                    if (forward) throw new IllegalArgumentException(\"Reshape operation does not support forward-AD!\");","                                                    return ADAgent.withAD((t, error) -> new FunctionParser( Neureka.get().backend() ).parse(f.toString(), false).derive(new Tsr[]{error}, 0));","                                                }","                                            )","                                            .setCallPreparation(","                                                    call -> {","                                                         Device<?> device = call.getDevice();","                                                        if ( call.input( 0 ) == null ) // Creating a new tensor:","                                                        {","                                                            int[] shp = new int[]{call.input( 1 ).getNDConf().shape(0), call.input( 2 ).getNDConf().shape(1)}","                                                            Tsr output = Tsr.of(shp, 0.0);","                                                            output.setIsVirtual(false);","                                                            device.store( output );","                                                            call = call.withInputAt( 0, output );","                                                        }","                                                        return call;","                                                    }","                                            )","                                            .setImplementationFor(","                                                    CPU.class,","                                                    CPUImplementation","                                                        .withArity(3)","                                                        .andImplementation(","                                                            (call) -> {","                                                                Tsr drn = call.input(Number.class, 0)","                                                                Tsr src1 = call.input(Number.class, 1)","                                                                Tsr src2 = call.input(Number.class, 2)","                                                                assert src1.shape(1) == src2.shape(0)","","                                                                //for ( int i=0; i<clContext.getGws(); i++ ) {","                                                                //    kernel.gemm_template(","                                                                //            drn.getDataAs( float[].class ),                     //__global float[] drain,","                                                                //            drn.getNDConf().asInlineArray(),   //__global int[] drn_conf,","                                                                //            src1.getDataAs( float[].class ),                    //const __global float[] src1,","                                                                //            src1.getNDConf().asInlineArray(),  //__global int[] src1_conf,","                                                                //            src2.getDataAs( float[].class ),                    //const __global float[] src2,","                                                                //            src2.getNDConf().asInlineArray(),  //__global int[] src2_conf,","                                                                //            //call.getTsrOfType( Number.class, 0).rank(),//int rank, == 2","                                                                //            //-1, //const int d,","                                                                //            clContext.getMaxTSRow(),//128, //const u int max_ts_row,//  = 128, // ts := tile size","                                                                //            clContext.getMaxTSCol(),//128, //const u int max_ts_col,//  = 128,","                                                                //            clContext.getMaxTSCom(),//16, //const u int max_ts_com,//  = 16,","                                                                //            clContext.getMaxWPTRow(),//8, //const u int max_wpt_row,// = 8,   // wpt := work per thread","                                                                //            clContext.getMaxWPTCol()//8  //const u int max_wpt_col // = 8,","                                                                //    )","                                                                //    clContext.increment()","                                                                //}","                                                                return call.input(0)","                                                            }","                                                        )","                                            )","                                            .buildFunAlgorithm()","                                )","                )","            }","Function testFun = run { Function.of(\"test_function(I[0],I[1])\") }"]},
        {"kind":"then","text":"","code":["testFun.toString() == \"test_function(I[0], I[1])\""]},
        {"kind":"when","text":"","code":["Tsr t3 = run { testFun([t1, t2]) }"]},
        {"kind":"then","text":"","code":["t3 != null"]},
        {"kind":"and","text":"","code":["Neureka.get().backend() == oldContext"]},
        {"kind":"where","text":"","code":[]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"Test context mock for opencl reference implementations.",
      "result":"PASS",
      "duration":"0.001 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["def clContext = new CLContext(lws, rws, com_sze, row_sze, col_sze)"]},
        {"kind":"expect","text":"","code":["clContext.getMaxWPTCol()==wpt_col","clContext.getMaxWPTRow()==wpt_row","clContext.getMaxTSCom()==ts_com","clContext.getMaxTSCol()==ts_col","clContext.getMaxTSRow()==ts_row"]},
        {"kind":"where","text":"","code":[]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"Tile parsing for kernel parameter calculation yields expected tile dimensions.",
      "result":"PASS",
      "duration":"0.001 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"","code":["int[] result = DispatchUtility.parseTile( size, shape as int[] )"]},
        {"kind":"then","text":"","code":["result == expected as int[]"]},
        {"kind":"where","text":"","code":[]}
      ],
      "problems":"[]"
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}