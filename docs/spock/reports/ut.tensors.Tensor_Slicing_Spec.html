<!DOCTYPE html><html>
<head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'></meta>
<style>
body {
    font-family: Helvetica, Arial, sans-serif;
    font-weight: 300;
}

h2 {
    font-weight: 400;
}

hr {
    margin-bottom: 1.5em;
}

h3 {
    font-weight: 200;
}

table {
    margin: 7px;
    -webkit-box-shadow: 0px 0px 3px 1px rgba(0,0,0,0.75);
    -moz-box-shadow: 0px 0px 3px 1px rgba(0,0,0,0.75);
    box-shadow: 0px 0px 3px 1px rgba(0,0,0,0.75);
}

.ignored {
    color: gray;
}

div.project-header {
    margin-bottom: 10px;
    font-size: large;
}

div.project-header &gt; span.project-name {

                        }

div.project-header &gt; span.project-version {
                            padding-left: 20px;
                        }

div.date-test-ran {
    font-size: small;
    font-style: italic;
}

div.spec-title {
    padding: 10px 0px 5px 0px;
}

tr.error td, td.error {
    background-color: #F89A4F !important;
}

tr.failure td, td.failure {
    color: red;
}

div.footer {
    text-align: center;
    font-size: small;
}






.back-link {
    font-size: small;
    font-weight: bold;
}


div.date-test-ran {
    font-size: small;
    font-style: italic;
}

table.features-table {
    width: 99%;
    text-align: left;
}

table.summary-table {
    width: 99%;

    font-weight: bold;
    font-size: small;
}

table.summary-table tbody {
    width: 99%;
    text-align: left;
}

table.summary-table th {
    background: lightblue;
    padding: 6px;
}

table.summary-table td {
    background: #E0E0E0;
    padding: 6px;
}

pre.title {
    font-family: inherit;
    font-size: 24px;
    line-height: 28px;
    letter-spacing: -1px;
    color: #333;
}

pre.narrative {
    font-family: inherit;
    font-size: 18px;
    font-style: italic;
    line-height: 23px;
    letter-spacing: -1px;
    color: #333;
}

.feature-description {
    font-size: large;
    background: lightblue;
    padding: 12px;
}

.feature-toc-error {
    color: #F89A4F;
}

.feature-toc-failure {
    color: #FF8080;
}

.feature-toc-ignored {
    color: lightgray;
}

.feature-toc-pass {
    color: green;
}

.feature-description.error {
    background: #F89A4F;
}

.feature-description.failure {
    background: #FF8080;
}

.feature-description.ignored {
    background: lightgray;
}

.feature-description.ignored .reason {
    color: black;
    font-style: italic;
    font-size: small;
}

div.extra-info {
    font-size: small;
}

div.spec-headers {
    margin: 4px;
    font-style: italic;
}

div.spec-header {
}

div.issues {
    margin-top: 6px;
    padding: 10px 5px 5px 5px;
    background-color: lemonchiffon;
    color: black;
    font-weight: 500;
    font-size: small;
    max-width: 50%;
}

div.pending-feature {
    background-color: dodgerblue;
    color: white;
    margin-top: 6px;
    padding: 5px;
    text-align: center;
    font-size: small;
    max-width: 120px;
}

div.problem-description {
    padding: 10px;
    background: pink;
    border-radius: 10px;
}

div.problem-header {
    font-weight: bold;
    color: red;
}

div.problem-list {

}

table.ex-table{
    width: 98%;
}

table.ex-table th {
    background: lightblue;
    padding: 5px;
}

table.ex-table td {
    background: #E0E0E0;
    padding: 2px 5px 2px 5px;
}

table td {
    min-width: 50px;
}

col.block-kind-col {
    width: 70px;
}

span.spec-header {
    font-weight: bold;
}

div.spec-text {
    /*color: green;*/
}

div.spec-status {
    font-style: italic;
}

.ignored {
    color: gray;
}

td.ex-result {
    text-align: center;
    background: white !important;
}

.ex-pass {
    color: darkgreen;
}

.ex-fail {
    color: red;
    font-weight: bold;
}

div.block-kind {
    margin: 2px;
    font-style: italic;
}

div.block-text {

}

pre.block-source {
    background-color: whitesmoke;
    padding: 10px;
}

pre.block-source.error {
    background-color: pink;
    color: red;
    font-weight: bold;
}

pre.block-source.pre-error {

}

pre.block-source.before-error {
    margin-bottom: -14px;
}

pre.block-source.after-error {
    color: gray;
    margin-top: -14px;
}

pre.block-source.post-error {
    color: gray;
}

div.footer {
    text-align: center;
    font-size: small;
}</style>
</head>
<body>
<h2>Report for ut.tensors.Tensor_Slicing_Spec</h2>
<hr></hr>
<div class='back-link'>
<a href='index.html'>&lt;&lt; Back</a>
</div>
<div class='summary-report'>
<h3>Summary:</h3>
<div class='date-test-ran'>Created on Sun Jul 17 20:20:16 CEST 2022 by danie</div>
<table class='summary-table'>
<thead>
<tr>
<th>Executed features</th>
<th>Passed</th>
<th>Failures</th>
<th>Errors</th>
<th>Skipped</th>
<th>Success rate</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>9</td>
<td>9</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>100.0%</td>
<td>0.150 seconds</td>
</tr>
</tbody>
</table>
</div>
<pre class='title'>Tensors within Tensors</pre>
<pre class='narrative'>ND-Array data structures can be "sliced" in the sense
    that one can create a subset view of the underlying data inside a tensor
    through a new tensor instance...
    This can be a tedious and complicated procedure.
    Therefore a tensor should expose a various user friendly API for slicing which
    are also fit for various languages.
    This specification covers these APIs for tensor slicing.</pre>
<div class='spec-headers'>
<div class='spec-header'>
                <h2> Tensor Slicing </h2>
                <br> 
                <p>
                    This specification covers the behavior of tensors when being sliced 
                    on multiple different device types using the SliceBuilder API.           
                </p>
            </div>
</div>
<h3>Features:</h3>
<table class='features-table'>
<colgroup>
<col class='block-kind-col'></col>
<col class='block-text-col'></col>
</colgroup>
<tbody>
<ul id='toc'>
<li>
<a href='#-1339468049' class='feature-toc-pass'>When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly.</a>
</li>
<li>
<a href='#-166916304' class='feature-toc-pass'>The "at" method and the "from" / "to" methods can be mixed when slicing a tensor.</a>
</li>
<li>
<a href='#254493439' class='feature-toc-pass'>A tensor can be sliced by passing ranges in the form of primitive arrays.</a>
</li>
<li>
<a href='#1446002092' class='feature-toc-pass'>A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).</a>
</li>
<li>
<a href='#461524293' class='feature-toc-pass'>The slice builder also supports slicing with custom step sizes.</a>
</li>
<li>
<a href='#-1195738256' class='feature-toc-pass'>Slicing is also a Function with autograd support!</a>
</li>
<li>
<a href='#-1308669192' class='feature-toc-pass'>Normal slicing will try to do autograd.</a>
</li>
<li>
<a href='#-2027312032' class='feature-toc-pass'>We can avoid autograd when slicing by using the "detached" instead of the "get" method.</a>
</li>
<li>
<a href='#1049106806' class='feature-toc-pass'>We can slice a scalar tensor from a larger tensor of rank 4.</a>
</li>
</ul>
<tr>
<td colspan='10'>
<div class='feature-description' id='-1339468049'>
<span>When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly.</span>
<span class='return-toc'>
<a href='#toc'>Return</a>
<div class='ex-time'>(0.024 seconds)</div>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>A device could be found.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device == null ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The found device is also supported (Which might not always be the case for the OpenCLDevice).</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device instanceof OpenCLDevice &amp;&amp; !Neureka.get().canAccessOpenCLDevice() ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>A 3 dimensional tensor which will be sliced.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr&lt;Double&gt; t = Tsr.of([2, 4, 3], -3d..7d)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>Which will be placed on a given device:</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t.to(device)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Slicing axis 1 of the tensor using the "from" &amp; "to" methods...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr s = t.slice()
.axis(1).from(1).to(2)
.get()</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>This will result in a slice which has 4 axis entries less than the original tensor.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape().sum() == t.shape().sum() - 2</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>This new slice will be displayed as follows when printed (with adjusted indent):</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.toString().replace('\n', '\n'+" "*20) ==
"""(2x2x3):[
       [
          [   0.0 ,   1.0 ,   2.0  ],
          [   3.0 ,   4.0 ,   5.0  ]
       ],
       [
          [   1.0 ,   2.0 ,   3.0  ],
          [   4.0 ,   5.0 ,   6.0  ]
       ]
    ]"""</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>As already shown by the printed view, the tensor as the expected shape:</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape() == [2, 2, 3]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Where:</div>
</td>
<td>
<div class='block-text'>This works both on the GPU as well as CPU of course.</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Examples:</div>
</td>
<td>
<div class='spec-examples'>
<table class='ex-table'>
<thead>
<tr>
<th class='ex-header'>device</th>
</tr>
</thead>
<tbody>
<tr class='ex-pass'>
<td class='ex-value'>OpenCLDevice[deviceId=cl_device_id[0x18052922af0],platform=OpenCLPlatform@19cac930[pid=cl_platform_id[0x7ffb3c43a490],context=cl_context[0x1804bbac220],kernels=[..46..]]]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.022 seconds)</span>
</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>CPU[coreCount=32]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.002 seconds)</span>
</td>
</tr>
</tbody>
</table>
</div>
</td>
<td>
<div class='spec-status'>2/2 passed</div>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-166916304'>
<span>The "at" method and the "from" / "to" methods can be mixed when slicing a tensor.</span>
<span class='return-toc'>
<a href='#toc'>Return</a>
<div class='ex-time'>(0.008 seconds)</div>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>A device could be found.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device == null ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The found device is also supported (Which might not always be the case for the OpenCLDevice).</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device instanceof OpenCLDevice &amp;&amp; !Neureka.get().canAccessOpenCLDevice() ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>A 3 dimensional tensor which will be sliced.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr&lt;Double&gt; t = Tsr.of([3, 3, 4], -11d..3d)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>Which will be placed on a given device:</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t.to(device)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Slicing the tensor using both "at", "from"/"to" and an implicit full ranged slice for axis 1...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr s = t.slice()
.axis(0).at(1)
// Note: Axis 1 will be sliced implicitly if not specified!
.axis(2).from(1).to(2)
.get()</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>This will result in a slice which has 4 axis entries less than the original tensor.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape().sum() == t.shape().sum() - 4</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>This new slice will be displayed as follows when printed (with adjusted indent):</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.toString().replace('\n', '\n'+" "*20) ==
"""(1x3x2):[
       [
          [   2.0 ,   3.0  ],
          [  -9.0 ,  -8.0  ],
          [  -5.0 ,  -4.0  ]
       ]
    ]"""</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The "at" method sliced a single axis point whereas the "from" &amp; "to" sliced from 1 to 2.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape() == [1, 3, 2]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Where:</div>
</td>
<td>
<div class='block-text'>This works both on the GPU as well as CPU of course.</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Examples:</div>
</td>
<td>
<div class='spec-examples'>
<table class='ex-table'>
<thead>
<tr>
<th class='ex-header'>device</th>
</tr>
</thead>
<tbody>
<tr class='ex-pass'>
<td class='ex-value'>OpenCLDevice[deviceId=cl_device_id[0x18052922af0],platform=OpenCLPlatform@19cac930[pid=cl_platform_id[0x7ffb3c43a490],context=cl_context[0x1804bbac220],kernels=[..46..]]]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.006 seconds)</span>
</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>CPU[coreCount=32]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.002 seconds)</span>
</td>
</tr>
</tbody>
</table>
</div>
</td>
<td>
<div class='spec-status'>2/2 passed</div>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='254493439'>
<span>A tensor can be sliced by passing ranges in the form of primitive arrays.</span>
<span class='return-toc'>
<a href='#toc'>Return</a>
<div class='ex-time'>(0.010 seconds)</div>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>A device could be found.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device == null ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The found device is also supported (Which might not always be the case for the OpenCLDevice).</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device instanceof OpenCLDevice &amp;&amp; !Neureka.get().canAccessOpenCLDevice() ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>A 3 dimensional tensor which will be sliced.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr t = Tsr.of([3, 3, 4], -11..3)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>Which will be placed on a given device:</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t.to(device)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Slicing the tensor using primitive int arrays...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr s = t.getAt(
    new int[]{1},    // Axis 0
    new int[]{0, 2}, // Axis 1
    new int[]{1, 2}  // Axis 2
)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>This will result in a slice which has 4 axis entries less than the original tensor.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape().sum() == t.shape().sum() - 4</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>This new slice will be displayed as follows when printed (with adjusted indent):</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.toString().replace('\n', '\n'+" "*20) ==
"""(1x3x2):[
       [
          [   2.0 ,   3.0  ],
          [  -9.0 ,  -8.0  ],
          [  -5.0 ,  -4.0  ]
       ]
    ]"""</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The the slice will have the following shape</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape() == [1, 3, 2]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Where:</div>
</td>
<td>
<div class='block-text'>This works both on the GPU as well as CPU of course.</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Examples:</div>
</td>
<td>
<div class='spec-examples'>
<table class='ex-table'>
<thead>
<tr>
<th class='ex-header'>device</th>
</tr>
</thead>
<tbody>
<tr class='ex-pass'>
<td class='ex-value'>OpenCLDevice[deviceId=cl_device_id[0x18052922af0],platform=OpenCLPlatform@19cac930[pid=cl_platform_id[0x7ffb3c43a490],context=cl_context[0x1804bbac220],kernels=[..46..]]]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.003 seconds)</span>
</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>CPU[coreCount=32]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.007 seconds)</span>
</td>
</tr>
</tbody>
</table>
</div>
</td>
<td>
<div class='spec-status'>2/2 passed</div>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='1446002092'>
<span>A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).</span>
<span class='return-toc'>
<a href='#toc'>Return</a>
<div class='ex-time'>(0.008 seconds)</div>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>A device could be found.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device == null ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The found device is also supported (Which might not always be the case for the OpenCLDevice).</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device instanceof OpenCLDevice &amp;&amp; !Neureka.get().canAccessOpenCLDevice() ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>A 3 dimensional tensor which will be sliced.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr t = Tsr.of([3, 3, 4], -11..3)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>Which will be placed on a given device:</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t.to(device)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Slicing the tensor using lists of integers generated by the Groovy range operator..</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr s = t[1, 0..2, 1..2]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>This will result in a slice which has 4 axis entries less than the original tensor.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape().sum() == t.shape().sum() - 4</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>This new slice will be displayed as follows when printed (with adjusted indent):</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.toString().replace('\n', '\n'+" "*20) ==
"""(1x3x2):[
       [
          [   2.0 ,   3.0  ],
          [  -9.0 ,  -8.0  ],
          [  -5.0 ,  -4.0  ]
       ]
    ]"""</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The the slice will have the following shape</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape() == [1, 3, 2]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Where:</div>
</td>
<td>
<div class='block-text'>This works both on the GPU as well as CPU of course.</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Examples:</div>
</td>
<td>
<div class='spec-examples'>
<table class='ex-table'>
<thead>
<tr>
<th class='ex-header'>device</th>
</tr>
</thead>
<tbody>
<tr class='ex-pass'>
<td class='ex-value'>OpenCLDevice[deviceId=cl_device_id[0x18052922af0],platform=OpenCLPlatform@19cac930[pid=cl_platform_id[0x7ffb3c43a490],context=cl_context[0x1804bbac220],kernels=[..46..]]]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.005 seconds)</span>
</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>CPU[coreCount=32]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.003 seconds)</span>
</td>
</tr>
</tbody>
</table>
</div>
</td>
<td>
<div class='spec-status'>2/2 passed</div>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='461524293'>
<span>The slice builder also supports slicing with custom step sizes.</span>
<span class='return-toc'>
<a href='#toc'>Return</a>
<div class='ex-time'>(0.009 seconds)</div>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>A device could be found.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device == null ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The found device is also supported (Which might not always be the case for the OpenCLDevice).</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>if ( device instanceof OpenCLDevice &amp;&amp; !Neureka.get().canAccessOpenCLDevice() ) return</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>A 3 dimensional tensor which will be sliced.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr&lt;Double&gt; t = Tsr.of([3, 3, 4], -11d..3d)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>Which will be placed on a given device:</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>t.to(device)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Slicing the tensor using lists of integers generated by the Groovy range operator..</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>Tsr s = t.slice()
.axis(0).at(0)
.axis(1).at(0)
.axis(2).from(0).to(3).step(2)
.get()</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>This will result in a slice which has 4 axis entries less than the original tensor.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape().sum() == t.shape().sum() - 6</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>This new slice will be displayed as follows when printed (with adjusted indent):</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.toString() == """(1x1x2):[
   [
      [  -11.0,  -9.0  ]
   ]
]"""</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>The the slice will have the following shape</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.shape() == [1, 1, 2]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Where:</div>
</td>
<td>
<div class='block-text'>This works both on the GPU as well as CPU of course.</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Examples:</div>
</td>
<td>
<div class='spec-examples'>
<table class='ex-table'>
<thead>
<tr>
<th class='ex-header'>device</th>
</tr>
</thead>
<tbody>
<tr class='ex-pass'>
<td class='ex-value'>OpenCLDevice[deviceId=cl_device_id[0x18052922af0],platform=OpenCLPlatform@19cac930[pid=cl_platform_id[0x7ffb3c43a490],context=cl_context[0x1804bbac220],kernels=[..46..]]]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.006 seconds)</span>
</td>
</tr>
<tr class='ex-pass'>
<td class='ex-value'>CPU[coreCount=32]</td>
<td class='ex-result'>
<span>OK</span>
<span class='ex-time'>(0.003 seconds)</span>
</td>
</tr>
</tbody>
</table>
</div>
</td>
<td>
<div class='spec-status'>2/2 passed</div>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-1195738256'>
<span>Slicing is also a Function with autograd support!</span>
<span class='return-toc'>
<a href='#toc'>Return</a>
<div class='ex-time'>(0.039 seconds)</div>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<pre class='block-source'>var t = Tsr.ofBytes().withShape(4, 4).andFill(-1, 7, 3).setRqsGradient(true)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<pre class='block-source'>int[] newShape  = [2, 2]
int[] newOffset = [1, 1]
int[] newSpread = [1, 1]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>Tsr&lt;Object&gt; slice = Function.of("slice(I[0])", true)
.with(Arg.Shape.of(newShape),Arg.Offset.of(newOffset),Arg.Stride.of(newSpread))
.call(t)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>slice.toString() == "(2x2):[\n" +
"   [   3.0 ,  -1.0  ],\n" +
"   [  -1.0 ,   7.0  ]\n" +
"]"</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>slice.backward(-8)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString() == "(4x4):[\n" +
"   [  -1.0 ,   7.0 ,   3.0 ,  -1.0  ],\n" +
"   [   7.0 ,   3.0 ,  -1.0 ,   7.0  ],\n" +
"   [   3.0 ,  -1.0 ,   7.0 ,   3.0  ],\n" +
"   [  -1.0 ,   7.0 ,   3.0 ,  -1.0  ]\n" +
"]:g:[\n" +
"   [   0.0 ,   0.0 ,   0.0 ,   0.0  ],\n" +
"   [   0.0 ,  -8.0 ,  -8.0 ,   0.0  ],\n" +
"   [   0.0 ,  -8.0 ,  -8.0 ,   0.0  ],\n" +
"   [   0.0 ,   0.0 ,   0.0 ,   0.0  ]\n" +
"]"</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-1308669192'>
<span>Normal slicing will try to do autograd.</span>
<span class='return-toc'>
<a href='#toc'>Return</a>
<div class='ex-time'>(0.004 seconds)</div>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<pre class='block-source'>var t = Tsr.ofBytes().withShape(5).andFill(-1, 7, 3).setRqsGradient(true)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>var s = t[2..3]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<pre class='block-source'>s.backward(42)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString() == "(5):[  -1.0 ,   7.0 ,   3.0 ,  -1.0 ,   7.0  ]:g:[   0.0 ,   0.0 ,  42.0 ,  42.0 ,   0.0  ]"</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='-2027312032'>
<span>We can avoid autograd when slicing by using the "detached" instead of the "get" method.</span>
<span class='return-toc'>
<a href='#toc'>Return</a>
<div class='ex-time'>(0.005 seconds)</div>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<pre class='block-source'>var t = Tsr.ofBytes().withShape(4).andFill(-1, 7, 3).setRqsGradient(true)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t.slice()
.axis(0).from(0).to(1)
.detached()
.backward(73)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString() == "(4):[  -1.0 ,   7.0 ,   3.0 ,  -1.0  ]:g:[null]"</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<pre class='block-source'>t.slice()
.axis(0).from(0).to(1)
.get()
.backward(73)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<pre class='block-source'>t.toString() == "(4):[  -1.0 ,   7.0 ,   3.0 ,  -1.0  ]:g:[  73.0 ,  73.0 ,   0.0 ,   0.0  ]"</pre>
</td>
</tr>
<tr>
<td colspan='10'>
<div class='feature-description' id='1049106806'>
<span>We can slice a scalar tensor from a larger tensor of rank 4.</span>
<span class='return-toc'>
<a href='#toc'>Return</a>
<div class='ex-time'>(0.003 seconds)</div>
</span>
</div>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Given:</div>
</td>
<td>
<div class='block-text'>A 4 dimensional tensor.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>var t = Tsr.ofBytes().withShape(4, 2, 3, 2).andFill(-1, 7, 9, 5, 4, 3)</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>When:</div>
</td>
<td>
<div class='block-text'>Slicing the tensor using lists of integers...</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>var s = t[1, 1, 2, 0]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>Then:</div>
</td>
<td>
<div class='block-text'>The slice will contain only a single number, namely: 4.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.items == [4]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>We verify this through the "getItemAt" method.</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.items == [t.getItemAt(1, 1, 2, 0)]</pre>
</td>
</tr>
<tr>
<td>
<div class='block-kind'>And:</div>
</td>
<td>
<div class='block-text'>A variation of the previous verification (here we test 0 padding of getItemAt).</div>
</td>
</tr>
<tr>
<td></td>
<td>
<pre class='block-source'>s.items == [t.getItemAt(1, 1, 2)]</pre>
</td>
</tr>
</tbody>
</table>
<hr></hr>
<div class='footer'>Generated by <a href='https://github.com/renatoathaydes/spock-reports'>Athaydes Spock Reports</a></div>
</body>
</html>