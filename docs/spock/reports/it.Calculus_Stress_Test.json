{
  "className":"it.Calculus_Stress_Test",
  "statistics":{
    "runs":"5",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"0.702 seconds"
  },

  "title":"",
  "narrative":"",
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"Stress test runs error free and produces expected result",
      "result":"PASS",
      "duration":"0.167 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["def stress = ( Tsr t ) -> {","t = t + Tsr.of( t.shape(), -3d..12d )","t = t * Tsr.of( t.shape(),  2d..3d  )","t = t / Tsr.of( t.shape(),  1d..2d  )","t = t **Tsr.of( t.shape(),  2d..1d  )","t = t - Tsr.of( t.shape(), -2d..2d  )","return t","}"]},
        {"kind":"and","text":"","code":["Tsr source = Tsr.of( [3, 3, 3, 3], -1d ).to( device )"]},
        {"kind":"when","text":"","code":["source[1..2, 0..2, 1..1, 0..2] = Tsr.of( [2, 3, 1, 3], -4d..2d )","Tsr t = source[1..2, 0..2, 1..1, 0d..2d]"]},
        {"kind":"then","text":"","code":["t.toString() == Tsr.of( [2, 3, 1, 3], -4d..2d ).toString()"]},
        {"kind":"when","text":"","code":["t = stress(t)"]},
        {"kind":"then","text":"","code":["t.toString({it.hasSlimNumbers = true}) ==","\"(2x3x1x3):[\" +","\"198, -6.5, \" +","\"36, -2.5, \" +","\"2, 6.5, \" +","\"\" +","\"101, 0, \" +","\"15, 4, \" +","\"146, 13, \" +","\"\" +","\"400, 17, \" +","\"194, 15.5, \" +","\"101, -4.5\" +","\"]\""]},
        {"kind":"and","text":"","code":["(device instanceof OpenCLDevice) || t.unsafe.data == [198.0, -6.5, 36.0, -2.5, 2.0, 6.5, 101.0, 0.0, 15.0, 4.0, 146.0, 13.0, 400.0, 17.0, 194.0, 15.5, 101.0, -4.5]","(device instanceof OpenCLDevice) || source.unsafe.data == [-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -4.0, -3.0, -2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 0.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 2.0, -4.0, -3.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0, -1.0, 0.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 2.0, -4.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -3.0, -2.0, -1.0, -1.0, -1.0, -1.0]"]},
        {"kind":"where","text":"","code":[]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"Dot operation stress test runs error free and produces expected result",
      "result":"PASS",
      "duration":"0.022 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["Tsr<Double> t = Tsr.of( shape, -4d..2d )"]},
        {"kind":"when","text":"","code":["t = t.convDot( t.T() )"]},
        {"kind":"then","text":"","code":["t.toString() == expected"]},
        {"kind":"where","text":"","code":[]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"The broadcast operation stress test runs error free and produces expected result",
      "result":"PASS",
      "duration":"0.044 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["Tsr<Double> t1 = Tsr.of( shape1, -4d..2d ).to( device )","Tsr<Double> t2 = Tsr.of( shape2, -3d..5d ).to( device )"]},
        {"kind":"when","text":"","code":["Tsr t = Tsr.of( operation, [t1,t2] )"]},
        {"kind":"then","text":"","code":["t.toString() == expected"]},
        {"kind":"where","text":"","code":[]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.",
      "result":"PASS",
      "duration":"0.308 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a function based on the provided expression.","code":["var func = Function.of(funExpression)"]},
        {"kind":"and","text":"We use a large prime number to size our tensors in order to stress workload divisibility.","code":["var PRIME_SIZE_1 = 7907","var PRIME_SIZE_2 = 7919"]},
        {"kind":"and","text":"We create 2 tensors storing the same values, one sliced and the other a normal tensor.","code":["var t1 = Tsr.of(type).withShape(PRIME_SIZE_1).andSeed(\"Tempeh\")","var t2 = Tsr.of(type).withShape(PRIME_SIZE_2).all(0)[9..7915]","t2[0..t2.size-1] = t1"]},
        {"kind":"expect","text":"The types of both tensors should match what was provided during instantiation.","code":["t1.dataType == DataType.of(type)","t1.itemClass == type","t2.dataType == DataType.of(type)","t2.itemClass == type"]},
        {"kind":"when","text":"We apply the function to both tensors...","code":["var result1 = func(t1)","var result2 = func(t2)"]},
        {"kind":"then","text":"First we ensure that both tensors have the correct value/element type.","code":["result1.itemClass == type","result2.itemClass == type"]},
        {"kind":"and","text":"The underlying data object should match the data array type as is defined by the data type!","code":["result1.unsafe.data.class == result1.dataType.dataArrayType()","result2.unsafe.data.class == result2.dataType.dataArrayType()"]},
        {"kind":"and","text":"The data of the first non slice tensor as well as its slice should be as expected.","code":["Arrays.hashCode(result1.unsafe.data) == expected[0]","Arrays.hashCode(result2.unsafe.data) == expected[1]"]},
        {"kind":"where","text":"","code":[]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"Activation functions work across types.",
      "result":"PASS",
      "duration":"0.034 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a function based on the provided expression.","code":["var func = Function.of(funExpression)"]},
        {"kind":"and","text":"We use a large prime number to size our tensors in order to stress workload divisibility.","code":["var PRIME_SIZE_1 = 3","var PRIME_SIZE_2 = 5"]},
        {"kind":"and","text":"We create 2 tensors storing the same values, one sliced and the other a normal tensor.","code":["var t1 = Tsr.of(type).withShape(PRIME_SIZE_1).andSeed(\"Seitan\")","var t2 = Tsr.of(type).withShape(PRIME_SIZE_2).all(0)[1..3]","t2[0..t2.size-1] = t1"]},
        {"kind":"expect","text":"The types of both tensors should match what was provided during instantiation.","code":["t1.dataType   == DataType.of(type)","t1.itemClass == type","t2.dataType   == DataType.of(type)","t2.itemClass == type"]},
        {"kind":"when","text":"We apply the function to both tensors...","code":["var result1 = ( !derive ? func(t1) : func.derive([t1], 0) )","var result2 = ( !derive ? func(t2) : func.derive([t2], 0) )"]},
        {"kind":"then","text":"First we ensure that both tensors have the correct value/element type.","code":["result1.itemClass == type","result2.itemClass == type"]},
        {"kind":"and","text":"The underlying data object should match the data array type as is defined by the data type!","code":["result1.unsafe.data.class == result1.dataType.dataArrayType()","result2.unsafe.data.class == result2.dataType.dataArrayType()"]},
        {"kind":"and","text":"The data of the first non slice tensor as well as its slice should be as expected.","code":["result1.items == expected","result2.items == expected"]},
        {"kind":"where","text":"","code":[]}
      ],
      "problems":"[]"
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}