{"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":77},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":960},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":234},"title":"Cross Device Tensor Slicing","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":14862},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":625},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3701},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":84},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":362},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":157},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":226},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because GraphNode instances of input tensors do not share the same GraphLock.","GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd.","GraphNode throws an exception when trying to instantiate it with the wrong context.","GraphNode throws exception when payload is null.","GraphNode throws exception when trying to instantiate it with the Function argument being null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":368},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Unit_Tests":{"executedFeatures":["GraphNode instantiation works as expected when the context argument is a GraphLock.","GraphNode instantiation works as expected when the context argument is an ExecutionCall."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":30},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":263},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Lambda properties of mock implementation interact with FunctionNode as expected.","Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":205},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":177},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":42},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3343},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":61},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":49},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":25},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":87},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":58},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":94},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":42},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":718},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":60},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":193},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":206},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":227},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":89},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":67},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":31},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":28},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":426},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3224},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":13},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":62},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":261},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":84},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":3},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":8055},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":42},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":132},"title":"","narrative":""},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":44},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":40},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":65},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":53},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":230},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1895},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":843},"title":"","narrative":""},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":9},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":29},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":95},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":371},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10768},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":34},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":38},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":706},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":256},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registersd cleaner actions when things are eligable for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":856},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":1008},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":13},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":449},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6097},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":397},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":364},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":75},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":183},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":119},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":359},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":8,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":0,"successRate":0.0,"time":6033},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":45},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1603},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":80},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":37},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":247},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9618},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":0,"successRate":0.0,"time":81},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":156},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":3,"successRate":0.6,"time":149},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":514},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":578},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":111},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":66},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":0,"successRate":0.0,"time":432},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":7,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":2,"successRate":0.2222222222222222,"time":928},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":4,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":1,"successRate":0.2,"time":2668},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.internal.GraphNode_Instantiation_Unit_Tests":{"executedFeatures":["GraphNode instantiation works as expected when the context argument is an ExecutionCall."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":0,"successRate":0.0,"time":1098},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":319},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":416},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":84},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":170},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":13},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":46},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":176},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":42},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":3,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":2,"successRate":0.4,"time":2057},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":0,"successRate":0.0,"time":571},"title":"Cross Device Tensor Slicing","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2049},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":103},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1186},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4201},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":132},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":1137},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1992},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":310},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":8998},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":21},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":57},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":4,"successRate":0.6666666666666666,"time":519},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":703},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":0,"successRate":0.0,"time":891},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock implementation interacts with FunctionNode as expected.","Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2111},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":280},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":494},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":10469},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":68},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":53},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":114},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":409},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":322},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5132},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1184},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":101},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":84},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":178},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":104},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":9,"successRate":0.8181818181818182,"time":13233},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":26187},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":618},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":72},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":68},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":61},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":35},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":88},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":101},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":267},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":725},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":8,"successRate":0.8,"time":1654},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":243},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":1,"successRate":1.0,"time":236},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5341},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":27},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1053},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":74},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":32},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":194},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6782},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":252},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":133},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":88},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":224},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":27},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":121},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":84},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10897},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":77},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":82},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":158},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":526},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":499},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":73},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":74},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":240},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3445},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":163},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1430},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4758},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":341},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5833},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":149},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":216},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":398},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.internal.GraphNode_Instantiation_Unit_Tests":{"executedFeatures":["GraphNode instantiation works as expected when the context argument is an ExecutionCall."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":0,"successRate":0.0,"time":1523},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":223},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":313},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":57},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":168},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":63},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":164},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3043},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":528},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":222},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":190},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":115},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":142},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":157},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":607},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1854},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":3378},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9490},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1366},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":164},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":6148},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":30},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":27},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":53},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":466},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":732},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":3802},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":435},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":184},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":238},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":14276},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":27589},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":570},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock implementation interacts with FunctionNode as expected.","Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":653},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":91},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":232},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6107},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":33},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":77},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":399},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":168},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":251},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":126},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":4435},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":290},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":321},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":139},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":147},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":81},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4863},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1840},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":236},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":221},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":42},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":99},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":23},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1317},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":374},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2841},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2573},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":63},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":29},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":140},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":498},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":228},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":234},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":206},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":141},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":71},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":129},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":701},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":355},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1866},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":4650},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1207},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8120},"title":"Cross Device Tensor Slicing","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":90},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":163},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":604},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":615},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":144},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":60},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":215},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":159},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17014},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":45},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":73},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":530},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":681},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11997},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":201},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1622},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":35},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":252},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3102},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":146},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10749},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":163},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":237},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":974},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":275},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7258},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":34},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":64},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":365},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":182},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":28392},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":612},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":145},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":55},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":45},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":97},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":42},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":9599},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2119},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4527},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":265},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":147},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":178},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":16},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":44},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":128},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":32},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":870},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":534},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":505},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":2781},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":119},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":78},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5790},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6729},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":60},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":70},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":332},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":294},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":834},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":213},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":169},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":148},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":196},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":935},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":440},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1437},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":3911},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7589},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":138},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":206},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":374},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2194},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":146},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1045},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3262},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":137},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3589},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1365},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":207},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":12157},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":76},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":29},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":96},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":674},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":856},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4111},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":115},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":893},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":183},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":534},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":10805},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":53},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":70},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":238},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":583},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":318},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12945},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":62},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":642},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":137},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":83},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":151},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":92},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":1,"errors":1,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":9,"successRate":0.8181818181818182,"time":12916},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":31850},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":113},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":49},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":92},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":28},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":66},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":56},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":32},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":1,"errors":1,"skipped":0,"totalRuns":1,"totalFeatures":11,"passed":0,"successRate":0.0,"time":4818},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":1,"errors":1,"skipped":0,"totalRuns":1,"totalFeatures":11,"passed":0,"successRate":0.0,"time":4662},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":1,"errors":1,"skipped":0,"totalRuns":1,"totalFeatures":11,"passed":0,"successRate":0.0,"time":4726},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":11,"passed":1,"successRate":1.0,"time":4319},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":11,"passed":1,"successRate":1.0,"time":4302},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":11,"passed":1,"successRate":1.0,"time":4362},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":153},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":270},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":545},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1507},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":16},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":128},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":46},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2172},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7607},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":542},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":189},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":287},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":32},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":55},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":132},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":30},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":6464},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":27},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3930},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":79},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":268},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":323},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":639},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":233},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":176},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":149},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":154},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":874},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":329},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1851},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":3712},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2844},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":154},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":338},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":2,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":3,"successRate":0.6,"time":2202},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2488},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":117},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1166},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3639},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":175},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2703},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1330},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":225},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":10960},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":50},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":42},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":127},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":666},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":985},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9185},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":184},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":0,"successRate":0.0,"time":1170},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":223},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":482},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":9846},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":55},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":135},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":479},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":285},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10186},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":187},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":581},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":141},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":97},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":197},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":82},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":13844},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":30887},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":151},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":112},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":28},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":65},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":49},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":33},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":237},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":1,"successRate":1.0,"time":334},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":186},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":257},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":528},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1869},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":140},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":103},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1120},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8491},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":389},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":163},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":176},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":55},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":141},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":27},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":75},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5771},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4047},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":39},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":41},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":189},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":138},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":858},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":306},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":195},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":129},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":147},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":913},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":407},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1220},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":3648},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2888},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":195},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":283},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3266},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2121},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":130},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1130},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3372},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":195},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2497},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1369},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":208},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":11486},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":61},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":35},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":102},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":643},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":917},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10924},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":139},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1231},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":236},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":429},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":9338},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":45},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":50},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":121},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":497},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":278},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12890},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":66},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":627},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":151},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":101},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":165},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":72},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":1,"errors":1,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":9,"successRate":0.8181818181818182,"time":13186},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":31173},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":619},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":61},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":80},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":31},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":96},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":16},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":67},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":37},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":1,"errors":1,"skipped":0,"totalRuns":1,"totalFeatures":11,"passed":0,"successRate":0.0,"time":4467},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":11,"passed":1,"successRate":1.0,"time":4351},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5885},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":56},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2037},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":81},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":55},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":320},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":79},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":238},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":158},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":195},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":151},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":286},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1378},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":549},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1868},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":4397},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1805},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7265},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":753},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":296},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":399},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":47},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":24},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":105},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":222},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":65},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":112},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":378},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1205},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1179},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":2740},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":32},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":211},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":139},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2085},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1948},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":365},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":9931},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":43},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":30},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":89},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":583},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":858},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7376},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":269},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":449},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":666},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1887},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":121},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":935},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3536},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":159},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":914},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":305},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2066},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":371},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":852},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":12016},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":117},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":64},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":146},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":622},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":275},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11792},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":95},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":719},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":134},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":83},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":234},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":85},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":13560},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":29241},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":602},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":44},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":88},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":35},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":95},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":52},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":33},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":67},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":96},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":340},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":476},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1901},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":127},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":138},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":325},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":8260},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":419},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":300},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":98},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":146},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":54},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2211},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":277},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":317},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2141},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":76},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":57},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":265},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2136},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":487},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2409},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2691},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":120},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1150},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3756},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":183},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1292},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3588},"title":"Cross Device Tensor Slicing","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":377},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":388},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":284},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":84},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":219},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1098},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":510},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1313},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2510},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":689},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":3054},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":266},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":597},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":12851},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":69},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":64},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":287},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":629},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":318},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13152},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":328},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":282},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":7916},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":30},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":33},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":79},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":650},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":900},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":607},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":2839},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":214},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":84},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":179},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":91},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":18291},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":33166},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":709},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":200},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":208},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":60},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":133},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":47},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":136},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":32},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1320},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6042},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":359},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":150},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":226},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":47},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":114},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":34},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":237},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":474},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":522},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3069},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":74},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":57},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5700},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9411},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":59},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":193},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":70},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":217},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":147},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":182},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":116},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":272},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1201},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":549},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1544},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":8099},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1481},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1005},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":134},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":12206},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":41},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":29},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":81},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":604},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":828},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8427},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":184},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":438},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":689},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2045},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":103},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1121},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3699},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":126},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9733},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":143},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1481},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":232},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":518},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":10254},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":47},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":110},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":469},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":293},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13404},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":68},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":643},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":116},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":125},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":199},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":88},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":12638},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":32388},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":586},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":45},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":74},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":29},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":64},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":52},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":31},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":781},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":200},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":246},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":409},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":30},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":123},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":505},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5199},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":524},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":289},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":72},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":116},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":70},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":97},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":345},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1038},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1028},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":2076},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":41},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":251},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":97},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":532},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3251},"title":"Cross Device Tensor Slicing","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":228},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":236},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":264},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":78},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":271},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1221},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":599},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1181},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2107},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2709},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":526},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":571},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2296},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":113},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1247},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3055},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":130},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9687},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":195},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":259},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5919},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":27},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":71},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":541},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":719},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":574},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2001},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":281},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":708},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":10097},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":55},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":52},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":133},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":729},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":249},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":772},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1817},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":284},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":233},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":281},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":257},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":13278},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":25523},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":588},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":137},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":170},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":112},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":36},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":114},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5950},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":744},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":48},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":45},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":132},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1512},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7240},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":343},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":127},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":142},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":46},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":115},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":34},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":377},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":390},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":571},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4138},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":70},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":56},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":339},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":344},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":183},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":121},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":137},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":267},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":787},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":331},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1018},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":3473},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1827},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":994},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":125},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":9695},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":40},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":25},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":109},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":579},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":874},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8794},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":167},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":230},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":258},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1544},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":67},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":809},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of devices such as `CPU`, `GPU`, `TPU`, `FPGA`, `OpenCLDevice`, `FileDevice` etc.\n    These various types of devices can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3440},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":119},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9025},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":141},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1180},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":172},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":405},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":8622},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":50},"title":"","narrative":""},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":71},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":95},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":391},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":274},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9776},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":96},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":534},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":118},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":81},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":155},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which should be able to store and load tensors as files (idx, jpg, png...)."},"ut.optimization.RMSprop_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":67},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":12163},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":28547},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":111},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":84},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":35},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":57},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["Passing String seed to tensor produces expected values.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated based on lists for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":33},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4907},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1467},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":35},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":29},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":163},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1389},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6614},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":268},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":150},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":163},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":16},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":11},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":75},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":109},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":35},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":322},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":855},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":833},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3642},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":105},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":85},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":126},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":578},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":365},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":299},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":97},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":135},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":850},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":306},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1107},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":3974},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2644},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":897},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":163},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":10441},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":29},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":22},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":71},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":537},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":719},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8906},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":270},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":295},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":430},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1667},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":76},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":773},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3158},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":112},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9843},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":191},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":970},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":231},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":477},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":8149},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":34},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":43},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":98},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":439},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":229},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11639},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":114},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":504},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":130},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":70},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":238},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":100},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":11765},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":26232},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":574},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":52},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":76},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":56},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":31},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":398},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6144},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":345},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":575},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":86},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":201},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":127},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":168},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":261},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":792},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":772},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1928},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":102},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":46},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4949},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":188},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":235},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":2510},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":56},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":214},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":823},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2089},"title":"Cross Device Tensor Slicing","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":272},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":292},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":115},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":61},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":223},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":805},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":346},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1300},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2937},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3413},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":638},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3999},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1916},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":83},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":888},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2837},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":143},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1364},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2248},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":375},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":584},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":9591},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":56},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":45},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":127},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":464},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":289},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11967},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":169},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":136},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5745},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":27},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":66},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":515},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":667},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":788},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":2678},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":334},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":193},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":185},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":187},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":13547},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":27128},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":590},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":183},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":168},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":48},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":113},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":35},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":119},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":3326},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":2977},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":48478},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":1,"successRate":1.0,"time":116133},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":1,"successRate":1.0,"time":3341},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1108},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6783},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":291},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":141},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":163},"title":"","narrative":""},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":16},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"","narrative":""},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":40},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":102},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":27},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4768},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3988},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":239},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":206},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":993},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1252},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3688},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":89},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":63},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":57},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":189},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":136},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":243},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":204},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":133},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1092},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":595},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1686},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":5750},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8727},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":117},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":195},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":429},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1906},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":86},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":881},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2984},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":119},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2311},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1400},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":167},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":10734},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":34},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":23},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":82},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":594},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":668},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11412},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":148},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":863},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":165},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":322},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":8050},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":31},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":39},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":100},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":411},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":237},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11713},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":165},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":420},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":81},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":71},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":180},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":60},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":11703},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":24558},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":576},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":79},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":28},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":71},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":48},"title":"","narrative":""},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":38},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":2,"passed":1,"successRate":1.0,"time":3222},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":60},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1046},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":150},"title":"Cross Device Tensor Slicing","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":17642},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":212},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2006},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":79},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":216},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":101},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":121},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":186},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":156},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":69},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":78},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":133},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":93},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1316},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":44},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":54},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":29},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":121},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":337},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":86},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":145},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":216},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":207},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4261},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2380},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":46},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5566},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":50},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":28},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":141},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":581},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1385},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":10},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":29},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":341},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8164},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":25},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":25},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type nnd data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":388},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":186},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":246},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":512},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":56},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1046},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":158},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":234},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2029},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":102},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":180},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":103},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":120},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":188},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":157},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":65},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":82},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":141},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":94},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1325},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":40},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":55},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":30},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":123},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":311},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":90},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":159},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":254},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":47},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":231},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4167},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2358},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":33},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":24},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":50},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5590},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":51},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":38},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":141},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":626},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":13},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1369},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":31},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":363},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8191},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":31},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":424},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":176},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":251},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":504},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":60},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":676},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":129},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":215},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1962},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":42},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":141},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":106},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":122},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":163},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":152},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":66},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":72},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":130},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":88},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1265},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":38},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":27},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":91},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":339},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":83},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":82},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":207},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":202},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4230},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2366},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":51},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5531},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":49},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":38},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":141},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":595},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":13},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1339},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":10},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":31},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":365},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8202},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":29},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":31},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":448},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":223},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":262},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":469},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":59},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":731},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":128},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":210},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2030},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":50},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":209},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":98},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":127},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":167},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":155},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":64},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":70},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":130},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1288},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":42},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":30},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":22},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":107},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":338},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":76},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":76},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":237},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":52},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":57},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":226},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4283},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2433},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":32},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":46},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":3},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5646},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":48},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":38},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":146},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":607},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1393},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":8},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":29},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":374},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8331},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":31},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":382},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":173},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":248},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":473},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":61},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":707},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":125},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":227},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1933},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":42},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":150},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":115},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":117},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":163},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":146},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":68},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":69},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":146},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":81},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1320},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":39},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":28},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":96},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":364},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":79},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":81},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":203},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":39},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":219},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4243},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2352},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":48},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":3},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5562},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":49},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":22},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":40},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":142},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":585},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":13},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1381},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":10},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":33},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":371},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":7986},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":28},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":399},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":190},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":243},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":470},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":57},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":660},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":120},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":219},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2034},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":138},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":110},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":438},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":161},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":166},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":66},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":69},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":125},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":79},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1330},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":27},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":38},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":29},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":95},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":334},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":77},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":91},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":225},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":207},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4253},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2394},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":45},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5753},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":51},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":19},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":35},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":141},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":603},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":15},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1411},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":11},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":29},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":370},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8332},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":27},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":387},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":166},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":245},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":468},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":2971},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":0,"successRate":0.0,"time":3003},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":2914},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":2993},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":2928},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":0,"successRate":0.0,"time":2926},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":0,"successRate":0.0,"time":2969},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":2918},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":2947},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":2923},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":0,"successRate":0.0,"time":2973},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":0,"successRate":0.0,"time":3036},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":2914},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":64},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":704},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":127},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":230},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1956},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":48},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":143},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":105},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":118},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":166},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":155},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":68},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":72},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":130},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1326},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":29},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":93},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":312},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":77},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":78},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":208},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":36},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":225},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4262},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2309},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":34},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":48},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5565},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":50},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":19},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":19},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":38},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":142},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":582},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1378},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":31},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":357},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":7990},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":31},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":31},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":383},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":191},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":245},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":470},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":58},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":664},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":125},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":229},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1899},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":43},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":141},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":100},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":120},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":173},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":158},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":66},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":71},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":136},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":79},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1308},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":27},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":22},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":98},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":348},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":95},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":91},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":207},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":39},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":221},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4214},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2434},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":34},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":22},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":47},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5508},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":51},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":19},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":39},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":136},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":581},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":13},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1384},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":30},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":349},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8010},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":29},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":372},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":165},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":237},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":457},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":16548},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":69},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":713},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":134},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":232},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2082},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":47},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":355},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":93},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":123},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":170},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":157},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":63},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":75},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":122},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":78},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1401},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":14},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":39},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":27},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":30},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":23},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":96},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":340},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":77},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":79},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":230},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":404},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4371},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2327},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":34},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":21},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":51},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5737},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":50},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":39},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":142},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":801},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":15},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1342},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":30},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":358},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8425},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":31},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":31},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":388},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":199},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":256},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":497},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":58},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":669},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":126},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":227},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1955},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":282},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":14},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":103},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":119},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":169},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":157},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":64},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":68},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":137},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":84},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1292},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":27},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":39},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":31},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":23},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":96},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":336},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":77},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":84},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":206},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":213},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4320},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2461},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":30},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":22},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":47},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":3},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5789},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":49},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":36},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":142},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":603},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":15},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1457},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":31},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":361},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8450},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":30},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":28},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":395},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":176},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":260},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":480},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":8,"passed":1,"successRate":1.0,"time":2992},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":1,"successRate":1.0,"time":3602},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":1,"successRate":1.0,"time":14286},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":1,"successRate":1.0,"time":2932},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":1,"successRate":1.0,"time":2976},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":63},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":250},"title":"Cross Device Tensor Slicing","narrative":""},"it.Cross_Device_Spec":{"executedFeatures":["A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","Convolution can model matrix multiplications across devices.","Cross device system test runs successfully.","Mapping tensors works for every device (even if they are not used).","Test simple NN implementation with manual backprop"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5574},"title":"Cross Device Stress Test Specification","narrative":"This specification is pretty much a system test which covers\n    the behavior of the library as a whole across multiple devices!\n    No matter which device is being used for a given stress test, the result should be the same..."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":264},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1583},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":49},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":114},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":121},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":108},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":169},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":153},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":62},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":71},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":115},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1255},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":33},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":40},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":32},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":23},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":71},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":427},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":69},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":147},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel."],"ignoredFeatures":["The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":2,"totalFeatures":3,"passed":2,"successRate":1.0,"time":90},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":[],"ignoredFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"stats":{"failures":0,"errors":0,"skipped":4,"totalRuns":0,"totalFeatures":4,"passed":0,"successRate":1.0,"time":2},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":[],"ignoredFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"stats":{"failures":0,"errors":0,"skipped":8,"totalRuns":0,"totalFeatures":8,"passed":0,"successRate":1.0,"time":4},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":[],"ignoredFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"stats":{"failures":0,"errors":0,"skipped":5,"totalRuns":0,"totalFeatures":5,"passed":0,"successRate":1.0,"time":0},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":33},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":23},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":55},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":["OpenCL related library objects adhere to the same toString formatting convention!"],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":5,"totalFeatures":6,"passed":5,"successRate":1.0,"time":5446},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":52},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":13},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":24},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":40},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":143},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods"],"stats":{"failures":0,"errors":0,"skipped":3,"totalRuns":2,"totalFeatures":5,"passed":2,"successRate":1.0,"time":136},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":15},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1385},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":3,"totalFeatures":4,"passed":3,"successRate":1.0,"time":7},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":19},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":24},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":206},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":7891},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":17},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":25},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":179},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation."],"ignoredFeatures":["Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":3,"totalFeatures":4,"passed":3,"successRate":1.0,"time":193},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":238},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":504},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":0,"successRate":0.0,"time":1003},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":1,"successRate":1.0,"time":3387},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":58},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":690},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":127},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":217},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1928},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":165},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":100},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":125},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":164},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":158},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":67},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":69},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":135},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":100},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1307},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":27},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":39},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":29},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":99},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":335},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":76},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":83},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":222},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":209},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4196},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2509},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":29},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":47},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5697},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":54},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":37},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":151},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":594},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1289},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":37},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":322},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":7821},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":30},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":410},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":186},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":251},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":466},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":0,"successRate":0.0,"time":3160},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":0,"successRate":0.0,"time":3185},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":0,"successRate":0.0,"time":3156},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":1,"successRate":1.0,"time":3127},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":61},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":693},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":127},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":216},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1951},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":39},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":293},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":94},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":118},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":175},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":63},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":130},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":83},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1290},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":29},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":95},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":349},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":27},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":89},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":94},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":228},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":44},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":202},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4423},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2524},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":22},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":50},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6108},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":55},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":35},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":158},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":614},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1432},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":39},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":348},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8373},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":29},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":31},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":422},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":201},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":239},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":484},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":0,"successRate":0.0,"time":3289},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":1,"successRate":1.0,"time":3202},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":63},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":758},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":145},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":235},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1910},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":72},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":271},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":110},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":126},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":164},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":161},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":66},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":71},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":149},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":84},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1290},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":55},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":23},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":133},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":370},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":85},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":91},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":229},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":212},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4190},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2455},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":32},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.NDA_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":51},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5675},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":56},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":19},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":36},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":169},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":589},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1341},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":33},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":331},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":7804},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":31},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":392},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":191},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":233},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":479},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["can mutate an ND-Array"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":135},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["An ND-Array can be mutated using the \"at(..).set(..)\" methods.","An ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":147},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A rank 2 ND-Array can be mutated using the \"set\" method.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":185},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A rank 2 ND-Array can be mutated using the \"set\" method.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":191},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":1,"successRate":1.0,"time":184},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":1,"successRate":1.0,"time":177},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":208},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":179},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":2,"passed":0,"successRate":0.0,"time":172},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":105},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":20},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":617},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":135},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":230},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1896},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":235},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":99},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":126},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":160},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":70},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":88},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":135},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":101},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1315},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":42},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":30},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":23},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":95},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":343},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":79},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":82},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":213},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":230},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4210},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2527},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":30},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":2,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":2,"successRate":0.5,"time":15},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":51},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5823},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":62},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":7,"successRate":0.875,"time":42},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":163},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":620},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1343},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":10},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":35},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":375},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8172},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":30},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":28},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":415},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":203},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":277},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":3,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":3,"successRate":0.5,"time":475},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":60},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":681},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":127},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":211},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1972},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":197},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":107},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":118},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":166},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":156},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":64},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":71},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":139},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":89},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1268},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":38},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":28},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":105},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":328},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":77},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":84},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":205},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":209},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4151},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2498},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":2,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":2,"successRate":0.5,"time":14},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":3},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":52},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5684},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":51},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":18},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":34},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":152},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":598},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1336},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":10},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":18},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":32},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":331},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8104},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":29},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":29},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":402},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":180},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":275},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":3,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":3,"successRate":0.5,"time":539},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":839},"title":"","narrative":""},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":191},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":2,"successRate":0.5,"time":77},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":3,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":3,"successRate":0.5,"time":524},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":527},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":127},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":260},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1641},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":35},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":203},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":83},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":124},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":68},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":156},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":57},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":65},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":64},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1291},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":38},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":28},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":22},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":87},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":405},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":71},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":206},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":39},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":220},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4149},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2508},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":29},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":52},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5715},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":64},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":13},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":24},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":36},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":175},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":610},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1397},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":37},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":310},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8030},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":30},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":29},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":422},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":241},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":250},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":0,"successRate":0.0,"time":202},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":0,"successRate":0.0,"time":229},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":0,"successRate":0.0,"time":261},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":6,"passed":0,"successRate":0.0,"time":234},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":60},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":668},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":132},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":248},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2052},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":43},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":276},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":97},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":121},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":169},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":155},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":74},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":108},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":131},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":84},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1267},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":40},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":28},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":22},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":103},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":350},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":83},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":214},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":208},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4236},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2496},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":52},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":3},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5904},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":50},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":16},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":31},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":157},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":585},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1326},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":34},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":321},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8032},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":31},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":33},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":387},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":183},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":251},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":472},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":57},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":681},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":135},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":240},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1956},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":206},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":102},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":119},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":167},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":154},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":64},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":70},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":125},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":95},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1288},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":38},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":30},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":22},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":99},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":333},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":81},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":218},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":206},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4183},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2497},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":49},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":3},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5753},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":51},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":17},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":33},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":161},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":576},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1363},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":10},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":33},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":327},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":7999},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":29},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":385},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":189},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":251},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":474},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":58},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":714},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":126},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":235},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1910},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":37},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":230},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":107},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":122},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":157},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":172},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":64},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":69},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":133},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1320},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":39},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":28},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":96},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":354},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":80},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":225},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":205},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4444},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2528},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":58},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5896},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":49},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":17},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":31},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":158},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":573},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1344},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":34},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":323},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8070},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":29},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":28},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":409},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":197},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":242},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":466},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":64},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":678},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":141},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":210},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1953},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":39},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":134},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":13},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":105},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":114},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":152},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":63},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":73},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":133},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":77},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1354},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":42},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":35},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":97},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":330},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":80},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":82},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":219},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":199},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4150},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2489},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":30},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":49},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5670},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":48},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":18},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":36},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":155},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":584},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":13},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1296},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":34},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":327},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":7847},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":29},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":29},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":410},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":168},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":251},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":456},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":59},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":649},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":127},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":226},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1922},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":191},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":103},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":123},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":160},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":155},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":66},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":74},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":130},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":77},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1327},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":14},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":38},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":26},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":95},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":376},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":81},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":79},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":214},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":36},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":202},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4353},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2534},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":31},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":50},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":3},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5752},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":51},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":17},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":33},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":159},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":562},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1329},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":32},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":323},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":7923},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":28},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":29},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":380},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":183},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":255},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":3,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":3,"successRate":0.5,"time":477},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":4,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":2,"successRate":0.3333333333333333,"time":303},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":574},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":119},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":222},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1909},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":131},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":113},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":117},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":69},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":73},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":127},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":81},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1275},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":40},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":26},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":94},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":342},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":75},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":37},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":214},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":36},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":28},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":218},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4167},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2481},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":30},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":54},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":3},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5677},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":49},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":18},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":38},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":28},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":148},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":596},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1322},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":8},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":34},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":342},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8029},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":29},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":27},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":396},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":186},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":254},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":800},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":551},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":118},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":228},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1915},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":45},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":243},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":114},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":120},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":162},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":152},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":71},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":73},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":146},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":99},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1265},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":33},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":22},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":92},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":334},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":67},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":32},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":207},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":36},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":15},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":201},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4181},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2527},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":32},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":49},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5656},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":53},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":17},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":35},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":145},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":577},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1278},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":8},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":34},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":321},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8422},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":30},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":28},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":390},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":181},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":235},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4829},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1528},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":159},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":11},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5770},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":945},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":157},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":123},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":55},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":96},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":31},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":382},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":791},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5805},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":260},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":117},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":35},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":39},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":84},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":40},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":404},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":595},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":532},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":2360},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":73},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":57},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":113},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":295},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":811},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":28},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":134},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1478},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":355},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":835},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":31},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6628},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5441},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":19},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":70},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":149},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":27},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":113},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":882},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":882},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":12281},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":144},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":110},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1679},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":89},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":115},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13638},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":94},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":448},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":105},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":445},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":185},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":248},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":8581},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":32},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":43},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":724},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":698},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7334},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3495},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":94},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1992},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5646},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":35},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10147},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10980},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":570},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":39},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":83},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":82},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1987},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":2,"passed":1,"successRate":1.0,"time":3246},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":58},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":658},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":118},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":223},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1895},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":45},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":232},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":103},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":116},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":180},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":151},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":63},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":68},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":125},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":78},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1252},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":10},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":40},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":27},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":23},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":103},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":373},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":81},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":81},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":215},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":197},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4070},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2424},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":29},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":50},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5726},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":48},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":34},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":150},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":577},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":15},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1324},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":34},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":322},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8154},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":29},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":379},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":166},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":255},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":464},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":0,"successRate":0.0,"time":214},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":0,"successRate":0.0,"time":3098},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":0,"successRate":0.0,"time":28719},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":0,"successRate":0.0,"time":3137},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":3,"passed":1,"successRate":1.0,"time":3099},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4946},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1701},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":222},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":30},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":19},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":272},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":807},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6130},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":251},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":137},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":29},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":47},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":72},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":41},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":6062},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1011},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":180},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":121},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":62},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":102},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":26},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7297},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":116},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":81},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1266},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":59},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":29},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":545},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":270},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":768},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":550},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3500},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":81},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":3,"successRate":0.75,"time":90},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":38},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":162},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":456},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1159},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":314},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":824},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":288},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":675},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":29},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":8504},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5137},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":16},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":64},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":171},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":27},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":78},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":733},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":950},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15262},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":96},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":482},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":94},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":495},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":198},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":176},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":8592},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":28},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":40},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":971},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":561},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4226},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1761},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":70},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":811},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":10465},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":49},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10483},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13505},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":601},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":43},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":97},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":97},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2027},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":765},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1475},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":171},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":184},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":111},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":177},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":54},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5147},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2729},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":422},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":89},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":263},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":121},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":393},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":849},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":577},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":857},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6712},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":266},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":943},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":788},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3508},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":169},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":210},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":4694},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1228},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":503},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":3562},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":320},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":132},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":467},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1468},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":67},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":720},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1183},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":436},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1171},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2652},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":802},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":563},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":160},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":46},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":9681},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":59},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":52},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":1761},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1240},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3494},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":87},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1156},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":8912},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":17},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":60},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":76},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":582},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":623},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":132},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":14359},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":172},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":145},"title":"","narrative":""},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":73},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":11642},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":3,"successRate":0.75,"time":759},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1638},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":14},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":689},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":49},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":45},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":114},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":158},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":72},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":132},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":3220},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":3150},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":3208},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":3179},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":1,"successRate":1.0,"time":3160},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5628},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1307},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":305},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":69},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":37},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":30},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":270},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":856},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6786},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":908},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":265},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":73},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":129},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":126},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":74},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2076},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":307},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":170},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":2223},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":117},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":402},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6590},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2194},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":448},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":204},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":83},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":159},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":50},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1059},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":3492},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5576},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":14},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":32},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":107},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":26},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":436},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":1064},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":768},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":399},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":882},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1413},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3043},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":109},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":107},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":57},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":176},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":432},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1602},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":53},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":2112},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":622},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":538},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11939},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":81},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":516},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":187},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":55},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":164},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":180},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7960},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":26},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":37},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1468},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":583},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":91},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":92},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2167},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":9},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":856},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":1008},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3679},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1716},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":149},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1247},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":7067},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10964},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5224},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2210},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":333},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":78},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":22},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":56},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":546},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":543},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":4056},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":303},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":57},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":411},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":280},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":506},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":362},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":595},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":186},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":5997},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4671},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":126},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":98},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":519},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1746},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":79},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":50},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":129},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":406},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":913},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":34},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":980},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1974},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":457},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":884},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":525},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":27},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":4022},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4532},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":14},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":93},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":114},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":794},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":838},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22114},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":139},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":164},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":157},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":71},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":146},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":37},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1966},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":529},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3730},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1583},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":62},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":898},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":9903},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10241},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":626},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1539},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":679},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":140},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":188},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":43},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":31},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":35592},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":196},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":194},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":203},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":3207},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":3127},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":1,"successRate":1.0,"time":3123},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":3,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":1,"successRate":0.25,"time":3328},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":3161},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6681},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1484},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":324},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":234},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":75},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":226},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":40},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":84},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5031},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1732},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":460},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":94},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":36},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":45},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":383},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":766},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6646},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":638},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":309},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":76},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":98},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":208},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":98},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5384},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":296},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":145},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1953},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":112},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":32},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":1163},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":979},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":29},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":794},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6291},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":25},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":41},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":181},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":32},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":7,"successRate":0.7777777777777778,"time":822},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":614},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":608},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":389},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":661},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":736},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":2974},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":159},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":205},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":39},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":269},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":608},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1541},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":63},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":386},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2114},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":218},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18738},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":49},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":335},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":115},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":68},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":133},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":139},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7243},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":25},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":39},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":817},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":744},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":854},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3584},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":98},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":2058},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":10716},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":16},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10718},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4364},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":580},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":44},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":81},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":102},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2050},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":286},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":399},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":2649},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":276},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":59},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":549},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":14},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":798},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":170},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":459},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":42},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":409},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":45},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":4023},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":9},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3567},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":69},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":112},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":448},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":998},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":82},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":48},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":139},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":325},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":955},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":35},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":111},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":750},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":71},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":185},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1552},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":284},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":213},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":348},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":392},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled also.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":54},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":9230},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":46},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":42},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":168},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":25},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4979},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2151},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":342},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":65},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":31},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":4591},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":692},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":528},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":31},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":10386},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5009},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":16},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":30},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":134},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23448},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":178},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":178},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":230},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":41},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"","narrative":""},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":1410},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9647},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":730},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":117},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":188},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":45},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":14},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":49},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":35},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":2172},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":476},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":12455},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1702},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":65},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":756},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4551},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":34},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10079},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":505},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":553},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":961},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":172},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":129},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":50},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":106},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5306},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1130},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":193},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":65},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":723},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":421},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1500},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":220},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":34},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":432},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":737},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":146},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":254},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":267},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":30},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":3943},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":934},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6180},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3616},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":23},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":173},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":89},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":380},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":2347},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":879},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":12138},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":33},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":50},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":435},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1521},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":99},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":67},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":179},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":594},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1283},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":40},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":157},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":651},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":432},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":64},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17325},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":40},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":429},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":168},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":91},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":150},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":216},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":30},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7504},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":22},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":32},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":812},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":427},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2172},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1547},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":58},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":653},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":9864},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":30},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":58},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":11245},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":997},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13570},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":647},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":107},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":177},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":43},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":9},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":48},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":1,"successRate":1.0,"time":630},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":0,"successRate":0.0,"time":246},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":4,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":0,"successRate":0.0,"time":291},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":3,"successRate":0.75,"time":4303},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":3,"successRate":0.75,"time":3227},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":3153},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":4,"passed":1,"successRate":1.0,"time":3187},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":3184},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6226},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1406},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":275},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":178},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":85},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":181},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":22},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":48},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":234},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":788},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6523},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":346},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":157},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":27},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":43},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":84},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":47},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5029},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1728},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":238},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":54},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":20},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":445},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":659},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":651},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":2638},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":79},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":3,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":1,"successRate":0.25,"time":91},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":111},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":334},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1012},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":486},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1851},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":255},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":971},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":1082},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4130},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":19},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":27},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":107},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":6,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":3,"successRate":0.3333333333333333,"time":150},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":4009},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":3,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":3,"successRate":0.5,"time":2291},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":5824},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":35},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":3,"successRate":0.75,"time":384},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":81},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":64},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":272},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":126},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":22},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":11245},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":70},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":82},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":14074},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":299},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":127},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1967},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":79},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":5,"successRate":0.7142857142857143,"time":149},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13903},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":577},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":36},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":84},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2029},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":9},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":937},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":687},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9750},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2876},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":171},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":2147},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4936},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":32},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10304},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":4,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":0,"successRate":0.0,"time":293},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":3198},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":3235},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":5902},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1577},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":305},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":289},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":128},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":170},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":72},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5502},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2328},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":575},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":55},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":83},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":21},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":265},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":742},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7492},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":731},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":313},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":35},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":54},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":121},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":60},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3260},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":225},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":126},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":2026},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":116},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":37},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":5,"successRate":0.7142857142857143,"time":242},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1183},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":35},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":1284},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6997},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":16},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":33},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":136},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":6,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":3,"successRate":0.3333333333333333,"time":97},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":3181},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":3,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":3,"successRate":0.5,"time":637},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":8017},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":103},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":618},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":168},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":135},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":314},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":200},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":28},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7883},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":32},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":34},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1530},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":596},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":44},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":107},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":94},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2169},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":955},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":866},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5423},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2031},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":85},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":856},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5675},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":34},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10847},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":2,"successRate":0.5,"time":1000},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":252},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":746},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1241},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":96},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":199},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":88},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":163},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":806},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":50},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":450},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":537},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2218},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":143},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1522},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4995},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":19},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"","narrative":""},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":430},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1129},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":425},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2100},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":388},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":281},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1010},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":34},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":130},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":509},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1359},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":61},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":304},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":939},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":5,"successRate":0.7142857142857143,"time":2145},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2503},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1940},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":166},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":321},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":75},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":204},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":129},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":109},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5481},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":1197},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":382},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4366},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":116},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":275},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":47},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":4725},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":21},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":28153},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":107},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":218},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":266},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":34},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":51},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":30},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":5,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":4,"successRate":0.4444444444444444,"time":2024},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":114},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":526},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":114},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":12425},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":45},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":38},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":4,"successRate":0.6666666666666666,"time":2812},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":255},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":2578},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":292},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":456},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":208},"title":"","narrative":""},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":31},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":119},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":17783},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3218},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":628},"title":"","narrative":""},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4181},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":12},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":74},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":4,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":0,"successRate":0.0,"time":260},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":4,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":0,"successRate":0.0,"time":271},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":3172},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":238},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1494},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4731},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":568},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":141},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":33},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":57},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":66},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":43},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":5814},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":998},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":153},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":113},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":94},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":28},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4706},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1986},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":186},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":34},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":21},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":340},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":672},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":553},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3844},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":70},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":47},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":30},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":126},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":322},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":834},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":34},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1964},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":705},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":882},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":14775},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":133},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":79},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1568},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":80},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":36},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":94},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":988},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":27},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":2907},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3634},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":12},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":103},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":24},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":98},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":585},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":2,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":4,"successRate":0.6666666666666666,"time":594},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17984},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":65},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":323},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":137},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":71},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":2,"successRate":0.6666666666666666,"time":157},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":177},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":25},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7670},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":26},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":36},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":852},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":745},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1839},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1408},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":58},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":699},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":11111},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":50},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":11097},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13565},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":121},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":43},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":79},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":73},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1908},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4653},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1791},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":217},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":60},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":25},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":5973},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1259},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":202},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":157},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":58},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":146},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":29},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":306},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":789},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6301},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":376},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":166},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":34},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":54},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":80},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":59},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2963},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":131},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":107},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1218},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":56},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":4670},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":178},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":707},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":784},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10636},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":71},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":45},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":23},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":105},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":263},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1245},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":53},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":152},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":612},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":304},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":958},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":12724},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4135},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":17},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":34},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":123},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":23},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":74},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":644},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":752},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18807},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":48},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":391},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":92},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":47},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":128},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":211},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7842},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":26},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":36},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":874},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":855},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":830},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1595},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":53},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":619},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":11321},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":29},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":32},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":11074},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8559},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":114},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":83},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":79},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1943},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":984},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":184},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":125},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":46},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":92},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":18},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":33},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5242},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2069},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":297},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":46},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":30},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":23},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":822},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":320},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1917},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":220},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":31},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":212},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":845},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":177},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":482},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":45},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":362},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":33},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":3676},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1199},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":43},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":3556},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3307},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":13},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":151},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":122},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":1358},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":1592},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":1137},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4144},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":64},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":132},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":482},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7959},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":85},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":82},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":54},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":288},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":531},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1008},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":35},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":82},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":494},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":286},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":165},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15407},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":69},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":422},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":97},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":59},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":129},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":151},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":21},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7527},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":24},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":38},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2340},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6894},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":652},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":119},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":202},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":50},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":53},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":48},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":302},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":452},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":628},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2252},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":148},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1182},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":14994},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":39},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10821},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":203},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":3118},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":12082},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":3206},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":144308},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":3093},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":1,"successRate":1.0,"time":3074},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":192},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1466},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4674},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":536},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":180},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":57},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":46},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":69},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":48},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5862},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1061},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":146},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":100},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":44},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":84},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":26},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4790},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1918},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":173},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":43},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":14},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":10},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7594},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":77},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":50},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":773},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":66},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":126},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1060},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":2672},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3500},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":14},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":95},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":187},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":1404},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":668},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":276},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":983},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":576},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6591},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":78},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":42},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":32},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":143},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":323},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1074},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":51},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":211},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3612},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":391},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19167},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":43},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":380},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":105},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":52},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":133},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":177},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":30},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7266},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":26},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":43},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12118},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":397},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":42},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":77},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":16},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":93},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2135},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":703},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":871},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10320},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3113},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":84},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":912},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":5253},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":38},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10680},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5129},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1127},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":203},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":56},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":16},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":11},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6428},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1095},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":216},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":150},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":61},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":104},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":28},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2594},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":146},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":88},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1044},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":60},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":5554},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":124},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":747},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6019},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":377},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":152},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":40},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":73},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":38},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":127},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":544},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":497},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11576},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":87},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":49},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":27},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":138},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":418},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1206},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":51},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1629},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":631},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":449},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":880},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":6692},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5390},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":13},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":28},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":129},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":25},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":822},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":617},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":757},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":14521},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":61},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":461},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":125},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":71},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":155},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":144},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":25},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7747},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":28},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":35},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":655},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":682},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3843},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3291},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":116},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1010},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":8107},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":40},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10581},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7164},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":592},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":39},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":86},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":83},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":2051},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":7},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5609},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2172},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":543},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":45},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":71},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":532},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":383},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":3465},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":351},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":53},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":625},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":167},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":579},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":297},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":459},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":100},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":8254},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4692},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":156},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":186},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":534},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1473},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":76},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":17},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":123},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":333},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":918},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":37},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":513},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":765},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":506},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"","narrative":""},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22053},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":143},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":137},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":161},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":44},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":112},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":40},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":1011},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":642},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":4782},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":3781},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":24},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":29},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":2},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":116},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":24},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":234},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":930},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":754},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":118},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":678},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":2725},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":322},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1532},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":491},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":265},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":23},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":8607},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":56},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":39},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":839},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":478},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":654},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":2324},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":80},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":1042},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":13550},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":35},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10171},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":523},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1430},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":679},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":108},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":188},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":44},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":49},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":27},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2210},"title":"","narrative":""},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":165},"title":"","narrative":""},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":151},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":47},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":89},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":29},"title":"","narrative":""},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4809},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2093},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":424},"title":"","narrative":""},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":99},"title":"","narrative":""},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":84},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":96},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":76},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":779},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":393},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":4439},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":529},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":26},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":322},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":781},"title":"","narrative":""},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":178},"title":"","narrative":""},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":456},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":43},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":507},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":82},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":5852},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":1423},"title":"","narrative":""},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":108},"title":"","narrative":""},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":1078},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6402},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":11},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":1},"title":"","narrative":""},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":81},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":109},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":695},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":675},"title":"","narrative":""},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4224},"title":"","narrative":""},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":253},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":355},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":1056},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4654},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":88},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":42},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":132},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":314},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1016},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":36},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":134},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":505},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":314},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"","narrative":""},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":134},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15241},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":41},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations behave as expected.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":395},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":92},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":51},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":119},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":173},"title":"","narrative":""},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":31},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":7308},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":24},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":33},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":573},"title":"","narrative":""},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":723},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1055},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4229},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":59},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":689},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":8398},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":16},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":42},"title":"","narrative":""},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":10568},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1954},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":870},"title":"Cross Device Tensor Slicing","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":660},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":115},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":175},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":41},"title":"","narrative":""},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":9},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":48},"title":"","narrative":""},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"Example_Spec.Example_Spec":{"executedFeatures":["Call me feature not unit test!","I am readable and also best practice!","Numbers to the power of two with a fancy data table!","Should be able to remove from list","iAmNotSoReadable"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":70},"title":"An Introduction to writing Spock Specifications","narrative":"Hello and welcome to the example / template specification of this project.\n    This is a simple introduction as to how to get started writing Spock specifications.\n    \n    Spock works on top of Groovy which is in essence a syntactic super-set of Java.\n    That means that one can write Java code in Groovy, and 99% of the time it will \n    work the exact same way."},"it.Calculus_Stress_Test":{"executedFeatures":["Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","Activation functions work across types.","Dot operation stress test runs error free and produces expected result","Stress test runs error free and produces expected result","The broadcast operation stress test runs error free and produces expected result"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":1125},"title":"","narrative":""},"it.Cross_Device_Sliced_Tensor_System_Test":{"executedFeatures":["Cross device sliced tensor integration test runs without errors.","Slices can be created using the SliceBuilder."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":153},"title":"Cross Device Tensor Slicing","narrative":""},"it.Eleven_Lines_NN_System_Spec":{"executedFeatures":["One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","One can write a simple float based neural network in less than 11 lines of java like code!","One can write a simple neural network in less than 11 lines of code!","One can write a simple neural network with custom back-prop in 11 lines of code!","The pseudo random number generator works as expected for the weights used in the 11 line NN examples!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":234},"title":"NN Code Golfing!","narrative":"This system test specification uses the following Numpy\n    code as reference implementation for the equivalent in Neureka\n    or similar implementations and variations.\n    The code below is a simple neural network in only 11 lines of code.\n\n    \u00b4\u00b4\u00b4\n        X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ])\n        y = np.array([[0,1,1,0]]).T\n        W1 = 2*np.random.random((3,4)) - 1\n        W2 = 2*np.random.random((4,1)) - 1\n        for j in xrange(60000):\n            l1 = 1/(1+np.exp(-(np.dot(X,W1))))\n            l2 = 1/(1+np.exp(-(np.dot(l1,W2))))\n            l2_delta = (y - l2)*(l2*(1-l2))\n            l1_delta = l2_delta.dot(W2.T) * (l1 * (1-l1))\n            W2 += l1.T.dot(l2_delta)\n            W1 += X.T.dot(l1_delta)\n    \u00b4\u00b4\u00b4"},"st.Benchmark_System_Test":{"executedFeatures":["Tensor can be constructed by passing List instances.","Test benchmark script and simple tensor constructor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1923},"title":"","narrative":""},"st.Broad_System_Test":{"executedFeatures":["The long broad integration test runs successfully."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":76},"title":"","narrative":""},"ut.autograd.AD_And_Computation_Graph_Spec":{"executedFeatures":["Payloads and derivatives are null after garbage collection.","Reshaping produces expected computation graph and also works with reverse mode AD."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":296},"title":"","narrative":""},"ut.autograd.Autograd_Explained":{"executedFeatures":["Simple automatic differentiation and propagation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"Autograd - Automatic Differentiation","narrative":"Central to all neural networks in Neureka is the autograd package.                                      \n    The autograd package provides automatic differentiation for all default operations on Tensors.          \n    Neureka is a define-by-run library, which means that your backpropagation is defined by how             \n    your code is run, and that every single iteration can be different.                                     \n                                                                                                            \n    The class neureka.Tsr is the central class of the main package.                                         \n    If you set its attribute 'rqsGradient' to True, Neureka starts to track all operations on it.           \n    When you finish the forward pass of your network                                                        \n    you can call .backward() and have all the gradients computed                                            \n    and distributed to the tensors requiring them automatically.                                            \n                                                                                                            \n    The gradient for a tensor will be accumulated into a child tensor (component) which                     \n    can be accessed via the '.getGradient()' method.                                                        \n                                                                                                            \n    To stop a tensor from tracking history, you can call '.detach()' to detach it from the                  \n    computation history, and to prevent future computation from being tracked."},"ut.autograd.Autograd_Flags_Explained":{"executedFeatures":["Advanced backpropagation on all AD-Modes ","We can create a shallow copy of a tensor detached from the computation graph."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":2,"passed":9,"successRate":1.0,"time":101},"title":"","narrative":""},"ut.autograd.Autograd_NN_Spec":{"executedFeatures":["Autograd work for simple matrix multiplications.","Autograd works for 2 matrix multiplications in a row.","Autograd works in a simple convolutional dot product and float based feed forward neural network.","Autograd works in a simple convolutional dot product based feed forward neural network.","Autograd works in a simple mat-mul based feed forward neural network."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":123},"title":"Simple Neural Network autograd integration test","narrative":"The integration test below has been implemented by using\n    the following code and the result it produces as reference : \n    https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0 \n    \n    The following seed has been used to assure reproducibility :\n    'torch.manual_seed(503672689411)'"},"ut.autograd.Autograd_Tensor_Spec":{"executedFeatures":["A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","Second-Test \"x-mul\" autograd behaviour. (Not on device)","Test basic autograd behaviour. (Not on device)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests":{"executedFeatures":["GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":169},"title":"","narrative":""},"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests":{"executedFeatures":["A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":6},"title":"","narrative":""},"ut.autograd.JITProp_Autograd_Tensor_Spec":{"executedFeatures":["Gradient auto-apply kicks in when used AD uses JIT prop","Test JIT propagation variant one.","Test JIT propagation variant two.","Test autograd without JIT and auto apply.","Test in-differential and JIT with auto apply","Test no JIT prop when forward AD","Test no preemptive gradient apply when not requested and auto apply and JIT_prop","Test pending error optimization"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":155},"title":"","narrative":""},"ut.backend.Backend_Extension_Spec":{"executedFeatures":["Mock operation interacts with FunctionNode (AbstractFunction) instance as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":67},"title":"","narrative":""},"ut.backend.Backend_MatMul_Extension_Spec":{"executedFeatures":["GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","Test context mock for opencl reference implementations.","Tile parsing for kernel parameter calculation yields expected tile dimensions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":81},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_AD_Spec":{"executedFeatures":["Activation implementations behave as expected.","Broadcast implementations have expected properties.","Convolution implementations behave as expected.","Operator implementations behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":103},"title":"","narrative":""},"ut.backend.core.Backend_Algorithm_Implementation_Spec":{"executedFeatures":["Activation implementations have expected Executor instances.","HostExecutors of Operator implementations behave as expected.","Operator implementations have expected Executor instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":101},"title":"","narrative":""},"ut.backend.core.Backend_Functional_Algorithm_Spec":{"executedFeatures":["A functional algorithm cannot be used if it was not built properly!","A functional algorithm does not accept null as an answer!","A functional algorithm warns us when modified after it has been built!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":19},"title":"","narrative":""},"ut.backend.core.Matrix_Multiplication_Spec":{"executedFeatures":["The CPU matrix multiplication implementation works as expected.","The internal matrix multiplication test script runs!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1255},"title":"Internal CPU based Matrix Multiplication","narrative":"This specification covers library internal matrix multiplication logic,\n    specifically the CPU implementation.\n    Do not depend on the API used in this specification as it is subject to change!"},"ut.backend.core.OpenCL_Backend_Spec":{"executedFeatures":["The OpenCL backend context can load implementations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":12},"title":"","narrative":""},"ut.backend.core.Randomization_Spec":{"executedFeatures":["Randomization is in essence the same algorithm as JDKs \"Random\".","The Randomization class can fill various types of arrays with pseudo random numbers.","We can make slices of tensors random."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"","narrative":""},"ut.backend.Matrix_Multiplication_Spec":{"executedFeatures":["The \"matMul\" method allows us to perform matrix multiplication.","The simple CPU matrix multiplication implementation works as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Matrix Multiplication","narrative":"The tensor API exposes a useful method for Matrix Multiplication.\n    This specification not only demonstrates how to use this method\n    but also shows how matrix multiplication work \n    for tensors with both row and column major layouts.\n    (typically, column major is faster)"},"ut.calculus.BackendContext_Spec":{"executedFeatures":["BackendContext instances can be created by cloning from Singleton instance.","BackendContext instances return Runner instances for easy visiting with return values.","BackendContext instances return Runner instances for easy visiting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"The BackendContext is a cloneable context which can run Tasks.","narrative":"This specification defines the expected behaviour of the backend context\n    which should expose a convenient API to work with.\n    This API should allow for tasks to be running on a given context\n    which is important for testing and modularity not only\n    during library startup but also throughout the runtime."},"ut.calculus.Calculus_Exception_Spec":{"executedFeatures":["Function throws exception when arity does not match input number.","Function throws exception when not enough inputs provided."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.calculus.Calculus_Function_Spec":{"executedFeatures":["Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","The library context exposes a set of useful functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":38},"title":"Testing Default Methods on Functions","narrative":"This specification tests the default methods on functions\n    through a simple dummy implementation of the Function interface."},"ut.calculus.Calculus_Parsing_Spec":{"executedFeatures":["Functions can derive themselves according to the provided index of the input which ought to be derived.","Parsed equations throw expected error messages.","Test parsed equations when building Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":21},"title":"Parsing Expressions into Functions","narrative":"Neureka uses the 'Function' interface as a representation of a\n    nested structure of operations.\n    This means that a 'Function' is simply an abstract syntax trees made up of other 'Function' implementations\n    which are assembled together by a parser receiving a string expression.\n    In this specification we ensure that function expressions will be properly parsed into\n    'Function' implementations."},"ut.calculus.Calculus_Scalar_Spec":{"executedFeatures":["Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","Function \"1/I[0]\" instance returns expected scalar results.","Function \"I[0]+1/I[0]\" instance returns expected scalar results.","Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","Test scalar results of various Function instances."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":52},"title":"Functions for Scalars","narrative":"The Function API and it's implementations \n    receive and process arrays of scalars as arguments.\n    Functions don't have to be used alongside tensors / nd-arrays,\n    they can also compute derivatives based on scalar values."},"ut.calculus.ConCat_Spec":{"executedFeatures":["We can concatenate 2 float tensors alongside a specified axis!","We can concatenate 2 string tensors alongside a specified axis!","We can concatenate 2 tensors alongside a specified axis!","We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":37},"title":"Merging Tensors","narrative":"Tensors can not only be sliced, but also merged.\n    This is most easily achieved through the concatenation operation, \n    which stacks 2 tensors alongside a specified axis.\n    This specification not only covers how you can concatenate tensors,\n    but also how this works alongside autograd and non-numeric tensors."},"ut.calculus.Tensor_Function_Spec":{"executedFeatures":["Executed tensors are intermediate tensors.","Reshaping on 3D tensors works by instantiate a Function instance built from a String.","Tensor results of various Function instances return expected results.","The \"DimTrim\" operation works forward as well as backward!","The optimization function for the SGD algorithm produces the expected result","The tensor API has built-in methods for applying functions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":150},"title":"Applying Functions to Tensors","narrative":"A tensor would be nothing without being able to apply operations on them.\n    However, calling operations manually in order to process your\n    tensors can be a verbose and error prone task.\n    This is where functions come into play.\n    Neureka's functions are composed of operations forming an abstract syntax tree.\n    Passing tensors to a function will route them trough this tree and apply\n    all of the operations on the tensors for you."},"ut.device.CPU_Spec":{"executedFeatures":["CPU knows the current number of available processor cores!","The CPU exposes a non null API for executing workloads in parallel.","Thread pool executes given workload in parallel"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":351},"title":"The CPU device, an API for CPU based execution","narrative":"The CPU class, one of many implementations of the Device interface, \n    is simply supposed to be an API for dispatching threaded workloads onto the CPU.\n    Contrary to other types of device, the CPU will host tensor data by default, simply\n    because the tensors will be stored in RAM if no device was specified."},"ut.device.Cross_Device_IO_Spec":{"executedFeatures":["We can use the access device API to read from a tensor.","We can use the access device API to write to a tensor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"Devices manage the states of the tensors they store!","narrative":"Tensors should not manage their states\n    themselves, simply because the type and location\n    of the data is dependent on the device onto which they are stored.\n    This specification tests of various device implementations\n    enable reading to or writing from the tensors they store."},"ut.device.Cross_Device_Type_Spec":{"executedFeatures":["Devices also store slices which can also be restored just like normal tensors.","Devices expose an API for accessing (reading and writing) the data of a tensor.","Devices store tensors which can also be restored.","Execution calls containing null arguments will cause an exception to be thrown in device instances.","In total there are 3 different types of methods for finding device instances.","Passing a numeric array to a tensor should modify its contents!","Virtual tensors stay virtual when outsourced.","We can find Device implementations or null by passing search keys to the \"get\" method.","We can query the backend for devices by specifying both the requested type and a key word."],"ignoredFeatures":["Devices cannot store slices whose parents are not already stored."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":9,"totalFeatures":10,"passed":9,"successRate":1.0,"time":108},"title":"Finding Device Types","narrative":"Neureka introduces a the concept of a `Device` which is an interface\n    that represents a computational device used for executing tensor / nd-array operations on them.\n    The `Device` interface is implemented by various classes which represent\n    different types of accelerator hardware such as `CPUs`, `GPUs`, `TPUs`, `FPGAs`, etc.\n    These various `Device` types can not be instantiated directly because they model \n    the concrete and finite hardware that is available on any given system Neureka is running on.\n    This means that they are usually instantiated lazily upon access request or \n    upfront by the library backend (usually a backend extension built fo a specific device).\n    In order to find these instances embedded in the library backend the `Device` interface\n    exposes various static methods which can be used to find a device instance by name or type."},"ut.device.FileDevice_Spec":{"executedFeatures":["A file device stores tensors in idx files by default.","A file device stores tensors in various file formats.","The file device can load known files in a directory."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":131},"title":"FileDevice, Storing Tensors in Files","narrative":"The `FileDevice` class, one of many implementations of the `Device` interface, \n    represents a file directory which can store and load tensors as files (`idx`, `jpg`, `png`...)."},"ut.device.internal.CLFunctionCompiler_Spec":{"executedFeatures":["The CLFunctionCompiler produces an operation which properly integrates to the backend.","The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":223},"title":"Turning functions into kernels.","narrative":"Neureka parses mathematical expressions into an AST representation\n    hidden behind the Function interface...\n    This feature does not exist without reason, we can use\n    this abstract syntax tree to compile to OpenCL kernels\n    for optimal execution speed!"},"ut.device.internal.CPU_Kernel_Spec":{"executedFeatures":["The Reduce implementation for the CPU has realistic behaviour","The Sum implementation for the CPU has realistic behaviour"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":70},"title":"","narrative":""},"ut.device.internal.OpenCL_Data_Spec":{"executedFeatures":["The \"Data\" class can represent various OpenCL data types.","The OpenCLDevice specific Data class represents JVM data for OpenCL."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.device.internal.OpenCL_Kernel_Unit_Spec":{"executedFeatures":["The GEMM implementation for the OpenCLDevice has realistic behaviour","The Reduce implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour","The Sum implementation for the OpenCLDevice has realistic behaviour for when the number of elements is a prime."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.device.OpenCLDevice_Exception_Spec":{"executedFeatures":["Ad hoc compilation produces expected exceptions when duplication is found.","Ad hoc compilation produces expected exceptions.","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","Trying to restore a tensor which is not on a device raises exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":202},"title":"OpenCLDevice Exception Handling","narrative":"The OpenCLDevice class, one of many implementations of the Device interface, \n    represents physical OpenCL devices.\n    This specification defines how instances of this class deal with exceptional information."},"ut.device.OpenCLDevice_Spec":{"executedFeatures":["Ad hoc compilation produces executable kernel.","Ad hoc compilation works for WIP general purpose matrix multiplication.","Ad hoc compilation works for custom column major based tiled matrix multiplication.","Ad hoc compilation works for custom simple row major based matrix multiplication.","Ad hoc matrix multiplication works for multiple of 16 matrices.","An OpenCLDevice loads tensors in a provided lambda temporarily.","We can get the items of an outsourced tensor as a primitive array.","We can take a look at the underlying data array of an outsourced tensor through the unsafe API."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":4154},"title":"The OpenCLDevice Specification","narrative":"Tensors need devices for execution!\n    By default tensors use the `CPU` device, but sometimes we want to\n    use something more suitable for large amounts of data and a high degree of parallelization.\n    This is were the `OpenCLDevice` comes into play!\n    It is a `Device` implementation built on top of the JOCL library, a thin OpenCL API.\n    We expect the `OpenCLDevice` to store tensors as well as being able to read and write\n    data from and to stored tensors.\n    Also, an `OpenCLDevice` should allows us to compile OpenCL kernel code on the fly..."},"ut.device.OpenCL_Spec":{"executedFeatures":["A given OpenCL context can be disposed!","An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","First found OpenCLDevice will have realistic numeric properties.","First found OpenCLDevice will have realistic properties inside summary query.","First found OpenCLDevice will have realistic text properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":2343},"title":"Working with OpenCL","narrative":"Neureka models the OpenCL API through various types of classes.\n    The most fundamental of these is the `OpenCLDevice` class which\n    represents a single device with OpenCL support.\n    Besides that, there is also the `OpenCLContext` class which\n    represents a OpenCL contexts, platforms and multiple devices on said platforms..."},"ut.dtype.DataType_Spec":{"executedFeatures":["DataType multi-ton instances behave as expected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":8},"title":"","narrative":""},"ut.dtype.NumericType_Spec":{"executedFeatures":["Conversion goes both ways and produces expected numeric values.","NumericType conversion to holder types yields expected results.","NumericType implementations behave as expected.","NumericType implementations return their expected properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":28},"title":"The NumericType and its implementations model their respective numeric data types.","narrative":"This specification covers the behavior of the NumericType interface\n    which is responsible for modelling numeric data types which may or may not be native to the JVM. \n    These implementations however do not model them in the traditional OO style\n    but merely expose useful utility method for converting and representing \n    these numeric data types using JVM types."},"ut.framing.Tensor_Framing_Spec":{"executedFeatures":["A matrix (rank 2 tensor) can be labeled and their labels can be used to extract slices / subsets.","A tensor can be labeled partially.","Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","We can add labels to tensors through lists or maps passed to the \"label()\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":26},"title":"Naming Tensors and their Dimensions.","narrative":"A powerful concept in the data science as well as machine learning\n    world is something usually referred to as \"Data Frames\".\n    These are highly flexible 2D data structures\n    used to load and store CSV, CRV, etc... files for \n    data exploration and further processing.\n    Data frames are so powerful because\n    their indices are labeled and therefore human readable.\n    Neureka's tensors are general purpose data containers\n    which may also stored data in 2 dimensions whose\n    indices may also be something other than integers."},"ut.introductions.Tensor_NDArray_Spec":{"executedFeatures":["Tensor is a subtype of NdArray.","We can use tensors for numeric calculations (but not nd-arrays)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Tensors or Nd-arrays","narrative":"*What is the difference?*\n\nIn the world of machine learning we use something called a **'tensor'** to represent data.\nThey might be called **'nd-arrays'** in some other frameworks,\nbut although they are very similar, \nthere are also some important distinctions to be made between these two concepts.\nBoth are at their core merely multidimensional arrays, however,\nthey are different in their typical usage and API.\nnd-arrays are merely used to represent any type of data as a \ncollection of elements in a multidimensional grid,  \ntensors on the other hand have additional requirements.\nThey are a type of nd-array which stores numeric data \nas well as expose various mathematical operations for said data.\nIn that sense it is actually merely a more complex kind of number.\nThis concept actually comes from the field of physics, \nwhere it is used to represent a physical quantity.\n\nNeureka models both concepts through the `Tsr` and the `Nda` interfaces.\n`Nda` is an abbreviation of `NdArray`, and `Tsr` is an abbreviation of `Tensor`.\nThe `Tsr` type is a subtype of the `Nda` type, exposing additional methods\nlike for example `plus`, `minus`, `times` and `divide`.\nBoth can be instantiated through static factory methods (and a fluent builder API)."},"ut.ndas.Nda_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one nd-array into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Nda Inline Assignment","narrative":"In this specification we cover the behaviour of nda's with respect to the assignment operation\n    as well as the assignment of individual Nda items."},"ut.ndas.Nda_Framing":{"executedFeatures":["Concatenating 2 labeled nd-arrays will produce a nd-array which is also labeled.","The slice of a labeled vector is labeled too.","We can label the columns and rows of a rank 3 nd-array.","We can label the columns of a rank 2 nd-array.","We can use labels as selectors for slicing."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"NDA Framing","narrative":"Framing an nd-array is all about naming its axes and then using those names to\n    access, read or write its values in a more convenient and human readable way."},"ut.ndas.Nda_Instantiation_Spec":{"executedFeatures":["A vector can be created from an array of values through the \"of\" method.","ND-arrays can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"ND-Array Instantiation","narrative":"In this specification we cover how ND-arrays can be instantiated."},"ut.ndas.Nda_Mutation_Spec":{"executedFeatures":["A ND-Array can be mutated simply using the \"set\" method.","A ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"at(..).set(..)\" methods.","A simple vector ND-Array can be mutated using the \"setItemAt\" method.","We can use the subscription operator to mutate a simple vector ND-Array.","We can use the subscription operator to mutate an ND-Array."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":11},"title":"Mutating ND-Arrays","narrative":"ND-Arrays should be considered immutable, so we should prefer creating new \n    ND-Arrays from existing ones using wither methods.\n    However this is not always a good idea as it can be expensive to create new\n    ND-Arrays, especially if the ND-Array is very large.\n    The ability to mutate ND-Arrays is therefore provided, but only\n    accessible via the mutation API exposed by the `getMut()` method."},"ut.ndas.Nda_Wither_Specification":{"executedFeatures":["An Nda can be labeled.","We can create a new Nda instance with a different shape."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"Nda Withers","narrative":"Immutability is a core concept of the Neureka library.\n    This means that the Nda API does not expose mutability directly.\n    Instead, the API exposes methods that return new instances of Nda\n    that are derived from the original instance."},"ut.ndim.NDConfiguration_Spec":{"executedFeatures":["Various NDConfigurations behaviour exactly as their general purpose implementation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":54},"title":"Making Arrays N-Dimensional","narrative":"Under the hood Neureka implements powerful indexing \n    abstractions through the `NDConfiguration` interface and its various implementations.\n    This allows for the creation of tensors/nd-arrays with arbitrary dimensions, \n    the ability to slice them into smaller tensors/nd-arrays with the same underlying data,\n    and finally the ability to reshape their axes (like transposing them for example).\n    \n    This specification however only focuses on the behaviour of the `NDConfiguration` interface\n    which translates various types of indices."},"ut.ndim.Tensor_NDConfiguration_Spec":{"executedFeatures":["NDConfiguration instances of tensors have expected state and behaviour.","NDConfiguration instances of tensors have expected state."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":8},"title":"What it means to be N-Dimensional","narrative":"This specification covers how implementations\n    of the `NDConfiguration` interface manage to define\n    what it means to be a n-dimensional tensor/nd-array."},"ut.ndim.Tensor_Reshape_Spec":{"executedFeatures":["When matrices are transpose, they will change their layout type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":2},"title":"Reshaping Tensors","narrative":"Reshaping a tensor means changing its shape.\n    This is a very important operation in Neureka, because it allows for the creation of new views on the same data.\n    This is very useful for example when you want to perform a matrix multiplication on a tensor which is not a matrix.\n    In this case you can reshape the tensor to a matrix and then perform the multiplication.\n\n    Reshaping a tensor is also very useful when you want to perform other kinds of linear\n    operations like for example doing 4D convolution with a tensor which is not a 4D tensor.\n    In this case you can create a reshape 4D tensor then perform the convolution.\n  \n    Reshaping is also a very cheap operation because it does not copy any data but merely\n    creates a new view on the same data with a different access pattern."},"ut.ndim.Tensor_Slice_Reshape_Spec":{"executedFeatures":["A slice of a tensor changes as expected when reshaping it.","Reshaping a slice works as expected.","Two slices of one big tensor perform matrix multiplication flawless."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Reshaping Slices of Tensors","narrative":"Neureka provides a convenient way to reshape tensors\n    even if they are slices of other tensors sharing the same underlying data.\n    This is possible because of the under the hood indexing \n    abstractions provided by the `NDConfiguration` interface and its various implementations."},"ut.neureka.Neureka_Spec":{"executedFeatures":["Backend related library objects adhere to the same toString formatting convention!","Every Thread instance has their own Neureka instance.","Neureka class instance has expected behaviour.","Neureka settings class can be locked causing its properties to be immutable.","OpenCL related library objects adhere to the same toString formatting convention!","Various library objects adhere to the same toString formatting convention!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":5819},"title":"The Neureka context can be used and configured as expected.","narrative":"This specification covers the behavior of the Neureka class which\n    exposes a global API for configuring thread local contexts and library settings.\n    The purpose of this is to assert that the API exposed by the Neureka class \n    is both thread local and configurable.\n    This specification also exists to cover standards for the Neureka library in general."},"ut.optimization.AdaGrad_Spec":{"executedFeatures":["AdaGrad optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":18},"title":"","narrative":""},"ut.optimization.ADAM_Spec":{"executedFeatures":["ADAM optimizes according to expected inputs","Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","Equations used by ADAM return expected result."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":51},"title":"","narrative":"ADAM is a more powerful alternative to the classical stochastic gradient descent. \n    It combines the best properties of the AdaGrad and the RMSProp algorithms, which makes \n    it especially well suited for sparse gradients and noisy data.\n    Adam is the most post popular among the adaptive optimizers\n    because its adaptive learning rate working so well with sparse datasets."},"ut.optimization.Momentum_Spec":{"executedFeatures":["Momentum optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":11},"title":"","narrative":"Momentum is an extension to the gradient descent optimization \n    algorithm that allows the search to build inertia in a direction \n    in the search space and overcome the oscillations of noisy \n    gradients and coast across flat spots of the search space."},"ut.optimization.Optimizer_Spec":{"executedFeatures":[],"ignoredFeatures":["Dot based feed forward and activation produces expected result."],"stats":{"failures":0,"errors":0,"skipped":1,"totalRuns":0,"totalFeatures":1,"passed":0,"successRate":1.0,"time":0},"title":"","narrative":""},"ut.optimization.RMSProp_Spec":{"executedFeatures":["RMSprop optimizes according to expected inputs"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":17},"title":"","narrative":"**Root Mean Squared Propagation**, or RMSProp, is an extension of gradient \n    descent and the AdaGrad version of gradient descent that uses a \n    decaying average of partial gradients in the adaptation of the \n    step size for each parameter."},"ut.tensors.Copy_Spec":{"executedFeatures":["A deep copy of a slice tensor is also a deep copy of the underlying data array.","A deep copy of a tensor is also a deep copy of the underlying data array.","A shallow copy of a tensor will be flagged as such.","A shallow copy will share the same underlying data as its original tensor.","We can deep copy various types of tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":17},"title":"To Copy or Not to Copy","narrative":"In this specification we cover the behaviour of tensors with respect to their copy methods.\n    There are to main ways to copy a tensor: <br>\n    1. .shallowCopy() <br>\n    2. .deepCopy() <br>\n    <br>\n    The first method creates a new tensor with the same underlying data array as the original tensor. <br>\n    The second method on the other hand creates a new tensor with a new data array. <br>\n    <br>\n    The first method is the most efficient, but it is not as safe as the second method. <br>\n    The second method is the most safe, but it is not as efficient. <br>\n    <br>\n    Besides these 2 main requirements, there are als some corner cases with respect to\n    the components of a tensor (like for example its computation graph) which\n    will be covered in this specification as well."},"ut.tensors.exceptions.Tensor_Delete_Exception_Spec":{"executedFeatures":["A deleted tensor will tell you that it has been deleted.","A deleted tensor will throw an exception when accessing its configuration.","A deleted tensor will throw an exception when accessing its data type.","A deleted tensor will throw an exception when accessing its data.","A deleted tensor will throw an exception when modifying its data type.","A deleted tensor will throw an exception when trying to modify its data.","A deleted tensor will throw an exception when trying to set its configuration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.tensors.exceptions.Tensor_Exception_Spec":{"executedFeatures":["Building a tensor with \"null\" as shape argument throws an exception.","Building a tensor with 0 shape arguments throws an exception.","Casting a tensor as something unusual will cuas an exception to be thrown.","Out of dimension bound causes descriptive exception!","Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","Passing an invalid object into Tsr constructor causes descriptive exception.","Passing null to various methods of the tensor API will throw exceptions.","Trying to inject an empty tensor into another causes fitting exception."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":31},"title":"Tensors Exception Behavior","narrative":"This specification covers the behavior of the $Tsr class in\n    exceptional scenarios which are contrary to its intended use.\n    The purpose of this is to assert that the $Tsr class will provide\n    useful feedback to a user to explain that a misuse of its API\n    occurred so that the user can correct this misuse."},"ut.tensors.Expression_Based_Tensor_Instantiation_Spec":{"executedFeatures":["A tensor can be created from a function as expression.","We can instantiate tensors from various simple string expressions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":6},"title":"Expression based Tensor Instantiation","narrative":"This specification defines how a tensor can be instantiated\n    using string expressions, which define operations to be executed.\n    This form of tensor instantiation is very useful to avoid boilerplate code."},"ut.tensors.Fluent_Tensor_Creation_Spec":{"executedFeatures":["Initialization lambda based tensors can be created fluently.","Range based tensors can be created fluently.","Scalars can be created fluently.","Seed based tensors can be created fluently.","Tensors can be created fluently.","Value based tensors can be created fluently.","Vectors can be created fluently."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":22},"title":"","narrative":""},"ut.tensors.Functional_Nda_Spec":{"executedFeatures":["We can find both min and max items in an ND-array by providing a comparator.","We can initialize an ND-Array using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":155},"title":"Functional ND-Arrays","narrative":"ND-Arrays expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Functional_Tensor_Spec":{"executedFeatures":["Tensor mapping lambdas produce expected tensors.","The \"map\" method is a shorter convenience method for mapping to the same type.","We can analyse the values of a tensor using various predicate receiving methods","We can find both min and max items in a tensor by providing a comparator.","We can initialize a tensor using a filler lambda mapping indices to items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":588},"title":"Functional Tensors","narrative":"Tensors expose a powerful API for performing operations on them\n    in a functional style."},"ut.tensors.Tensor_Assign_Spec":{"executedFeatures":["Assignment can be easily achieved through subscription operators.","We can assign one slice into another one.","We can use the \"mut\" API to assign the contents of one tensor into another one."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":3},"title":"Tsr Inline Assignment","narrative":"In this specification we cover the behaviour of tensors with respect to the assignment operation\n    as well as the assignment of individual tensor items."},"ut.tensors.Tensor_As_Container_Spec":{"executedFeatures":["More tensor operations translate to custom data type \"ComplexNumber\".","Plus operator on String tensors works element-wise.","Tensor operations translate to custom data type \"ComplexNumber\".","We can apply predicates on the values of a tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Why not have a tensor of words?","narrative":"Technically, tensors are merely fancy ND-arrays with some useful mathematical operations\n    applicable to them...\n    Therefore, there is no reason why a tensor would not also be able to store\n    other kinds of objects besides numbers like strings for example.\n    This specification ensures that tensors can hold and index many other things..."},"ut.tensors.Tensor_Conversion_Spec":{"executedFeatures":["Tensors value type can be changed by calling \"toType(...)\".","We can change the data type of all kinds of tensors.","We turn a tensor into a scalar value or string through the \"as\" operator!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Tensor Type Conversion","narrative":"Here we specify how a tensor can be converted to other data types\n    like for example another tensor of a different data type."},"ut.tensors.Tensor_Convolution_Spec":{"executedFeatures":["Autograd works with simple 2D convolution.","Convolution can be performed using non-quadratic matrix tensors.","Convolution can be performed using tensors with an additional dimension as batch size.","Convolution with tensors of the same shape is equivalent to a dot product.","Manual convolution produces expected result.","Sime convolution works as expected eith autograd.","Tensors have the correct layout after convolution.","The \"x\" (convolution) operator produces expected results (On the CPU).","Very simple manual convolution produces expected result.","We can perform a convolution operation on a 2D tensor."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1341},"title":"Tensor Convolution","narrative":"This specification shows how convolution can be performed on tensors.\n\n    Convolution is a linear operation which is not only important for image processing but also\n    a central player in the field of machine learning (especially for computer vision).\n    It is used to extract features from images and other typically ~2 dimensional data.\n    Other than that it is extremely important in the field of signal processing."},"ut.tensors.Tensor_Device_Spec":{"executedFeatures":["Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","Tensors try to migrate themselves to a device that is being added to them as component.","The device of a tensor can be accessed via the \"device()\" method.","When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Tensors on Devices","narrative":"This unit test specification covers \n    the expected behavior of tensors when interacting\n    with instances of implementations of the Device interface."},"ut.tensors.Tensor_Generics_Spec":{"executedFeatures":["1D tensors can be created from primitive arrays.","Anonymous tensor instance has the default datatype class as defined in Neureka settings.","We can create a tensor of strings."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":6},"title":"Tensors as Generic Containers","narrative":"Tensors do not just store numeric data.\n    They can hold anything which can be stuffed into a \"Object[]\" array.\n    You could even create a tensor of tensors!"},"ut.tensors.Tensor_Gradient_Spec":{"executedFeatures":["Gradient of tensor is being applies regardless of the tensor requiring gradient or not","Tensors can have gradients but not require them.","Tensors that have gradients but do not require them still print them."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"Gradients are Tensors which are Components of other Tensors","narrative":"This specification defines the gradient API on tensors.\n    So one ought to be able to check wetter or not a tensor has a gradient attached to it or not.\n    In that case one should be able to get this gradient and then work with\n    it independently of the original tensor to which it belongs to..."},"ut.tensors.Tensor_Instantiation_Spec":{"executedFeatures":["A matrix tensor can be instantiated using lists for it's shape and values.","A simple 2D vector can be instantiated using lists for it's shape and values.","Passing a seed in the form of a String to a tensor produces pseudo random items.","Scalar tensors can be created via static factory methods","Tensors can be instantiated based on arrays for both shapes and values.","Tensors can be instantiated with String seed.","Vector tensors can be instantiated via factory methods."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Instantiating Tensors","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to show how a tensor can be instantiated in different ways."},"ut.tensors.Tensor_Interop_Spec":{"executedFeatures":["Not all tensor can be converted to images.","Tensor can be converted to buffered images."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Tensors play well with other data structures!","narrative":"Tensors should have good interoperability with other JDK data structures like images.\n    In this specification we define these interoperability requirements."},"ut.tensors.Tensor_IO_Spec":{"executedFeatures":["A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","Indexing after reshaping works as expected.","Tensor value type can not be changed by passing float or double arrays to it.","Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","The tensor data array can be modified by targeting them with an index.","We can manipulate the underlying data array of a tensor through the unsafe API.","We can re-populate a tensor of shorts from a single scalar value!","When we try to manipulate the underlying data array of a virtual tensor then it will become actual."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":37},"title":"Reading and Writing Tensor Items","narrative":"Tensors are complicated data structures with a wide range of different possible states.\n    They can host elements of different types residing on many kinds of different devices.\n    Here we want to read from and write to the state of a tensor."},"ut.tensors.Tensor_Layout_Spec":{"executedFeatures":["A new transposed version of a given tensor will be returned by the \"T()\" method.","Matrix multiplication works for both column and row major matrices across devices."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":330},"title":"Row or Column Major. Why not both?","narrative":"Although Neureka exposes tensors as row major tensors from \n    a users point of view, it does in fact support both row major and column major \n    based tensor layout under the hood.\n    Here we cover how the layout of tensors can be modified\n    and we ensure the different tensor types still work as expected...\n    (The features in this specification involve mutating tensors, be careful when playing around with this yourself)"},"ut.tensors.Tensor_Operation_Spec":{"executedFeatures":["Activation functions work across types on slices and non sliced tensors.","Auto reshaping and broadcasting works and the result can be back propagated.","New method \"asFunction\" of String added at runtime is callable by groovy and also works.","New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","Overloaded operation methods on tensors produce expected results when called.","Simple slice addition produces expected result.","The \"dot\" operation reshapes and produces valid \"x\" operation result.","The \"matMul\" operation produces the expected result.","The \"random\" function/operation populates tensors randomly.","The values of a randomly populated tensor seems to adhere to a gaussian distribution."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":8078},"title":"Running Tensors through operations","narrative":"This specification covers the interaction \n    between tensors and operations, more specifically it\n    runs tensors through operations and validates that the results are valid."},"ut.tensors.Tensor_Slicing_Spec":{"executedFeatures":["A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","A tensor can be sliced by passing ranges in the form of primitive arrays.","Normal slicing will try to do autograd.","Slicing is also a Function with autograd support!","The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","The slice builder also supports slicing with custom step sizes.","We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","We can slice a scalar tensor from a larger tensor of rank 4.","When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":30},"title":"Tensors within Tensors","narrative":"ND-Array data structures can be \"sliced\" in the sense\n    that one can create a subset view of the underlying data inside a tensor\n    through a new tensor instance...\n    This can be a tedious and complicated procedure.\n    Therefore a tensor should expose a various user friendly API for slicing which\n    are also fit for various languages.\n    This specification covers these APIs for tensor slicing."},"ut.tensors.Tensor_State_Spec":{"executedFeatures":["A tensor can be instantiated from a item type class and nested lists.","Numeric tensors as String can be formatted on an entry based level.","Tensor created from shape and datatype has expected state.","Tensors as String can be formatted depending on shape.","Tensors as String can be formatted on an entry based level.","The data and the value of a tensor a 2 different things!","We can create scalar tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":31},"title":"The Tensor Initialization and State Specification","narrative":"This specification defines the expected states of freshly instantiated\n    and initialized tensors.\n    After a tensor was created successfully we expect it \n    to have certain properties like a shape, rank, type and data array\n    among other things."},"ut.tensors.Tensor_Stats_Spec":{"executedFeatures":["Both the min and max operation support autograd (back-propagation).","The sum operation support autograd (back-propagation).","There is no need to use a function, we can use the min() and max() methods on tensors instead.","We can get pre-instantiated min and max functions from the library context.","We can use the \"sum\" method to sum the items of a tensor.","We can use the max operation as a function"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":407},"title":"Reducing Tensors","narrative":"Various kinds of operations reduce tensors to scalars,\n    the most common ones being the min and max operations \n    which find the smallest as well as largest number among all \n    items of a tensor.\n    Neureka exposes various different ways to achieve this,\n    all of which are also differential (autograd support)."},"ut.tensors.Tensor_Version_Spec":{"executedFeatures":["Inline operations cause illegal state exceptions.","Inline operations causes version incrementation.","Non-inline operations do not cause version incrementation.","Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically)."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":198},"title":"Tensor (Data Array) Version","narrative":"There are two fundamental categories of operations\n    which can be applied to tensors : \n    Inline operations and Non-Inline  operations! \n    \n    Inline operations are often times problematic because they produce\n    side effects by changing passed tensors instead of producing new ones... \n    One such bad side effect can easily occur for tensors involved in the\n    autograd system, more specifically: the recorded computation graph. \n    Inline operations can break the mathematically pureness of the back-propagation\n    procedure by for example changing partial derivatives... <br>\n    In order to prevent said errors from occurring unnoticed tensors\n    have versions which will increment when the underlying data of the tensor changes. \n    This version will be tracked by the computation graph as well in order to\n    match it with the ones stored inside the tensor. \n    A mismatch would then yield an exception! \n    \n    This specification is responsible for defining the behaviour of this\n    version number with respect to their wrapping tensors as well as computation graph nodes."},"ut.utility.Cleaner_Testing":{"executedFeatures":["The DeviceCleaner triggers registered cleaner actions when things are eligible for GC."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":244},"title":"How Neureka Cleans Up","narrative":"Under the hood \n    Neureka deals whith large arrays of\n    data, which are often times \n    native data arrays requiring explicit\n    memory freeing!\n    This freeing of memory can happen at any time\n    during the livetime of a nd-array, however\n    it should happen at least up until the nd-arra/tensor\n    objects representing their referenced data arrays become\n    eligible for garbage collection.\n    This specification ensures that the custom garbage\n    cleaner implementation used by Neureka fulfills this role"},"ut.utility.DataConverter_Spec":{"executedFeatures":["An array of any type of object may be converted to a array of primitives.","The DataConverter can convert the given array data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":3},"title":"","narrative":""},"ut.utility.FileHandle_Spec":{"executedFeatures":["Fully labeled tenors will be stored with their labels included when saving them as CSV.","Partially labeled tenors will be stored with their labels included when saving them as CSV.","Test reading IDX file format.","Test writing IDX file format.","The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","We can load image files as tensors."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":509},"title":"","narrative":""},"ut.utility.ListReader_Exception_Spec":{"executedFeatures":["The ListReader will detect inconsistent degrees of nesting in the provided data.","The ListReader will detect inconsistent types in the provided data."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":4},"title":"","narrative":""},"ut.utility.ListReader_Spec":{"executedFeatures":["The ListReader can interpret nested lists into a shape list and value list.","The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","The ListReader can interpret nested lists resembling a matrix into a shape list and value list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":5},"title":"The Internal ListReader turning lists into flat arrays with shape and type data","narrative":"This specification covers an internal class which should not be used\n    outside this library, namely the ListReader class.\n    This class is simply a converter which turns nested lists\n    into flat arrays alongside the type of the elements and the shape of this \"tensor\"."},"ut.utility.Utility_Spec":{"executedFeatures":["Object arrays can be converted to primitive arrays."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":9},"title":"","narrative":""}}