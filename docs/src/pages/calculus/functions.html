
<div class="col-sm-12 col-md-12 col-lg-12">
    <div class="ContentBox">
        <h3>
            Function instantiation:
        </h3>
        <p class="MarkdownMe">
The calculus package contains a class of major importance in Neureka.
Namely, the `Function` interface.
Instances implementing this interface are responsible for scheduling
the execution of operations on tensors.

A `Function` is created by calling its static factory method:
        </p>
    </div>
</div>
<div class="col-sm-12 col-md-6 col-lg-6">
    <div class="TabWrapper">
        <div class="TabHead BasicTabHeader">
            <button onclick="switchTab(event, '.groovyTab')" class="selected">Groovy</button>
            <button onclick="switchTab(event, '.javaTab')">Java</button>
            <button onclick="switchTab(event, '.kotlinTab')">Kotlin</button>
        </div>
        <div class="TabBody">
            <div class="groovyTab">
                <pre><code class="hljs language-java">

var f = Function.of('I[0] * (I[1] + I[2])')

                </code></pre>
            </div>
            <div class="javaTab" style="display:none">
                <pre><code class="hljs language-java">

Function f = Function.of("I[0] * (I[1] + I[2])");

                </code></pre>
            </div>
            <div class="kotlinTab" style="display:none">
                <pre><code class="hljs kotlin">

val f : Function = Function.of("I[0] * (I[1] + I[2])")

                </code></pre>
            </div>
        </div>
    </div>
</div>
<div class="col-sm-12 col-md-6 col-lg-6">
    <div class="ContentBox">
        <p class="MarkdownMe">
Internally a `Function` is really a graph of nodes that represent a given equation.
In a given string expression passed to the factory method,
inputs will be recognized by '`I[j]`', '`Ij`' or '`ij`', where `j` is the input index.
`Function` instances accept arrays which is why variables must be targeted in such a way.
        </p>
    </div>
</div>

<div class="col-sm-12 col-md-6 col-lg-12">
    <div class="TabWrapper">
        <div class="TabHead BasicTabHeader">
            <button onclick="switchTab(event, '.groovyTab')" class="selected">Groovy</button>
            <button onclick="switchTab(event, '.javaTab')">Java</button>
            <button onclick="switchTab(event, '.kotlinTab')">Kotlin</button>
        </div>
        <div class="TabBody">
            <div class="groovyTab">
                <pre><code class="hljs language-java">

Neureka.get().context.autogradFunction.sig(4)

                </code></pre>
            </div>
            <div class="javaTab" style="display:none">
                <pre><code class="hljs language-java">

Neureka.get().backend().getAutogradFunction().sig().call(4);

                </code></pre>
            </div>
            <div class="kotlinTab" style="display:none">
                <pre><code class="hljs kotlin">

Neureka.get().context.autogradFunction.sig(4)

                </code></pre>
            </div>
        </div>
    </div>
</div>
<div class="col-sm-12 col-md-12 col-lg-12">
    <div class="ContentBox">
        <p>
            There are plenty of pre-instantiated and optimized functions
            to pick from in the backend context.
        </p>
    </div>
</div>


<div class="col-sm-12 col-md-6">
    <div class="TabWrapper">
        <div class="TabHead BasicTabHeader">
            <button onclick="switchTab(event, '.groovyTab')" class="selected">Groovy</button>
            <button onclick="switchTab(event, '.javaTab')">Java</button>
            <button onclick="switchTab(event, '.kotlinTab')">Kotlin</button>
        </div>
        <div class="TabBody">
            <div class="groovyTab">
                <pre><code class="hljs language-java">

Neureka.get().backend().getFunction().sig(4)

                </code></pre>
            </div>
            <div class="javaTab" style="display:none">
                <pre><code class="hljs language-java">

Neureka.get().backend().getFunction().sig().call(4);

                </code></pre>
            </div>
            <div class="kotlinTab" style="display:none">
                <pre><code class="hljs kotlin">

Neureka.get().context.function.sig(4)

                </code></pre>
            </div>
        </div>
    </div>
</div>
<div class="col-sm-12 col-md-6 col-lg-6">
    <div class="ContentBox">
        <p class="MarkdownMe">
Usually a `Function` will create a dynamic computation graph during execution
which is then responsible for enabling Neureka's autograd system.
If you have tensors attached to a graph requiring autograd, but
you do not want there to be partial derivatives created automatically, simply
select one of the many functions exposed by the `Functions` instance accessible though the `getFunction()`
method in the current backend context.
        </p>
    </div>
</div>


