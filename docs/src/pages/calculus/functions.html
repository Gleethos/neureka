
<div class="col-sm-12 col-md-12 col-lg-12">
    <div class="ContentBox">
        <h3>
            Function instantiation:
        </h3>
        <p>
            The calculus package contains a class of major importance in Neureka.
            Namely the Function interface.
            Instances implementing this interface are the responsible for scheduling
            the executorFor of operations on tensors.
            A Function is created by calling the static factory method on the interface.
        </p>
    </div>
</div>
<div class="col-sm-12 col-md-6 col-lg-6">
    <div class="TabWrapper">
        <div class="TabHead">
            <button onclick="switchTab(event, '.groovyTab')" class="selected">Groovy</button>
            <button onclick="switchTab(event, '.javaTab')">Java</button>
        </div>
        <div class="TabBody">
            <div class="groovyTab">
                <pre><code class="hljs java">

    def f = Function.of("I[0] * (I[1] + I[2])")

                </code></pre>
            </div>
            <div class="javaTab" style="display:none">
                <pre><code class="hljs java">

    Function f = Function.of("I[0] * (I[1] + I[2])");

                </code></pre>
            </div>
        </div>
    </div>
</div>
<div class="col-sm-12 col-md-6 col-lg-6">
    <div class="ContentBox">
        <p>
            Internally a Function is really a graph of nodes that represent a given equation.
            Inputs are recognized by 'I[j]', 'Ij' or 'ij', where j is the input index.
            Functions accept arrays which is why variables must be targeted in such a way.

        </p>
    </div>
</div>

<div class="col-sm-12 col-md-6 col-lg-12">
    <div class="TabWrapper">
        <div class="TabHead">
            <button onclick="switchTab(event, '.groovyTab')" class="selected">Groovy</button>
            <button onclick="switchTab(event, '.javaTab')">Java</button>
        </div>
        <div class="TabBody">
            <div class="groovyTab">
                <pre><code class="hljs java">

    Neureka.get().context().getAutogradFunction().sig(4)

                </code></pre>
            </div>
            <div class="javaTab" style="display:none">
                <pre><code class="hljs java">

    Neureka.get().context().getAutogradFunction().sig().call(4);

                </code></pre>
            </div>
        </div>
    </div>
</div>
<div class="col-sm-12 col-md-12 col-lg-12">
    <div class="ContentBox">
        <p>
            There are plenty of pre-instantiated and optimized Functions
            to pick from in the operation context.
        </p>
    </div>
</div>


<div class="col-sm-12 col-md-6">
    <div class="TabWrapper">
        <div class="TabHead">
            <button onclick="switchTab(event, '.groovyTab')" class="selected">Groovy</button>
            <button onclick="switchTab(event, '.javaTab')">Java</button>
        </div>
        <div class="TabBody">
            <div class="groovyTab">
                <pre><code class="hljs java">

    Neureka.get().context().getFunction().sig(4)

                </code></pre>
            </div>
            <div class="javaTab" style="display:none">
                <pre><code class="hljs java">

    Neureka.get().context().getFunction().sig().call(4);

                </code></pre>
            </div>
        </div>
    </div>
</div>
<div class="col-sm-12 col-md-6 col-lg-6">
    <div class="ContentBox">
        <p>
            Usually a Function creates a dynamic computation graph responsible for
            enabling Neureka's autograd system.
            If you have tensors attached to a graph requiring autograd, but
            you do not want there to be derivatives created simply
            use the Functions within the 'Detached' subclass of the Function interface.
        </p>
    </div>
</div>


