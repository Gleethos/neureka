<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Tsr (neureka 0.17.0 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Tsr (neureka 0.17.0 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":9,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":9,"i75":9,"i76":9,"i77":9,"i78":9,"i79":9,"i80":9,"i81":9,"i82":9,"i83":9,"i84":9,"i85":9,"i86":9,"i87":9,"i88":9,"i89":9,"i90":9,"i91":9,"i92":9,"i93":9,"i94":9,"i95":9,"i96":9,"i97":9,"i98":9,"i99":9,"i100":9,"i101":9,"i102":9,"i103":9,"i104":9,"i105":9,"i106":9,"i107":9,"i108":9,"i109":9,"i110":9,"i111":9,"i112":9,"i113":9,"i114":9,"i115":9,"i116":9,"i117":9,"i118":9,"i119":9,"i120":9,"i121":9,"i122":9,"i123":9,"i124":9,"i125":10,"i126":10,"i127":10,"i128":10,"i129":10,"i130":10,"i131":10,"i132":10,"i133":10,"i134":10,"i135":10,"i136":10,"i137":10,"i138":10,"i139":10,"i140":10,"i141":10,"i142":10,"i143":10,"i144":10,"i145":10,"i146":10,"i147":10,"i148":10,"i149":10,"i150":10,"i151":10,"i152":10,"i153":10,"i154":10,"i155":10,"i156":10,"i157":10,"i158":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">neureka</a></div>
<h2 title="Class Tsr" class="title">Class Tsr&lt;V&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="common/composition/AbstractComponentOwner.html" title="class in neureka.common.composition">neureka.common.composition.AbstractComponentOwner</a>&lt;C&gt;</li>
<li>
<ul class="inheritance">
<li><a href="ndim/AbstractTensor.html" title="class in neureka.ndim">neureka.ndim.AbstractTensor</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;,&#8203;V&gt;</li>
<li>
<ul class="inheritance">
<li>neureka.Tsr&lt;V&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>V</code> - The type parameter for the individual value items within this tensor.</dd>
</dl>
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code>java.lang.Cloneable</code>, <code>java.lang.Iterable&lt;V&gt;</code>, <code><a href="common/composition/Component.html" title="interface in neureka.common.composition">Component</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&gt;</code>, <code><a href="ndim/NDimensional.html" title="interface in neureka.ndim">NDimensional</a></code>, <code><a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a>&lt;V&gt;</code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">Tsr&lt;V&gt;</span>
extends <a href="ndim/AbstractTensor.html" title="class in neureka.ndim">AbstractTensor</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;,&#8203;V&gt;
implements <a href="common/composition/Component.html" title="interface in neureka.common.composition">Component</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&gt;, java.lang.Cloneable</pre>
<div class="block">This class name <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> is a 3 letter abbreviation of the word "tensor", a mathematical concept.
  A tensor is a type of multidimensional data-structure with certain transformation properties.
  Technically however, it is mostly a simple container / data-structure which can house data indexed by N dimensions.
  Therefore it is often also described as a nd-array.
  Elements of a tensor are also mostly numeric.<br>
  This means that: <br>
  <i><b>...a tensor of rank 0 is a scalar, a tensor of rank 1 is a vector and a tensor of rank 2 is a matrix, etc...</b></i>
  <br><br>
  Consequently, tensors are a perfect fit for applying various operations on them.
  Such operations might be simple elementwise operations or more complex linear operations like
  the dot-product, matrix- or even tensor multiplications. <br>
  <br></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="Tsr.ImageType.html" title="enum in neureka">Tsr.ImageType</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.neureka.ndim.AbstractTensor">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from class&nbsp;neureka.ndim.<a href="ndim/AbstractTensor.html" title="class in neureka.ndim">AbstractTensor</a></h3>
<code><a href="ndim/AbstractTensor.Unsafe.html" title="interface in neureka.ndim">AbstractTensor.Unsafe</a>&lt;<a href="ndim/AbstractTensor.Unsafe.html" title="type parameter in AbstractTensor.Unsafe">T</a>&gt;, <a href="ndim/AbstractTensor.Utility.html" title="class in neureka.ndim">AbstractTensor.Utility</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.neureka.common.composition.Component">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;neureka.common.composition.<a href="common/composition/Component.html" title="interface in neureka.common.composition">Component</a></h3>
<code><a href="common/composition/Component.IsBeing.html" title="enum in neureka.common.composition">Component.IsBeing</a>, <a href="common/composition/Component.OwnerChangeRequest.html" title="interface in neureka.common.composition">Component.OwnerChangeRequest</a>&lt;<a href="common/composition/Component.OwnerChangeRequest.html" title="type parameter in Component.OwnerChangeRequest">O</a>&gt;</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.neureka.ndim.NDimensional">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;neureka.ndim.<a href="ndim/NDimensional.html" title="interface in neureka.ndim">NDimensional</a></h3>
<code><a href="ndim/NDimensional.Util.html" title="class in neureka.ndim">NDimensional.Util</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.neureka.ndim.TensorAPI">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;neureka.ndim.<a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a></h3>
<code><a href="ndim/TensorAPI.Access.html" title="interface in neureka.ndim">TensorAPI.Access</a>&lt;<a href="ndim/TensorAPI.Access.html" title="type parameter in TensorAPI.Access">V</a>&gt;</code></li>
</ul>
</li>
</ul>
</section>
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.neureka.ndim.AbstractTensor">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;neureka.ndim.<a href="ndim/AbstractTensor.html" title="class in neureka.ndim">AbstractTensor</a></h3>
<code><a href="ndim/AbstractTensor.html#_LOG">_LOG</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_become(neureka.Tsr)">_become</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;tensor)</code></th>
<td class="colLast">
<div class="block">In essence tensors are merely fancy wrapper for some form of array of any type...</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected &lt;T extends <a href="common/composition/Component.html" title="interface in neureka.common.composition">Component</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&gt;&gt;<br>T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_removeOrReject(T)">_removeOrReject</a></span>&#8203;(T&nbsp;newComponent)</code></th>
<td class="colLast">
<div class="block">This method is executed when a component is being removed from the tensor.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_setIsIntermediate(boolean)">_setIsIntermediate</a></span>&#8203;(boolean&nbsp;isIntermediate)</code></th>
<td class="colLast">
<div class="block">Intermediate tensors are internal non-user tensors which may be eligible
  for deletion when further consumed by a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_setIsOutsourced(boolean)">_setIsOutsourced</a></span>&#8203;(boolean&nbsp;isOutsourced)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_setIsVirtual(boolean)">_setIsVirtual</a></span>&#8203;(boolean&nbsp;isVirtual)</code></th>
<td class="colLast">
<div class="block">This method is the inner counterpart to the public "<a href="#setIsVirtual(boolean)"><code>setIsVirtual(boolean)</code></a>" method.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected &lt;T extends <a href="common/composition/Component.html" title="interface in neureka.common.composition">Component</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&gt;&gt;<br>T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_setOrReject(T)">_setOrReject</a></span>&#8203;(T&nbsp;newComponent)</code></th>
<td class="colLast">
<div class="block">This method is executed when a new Component is added to the tensor.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_setRqsGradient(boolean)">_setRqsGradient</a></span>&#8203;(boolean&nbsp;rqsGradient)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addToGradient(neureka.Tsr)">addToGradient</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;error)</code></th>
<td class="colLast">
<div class="block">This method takes the provided <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance and adds its
  contents to the contents of the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> which is set as gradient of this very <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#applyGradient()">applyGradient</a></span>()</code></th>
<td class="colLast">
<div class="block">If this tensor owns a gradient tensor as component, then it can be applied by this method.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>java.awt.image.BufferedImage</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asImage(neureka.Tsr.ImageType)">asImage</a></span>&#8203;(<a href="Tsr.ImageType.html" title="enum in neureka">Tsr.ImageType</a>&nbsp;type)</code></th>
<td class="colLast">
<div class="block">Turns this tensor into a <code>BufferedImage</code> based on the provided
  <a href="Tsr.ImageType.html" title="enum in neureka"><code>Tsr.ImageType</code></a> formatting choice.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asType(java.lang.Class)">asType</a></span>&#8203;(java.lang.Class&lt;T&gt;&nbsp;typeClass)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#backward()">backward</a></span>()</code></th>
<td class="colLast">
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#backward(double)">backward</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#backward(neureka.Tsr)">backward</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;error)</code></th>
<td class="colLast">
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#belongsToGraph()">belongsToGraph</a></span>()</code></th>
<td class="colLast">
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clone()">clone</a></span>()</code></th>
<td class="colLast">
<div class="block">If this tensor stores value types then this method will
  essentially produce a deep copy of this tensor.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#contains(neureka.Tsr)">contains</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">This method name translates to the "in" keyword in Kotlin!
  The same is true for the "isCase" method in Groovy.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convDot(neureka.Tsr)">convDot</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">This method performs a convolutional based dot product between the last dimension of this tensor
  and the first dimension of the passed tensor.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#detach()">detach</a></span>()</code></th>
<td class="colLast">
<div class="block"><b>This method detaches this tensor from its underlying computation-graph
  or simply does nothing if no graph is present.</b> <br>
  Nodes within a computation graph are instances of the "<a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a>" class which are also
  simple components of the tensors they represent in the graph.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dimtrim()">dimtrim</a></span>()</code></th>
<td class="colLast">
<div class="block">This method creates a new tensor sharing the same data and whose shape is trimmed.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#div(double)">div</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#div(neureka.Tsr)">div</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">The <a href="#div(neureka.Tsr)"><code>div(Tsr)</code></a> method will produce the quotient of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#divAssign(neureka.Tsr)">divAssign</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dot(neureka.Tsr)">dot</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">This method performs a dot product between the last dimension of this tensor
  and the first dimension of the passed tensor.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code><a href="framing/NDFrame.html" title="class in neureka.framing">NDFrame</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#frame()">frame</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAt(int...)">getAt</a></span>&#8203;(int...&nbsp;indices)</code></th>
<td class="colLast">
<div class="block">The following method enables access to specific scalar elements within the tensor.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAt(java.util.List)">getAt</a></span>&#8203;(java.util.List&lt;?&gt;&nbsp;key)</code></th>
<td class="colLast">
<div class="block">This method enables tensor slicing!
  It takes a key of various types and configures a slice
  tensor which shares the same underlying data as the original tensor.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAt(java.util.Map)">getAt</a></span>&#8203;(java.util.Map&lt;?,&#8203;java.lang.Integer&gt;&nbsp;rankToStrides)</code></th>
<td class="colLast">
<div class="block">This method is most useful when used in Groovy
  where defining maps is done through square brackets,
  making it possible to slice tensors like so: <br></div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getData()">getData</a></span>()</code></th>
<td class="colLast">
<div class="block">This returns an unprocessed version of the underlying data of this tensor.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;A</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDataAs(java.lang.Class)">getDataAs</a></span>&#8203;(java.lang.Class&lt;A&gt;&nbsp;arrayTypeClass)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="type parameter in Tsr">V</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDataAt(int)">getDataAt</a></span>&#8203;(int&nbsp;i)</code></th>
<td class="colLast">
<div class="block">A tensor ought to have some way to access its underlying data array.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="devices/Device.html" title="interface in neureka.devices">Device</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDevice()">getDevice</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getGradient()">getGradient</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="autograd/GraphNode.html" title="class in neureka.autograd">GraphNode</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getGraphNode()">getGraphNode</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getT()">getT</a></span>()</code></th>
<td class="colLast">
<div class="block">A method which returns a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance which is a transposed twin of this instance.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="ndim/AbstractTensor.Unsafe.html" title="interface in neureka.ndim">AbstractTensor.Unsafe</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUnsafe()">getUnsafe</a></span>()</code></th>
<td class="colLast">
<div class="block">This method exposes an API for mutating the state of this tensor.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getValue()">getValue</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;A</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getValueAs(java.lang.Class)">getValueAs</a></span>&#8203;(java.lang.Class&lt;A&gt;&nbsp;arrayTypeClass)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getVersion()">getVersion</a></span>()</code></th>
<td class="colLast">
<div class="block">The version number is tracking how often this tensor has been mutated.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#gradientApplyRequested()">gradientApplyRequested</a></span>()</code></th>
<td class="colLast">
<div class="block">This flag works alongside two autograd features which can be enables inside the library settings.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasGradient()">hasGradient</a></span>()</code></th>
<td class="colLast">
<div class="block">Tensors can be components of other tensors which makes the
  implicitly their gradients.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isBranch()">isBranch</a></span>()</code></th>
<td class="colLast">
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isCase(neureka.Tsr)">isCase</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">This method name translates to the "in" keyword in Groovy!
  The same is true for the "contains" method in Kotlin.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isDeleted()">isDeleted</a></span>()</code></th>
<td class="colLast">
<div class="block">This will check if the <a href="#_delete()"><code>_delete()</code></a> method was previously called on this tensor.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isEmpty()">isEmpty</a></span>()</code></th>
<td class="colLast">
<div class="block">A tensor is empty if there is neither data referenced within the tensor directly
  or within any given device to which the tensor might belong.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isIntermediate()">isIntermediate</a></span>()</code></th>
<td class="colLast">
<div class="block">Intermediate tensors are internal non-user tensors which may be eligible
  for deletion when further consumed by a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a>.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isLeave()">isLeave</a></span>()</code></th>
<td class="colLast">
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isOutsourced()">isOutsourced</a></span>()</code></th>
<td class="colLast">
<div class="block">Outsourced means that the tensor is stored on a <a href="devices/Device.html" title="interface in neureka.devices"><code>Device</code></a> implementation instance.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isSlice()">isSlice</a></span>()</code></th>
<td class="colLast">
<div class="block">If this tensor is a slice of a parent tensor then this method will yield true.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isSliceParent()">isSliceParent</a></span>()</code></th>
<td class="colLast">
<div class="block">If slices have been derived from this tensor then it is a "slice parent".</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isUndefined()">isUndefined</a></span>()</code></th>
<td class="colLast">
<div class="block">A tensor is "undefined" if it has either no <a href="ndim/config/NDConfiguration.html" title="interface in neureka.ndim.config"><code>NDConfiguration</code></a> implementation instance
  or this instance does not have a shape set for this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> which is needed for
  a tensor to also have a rank and dimensionality...</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isVirtual()">isVirtual</a></span>()</code></th>
<td class="colLast">
<div class="block">A tensor is virtual if the size of the underlying data is not actually equal to
  the number of elements which the tensor claims to store, aka its size.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>@NotNull java.util.Iterator&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#iterator()">iterator</a></span>()</code></th>
<td class="colLast">
<div class="block">This method returns an iterator over the elements of this tensor.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#label(java.lang.String%5B%5D%5B%5D)">label</a></span>&#8203;(java.lang.String[][]&nbsp;labels)</code></th>
<td class="colLast">
<div class="block">This method receives a nested <code>String</code> array which
  ought to contain a label for the index of this tensor.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#label(java.lang.String,java.lang.String%5B%5D%5B%5D)">label</a></span>&#8203;(java.lang.String&nbsp;tensorName,
     java.lang.String[][]&nbsp;labels)</code></th>
<td class="colLast">
<div class="block">This method receives a label for this tensor and a
  nested <code>String</code> array which ought to contain a
  label for the index of this tensor.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#label(java.lang.String,java.util.List)">label</a></span>&#8203;(java.lang.String&nbsp;tensorName,
     java.util.List&lt;java.util.List&lt;java.lang.Object&gt;&gt;&nbsp;labels)</code></th>
<td class="colLast">
<div class="block">This method receives a label for this tensor and a nested
  <code>String</code> list which ought to contain a label for the index of
  this tensor The index for a single element of this tensor would
  be an array of numbers as long as the rank where every number is
  in the range of the corresponding shape dimension...</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#label(java.lang.String,java.util.Map)">label</a></span>&#8203;(java.lang.String&nbsp;tensorName,
     java.util.Map&lt;java.lang.Object,&#8203;java.util.List&lt;java.lang.Object&gt;&gt;&nbsp;labels)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#label(java.util.List)">label</a></span>&#8203;(java.util.List&lt;java.util.List&lt;java.lang.Object&gt;&gt;&nbsp;labels)</code></th>
<td class="colLast">
<div class="block">This method receives a nested <code>String</code> list which
  ought to contain a label for the index of this tensor.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#label(java.util.Map)">label</a></span>&#8203;(java.util.Map&lt;java.lang.Object,&#8203;java.util.List&lt;java.lang.Object&gt;&gt;&nbsp;labels)</code></th>
<td class="colLast">
<div class="block">This method provides the ability to
  label not only the indices of the shape of this tensor, but also
  the dimension of the shape.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="fluent/building/states/IterByOrIterFromOrAll.html" title="interface in neureka.fluent.building.states">IterByOrIterFromOrAll</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#like(neureka.Tsr)">like</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;template)</code></th>
<td class="colLast">
<div class="block">Use this factory method to instantiate a new tensor with the same data type, shape
  and memory location (<a href="devices/Device.html" title="interface in neureka.devices"><code>Device</code></a> instance) as the provided template tensor.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapTo(java.lang.Class,java.util.function.Function)">mapTo</a></span>&#8203;(java.lang.Class&lt;T&gt;&nbsp;typeClass,
     java.util.function.Function&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>,&#8203;T&gt;&nbsp;mapper)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#matMul(neureka.Tsr)">matMul</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">The <a href="#matMul(neureka.Tsr)"><code>matMul(Tsr)</code></a> method will produce the matrix product of
  two 2 dimensional arrays, where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mean()">mean</a></span>()</code></th>
<td class="colLast">
<div class="block">This method performs various operations by calling <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instances
  in order to ultimately calculate the mean value of all values
  of this very tensor!
  This scalar tensor is then returned.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#minus(neureka.Tsr)">minus</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">This method will perform subtraction on
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#minus(V)">minus</a></span>&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#minusAssign(neureka.Tsr)">minusAssign</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#minusAssign(V)">minusAssign</a></span>&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mod(int)">mod</a></span>&#8203;(int&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mod(neureka.Tsr)">mod</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">The <a href="#mod(neureka.Tsr)"><code>mod(Tsr)</code></a> method will produce the modulus of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#modAssign(neureka.Tsr)">modAssign</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multiply(double)">multiply</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multiply(neureka.Tsr)">multiply</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">This method is synonymous to the <a href="#times(neureka.Tsr)"><code>times(Tsr)</code></a> method.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multiply(V)">multiply</a></span>&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#negative()">negative</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#newInstance()">newInstance</a></span>()</code></th>
<td class="colLast">
<div class="block">This static factory method creates and return a completely empty and undefined tensor
  which is void of any contents and meaning.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Boolean&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(boolean...)">of</a></span>&#8203;(boolean...&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Constructs a vector of booleans based on the provided array.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Byte&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(byte...)">of</a></span>&#8203;(byte...&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Constructs a vector of bytes based on the provided array.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(double)">of</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(double...)">of</a></span>&#8203;(double...&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Constructs a vector of doubles based on the provided array.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Float&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(float...)">of</a></span>&#8203;(float...&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Constructs a vector of floats based on the provided array.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Integer&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int...)">of</a></span>&#8203;(int...&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Constructs a vector of ints based on the provided array.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Boolean&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int%5B%5D,boolean%5B%5D)">of</a></span>&#8203;(int[]&nbsp;shape,
  boolean[]&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Byte&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int%5B%5D,byte%5B%5D)">of</a></span>&#8203;(int[]&nbsp;shape,
  byte[]&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int%5B%5D,double)">of</a></span>&#8203;(int[]&nbsp;shape,
  double&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int%5B%5D,double%5B%5D)">of</a></span>&#8203;(int[]&nbsp;shape,
  double[]&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Float&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int%5B%5D,float%5B%5D)">of</a></span>&#8203;(int[]&nbsp;shape,
  float[]&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Integer&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int%5B%5D,int%5B%5D)">of</a></span>&#8203;(int[]&nbsp;shape,
  int[]&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int%5B%5D,long%5B%5D)">of</a></span>&#8203;(int[]&nbsp;shape,
  long[]&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Short&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int%5B%5D,short%5B%5D)">of</a></span>&#8203;(int[]&nbsp;shape,
  short[]&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(int%5B%5D,java.util.List)">of</a></span>&#8203;(int[]&nbsp;shape,
  java.util.List&lt;V&gt;&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance based on an array of integers representing the shape,
  and a list of values representing the value of the resulting tensor.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(long...)">of</a></span>&#8203;(long...&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Constructs a vector of longs based on the provided array.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Short&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(short...)">of</a></span>&#8203;(short...&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Constructs a vector of shorts based on the provided array.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.Class,java.util.List)">of</a></span>&#8203;(java.lang.Class&lt;T&gt;&nbsp;targetType,
  java.util.List&lt;java.lang.Object&gt;&nbsp;conf)</code></th>
<td class="colLast">
<div class="block">This factory method will turn a list of values or nested lists of values into a <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance with the corresponding rank and shape and whose values
  are of the provided type.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.Class)">of</a></span>&#8203;(java.lang.Class&lt;V&gt;&nbsp;typeClass)</code></th>
<td class="colLast">
<div class="block">This is the entry point to the fluent tensor builder API for building
  <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instances in a readable and type safe fashion.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.Class,int%5B%5D,java.lang.Object)">of</a></span>&#8203;(java.lang.Class&lt;V&gt;&nbsp;typeClass,
  int[]&nbsp;shape,
  java.lang.Object&nbsp;data)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.Class,int%5B%5D,java.lang.String)">of</a></span>&#8203;(java.lang.Class&lt;V&gt;&nbsp;valueType,
  int[]&nbsp;shape,
  java.lang.String&nbsp;seed)</code></th>
<td class="colLast">
<div class="block">Use this to construct and return a seeded tensor of the specified type.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.Class,java.util.List,java.lang.Object)">of</a></span>&#8203;(java.lang.Class&lt;V&gt;&nbsp;typeClass,
  java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
  java.lang.Object&nbsp;data)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.Class,java.util.List,java.util.List)">of</a></span>&#8203;(java.lang.Class&lt;V&gt;&nbsp;typeClass,
  java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
  java.util.List&lt;V&gt;&nbsp;data)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.Object...)">of</a></span>&#8203;(java.lang.Object...&nbsp;args)</code></th>
<td class="colLast">
<div class="block">This static <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> factory method tries to interpret the provided
  arguments to create the instance the use might wants.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.String,boolean,java.util.List)">of</a></span>&#8203;(java.lang.String&nbsp;expression,
  boolean&nbsp;doAD,
  java.util.List&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&gt;&nbsp;tensors)</code></th>
<td class="colLast">
<div class="block">This method takes a list of tensors and a String expression describing
  operations which ought to be applied to the tensors in said list.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.String,boolean,neureka.Tsr...)">of</a></span>&#8203;(java.lang.String&nbsp;expression,
  boolean&nbsp;doAD,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;...&nbsp;tensors)</code></th>
<td class="colLast">
<div class="block">This method takes an array of tensors and a String expression describing
  operations which ought to be applied to the tensors in said array.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.String,java.util.List)">of</a></span>&#8203;(java.lang.String&nbsp;expression,
  java.util.List&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&gt;&nbsp;inputs)</code></th>
<td class="colLast">
<div class="block">This factory method allows for the creation and execution of <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instances
  without actually instantiating them manually,
  where the result will then be returned by this factory method.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.String,neureka.Tsr,char,neureka.Tsr,java.lang.String)">of</a></span>&#8203;(java.lang.String&nbsp;e1,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
  char&nbsp;o,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;b,
  java.lang.String&nbsp;e2)</code></th>
<td class="colLast">
<div class="block">Use this to conveniently operate on 2 tensors.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.String,neureka.Tsr,java.lang.String)">of</a></span>&#8203;(java.lang.String&nbsp;e1,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
  java.lang.String&nbsp;e2)</code></th>
<td class="colLast">
<div class="block">Use this to conveniently operate on a tensor.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.String,neureka.Tsr,java.lang.String,neureka.Tsr,java.lang.String,neureka.Tsr,java.lang.String)">of</a></span>&#8203;(java.lang.String&nbsp;e1,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
  java.lang.String&nbsp;e2,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;b,
  java.lang.String&nbsp;e3,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;c,
  java.lang.String&nbsp;e4)</code></th>
<td class="colLast">
<div class="block">Use this to conveniently operate on 3 tensors.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.String,neureka.Tsr)">of</a></span>&#8203;(java.lang.String&nbsp;expression,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;tensor)</code></th>
<td class="colLast">
<div class="block">This method takes a tensor and a String expression describing
  operations which ought to be applied to said tensor.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.String,neureka.Tsr...)">of</a></span>&#8203;(java.lang.String&nbsp;expression,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;...&nbsp;tensors)</code></th>
<td class="colLast">
<div class="block">This method takes an array of tensors and a String expression describing
  operations which ought to be applied to the tensors in said array.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>static &lt;V extends java.lang.Number&gt;<br><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.lang.String,V...)">of</a></span>&#8203;(java.lang.String&nbsp;expression,
  V...&nbsp;inputs)</code></th>
<td class="colLast">
<div class="block">This factory method allows for the creation and execution of <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instances
  without actually instantiating them manually,
  where the result will then be returned by this factory method.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.util.List,java.lang.String)">of</a></span>&#8203;(java.util.List&lt;? extends java.lang.Number&gt;&nbsp;shape,
  java.lang.String&nbsp;seed)</code></th>
<td class="colLast">
<div class="block">This factory method will create and return a <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance
  based on a list of <code>Number</code> instances whose rounded values will be interpreted as
  the shape of this new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance and a seed which will serve
  as a source of pseudo randomness to generate the values for the new instance.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.util.List,java.util.List)">of</a></span>&#8203;(java.util.List&lt;? extends java.lang.Number&gt;&nbsp;shape,
  java.util.List&lt;V&gt;&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance based on a list of numbers representing the shape,
  and a list of values representing the value of the resulting tensor.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.util.List,T)">of</a></span>&#8203;(java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
  T&nbsp;value)</code></th>
<td class="colLast">
<div class="block">This is a convenient factory method for creating <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instances for
  values of type <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> based on a list of integers
  defining a shape made up of axes sizes as well as a scalar value of type <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  which will fill out the data array spanned by the provided shape information.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>static <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(java.util.List)">of</a></span>&#8203;(java.util.List&lt;java.lang.Object&gt;&nbsp;conf)</code></th>
<td class="colLast">
<div class="block">This factory method will turn a list of values or nested lists of values into a <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance with the corresponding rank and shape.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(neureka.dtype.DataType,int%5B%5D,neureka.ndim.Filler)">of</a></span>&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;T&gt;&nbsp;type,
  int[]&nbsp;shape,
  <a href="ndim/Filler.html" title="interface in neureka.ndim">Filler</a>&lt;T&gt;&nbsp;filler)</code></th>
<td class="colLast">
<div class="block">This factory method allows the creation of tensors with an additional initialization
  lambda for filling the underlying data array with desired values.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(neureka.dtype.DataType,java.util.List,neureka.ndim.Filler)">of</a></span>&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;T&gt;&nbsp;type,
  java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
  <a href="ndim/Filler.html" title="interface in neureka.ndim">Filler</a>&lt;T&gt;&nbsp;filler)</code></th>
<td class="colLast">
<div class="block">This factory method allows the creation of tensors with an additional initialization
  lambda for filling the underlying data array with desired values.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(neureka.dtype.DataType,int%5B%5D)">of</a></span>&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;V&gt;&nbsp;type,
  int[]&nbsp;shape)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(neureka.dtype.DataType,int%5B%5D,java.lang.Object)">of</a></span>&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;V&gt;&nbsp;dataType,
  int[]&nbsp;shape,
  java.lang.Object&nbsp;data)</code></th>
<td class="colLast">
<div class="block">This factory method is among the most flexible and forgiving ways to create a <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(neureka.dtype.DataType,java.util.List,java.util.List)">of</a></span>&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;V&gt;&nbsp;dataType,
  java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
  java.util.List&lt;V&gt;&nbsp;data)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(neureka.Tsr,char,neureka.Tsr)">of</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
  char&nbsp;o,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;b)</code></th>
<td class="colLast">
<div class="block">Use this to conveniently operate on 2 tensors.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#of(neureka.Tsr,char,neureka.Tsr,char,neureka.Tsr)">of</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
  char&nbsp;o1,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;b,
  char&nbsp;o2,
  <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;c)</code></th>
<td class="colLast">
<div class="block">Use this to conveniently operate on 3 tensors.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>static <a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Byte&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofBytes()">ofBytes</a></span>()</code></th>
<td class="colLast">
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Byte.class)</code>.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>static <a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Double&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofDoubles()">ofDoubles</a></span>()</code></th>
<td class="colLast">
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Double.class)</code>.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>static <a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Float&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofFloats()">ofFloats</a></span>()</code></th>
<td class="colLast">
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Float.class)</code>.</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>static <a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Integer&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofInts()">ofInts</a></span>()</code></th>
<td class="colLast">
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Integer.class)</code>.</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>static &lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofRandom(java.lang.Class,int...)">ofRandom</a></span>&#8203;(java.lang.Class&lt;V&gt;&nbsp;valueTypeClass,
        int...&nbsp;shape)</code></th>
<td class="colLast">
<div class="block">This factory method produces a randomly populated tensor of the provided
  type and shape using a hard coded default seed.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>static <a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Short&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofShorts()">ofShorts</a></span>()</code></th>
<td class="colLast">
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Short.class)</code>.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#plus(double)">plus</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">This method will create a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  with the provided double scalar added to all elements of this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#plus(neureka.Tsr)">plus</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">This method will produce the sum of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#plusAssign(neureka.Tsr)">plusAssign</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#power(double)">power</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#power(neureka.Tsr)">power</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">The <a href="#power(neureka.Tsr)"><code>power(Tsr)</code></a> (Tsr)} method will produce the power of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#putAt(int%5B%5D,V)">putAt</a></span>&#8203;(int[]&nbsp;indices,
     <a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;item)</code></th>
<td class="colLast">
<div class="block">Use this to place an element at a particular position
  within this tensor by providing a array of axis indices and said element.</div>
</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#putAt(java.util.List,neureka.Tsr)">putAt</a></span>&#8203;(java.util.List&lt;?&gt;&nbsp;key,
     <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;value)</code></th>
<td class="colLast">
<div class="block">This method enables injecting slices of tensor to be assigned into this tensor!
  It takes a key of various types which is used to configure a slice
  tensor sharing the same underlying data as the original tensor.</div>
</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#putAt(java.util.Map,neureka.Tsr)">putAt</a></span>&#8203;(java.util.Map&lt;?,&#8203;java.lang.Integer&gt;&nbsp;key,
     <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;value)</code></th>
<td class="colLast">
<div class="block">This method enables assigning a provided tensor to be a subset of this tensor!
  It takes a key which is used to configure a slice
  sharing the same underlying data as the original tensor.</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rem(int)">rem</a></span>&#8203;(int&nbsp;other)</code></th>
<td class="colLast">
<div class="block">This method is synonymous to the <a href="#mod(int)"><code>mod(int)</code></a> method.</div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rqsGradient()">rqsGradient</a></span>()</code></th>
<td class="colLast">
<div class="block">This flag will indirectly trigger the activation of the autograd / auto-differentiation system of this library!
  If the flag is set to 'true' and the tensor is used for computation then
  it will also receive gradients when the <a href="#backward()"><code>backward()</code></a> method is being called
  on any descendant tensor within the computation graph.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setGradientApplyRequested(boolean)">setGradientApplyRequested</a></span>&#8203;(boolean&nbsp;applyRequested)</code></th>
<td class="colLast">
<div class="block">This flag works alongside two autograd features which can be enables inside the library settings.</div>
</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setIsOutsourced(boolean)">setIsOutsourced</a></span>&#8203;(boolean&nbsp;isOutsourced)</code></th>
<td class="colLast">
<div class="block">This method informs this tensor if it's data is supposed to be kept in RAM
  or if it has already been migrated somewhere else.</div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setIsVirtual(boolean)">setIsVirtual</a></span>&#8203;(boolean&nbsp;isVirtual)</code></th>
<td class="colLast">
<div class="block">Virtualizing is the opposite to actualizing a tensor.</div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRqsGradient(boolean)">setRqsGradient</a></span>&#8203;(boolean&nbsp;rqsGradient)</code></th>
<td class="colLast">
<div class="block">Settings this flag via this setter will indirectly trigger the activation of
  the autograd / auto-differentiation system of this library!
  If the flag is set to 'true' and the tensor is used for computation then
  it will also receive gradients when the <a href="#backward()"><code>backward()</code></a> method is being called
  on any descendant tensor within the computation graph.</div>
</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setValue(java.lang.Object)">setValue</a></span>&#8203;(java.lang.Object&nbsp;value)</code></th>
<td class="colLast">
<div class="block">This method will receive an object an try to interpret
  it or its contents to be set as value for this tensor.</div>
</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setValueAt(int,V)">setValueAt</a></span>&#8203;(int&nbsp;i,
          <a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;o)</code></th>
<td class="colLast">
<div class="block">A tensor ought to have some way to selectively modify its underlying value array.</div>
</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shallowCopy()">shallowCopy</a></span>()</code></th>
<td class="colLast">
<div class="block">This is technically the equivalent to a full slice.</div>
</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code><a href="fluent/slicing/SliceBuilder.html" title="class in neureka.fluent.slicing">SliceBuilder</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#slice()">slice</a></span>()</code></th>
<td class="colLast">
<div class="block">This method returns a <a href="fluent/slicing/SliceBuilder.html" title="class in neureka.fluent.slicing"><code>SliceBuilder</code></a> instance exposing a simple builder API
  which enables the configuration of a slice of the current tensor via method chaining.</div>
</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sliceCount()">sliceCount</a></span>()</code></th>
<td class="colLast">
<div class="block">This method returns the number of slices which have been
  created from this very tensor.</div>
</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sum()">sum</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i145" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#T()">T</a></span>()</code></th>
<td class="colLast">
<div class="block">A method which returns a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance which is a transposed twin of this instance.</div>
</td>
</tr>
<tr id="i146" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#times(neureka.Tsr)">times</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">The <a href="#times(neureka.Tsr)"><code>times(Tsr)</code></a> method is synonymous to the <a href="#multiply(neureka.Tsr)"><code>multiply(Tsr)</code></a>.</div>
</td>
</tr>
<tr id="i147" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#times(V)">times</a></span>&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i148" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timesAssign(neureka.Tsr)">timesAssign</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i149" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timesAssign(V)">timesAssign</a></span>&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i150" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#to(java.lang.String)">to</a></span>&#8203;(java.lang.String&nbsp;deviceType)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i151" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#to(neureka.devices.Device)">to</a></span>&#8203;(<a href="devices/Device.html" title="interface in neureka.devices">Device</a>&lt;?&gt;&nbsp;device)</code></th>
<td class="colLast">
<div class="block">This method taked a <a href="devices/Device.html" title="interface in neureka.devices"><code>Device</code></a> and tries to migrate the contents of this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
 instance to that <a href="devices/Device.html" title="interface in neureka.devices"><code>Device</code></a>!</div>
</td>
</tr>
<tr id="i152" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i153" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString(java.lang.String)">toString</a></span>&#8203;(java.lang.String&nbsp;mode)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i154" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString(java.util.function.Consumer)">toString</a></span>&#8203;(java.util.function.Consumer&lt;<a href="view/TsrStringSettings.html" title="class in neureka.view">TsrStringSettings</a>&gt;&nbsp;config)</code></th>
<td class="colLast">
<div class="block">This allows you to provide a lambda to configure how this tensor should be
  converted to <code>String</code> instances.</div>
</td>
</tr>
<tr id="i155" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString(neureka.view.TsrStringSettings)">toString</a></span>&#8203;(<a href="view/TsrStringSettings.html" title="class in neureka.view">TsrStringSettings</a>&nbsp;config)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i156" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#update(neureka.common.composition.Component.OwnerChangeRequest)">update</a></span>&#8203;(<a href="common/composition/Component.OwnerChangeRequest.html" title="interface in neureka.common.composition">Component.OwnerChangeRequest</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&gt;&nbsp;changeRequest)</code></th>
<td class="colLast">
<div class="block">Important : Components of type <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> are simply gradients!
  Currently this method is used only to catch illegal arguments which
  is for example the case when trying to attach a gradient with a different shape...</div>
</td>
</tr>
<tr id="i157" class="rowColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#xor(double)">xor</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">This method is synonymous to the <a href="#power(neureka.Tsr)"><code>power(Tsr)</code></a> method.</div>
</td>
</tr>
<tr id="i158" class="altColor">
<td class="colFirst"><code><a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#xor(neureka.Tsr)">xor</a></span>&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">This method is synonymous to the <a href="#power(neureka.Tsr)"><code>power(Tsr)</code></a> method.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.neureka.ndim.AbstractTensor">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;neureka.ndim.<a href="ndim/AbstractTensor.html" title="class in neureka.ndim">AbstractTensor</a></h3>
<code><a href="ndim/AbstractTensor.html#_actualize()">_actualize</a>, <a href="ndim/AbstractTensor.html#_allocate(int)">_allocate</a>, <a href="ndim/AbstractTensor.html#_convertedDataOfType(java.lang.Class)">_convertedDataOfType</a>, <a href="ndim/AbstractTensor.html#_getData()">_getData</a>, <a href="ndim/AbstractTensor.html#_guardGet(java.lang.String)">_guardGet</a>, <a href="ndim/AbstractTensor.html#_guardMod(java.lang.String)">_guardMod</a>, <a href="ndim/AbstractTensor.html#_guardSet(java.lang.String)">_guardSet</a>, <a href="ndim/AbstractTensor.html#_initData(neureka.ndim.Filler)">_initData</a>, <a href="ndim/AbstractTensor.html#_setData(java.lang.Object)">_setData</a>, <a href="ndim/AbstractTensor.html#_setDataType(neureka.dtype.DataType)">_setDataType</a>, <a href="ndim/AbstractTensor.html#_setNDConf(neureka.ndim.config.NDConfiguration)">_setNDConf</a>, <a href="ndim/AbstractTensor.html#_virtualize()">_virtualize</a>, <a href="ndim/AbstractTensor.html#createConstructionAPI()">createConstructionAPI</a>, <a href="ndim/AbstractTensor.html#getDataType()">getDataType</a>, <a href="ndim/AbstractTensor.html#getNDConf()">getNDConf</a>, <a href="ndim/AbstractTensor.html#getRepresentativeValueClass()">getRepresentativeValueClass</a>, <a href="ndim/AbstractTensor.html#getValueClass()">getValueClass</a>, <a href="ndim/AbstractTensor.html#is(java.lang.Class)">is</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.neureka.common.composition.AbstractComponentOwner">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;neureka.common.composition.<a href="common/composition/AbstractComponentOwner.html" title="class in neureka.common.composition">AbstractComponentOwner</a></h3>
<code><a href="common/composition/AbstractComponentOwner.html#_deleteComponents()">_deleteComponents</a>, <a href="common/composition/AbstractComponentOwner.html#_set(neureka.common.composition.Component)">_set</a>, <a href="common/composition/AbstractComponentOwner.html#_this()">_this</a>, <a href="common/composition/AbstractComponentOwner.html#_transferFrom(neureka.common.composition.AbstractComponentOwner)">_transferFrom</a>, <a href="common/composition/AbstractComponentOwner.html#forComponent(java.lang.Class,java.util.function.Consumer)">forComponent</a>, <a href="common/composition/AbstractComponentOwner.html#get(java.lang.Class)">get</a>, <a href="common/composition/AbstractComponentOwner.html#getAll(java.lang.Class)">getAll</a>, <a href="common/composition/AbstractComponentOwner.html#has(java.lang.Class)">has</a>, <a href="common/composition/AbstractComponentOwner.html#remove(java.lang.Class)">remove</a>, <a href="common/composition/AbstractComponentOwner.html#set(T)">set</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Iterable">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;java.lang.Iterable</h3>
<code>forEach, spliterator</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.neureka.ndim.NDimensional">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;neureka.ndim.<a href="ndim/NDimensional.html" title="interface in neureka.ndim">NDimensional</a></h3>
<code><a href="ndim/NDimensional.html#getRank()">getRank</a>, <a href="ndim/NDimensional.html#getShape()">getShape</a>, <a href="ndim/NDimensional.html#getSize()">getSize</a>, <a href="ndim/NDimensional.html#indexOfIndex(int)">indexOfIndex</a>, <a href="ndim/NDimensional.html#indexOfIndices(int%5B%5D)">indexOfIndices</a>, <a href="ndim/NDimensional.html#indicesMap()">indicesMap</a>, <a href="ndim/NDimensional.html#indicesOfIndex(int)">indicesOfIndex</a>, <a href="ndim/NDimensional.html#offset()">offset</a>, <a href="ndim/NDimensional.html#rank()">rank</a>, <a href="ndim/NDimensional.html#shape()">shape</a>, <a href="ndim/NDimensional.html#shape(int)">shape</a>, <a href="ndim/NDimensional.html#size()">size</a>, <a href="ndim/NDimensional.html#spread()">spread</a>, <a href="ndim/NDimensional.html#translation()">translation</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.neureka.ndim.TensorAPI">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;neureka.ndim.<a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a></h3>
<code><a href="ndim/TensorAPI.html#at(int...)">at</a>, <a href="ndim/TensorAPI.html#get(int)">get</a>, <a href="ndim/TensorAPI.html#get(int...)">get</a>, <a href="ndim/TensorAPI.html#get(java.lang.Number)">get</a>, <a href="ndim/TensorAPI.html#get(java.lang.Object)">get</a>, <a href="ndim/TensorAPI.html#get(java.lang.Object...)">get</a>, <a href="ndim/TensorAPI.html#getAt(int)">getAt</a>, <a href="ndim/TensorAPI.html#getAt(java.lang.Number)">getAt</a>, <a href="ndim/TensorAPI.html#getAt(java.lang.Object...)">getAt</a>, <a href="ndim/TensorAPI.html#getValueAt(int)">getValueAt</a>, <a href="ndim/TensorAPI.html#getValueAt(int...)">getValueAt</a>, <a href="ndim/TensorAPI.html#putAt(int,V)">putAt</a>, <a href="ndim/TensorAPI.html#putAt(java.util.List,V)">putAt</a>, <a href="ndim/TensorAPI.html#set(int%5B%5D,V)">set</a>, <a href="ndim/TensorAPI.html#set(int,V)">set</a>, <a href="ndim/TensorAPI.html#valueClass()">valueClass</a></code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="newInstance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newInstance</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Object&gt;&nbsp;newInstance()</pre>
<div class="block">This static factory method creates and return a completely empty and undefined tensor
  which is void of any contents and meaning.
  The use case for this would be to use the produced <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance as a target for an inline operations which fills the instance with an actual value. <br>
  An example of this approach would be to call the <a href="#putAt(java.util.List,neureka.Tsr)"><code>putAt(List, Tsr)</code></a> method with an empty list as key.
  This will be interpreted as an inline copy of the contents of the
  second parameter into this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new and completely empty / unitialized <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance.</dd>
</dl>
</li>
</ul>
<a id="of(neureka.Tsr,char,neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
                            char&nbsp;o,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;b)</pre>
<div class="block">Use this to conveniently operate on 2 tensors.
  A simple example would be: <code>Tsr.of(a,'*',b)</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The value item type parameter for the involved tensors.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - The left operand.</dd>
<dd><code>o</code> - The operator, which may be '+', '-', '*'...</dd>
<dd><code>b</code> - The right operand.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The result of the operation defined by the provided character.</dd>
</dl>
</li>
</ul>
<a id="of(neureka.Tsr,char,neureka.Tsr,char,neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
                            char&nbsp;o1,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;b,
                            char&nbsp;o2,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;c)</pre>
<div class="block">Use this to conveniently operate on 3 tensors.
  A simple example would be: <code>Tsr.of(a,'*',b,'+',c)</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The value item type parameter for the involved tensors.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - The first and left most operand.</dd>
<dd><code>o1</code> - The first operator, which may be '+', '-', '*'...</dd>
<dd><code>b</code> - The second operand.</dd>
<dd><code>o2</code> - The second operator, which may also be '+', '-', '*'...</dd>
<dd><code>c</code> - The third and last operand.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The result of the operations defined by the 2 provided characters.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.String,neureka.Tsr,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(java.lang.String&nbsp;e1,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
                            java.lang.String&nbsp;e2)</pre>
<div class="block">Use this to conveniently operate on a tensor.
  A simple example would be: <code>Tsr.of("sig(tanh(",a,"))")</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The value item type parameter for the involved tensor.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>e1</code> - The first part of the string expression defining how the provided tensor should be processed.</dd>
<dd><code>a</code> - The tensor which ought to be sent to whatever is defined by the provided expressions.</dd>
<dd><code>e2</code> - The latter part of the expression defining how the provided tensor should be executed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The result of the operation(s) defined by the provided strings.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.String,neureka.Tsr,char,neureka.Tsr,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(java.lang.String&nbsp;e1,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
                            char&nbsp;o,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;b,
                            java.lang.String&nbsp;e2)</pre>
<div class="block">Use this to conveniently operate on 2 tensors.
  A simple example would be: <code>Tsr.of("relu(",a,'-',b,")*2")</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The value item type parameter for the involved tensor.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>e1</code> - The first part of the string expression defining how the provided tensor should be processed.</dd>
<dd><code>a</code> - The first tensor which ought to be sent to whatever function is defined by the provided expressions.</dd>
<dd><code>o</code> - An operator combining both <code>a</code> and <code>b</code> to form a result.</dd>
<dd><code>b</code> - The second tensor and right operand which ought to be sent to whatever function is defined by the provided expressions.</dd>
<dd><code>e2</code> - The latter part of the expression defining how the provided tensor should be executed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The result of the operation(s) defined by the provided strings.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.String,neureka.Tsr,java.lang.String,neureka.Tsr,java.lang.String,neureka.Tsr,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(java.lang.String&nbsp;e1,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;a,
                            java.lang.String&nbsp;e2,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;b,
                            java.lang.String&nbsp;e3,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;c,
                            java.lang.String&nbsp;e4)</pre>
<div class="block">Use this to conveniently operate on 3 tensors.
  A simple example would be:
  <code>Tsr.of("abs((",a,"-",b,") * ",c,")")</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type parameter for the involved tensors.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>e1</code> - The first part of the expression which would typically be used to define a function name.</dd>
<dd><code>a</code> - The first argument.</dd>
<dd><code>e2</code> - The second part of the expression, which might be an operation.</dd>
<dd><code>b</code> - The second argument.</dd>
<dd><code>e3</code> - The third part of the expression...</dd>
<dd><code>c</code> - The third argument.</dd>
<dd><code>e4</code> - The last part of the expression which should syntactically match the other expression...</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The result of the calculation defined by the provided expressions and arguments.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(java.lang.Object...&nbsp;args)</pre>
<div class="block">This static <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> factory method tries to interpret the provided
  arguments to create the instance the use might wants.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>args</code> - The arguments which ought to be interpreted.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The result of the interpretation in the form of a <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance of typ <code>Object</code>.</dd>
</dl>
</li>
</ul>
<a id="of(java.util.List,java.lang.Object)">
<!--   -->
</a><a id="of(java.util.List,T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
                            T&nbsp;value)</pre>
<div class="block">This is a convenient factory method for creating <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instances for
  values of type <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> based on a list of integers
  defining a shape made up of axes sizes as well as a scalar value of type <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  which will fill out the data array spanned by the provided shape information.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shape</code> - A list of integers whose values ought to define the size of the axes of the shape of the new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</dd>
<dd><code>value</code> - An object of type <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> which will populate the data array of the new instance.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance for the generic type <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</dd>
</dl>
</li>
</ul>
<a id="of(java.util.List,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;&nbsp;of&#8203;(java.util.List&lt;? extends java.lang.Number&gt;&nbsp;shape,
                                       java.lang.String&nbsp;seed)</pre>
<div class="block">This factory method will create and return a <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance
  based on a list of <code>Number</code> instances whose rounded values will be interpreted as
  the shape of this new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance and a seed which will serve
  as a source of pseudo randomness to generate the values for the new instance.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shape</code> - A list of <code>Number</code> instances which will be interpreted as a shape array.</dd>
<dd><code>seed</code> - A source of pseudo randomness for the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance created by this method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance created based on a shape and a seed.</dd>
</dl>
</li>
</ul>
<a id="of(java.util.List,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.util.List&lt;? extends java.lang.Number&gt;&nbsp;shape,
                            java.util.List&lt;V&gt;&nbsp;value)</pre>
<div class="block">Creates a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance based on a list of numbers representing the shape,
  and a list of values representing the value of the resulting tensor.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>V</code> - The type parameter of the value list and returned tensor.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shape</code> - A list of numbers whose integer values will be used to form the shape of the resulting <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</dd>
<dd><code>value</code> - A list of values which will be used to populate the data array of the resulting <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance constructed based on the provided shape and value list.</dd>
</dl>
</li>
</ul>
<a id="of(int[],java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(int[]&nbsp;shape,
                            java.util.List&lt;V&gt;&nbsp;value)</pre>
<div class="block">Creates a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance based on an array of integers representing the shape,
  and a list of values representing the value of the resulting tensor.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>V</code> - The type parameter of the value list and returned tensor.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shape</code> - An array of integers will be used to form the shape of the resulting <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</dd>
<dd><code>value</code> - A list of values which will be used to populate the data array of the resulting <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance constructed based on the provided shape and value list.</dd>
</dl>
</li>
</ul>
<a id="of(java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Object&gt;&nbsp;of&#8203;(java.util.List&lt;java.lang.Object&gt;&nbsp;conf)</pre>
<div class="block">This factory method will turn a list of values or nested lists of values into a <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance with the corresponding rank and shape.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>conf</code> - A list of either values or nested lists which are themselves either or.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance whose shape and data is based on the provided list structure.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.Class,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(java.lang.Class&lt;T&gt;&nbsp;targetType,
                            java.util.List&lt;java.lang.Object&gt;&nbsp;conf)</pre>
<div class="block">This factory method will turn a list of values or nested lists of values into a <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance with the corresponding rank and shape and whose values
  are of the provided type.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type parameter of the tensor returned by this factoy method.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>targetType</code> - The type of the tensor produced by this factory method.</dd>
<dd><code>conf</code> - A list of either values or nested lists which are themselves either or.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance whose shape and data is based on the provided list structure.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.Class&lt;V&gt;&nbsp;typeClass)</pre>
<div class="block">This is the entry point to the fluent tensor builder API for building
  <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instances in a readable and type safe fashion.
  The returned <a href="fluent/building/states/WithShapeOrScalarOrVector.html" title="interface in neureka.fluent.building.states"><code>WithShapeOrScalarOrVector</code></a> is the next step in the
  fluent <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which will lead to the creation
  of a tensor storing values defined by the provided type class.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The next step of the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which exposes methods for defining shapes.</dd>
</dl>
</li>
</ul>
<a id="ofDoubles()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ofDoubles</h4>
<pre class="methodSignature">public static&nbsp;<a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Double&gt;&nbsp;ofDoubles()</pre>
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Double.class)</code>.
  The returned <a href="fluent/building/states/WithShapeOrScalarOrVector.html" title="interface in neureka.fluent.building.states"><code>WithShapeOrScalarOrVector</code></a> is the next step in the
  fluent <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which in this case will lead to the creation
  of a tensor storing doubles.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The next step of the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which exposes methods for defining shapes.</dd>
</dl>
</li>
</ul>
<a id="ofFloats()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ofFloats</h4>
<pre class="methodSignature">public static&nbsp;<a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Float&gt;&nbsp;ofFloats()</pre>
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Float.class)</code>.
  The returned <a href="fluent/building/states/WithShapeOrScalarOrVector.html" title="interface in neureka.fluent.building.states"><code>WithShapeOrScalarOrVector</code></a> is the next step in the
  fluent <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which in this case will lead to the creation
  of a tensor storing floats.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The next step of the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which exposes methods for defining shapes.</dd>
</dl>
</li>
</ul>
<a id="ofInts()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ofInts</h4>
<pre class="methodSignature">public static&nbsp;<a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Integer&gt;&nbsp;ofInts()</pre>
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Integer.class)</code>.
  The returned <a href="fluent/building/states/WithShapeOrScalarOrVector.html" title="interface in neureka.fluent.building.states"><code>WithShapeOrScalarOrVector</code></a> is the next step in the
  fluent <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which in this case will lead to the creation
  of a tensor storing integers.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The next step of the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which exposes methods for defining shapes.</dd>
</dl>
</li>
</ul>
<a id="ofShorts()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ofShorts</h4>
<pre class="methodSignature">public static&nbsp;<a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Short&gt;&nbsp;ofShorts()</pre>
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Short.class)</code>.
  The returned <a href="fluent/building/states/WithShapeOrScalarOrVector.html" title="interface in neureka.fluent.building.states"><code>WithShapeOrScalarOrVector</code></a> is the next step in the
  fluent <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which in this case will lead to the creation
  of a tensor storing shorts.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The next step of the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which exposes methods for defining shapes.</dd>
</dl>
</li>
</ul>
<a id="ofBytes()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ofBytes</h4>
<pre class="methodSignature">public static&nbsp;<a href="fluent/building/states/WithShapeOrScalarOrVectorOnDevice.html" title="interface in neureka.fluent.building.states">WithShapeOrScalarOrVectorOnDevice</a>&lt;java.lang.Byte&gt;&nbsp;ofBytes()</pre>
<div class="block">This is a simple convenience method which is simply calling the <a href="#of(java.lang.Class)"><code>of(Class)</code></a>
  method like so: <code>Tsr.of(Byte.class)</code>.
  The returned <a href="fluent/building/states/WithShapeOrScalarOrVector.html" title="interface in neureka.fluent.building.states"><code>WithShapeOrScalarOrVector</code></a> is the next step in the
  fluent <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which in this case will lead to the creation
  of a tensor storing bytes.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The next step of the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> builder API which exposes methods for defining shapes.</dd>
</dl>
</li>
</ul>
<a id="of(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;&nbsp;of&#8203;(double&nbsp;value)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The scalar value which ought to be represented as tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A scalar double tensor.</dd>
</dl>
</li>
</ul>
<a id="of(float...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Float&gt;&nbsp;of&#8203;(float...&nbsp;value)</pre>
<div class="block">Constructs a vector of floats based on the provided array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The array of floats from which a 1D tensor ought to be constructed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vector / 1D tensor of floats.</dd>
</dl>
</li>
</ul>
<a id="of(double...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;&nbsp;of&#8203;(double...&nbsp;value)</pre>
<div class="block">Constructs a vector of doubles based on the provided array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The array of doubles from which a 1D tensor ought to be constructed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vector / 1D tensor of doubles.</dd>
</dl>
</li>
</ul>
<a id="of(byte...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Byte&gt;&nbsp;of&#8203;(byte...&nbsp;value)</pre>
<div class="block">Constructs a vector of bytes based on the provided array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The array of bytes from which a 1D tensor ought to be constructed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vector / 1D tensor of bytes.</dd>
</dl>
</li>
</ul>
<a id="of(int...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Integer&gt;&nbsp;of&#8203;(int...&nbsp;value)</pre>
<div class="block">Constructs a vector of ints based on the provided array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The array of ints from which a 1D tensor ought to be constructed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vector / 1D tensor of ints.</dd>
</dl>
</li>
</ul>
<a id="of(long...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Long&gt;&nbsp;of&#8203;(long...&nbsp;value)</pre>
<div class="block">Constructs a vector of longs based on the provided array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The array of longs from which a 1D tensor ought to be constructed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vector / 1D tensor of longs.</dd>
</dl>
</li>
</ul>
<a id="of(short...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Short&gt;&nbsp;of&#8203;(short...&nbsp;value)</pre>
<div class="block">Constructs a vector of shorts based on the provided array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The array of shorts from which a 1D tensor ought to be constructed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vector / 1D tensor of shorts.</dd>
</dl>
</li>
</ul>
<a id="of(boolean...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Boolean&gt;&nbsp;of&#8203;(boolean...&nbsp;value)</pre>
<div class="block">Constructs a vector of booleans based on the provided array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The array of booleans from which a 1D tensor ought to be constructed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vector / 1D tensor of shorts.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.Class,int[],java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.Class&lt;V&gt;&nbsp;valueType,
                            int[]&nbsp;shape,
                            java.lang.String&nbsp;seed)</pre>
<div class="block">Use this to construct and return a seeded tensor of the specified type.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>V</code> - The type parameter of individual tensor items.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>valueType</code> - The type class of the items stored by the resulting tensor.</dd>
<dd><code>shape</code> - The shape of the resulting tensor consisting of any number of axis-sizes.</dd>
<dd><code>seed</code> - An arbitrary <code>String</code> whose hash will be used to as a seed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A newly created and seeded tensor of the provided type and shape.</dd>
</dl>
</li>
</ul>
<a id="of(int[],double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;&nbsp;of&#8203;(int[]&nbsp;shape,
                                       double&nbsp;value)</pre>
</li>
</ul>
<a id="of(int[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Double&gt;&nbsp;of&#8203;(int[]&nbsp;shape,
                                       double[]&nbsp;value)</pre>
</li>
</ul>
<a id="of(int[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Integer&gt;&nbsp;of&#8203;(int[]&nbsp;shape,
                                        int[]&nbsp;value)</pre>
</li>
</ul>
<a id="of(int[],byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Byte&gt;&nbsp;of&#8203;(int[]&nbsp;shape,
                                     byte[]&nbsp;value)</pre>
</li>
</ul>
<a id="of(int[],long[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Long&gt;&nbsp;of&#8203;(int[]&nbsp;shape,
                                     long[]&nbsp;value)</pre>
</li>
</ul>
<a id="of(int[],short[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Short&gt;&nbsp;of&#8203;(int[]&nbsp;shape,
                                      short[]&nbsp;value)</pre>
</li>
</ul>
<a id="of(int[],float[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Float&gt;&nbsp;of&#8203;(int[]&nbsp;shape,
                                      float[]&nbsp;value)</pre>
</li>
</ul>
<a id="of(int[],boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;java.lang.Boolean&gt;&nbsp;of&#8203;(int[]&nbsp;shape,
                                        boolean[]&nbsp;value)</pre>
</li>
</ul>
<a id="of(neureka.dtype.DataType,int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;V&gt;&nbsp;type,
                            int[]&nbsp;shape)</pre>
</li>
</ul>
<a id="of(java.lang.Class,int[],java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.Class&lt;V&gt;&nbsp;typeClass,
                            int[]&nbsp;shape,
                            java.lang.Object&nbsp;data)</pre>
</li>
</ul>
<a id="of(java.lang.Class,java.util.List,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.Class&lt;V&gt;&nbsp;typeClass,
                            java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
                            java.lang.Object&nbsp;data)</pre>
</li>
</ul>
<a id="of(java.lang.Class,java.util.List,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.Class&lt;V&gt;&nbsp;typeClass,
                            java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
                            java.util.List&lt;V&gt;&nbsp;data)</pre>
</li>
</ul>
<a id="of(neureka.dtype.DataType,java.util.List,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;V&gt;&nbsp;dataType,
                            java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
                            java.util.List&lt;V&gt;&nbsp;data)</pre>
</li>
</ul>
<a id="of(neureka.dtype.DataType,int[],java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;V&gt;&nbsp;dataType,
                            int[]&nbsp;shape,
                            java.lang.Object&nbsp;data)</pre>
<div class="block">This factory method is among the most flexible and forgiving ways to create a <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance.
  It receives a <a href="dtype/DataType.html" title="class in neureka.dtype"><code>DataType</code></a> for type safety and to ensure that the produced <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance
  will contain elements of the correct type, a shape array which stores the sizes of the axes that the
  instance ought to possess, and finally it receives a data <code>Object</code> which can be anything ranging from
  a <code>List</code> to an array or simply a single value which ought to fill out the entire <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dataType</code> - The data type of the data represented by <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance created by this method.</dd>
<dd><code>shape</code> - An array of axis sizes describing the dimensionality of the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> created by this method.</dd>
<dd><code>data</code> - The data for the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> that is about to be created, which can be a list, an array or scalar.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance of the specified type, shape and containing the provided data.</dd>
</dl>
</li>
</ul>
<a id="of(neureka.dtype.DataType,java.util.List,neureka.ndim.Filler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;T&gt;&nbsp;type,
                            java.util.List&lt;java.lang.Integer&gt;&nbsp;shape,
                            <a href="ndim/Filler.html" title="interface in neureka.ndim">Filler</a>&lt;T&gt;&nbsp;filler)</pre>
<div class="block">This factory method allows the creation of tensors with an additional initialization
  lambda for filling the underlying data array with desired values.
  Other than regular numeric types it is also possible to initialize the
  tensor with regular Objects like String instances or custom data types like complex
  numbers for example... <br>
  Therefore the constructor requires not only a shape as argument but also
  the data type which ought to be allocated as well as the initialization
  lambda which will be called iteratively.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type parameter for the actual data array items.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The data type this tensor ought to have.</dd>
<dd><code>shape</code> - The shape of this new tensor ought to have.</dd>
<dd><code>filler</code> - The lambda Object which ought to fill this tensor with the appropriate data.</dd>
</dl>
</li>
</ul>
<a id="of(neureka.dtype.DataType,int[],neureka.ndim.Filler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;of&#8203;(<a href="dtype/DataType.html" title="class in neureka.dtype">DataType</a>&lt;T&gt;&nbsp;type,
                            int[]&nbsp;shape,
                            <a href="ndim/Filler.html" title="interface in neureka.ndim">Filler</a>&lt;T&gt;&nbsp;filler)</pre>
<div class="block">This factory method allows the creation of tensors with an additional initialization
  lambda for filling the underlying data array with desired values.
  Besides regular numeric types it is also possible to initialize the
  tensor with regular objects like <code>String</code> instances or custom data types like complex
  numbers for example... <br>
  Therefore the constructor requires not only a shape as argument but also
  the data type which ought to be allocated as well as the initialization
  lambda which will be called iteratively.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type parameter for the actual data array items.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The data type this tensor ought to have.</dd>
<dd><code>shape</code> - The shape of this new tensor ought to have.</dd>
<dd><code>filler</code> - The lambda Object which ought to fill this tensor with the appropriate data.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.String,java.lang.Number[])">
<!--   -->
</a><a id="of(java.lang.String,V...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;V extends java.lang.Number&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.String&nbsp;expression,
                                                     V...&nbsp;inputs)</pre>
<div class="block">This factory method allows for the creation and execution of <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instances
  without actually instantiating them manually,
  where the result will then be returned by this factory method. <br><br>
  The passed <code>String</code> will be parsed into a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> AST which will be cached
  using the expression as key in case it will be used in future constructor calls
  like this one, or elsewhere...
  The created / retrieved <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> will then be called with the supplied input list
  in order to trigger an execution.
  The result of which will be used for the population of the fields of this
  very instance.                                                                      <br>
  An example would be the following :                                                 <br>
 <ul>
      <li><i> 'Tsr a = Tsr.of( "sin( I[0] ) / I[1]", 12f, -6.34f )'</i></li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expression</code> - A String which will be used for parsing a Function AST.</dd>
<dd><code>inputs</code> - An array of inputs which can be tensors or numeric types.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.String,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.String&nbsp;expression,
                            java.util.List&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&gt;&nbsp;inputs)</pre>
<div class="block">This factory method allows for the creation and execution of <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instances
  without actually instantiating them manually,
  where the result will then be returned by this factory method. <br><br>
  The passed <code>String</code> will be parsed into a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> AST which will be cached
  using the expression as key in case it will be used in future constructor calls
  like this one, or elsewhere...
  The created / retrieved <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> will then be called with the supplied input list
  in order to trigger an execution.
  The result of which will be used for the population of the fields of this
  very instance.                                                                      <br>
  An example would be the following :                                                 <br>
 <ul>
      <li><i> 'Tsr a = Tsr.of( "sin( I[0] ) / I[1]", List.of(b, c) )'</i></li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expression</code> - A String which will be used for parsing a Function AST.</dd>
<dd><code>inputs</code> - A list of inputs which can be tensors or numeric types.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.String,boolean,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.String&nbsp;expression,
                            boolean&nbsp;doAD,
                            java.util.List&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&gt;&nbsp;tensors)</pre>
<div class="block">This method takes a list of tensors and a String expression describing
  operations which ought to be applied to the tensors in said list.
  It also receives a boolean flag which determines if the defined function
  should be executed with autograd enabled.
  The provided expression will be parsed to a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instance expecting as many inputs
  as there are array entries, namely : "I[0]", "I[1]", "I[2]", ...                    <br>
  An example would be the following :                                                 <br>
 <ul>
      <li><i> 'Tsr a = Tsr.of( "sin( I[0] ) / I[1]", true, List.of(b, c) )'</i></li>
 </ul>
  Which takes the tensor 'b' and 'c' and applies the function "f(x,y) = sin(x) / y"
  element-wise to produce a new tensor 'a'!
  Additionally, there is a helpful flag which allows one to specify if the
  parsed <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instance emerging from the provided expression
  should also allow the tracking of computations via a computation graph (<a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> instances).
  This history tracking then enables auto-differentiation. <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expression</code> - The expression describing operations applied to the provided tensors.</dd>
<dd><code>doAD</code> - A flag which when set to true commands the creation of a computation graph during operation execution.</dd>
<dd><code>tensors</code> - A list of tensors used as inputs to the Function instance parsed from the provided expression.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.String,neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.String&nbsp;expression,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;tensor)</pre>
<div class="block">This method takes a tensor and a String expression describing
  operations which ought to be applied to said tensor.
  This expression will be parsed to a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instance expecting one input,
  namely : "I[0]" <br>
  An example would be the following :
 <ul>
      <li><i> 'Tsr a = Tsr.of( "sin( I[0] ) * 2", b )'</i></li>
 </ul>

  Which takes the tensor 'b' and applies the function "f(x) = sin(x) * 2"
  element-wise to produce a new tensor 'a'! <br>
  <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tensor</code> - A tensor which serves as input to the Function instance parsed from the given expression.</dd>
<dd><code>expression</code> - The expression describing operations applied to the provided tensor.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.String,neureka.Tsr...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.String&nbsp;expression,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;...&nbsp;tensors)</pre>
<div class="block">This method takes an array of tensors and a String expression describing
  operations which ought to be applied to the tensors in said array.
  This expression will be parsed to a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instance expecting as many inputs
  as there are array entries, namely : "I[0]", "I[1]", "I[2]", ... <br>
  An example would be the following :
 <ul>
      <li><i> 'Tsr a = Tsr.of( "sin( I[0] ) / I[1]", b, c )'</i></li>
 </ul>

  Which takes the tensor 'b' and 'c' and applies the function "f(x,y) = sin(x) / y"
  element-wise to produce a new tensor 'a'! <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expression</code> - The expression describing operations applied to the provided tensors.</dd>
<dd><code>tensors</code> - An array of tensors used as inputs to the Function instance parsed from the provided expression.</dd>
</dl>
</li>
</ul>
<a id="of(java.lang.String,boolean,neureka.Tsr...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>of</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;of&#8203;(java.lang.String&nbsp;expression,
                            boolean&nbsp;doAD,
                            <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;...&nbsp;tensors)</pre>
<div class="block">This method takes an array of tensors and a String expression describing
  operations which ought to be applied to the tensors in said array.
  It also receives a boolean flag which determines if the defined function
  should be executed with autograd enabled.
  The provided expression will be parsed to a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instance expecting as many inputs
  as there are array entries, namely : "I[0]", "I[1]", "I[2]", ...                    <br>
  An example would be the following :                                                 <br>
 <ul>
      <li><i> 'Tsr a = Tsr.of( "sin( I[0] ) / I[1]", true, b, c )'</i></li>
 </ul>
  Which takes the tensor 'b' and 'c' and applies the function "f(x,y) = sin(x) / y"
  element-wise to produce a new tensor 'a'!
  Additionally, there is a helpful flag which allows one to specify if the
  parsed <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instance emerging from the provided expression
  should also allow the tracking of computations via a computation graph (<a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> instances).
  This history tracking then enables auto-differentiation. <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expression</code> - The expression describing operations applied to the provided tensors.</dd>
<dd><code>doAD</code> - A flag which when set to true commands the creation of a computation graph during operation execution.</dd>
<dd><code>tensors</code> - An array of tensors used as inputs to the Function instance parsed from the provided expression.</dd>
</dl>
</li>
</ul>
<a id="setRqsGradient(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRqsGradient</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;setRqsGradient&#8203;(boolean&nbsp;rqsGradient)</pre>
<div class="block">Settings this flag via this setter will indirectly trigger the activation of
  the autograd / auto-differentiation system of this library!
  If the flag is set to 'true' and the tensor is used for computation then
  it will also receive gradients when the <a href="#backward()"><code>backward()</code></a> method is being called
  on any descendant tensor within the computation graph.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rqsGradient</code> - The truth value determining if this tensor ought to receive gradients via
                     the built-in automatic backpropagation system.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance in order to enable method chaining.</dd>
</dl>
</li>
</ul>
<a id="rqsGradient()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rqsGradient</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;rqsGradient()</pre>
<div class="block">This flag will indirectly trigger the activation of the autograd / auto-differentiation system of this library!
  If the flag is set to 'true' and the tensor is used for computation then
  it will also receive gradients when the <a href="#backward()"><code>backward()</code></a> method is being called
  on any descendant tensor within the computation graph.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor ought to receive gradients via
         the built in automatic backpropagation system.</dd>
</dl>
</li>
</ul>
<a id="_setRqsGradient(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_setRqsGradient</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_setRqsGradient&#8203;(boolean&nbsp;rqsGradient)</pre>
</li>
</ul>
<a id="isIntermediate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isIntermediate</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isIntermediate()</pre>
<div class="block">Intermediate tensors are internal non-user tensors which may be eligible
  for deletion when further consumed by a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a>.
  For the casual user of Neureka, this flag should always be false!</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor is not a user tensor but an internal
         tensor which may be eligible for deletion by <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a>s consuming it.</dd>
</dl>
</li>
</ul>
<a id="_setIsIntermediate(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_setIsIntermediate</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_setIsIntermediate&#8203;(boolean&nbsp;isIntermediate)</pre>
<div class="block">Intermediate tensors are internal non-user tensors which may be eligible
  for deletion when further consumed by a <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a>.
  For the casual user of Neureka, this flag should always be false!</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>isIntermediate</code> - The truth value determining if this tensor is not a user tensor but an internal
                       tensor which may be eligible for deletion by <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a>s consuming it.</dd>
</dl>
</li>
</ul>
<a id="setIsOutsourced(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setIsOutsourced</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;setIsOutsourced&#8203;(boolean&nbsp;isOutsourced)</pre>
<div class="block">This method informs this tensor if it's data is supposed to be kept in RAM
  or if it has already been migrated somewhere else.
  In the latter case, the tensor will nullify the reference to it's
  underlying data array to make it elegable for garbage collection.
  Otherwise, if <code>isOutsourced</code> is set to true, the method might
  allocate a new data array if none is present.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>isOutsourced</code> - The truth value which determines if this tensor should live in RAM or somewhere else.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance to allow for method chaining.</dd>
</dl>
</li>
</ul>
<a id="isOutsourced()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isOutsourced</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isOutsourced()</pre>
<div class="block">Outsourced means that the tensor is stored on a <a href="devices/Device.html" title="interface in neureka.devices"><code>Device</code></a> implementation instance.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if the data of this tensor is not actually stored inside of it
         in the form of of a traditional primitive JVM array!</dd>
</dl>
</li>
</ul>
<a id="_setIsOutsourced(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_setIsOutsourced</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_setIsOutsourced&#8203;(boolean&nbsp;isOutsourced)</pre>
</li>
</ul>
<a id="setIsVirtual(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setIsVirtual</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;setIsVirtual&#8203;(boolean&nbsp;isVirtual)</pre>
<div class="block">Virtualizing is the opposite to actualizing a tensor.
  A tensor is virtual if the size of the underlying data is not actually equal to
  the number of elements which the tensor claims to store, aka its size.
  This is for example the case when initializing a tensor filled with a single
  value continuously. In that case the tensor will flag itself as virtual and only allocate the
  underlying data array to hold a single item even though the tensor might actually hold
  many more items.
  The reasons for this feature is that it greatly improves performance in certain cases.
  In essence this feature is a form of lazy loading.
  <br><br></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/AbstractTensor.html#setIsVirtual(boolean)">setIsVirtual</a></code>&nbsp;in class&nbsp;<code><a href="ndim/AbstractTensor.html" title="class in neureka.ndim">AbstractTensor</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;,&#8203;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>isVirtual</code> - The truth value determining if this tensor ought to be virtualized.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very tensor to enable method chaining.</dd>
</dl>
</li>
</ul>
<a id="isVirtual()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isVirtual</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isVirtual()</pre>
<div class="block">A tensor is virtual if the size of the underlying data is not actually equal to
  the number of elements which the tensor claims to store, aka its size.
  This is for example the case when initializing a tensor filled with a single
  value continuously. In that case the tensor will flag itself as virtual and only allocate the
  underlying data array to hold a single item even though the tensor might actually hold
  many more items.
  The reasons for this feature is that it greatly improves performance in certain cases.
  In essence this feature is a form of lazy loading.
  <br><br></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/AbstractTensor.html#isVirtual()">isVirtual</a></code>&nbsp;in class&nbsp;<code><a href="ndim/AbstractTensor.html" title="class in neureka.ndim">AbstractTensor</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;,&#8203;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor is virtual (and therefore not "actual").</dd>
</dl>
</li>
</ul>
<a id="_setIsVirtual(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_setIsVirtual</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_setIsVirtual&#8203;(boolean&nbsp;isVirtual)</pre>
<div class="block">This method is the inner counterpart to the public "<a href="#setIsVirtual(boolean)"><code>setIsVirtual(boolean)</code></a>" method.
  It actually performs the bit flipping by applying the corresponding bit mask. <br>
  <br></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/AbstractTensor.html#_setIsVirtual(boolean)">_setIsVirtual</a></code>&nbsp;in class&nbsp;<code><a href="ndim/AbstractTensor.html" title="class in neureka.ndim">AbstractTensor</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;,&#8203;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>isVirtual</code> - The truth value which ought to be applied.</dd>
</dl>
</li>
</ul>
<a id="setGradientApplyRequested(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setGradientApplyRequested</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;setGradientApplyRequested&#8203;(boolean&nbsp;applyRequested)</pre>
<div class="block">This flag works alongside two autograd features which can be enables inside the library settings.
  They will come into effect when flipping their feature flags, <br>
  namely: <i>'isApplyingGradientWhenRequested'</i> and <i>'isApplyingGradientWhenTensorIsUsed'</i><br>
  As the first flag name suggests gradients will be applied to their tensors when it is set to true,
  however this will only happened when the second flag is set to true as well, because otherwise gradients
  wouldn't be applied to their tensors automatically in the first place... <br>
  <br>
  Setting both flags to true will inhibit effect of the second setting <i>'isApplyingGradientWhenTensorIsUsed'</i>
  unless a form of "permission" is being signaled to the autograd system.
  This signal comes in the form of a "request" flag which marks a tensor as <b>allowed to
  be updated by its gradient</b>.<br>
  <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>applyRequested</code> - The truth value determining if the application of the gradient of this tensor is requested.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very tensor instance in order to enable method chaining.</dd>
</dl>
</li>
</ul>
<a id="gradientApplyRequested()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gradientApplyRequested</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;gradientApplyRequested()</pre>
<div class="block">This flag works alongside two autograd features which can be enables inside the library settings.
  They will come into effect when flipping their feature flags, <br>
  namely: <i>'isApplyingGradientWhenRequested'</i> and <i>'isApplyingGradientWhenTensorIsUsed'</i><br>
  As the first flag name suggests gradients will be applied to their tensors when it is set to true,
  however this will only happened when the second flag is set to true as well, because otherwise gradients
  wouldn't be applied to their tensors automatically in the first place... <br>
  <br>
  Setting both flags to true will inhibit the effect of the second setting <i>'isApplyingGradientWhenTensorIsUsed'</i>
  unless a form of "permission" is being signaled to the autograd system.
  This signal comes in the form of a "request" flag which marks a tensor as <b>allowed to
  be updated by its gradient</b>.<br>
  <br></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if the application of the gradient of this tensor is requested.</dd>
</dl>
</li>
</ul>
<a id="isDeleted()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDeleted</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isDeleted()</pre>
<div class="block">This will check if the <a href="#_delete()"><code>_delete()</code></a> method was previously called on this tensor.
  This means that any references inside the tensor will be null
  as well as that the tensor data was freed on every device,
  meaning that what was previously referenced was most likely garbage collected...</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/AbstractTensor.html#isDeleted()">isDeleted</a></code>&nbsp;in class&nbsp;<code><a href="ndim/AbstractTensor.html" title="class in neureka.ndim">AbstractTensor</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;,&#8203;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value which determines if <a href="#_delete()"><code>_delete()</code></a> was called on this tensor,
         making it in essence an empty shell void of any references to data.</dd>
</dl>
</li>
</ul>
<a id="_setOrReject(neureka.common.composition.Component)">
<!--   -->
</a><a id="_setOrReject(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_setOrReject</h4>
<pre class="methodSignature">protected&nbsp;&lt;T extends <a href="common/composition/Component.html" title="interface in neureka.common.composition">Component</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&gt;&gt;&nbsp;T&nbsp;_setOrReject&#8203;(T&nbsp;newComponent)</pre>
<div class="block">This method is executed when a new Component is added to the tensor.
 The public add method is implemented in the super class
 '<a href="common/composition/AbstractComponentOwner.html" title="class in neureka.common.composition"><code>AbstractComponentOwner</code></a>' from which this class inherits.
 In this super class the component logic is implemented.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="common/composition/AbstractComponentOwner.html#_setOrReject(T)">_setOrReject</a></code>&nbsp;in class&nbsp;<code><a href="common/composition/AbstractComponentOwner.html" title="class in neureka.common.composition">AbstractComponentOwner</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newComponent</code> - A component used to access features. (<a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a>, <a href="framing/NDFrame.html" title="class in neureka.framing"><code>NDFrame</code></a>, <a href="framing/Relation.html" title="class in neureka.framing"><code>Relation</code></a>, int[], ...)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The unchanged object or maybe in future versions: null (component rejected)</dd>
</dl>
</li>
</ul>
<a id="_removeOrReject(neureka.common.composition.Component)">
<!--   -->
</a><a id="_removeOrReject(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_removeOrReject</h4>
<pre class="methodSignature">protected&nbsp;&lt;T extends <a href="common/composition/Component.html" title="interface in neureka.common.composition">Component</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&gt;&gt;&nbsp;T&nbsp;_removeOrReject&#8203;(T&nbsp;newComponent)</pre>
<div class="block">This method is executed when a component is being removed from the tensor.
 The public remove method is implemented in the super class
 '<a href="common/composition/AbstractComponentOwner.html" title="class in neureka.common.composition"><code>AbstractComponentOwner</code></a>' from which this class inherits.
 In this super class the component logic is implemented.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="common/composition/AbstractComponentOwner.html#_removeOrReject(T)">_removeOrReject</a></code>&nbsp;in class&nbsp;<code><a href="common/composition/AbstractComponentOwner.html" title="class in neureka.common.composition">AbstractComponentOwner</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newComponent</code> - A component used to access features. (<a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a>, <a href="framing/NDFrame.html" title="class in neureka.framing"><code>NDFrame</code></a>, <a href="framing/Relation.html" title="class in neureka.framing"><code>Relation</code></a>, int[], ...)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The unchanged object or when rejected: null (component rejected)</dd>
</dl>
</li>
</ul>
<a id="update(neureka.common.composition.Component.OwnerChangeRequest)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>update</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;update&#8203;(<a href="common/composition/Component.OwnerChangeRequest.html" title="interface in neureka.common.composition">Component.OwnerChangeRequest</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&gt;&nbsp;changeRequest)</pre>
<div class="block">Important : Components of type <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> are simply gradients!
  Currently this method is used only to catch illegal arguments which
  is for example the case when trying to attach a gradient with a different shape...
  (Otherwise the gradient tensor "does not mind" an owner change...)</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="common/composition/Component.html#update(neureka.common.composition.Component.OwnerChangeRequest)">update</a></code>&nbsp;in interface&nbsp;<code><a href="common/composition/Component.html" title="interface in neureka.common.composition">Component</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>changeRequest</code> - An <a href="common/composition/Component.OwnerChangeRequest.html" title="interface in neureka.common.composition"><code>Component.OwnerChangeRequest</code></a> implementation instance used to communicate the type of change, context information and the ability to execute the change directly.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if the state change should be aborted or not.</dd>
</dl>
</li>
</ul>
<a id="to(neureka.devices.Device)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;to&#8203;(<a href="devices/Device.html" title="interface in neureka.devices">Device</a>&lt;?&gt;&nbsp;device)</pre>
<div class="block">This method taked a <a href="devices/Device.html" title="interface in neureka.devices"><code>Device</code></a> and tries to migrate the contents of this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
 instance to that <a href="devices/Device.html" title="interface in neureka.devices"><code>Device</code></a>!</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>device</code> - The <a href="devices/Device.html" title="interface in neureka.devices"><code>Device</code></a> which should host this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> as well as be added to its components list.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very class to enable method chaining.</dd>
</dl>
</li>
</ul>
<a id="to(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>to</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;to&#8203;(java.lang.String&nbsp;deviceType)</pre>
</li>
</ul>
<a id="isEmpty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isEmpty</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isEmpty()</pre>
<div class="block">A tensor is empty if there is neither data referenced within the tensor directly
  or within any given device to which the tensor might belong.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor has data.</dd>
</dl>
</li>
</ul>
<a id="isUndefined()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isUndefined</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isUndefined()</pre>
<div class="block">A tensor is "undefined" if it has either no <a href="ndim/config/NDConfiguration.html" title="interface in neureka.ndim.config"><code>NDConfiguration</code></a> implementation instance
  or this instance does not have a shape set for this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> which is needed for
  a tensor to also have a rank and dimensionality...</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor has an <a href="ndim/config/NDConfiguration.html" title="interface in neureka.ndim.config"><code>NDConfiguration</code></a> stored internally.</dd>
</dl>
</li>
</ul>
<a id="isSlice()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isSlice</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isSlice()</pre>
<div class="block">If this tensor is a slice of a parent tensor then this method will yield true.
  Slices can be created by calling the variations of the "<a href="#getAt(int...)"><code>getAt(int...)</code></a>" method.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor is a slice of another tensor.</dd>
</dl>
</li>
</ul>
<a id="sliceCount()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sliceCount</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;sliceCount()</pre>
<div class="block">This method returns the number of slices which have been
  created from this very tensor.
  It does so by accessing the <a href="framing/Relation.html" title="class in neureka.framing"><code>Relation</code></a> component if present
  which internally keeps track of slices via weak references.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of slices derived from this tensor.</dd>
</dl>
</li>
</ul>
<a id="isSliceParent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isSliceParent</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isSliceParent()</pre>
<div class="block">If slices have been derived from this tensor then it is a "slice parent".
  This is what this method will determine, in which case, it will return true.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if slices have been derived from this tensor.</dd>
</dl>
</li>
</ul>
<a id="belongsToGraph()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>belongsToGraph</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;belongsToGraph()</pre>
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.
  This is because autograd requires recording a computation graph for back-prop traversal.
  This autograd system however, will only be triggered by <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> implementations which
  are not "detached", meaning they have their "<a href="calculus/Function.html#isDoingAD()"><code>Function.isDoingAD()</code></a>" flags set to true! <br>
  Detached functions (like those pre-instantiated in Function.Detached.*) will not attach <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a>
  instances to involved tensors which will prevent the formation of a computation graph.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor belongs to a recorded computation graph.</dd>
</dl>
</li>
</ul>
<a id="isLeave()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isLeave</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isLeave()</pre>
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.
  This is because autograd requires recording a computation graph for back-prop traversal.
  This autograd system however, will only be triggered by <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> implementations which
  are not "detached", meaning they have their "<a href="calculus/Function.html#isDoingAD()"><code>Function.isDoingAD()</code></a>" flags set to true! <br>
  A tensor is a leave if it is attached to a computation graph in which it is not an intermediate / branch node
  but input / branch node.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor is attached to a computation graph as leave node.</dd>
</dl>
</li>
</ul>
<a id="isBranch()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isBranch</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isBranch()</pre>
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.
  This is because autograd requires recording a computation graph for back-prop traversal.
  This autograd system however, will only be triggered by <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> implementations which
  are not "detached", meaning they have their "<a href="calculus/Function.html#isDoingAD()"><code>Function.isDoingAD()</code></a>" flags set to true! <br>
  A tensor is a branch if it is attached to a computation graph in which it is not an input / leave node
  but intermediate / branch node.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor is attached to a computation graph as branch node.</dd>
</dl>
</li>
</ul>
<a id="hasGradient()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasGradient</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasGradient()</pre>
<div class="block">Tensors can be components of other tensors which makes the
  implicitly their gradients.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The truth value determining if this tensor has another tensor attached to it (which is its gradient).</dd>
</dl>
</li>
</ul>
<a id="getGradient()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGradient</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;getGradient()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The gradient of this tensor which is internally stored as component.</dd>
</dl>
</li>
</ul>
<a id="getDevice()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDevice</h4>
<pre class="methodSignature">public&nbsp;<a href="devices/Device.html" title="interface in neureka.devices">Device</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;getDevice()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The device on which this tensor is stored or <a href="devices/host/CPU.html" title="class in neureka.devices.host"><code>CPU</code></a> if it is not outsourced.</dd>
</dl>
</li>
</ul>
<a id="getGraphNode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphNode</h4>
<pre class="methodSignature">public&nbsp;<a href="autograd/GraphNode.html" title="class in neureka.autograd">GraphNode</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;getGraphNode()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The graph node of the computation graph to which this tensor belongs or null if not part of a graph.</dd>
</dl>
</li>
</ul>
<a id="frame()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>frame</h4>
<pre class="methodSignature">public&nbsp;<a href="framing/NDFrame.html" title="class in neureka.framing">NDFrame</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;frame()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An instance of the <a href="framing/NDFrame.html" title="class in neureka.framing"><code>NDFrame</code></a> component if present.</dd>
</dl>
</li>
</ul>
<a id="_become(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_become</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_become&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;tensor)</pre>
<div class="block">In essence tensors are merely fancy wrapper for some form of array of any type... 
  This wrapper usually stays the same of a given data array.
  However, sometimes a tensor changes its identity, or rather the underlying
  data changes the wrapping tensor instance. <br>
  <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tensor</code> - The tensor whose identity should be stolen.</dd>
</dl>
</li>
</ul>
<a id="iterator()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterator</h4>
<pre class="methodSignature">@NotNull
public&nbsp;@NotNull java.util.Iterator&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;iterator()</pre>
<div class="block">This method returns an iterator over the elements of this tensor. <br></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>iterator</code>&nbsp;in interface&nbsp;<code>java.lang.Iterable&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An iterator over elements of type ValType.</dd>
</dl>
</li>
</ul>
<a id="backward(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>backward</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;backward&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;error)</pre>
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.
  This is because autograd requires recording a computation graph for back-prop traversal.
  If this tensor is part of a computation graph then this method
  will traverse an error backward in the recorded history towards tensors which require
  the accumulation of gradients.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>error</code> - A tensor which is back-propagated to gradients. Must match the size og this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The tensor on which this method was called. (factory pattern)</dd>
</dl>
</li>
</ul>
<a id="backward(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>backward</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;backward&#8203;(double&nbsp;value)</pre>
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.
  This is because autograd requires recording a computation graph for back-prop traversal.
  If this tensor is part of a computation graph then this method
  will traverse an error backward in the recorded history towards tensors which require
  the accumulation of gradients.<br>
  <br>
  This method turns the given scalar value and
  turns it into a matching tensor ( with the same shape)
  which will then be back-propagated through the
  recorded computation graph.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - A scalar which is back-propagated to gradients. Must match the size og this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The tensor on which this method was called. (factory pattern)</dd>
</dl>
</li>
</ul>
<a id="backward()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>backward</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;backward()</pre>
<div class="block">Tensors which are used or produced by the autograd system will have a <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component attached to them.
  This is because autograd requires recording a computation graph for back-prop traversal.
  If this tensor is part of a computation graph then this method
  will traverse an error backward in the recorded history towards tensors which require
  the accumulation of gradients. <br>
  <br>
  This method assumes that the user wants to back-propagate
  an error of "1" having the same shape as
  this tensor.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The tensor on which this method was called. (factory pattern)</dd>
</dl>
</li>
</ul>
<a id="applyGradient()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyGradient</h4>
<pre class="methodSignature">public final&nbsp;void&nbsp;applyGradient()</pre>
<div class="block">If this tensor owns a gradient tensor as component, then it can be applied by this method. <br>
  "Applying" a gradient to a tensor simply means adding the values inside the gradient element-wise
  to the owning host tensor via an inline operation. <br></div>
</li>
</ul>
<a id="detach()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>detach</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;detach()</pre>
<div class="block"><b>This method detaches this tensor from its underlying computation-graph
  or simply does nothing if no graph is present.</b> <br>
  Nodes within a computation graph are instances of the "<a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a>" class which are also
  simple components of the tensors they represent in the graph. <br>
  Therefore, "detaching" this tensor from the graph simply means removing its <a href="autograd/GraphNode.html" title="class in neureka.autograd"><code>GraphNode</code></a> component.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance in order to allows for a more streamline usage of this method.</dd>
</dl>
</li>
</ul>
<a id="label(java.lang.String[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>label</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;label&#8203;(java.lang.String[][]&nbsp;labels)</pre>
<div class="block">This method receives a nested <code>String</code> array which
  ought to contain a label for the index of this tensor.
  The index for a single element of this tensor would be an array
  of numbers as long as the rank where every number is
  in the range of the corresponding shape dimension...
  Labeling an index means that for every dimension there
  must be a label for elements in this range array! <br>
  For example the shape (2,3) could be labeled as follows:    <br>
                                                              <br>
      dim 0 : ["A", "B"]                                      <br>
      dim 1 : ["1", "2", "3"]                                 <br>
                                                              <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>labels</code> - A nested String array containing labels for indexes of the tensor dimensions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This tensor (method chaining).</dd>
</dl>
</li>
</ul>
<a id="label(java.lang.String,java.lang.String[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>label</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;label&#8203;(java.lang.String&nbsp;tensorName,
                          java.lang.String[][]&nbsp;labels)</pre>
<div class="block">This method receives a label for this tensor and a
  nested <code>String</code> array which ought to contain a
  label for the index of this tensor.
  The index for a single element of this tensor would be an array
  of numbers as long as the rank where every number is
  in the range of the corresponding shape dimension...
  Labeling an index means that for every dimension there
  must be a label for elements in this range array! <br>
  For example the shape (2,3) could be labeled as follows:    <br>
                                                              <br>
      dim 0 : ["A", "B"]                                      <br>
      dim 1 : ["1", "2", "3"]                                 <br>
                                                              <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tensorName</code> - A label for this tensor itself.</dd>
<dd><code>labels</code> - A nested String array containing labels for indexes of the tensor dimensions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This tensor (method chaining).</dd>
</dl>
</li>
</ul>
<a id="label(java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>label</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;label&#8203;(java.util.List&lt;java.util.List&lt;java.lang.Object&gt;&gt;&nbsp;labels)</pre>
<div class="block">This method receives a nested <code>String</code> list which
  ought to contain a label for the index of this tensor.
  The index for a single element of this tensor would be an array
  of numbers as long as the rank where every number is
  in the range of the corresponding shape dimension...
  Labeling an index means that for every dimension there
  must be a label for elements in this range array! <br>
  For example the shape (2,3) could be labeled as follows: <br>
                                                           <br>
      dim 0 : ["A", "B"]                                   <br>
      dim 1 : ["1", "2", "3"]                              <br>
                                                           <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>labels</code> - A nested String list containing labels for indexes of the tensor dimensions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This tensor (method chaining).</dd>
</dl>
</li>
</ul>
<a id="label(java.lang.String,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>label</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;label&#8203;(java.lang.String&nbsp;tensorName,
                          java.util.List&lt;java.util.List&lt;java.lang.Object&gt;&gt;&nbsp;labels)</pre>
<div class="block">This method receives a label for this tensor and a nested
  <code>String</code> list which ought to contain a label for the index of
  this tensor The index for a single element of this tensor would
  be an array of numbers as long as the rank where every number is
  in the range of the corresponding shape dimension...
  Labeling an index means that for every dimension there
  must be a label for elements in this range array! <br>
  For example the shape (2,3) could be labeled as follows: <br>
                                                           <br>
      dim 0 : ["A", "B"]                                   <br>
      dim 1 : ["1", "2", "3"]                              <br>
                                                           <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tensorName</code> - A label for this tensor itself.</dd>
<dd><code>labels</code> - A nested String list containing labels for indexes of the tensor dimensions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This tensor (method chaining).</dd>
</dl>
</li>
</ul>
<a id="label(java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>label</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;label&#8203;(java.util.Map&lt;java.lang.Object,&#8203;java.util.List&lt;java.lang.Object&gt;&gt;&nbsp;labels)</pre>
<div class="block">This method provides the ability to
  label not only the indices of the shape of this tensor, but also
  the dimension of the shape.
  The first and only argument of the method expects a map instance
  where keys are the objects which ought to act as dimension labels
  and the values are lists of labels for the indices of said dimensions.
  For example the shape (2,3) could be labeled as follows:            <br>
  [                                                                   <br>
      "dim 0" : ["A", "B"],                                           <br>
      "dim 1" : ["1", "2", "3"]                                       <br>
  ]                                                                   <br>
                                                                      <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>labels</code> - A map in which the keys are dimension labels and the values are lists of index labels for the dimension.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This tensor (method chaining).</dd>
</dl>
</li>
</ul>
<a id="label(java.lang.String,java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>label</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;label&#8203;(java.lang.String&nbsp;tensorName,
                          java.util.Map&lt;java.lang.Object,&#8203;java.util.List&lt;java.lang.Object&gt;&gt;&nbsp;labels)</pre>
</li>
</ul>
<a id="plus(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>plus</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;plus&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">This method will produce the sum of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.
  If the shapes of both of the involved tensors is identical then
  the result will be a regular element-wise addition.
  Otherwise, the method will also be able to perform broadcasting, however only if
  for every pair of shape dimension the following is true:
  Either the dimensions have the same size or one of them has size 1. <br>
  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       <br>
  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The right operand of the addition.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sum of this instance as the left and the passed <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance as right operand.</dd>
</dl>
</li>
</ul>
<a id="plusAssign(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>plusAssign</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;plusAssign&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
</li>
</ul>
<a id="plus(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>plus</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;plus&#8203;(double&nbsp;value)</pre>
<div class="block">This method will create a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  with the provided double scalar added to all elements of this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.

  The shapes of this tensor is irrelevant as the provided value will
  simply be broadcast to any possible shape.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The right operand of the addition.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sum between this instance as the left and the passed double as right operand.</dd>
</dl>
</li>
</ul>
<a id="minus(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minus</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;minus&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">This method will perform subtraction on
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.
  If the shapes of both of the involved tensors is identical then
  the result will be a regular element-wise subtraction.
  Otherwise, the method will also be able to perform broadcasting, however only if
  for every pair of shape dimension the following is true:
  Either the dimensions have the same size or one of them has size 1. <br>
  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       <br>
  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The right operand of the subtraction.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The difference between this instance as the left and the passed <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance as right operand.</dd>
</dl>
</li>
</ul>
<a id="minus(java.lang.Object)">
<!--   -->
</a><a id="minus(V)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minus</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;minus&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</pre>
</li>
</ul>
<a id="minusAssign(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minusAssign</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;minusAssign&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
</li>
</ul>
<a id="minusAssign(java.lang.Object)">
<!--   -->
</a><a id="minusAssign(V)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minusAssign</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;minusAssign&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</pre>
</li>
</ul>
<a id="negative()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>negative</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;negative()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A clone of this tensor where the signs of all elements are flipped.</dd>
</dl>
</li>
</ul>
<a id="multiply(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;multiply&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">This method is synonymous to the <a href="#times(neureka.Tsr)"><code>times(Tsr)</code></a> method.
  Both of which will produce the product of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.
  If the shapes of both of the involved tensors is identical then
  the result will be a regular element-wise product.
  Otherwise, the method will also be able to perform broadcasting, however only if
  for every pair of shape dimension the following is true:
  Either the dimensions have the same size or one of them has size 1. <br>
  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       <br>
  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The right operand of the multiplication.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The product of this instance as the left and the passed <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance as right operand.</dd>
</dl>
</li>
</ul>
<a id="multiply(java.lang.Object)">
<!--   -->
</a><a id="multiply(V)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;multiply&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The value which should be broadcast to all elements of a clone of this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new clone of this tensor where all elements are multiplied by the provided value.</dd>
</dl>
</li>
</ul>
<a id="times(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>times</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;times&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">The <a href="#times(neureka.Tsr)"><code>times(Tsr)</code></a> method is synonymous to the <a href="#multiply(neureka.Tsr)"><code>multiply(Tsr)</code></a>.
  Both of which will produce the product of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.
  If the shapes of both of the involved tensors is identical then
  the result will be a regular elementwise product.
  Otherwise the method will also be able to perform broadcasting, however only if
  for every pair of shape dimension the following is true:
  Either the dimensions have the same size or one of them has size 1. <br>
  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       <br>
  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The right operand of the multiplication.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The product of this instance as the left and the passed <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance as right operand.</dd>
</dl>
</li>
</ul>
<a id="times(java.lang.Object)">
<!--   -->
</a><a id="times(V)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>times</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;times&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The value which should be broadcast to all elements of a clone of this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new clone of this tensor where all elements are multiplied by the provided value.</dd>
</dl>
</li>
</ul>
<a id="timesAssign(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timesAssign</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;timesAssign&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The tensor whose elements ought to be multiplied and assigned to elements in this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This instance where each value element was multiplied by the corresponding element in the provided tensor.</dd>
</dl>
</li>
</ul>
<a id="timesAssign(java.lang.Object)">
<!--   -->
</a><a id="timesAssign(V)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timesAssign</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;timesAssign&#8203;(<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;other)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The value which ought to be multiplied and assigned to each element in this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This instance where each value element was multiplied by the provided element.</dd>
</dl>
</li>
</ul>
<a id="multiply(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;multiply&#8203;(double&nbsp;value)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The value which should be broadcast to all elements of a clone of this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new clone of this tensor where all elements are multiplied by the provided value.</dd>
</dl>
</li>
</ul>
<a id="div(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>div</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;div&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">The <a href="#div(neureka.Tsr)"><code>div(Tsr)</code></a> method will produce the quotient of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.
  If the shapes of both of the involved tensors is identical then
  the result will be a regular element-wise division.
  Otherwise, the method will also be able to perform broadcasting, however only if
  for every pair of shape dimension the following is true:
  Either the dimensions have the same size or one of them has size 1. <br>
  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       <br>
  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The right operand of the division.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The quotient of this instance as the left and the passed <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance as right operand.</dd>
</dl>
</li>
</ul>
<a id="div(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>div</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;div&#8203;(double&nbsp;value)</pre>
</li>
</ul>
<a id="divAssign(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divAssign</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;divAssign&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
</li>
</ul>
<a id="mod(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mod</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;mod&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">The <a href="#mod(neureka.Tsr)"><code>mod(Tsr)</code></a> method will produce the modulus of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.
  If the shapes of both of the involved tensors is identical then
  the result will be a regular element-wise modulo operation.
  Otherwise, the method will also be able to perform broadcasting, however only if
  for every pair of shape dimension the following is true:
  Either the dimensions have the same size or one of them has size 1. <br>
  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       <br>
  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The right operand of the modulo operation.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The modulus of this instance as the left and the passed <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance as right operand.</dd>
</dl>
</li>
</ul>
<a id="mod(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mod</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;mod&#8203;(int&nbsp;other)</pre>
</li>
</ul>
<a id="rem(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rem</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;rem&#8203;(int&nbsp;other)</pre>
<div class="block">This method is synonymous to the <a href="#mod(int)"><code>mod(int)</code></a> method.</div>
</li>
</ul>
<a id="modAssign(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>modAssign</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;modAssign&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
</li>
</ul>
<a id="power(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>power</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;power&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">The <a href="#power(neureka.Tsr)"><code>power(Tsr)</code></a> (Tsr)} method will produce the power of
  two tensors with the same rank (or two ranks which can be made compatible with padding ones),
  where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.
  If the shapes of both of the involved tensors is identical then
  the result will be a regular element-wise exponentiation.
  Otherwise, the method will also be able to perform broadcasting, however only if
  for every pair of shape dimension the following is true:
  Either the dimensions have the same size or one of them has size 1. <br>
  Here is an example of 2 matching shapes: (1, 4, 1) and (3, 4, 1)       <br>
  And here is an example of a mismatch: (2, 4, 1) and (3, 4, 1)         <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The right operand, also known as exponent, of the exponentiation.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The power of this instance as the left and the passed <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance as right operand.</dd>
</dl>
</li>
</ul>
<a id="power(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>power</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;power&#8203;(double&nbsp;value)</pre>
</li>
</ul>
<a id="xor(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>xor</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;xor&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">This method is synonymous to the <a href="#power(neureka.Tsr)"><code>power(Tsr)</code></a> method.</div>
</li>
</ul>
<a id="xor(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>xor</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;xor&#8203;(double&nbsp;value)</pre>
<div class="block">This method is synonymous to the <a href="#power(neureka.Tsr)"><code>power(Tsr)</code></a> method.</div>
</li>
</ul>
<a id="T()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>T</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;T()</pre>
<div class="block">A method which returns a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance which is a transposed twin of this instance.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new transposed tensor with the same underlying data as this tensor.</dd>
</dl>
</li>
</ul>
<a id="getT()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getT</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;getT()</pre>
<div class="block">A method which returns a new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance which is a transposed twin of this instance.
  It is and alias method to the <a href="#T()"><code>T()</code></a> method...</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new transposed tensor with the same underlying data as this tensor.</dd>
</dl>
</li>
</ul>
<a id="mean()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mean</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;mean()</pre>
<div class="block">This method performs various operations by calling <a href="calculus/Function.html" title="interface in neureka.calculus"><code>Function</code></a> instances
  in order to ultimately calculate the mean value of all values
  of this very tensor!
  This scalar tensor is then returned.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A scalar tensor which is the mean value of all values of this very tensor.</dd>
</dl>
</li>
</ul>
<a id="sum()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sum</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;sum()</pre>
</li>
</ul>
<a id="convDot(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convDot</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;convDot&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">This method performs a convolutional based dot product between the last dimension of this tensor
  and the first dimension of the passed tensor.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The tensor which is the right part of the dot product operation.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new tensor which is the dot product of this tensor and the passed one.</dd>
</dl>
</li>
</ul>
<a id="dot(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dot</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;dot&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">This method performs a dot product between the last dimension of this tensor
  and the first dimension of the passed tensor.
  However, currently this method can only handle matrices which means
  that it is functionally completely identical to the <a href="#matMul(neureka.Tsr)"><code>matMul(Tsr)</code></a> method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The tensor which is the right part of the dot product operation.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new tensor which is the dot product of this tensor and the passed one.</dd>
</dl>
</li>
</ul>
<a id="matMul(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matMul</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;matMul&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">The <a href="#matMul(neureka.Tsr)"><code>matMul(Tsr)</code></a> method will produce the matrix product of
  two 2 dimensional arrays, where the left operand is this <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>
  instance and the right operand is the tensor passed to the method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The right operand of the matrix multiplication.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The matrix product of this instance as the left and the passed <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance as right operand.</dd>
</dl>
</li>
</ul>
<a id="dimtrim()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dimtrim</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;dimtrim()</pre>
<div class="block">This method creates a new tensor sharing the same data and whose shape is trimmed.
  A trimmed shape is simply a shape without preceding and trailing ones. <br>
  For example the shape (1x4x1x2x1) would be trimmed to (4x1x2).
  The underlying operation does not perform a removal of redundant ones all together.
  Only ones at the start and the beginning will be removed.
  A scalar tensor will not be affected by this operation.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A tensor with the same underlying data but possibly trimmed shape without preceding or trailing ones.</dd>
</dl>
</li>
</ul>
<a id="isCase(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCase</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isCase&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">This method name translates to the "in" keyword in Groovy!
  The same is true for the "contains" method in Kotlin.
  Both methods do the exact same thing, however they exist
  for better language support.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The tensor which will be checked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The answer to the following question: Is the data of the provided tensor a subset of the data of this tensor?</dd>
</dl>
</li>
</ul>
<a id="contains(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contains</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;contains&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;other)</pre>
<div class="block">This method name translates to the "in" keyword in Kotlin!
  The same is true for the "isCase" method in Groovy.
  Both methods do the exact same thing, however they exist
  for better language support.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - The tensor which will be checked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The answer to the following question: Is the data of the provided tensor a subset of the data of this tensor?</dd>
</dl>
</li>
</ul>
<a id="getAt(int...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAt</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;getAt&#8203;(int...&nbsp;indices)</pre>
<div class="block">The following method enables access to specific scalar elements within the tensor.
  The method name also translates to the subscript operator in Groovy.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/TensorAPI.html#getAt(int...)">getAt</a></code>&nbsp;in interface&nbsp;<code><a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indices</code> - The index array of the element which should be returned.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An element located at the provided index.</dd>
</dl>
</li>
</ul>
<a id="getAt(java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAt</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;getAt&#8203;(java.util.Map&lt;?,&#8203;java.lang.Integer&gt;&nbsp;rankToStrides)</pre>
<div class="block">This method is most useful when used in Groovy
  where defining maps is done through square brackets,
  making it possible to slice tensors like so: <br>
  <pre><code>
      var b = a[[[0..0]:1, [0..0]:1, [0..3]:2]]
  </code></pre>
  Here a single argument with the format '[i..j]:k' is equivalent
  to Pythons 'i:j:k' syntax for indexing! (numpy)                            <br>
  i... start indexAlias.                                                      <br>
  j... end indexAlias. (inclusive!)                                           <br>
  k... step size.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/TensorAPI.html#getAt(java.util.Map)">getAt</a></code>&nbsp;in interface&nbsp;<code><a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rankToStrides</code> - A map where the keys define where axes should be sliced and values which define the strides for the specific axis.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A tensor slice with an offset based on the provided map keys and
         strides based on the provided map values.</dd>
</dl>
</li>
</ul>
<a id="shallowCopy()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shallowCopy</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;shallowCopy()</pre>
<div class="block">This is technically the equivalent to a full slice.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A shallow copy where the underlying data is shared with this tensor.</dd>
</dl>
</li>
</ul>
<a id="getAt(java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAt</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;getAt&#8203;(java.util.List&lt;?&gt;&nbsp;key)</pre>
<div class="block">This method enables tensor slicing!
  It takes a key of various types and configures a slice
  tensor which shares the same underlying data as the original tensor.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/TensorAPI.html#getAt(java.util.List)">getAt</a></code>&nbsp;in interface&nbsp;<code><a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - This object might be a wide range of objects including maps, lists or arrays...</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A slice tensor or scalar value.</dd>
</dl>
</li>
</ul>
<a id="clone()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clone</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;clone()</pre>
<div class="block">If this tensor stores value types then this method will
  essentially produce a deep copy of this tensor.
  If the stored elements are reference types on the other hand,
  then the resulting clone may not be treated as a deep copy,
  especially if elements are mutable objects.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>clone</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A deep copy of this tensor.</dd>
</dl>
</li>
</ul>
<a id="slice()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>slice</h4>
<pre class="methodSignature">public&nbsp;<a href="fluent/slicing/SliceBuilder.html" title="class in neureka.fluent.slicing">SliceBuilder</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;slice()</pre>
<div class="block">This method returns a <a href="fluent/slicing/SliceBuilder.html" title="class in neureka.fluent.slicing"><code>SliceBuilder</code></a> instance exposing a simple builder API
  which enables the configuration of a slice of the current tensor via method chaining.    <br>
  The following code snippet slices a 3-dimensional tensor into a tensor of shape (2x1x3)  <br>
 <pre><code>
  myTensor.slice()
          .axis(0).from(0).to(1)
          .then()
          .axis(1).at(5) // equivalent to '.from(5).to(5)'
          .then()
          .axis().from(0).to(2)
          .get();
 </code></pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An instance of the <a href="fluent/slicing/SliceBuilder.html" title="class in neureka.fluent.slicing"><code>SliceBuilder</code></a> class exposing a readable builder API for creating slices.</dd>
</dl>
</li>
</ul>
<a id="putAt(java.util.List,neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putAt</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;putAt&#8203;(java.util.List&lt;?&gt;&nbsp;key,
                          <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;value)</pre>
<div class="block">This method enables injecting slices of tensor to be assigned into this tensor!
  It takes a key of various types which is used to configure a slice
  tensor sharing the same underlying data as the original tensor.
  This slice is then used to assign the second argument to it, namely
  the "value" argument.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/TensorAPI.html#putAt(java.util.List,neureka.Tsr)">putAt</a></code>&nbsp;in interface&nbsp;<code><a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - This object is a list defining a targeted index or range of indices...</dd>
<dd><code>value</code> - the tensor which ought to be assigned to a slice of this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A slice tensor or scalar value.</dd>
</dl>
</li>
</ul>
<a id="putAt(int[],java.lang.Object)">
<!--   -->
</a><a id="putAt(int[],V)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putAt</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;putAt&#8203;(int[]&nbsp;indices,
                          <a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;item)</pre>
<div class="block">Use this to place an element at a particular position
  within this tensor by providing a array of axis indices and said element.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/TensorAPI.html#putAt(int%5B%5D,V)">putAt</a></code>&nbsp;in interface&nbsp;<code><a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indices</code> - The array of axis indices defining the position for the provided item.</dd>
<dd><code>item</code> - The element which ought to be placed at the indexed position.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This tensor instance to allow for method chaining.</dd>
</dl>
</li>
</ul>
<a id="putAt(java.util.Map,neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putAt</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;putAt&#8203;(java.util.Map&lt;?,&#8203;java.lang.Integer&gt;&nbsp;key,
                          <a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;value)</pre>
<div class="block">This method enables assigning a provided tensor to be a subset of this tensor!
  It takes a key which is used to configure a slice
  sharing the same underlying data as the original tensor.
  This slice is then used to assign the second argument <code>value</code> to it.
  The usage of this method is especially powerful when used in Groovy. <br>
  The following code illustrates this very well:
  <pre><code>
      a[[[0..0]:1, [0..0]:1, [0..3]:2]] = b
  </code></pre>
  Here a single argument with the format '[i..j]:k' is equivalent
  to pythons 'i:j:k' syntax for indexing! (numpy)                            <br>
  i... start indexAlias.                                                      <br>
  j... end indexAlias. (inclusive!)                                           <br>
  k... step size.                                                             <br></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/TensorAPI.html#putAt(java.util.Map,neureka.Tsr)">putAt</a></code>&nbsp;in interface&nbsp;<code><a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - This object is a map defining a stride and a targeted index or range of indices...</dd>
<dd><code>value</code> - The tensor which ought to be assigned into a slice of this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A slice tensor or scalar value.</dd>
</dl>
</li>
</ul>
<a id="getDataAt(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDataAt</h4>
<pre class="methodSignature">public&nbsp;<a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;getDataAt&#8203;(int&nbsp;i)</pre>
<div class="block">A tensor ought to have some way to access its underlying data array.
  This method simple returns an element within this data array sitting at position "i".</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/TensorAPI.html#getDataAt(int)">getDataAt</a></code>&nbsp;in interface&nbsp;<code><a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - The position of the targeted item within the raw data array of the tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The found object sitting at the specified index position.</dd>
</dl>
</li>
</ul>
<a id="setValueAt(int,java.lang.Object)">
<!--   -->
</a><a id="setValueAt(int,V)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setValueAt</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;setValueAt&#8203;(int&nbsp;i,
                               <a href="Tsr.html" title="type parameter in Tsr">V</a>&nbsp;o)</pre>
<div class="block">A tensor ought to have some way to selectively modify its underlying value array.
  This method simply overrides an element within this value array sitting at position "i".</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/TensorAPI.html#setValueAt(int,V)">setValueAt</a></code>&nbsp;in interface&nbsp;<code><a href="ndim/TensorAPI.html" title="interface in neureka.ndim">TensorAPI</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - The index of the value array entry which ought to be addressed.</dd>
<dd><code>o</code> - The object which ought to be placed at the requested position.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very tensor in order to enable method chaining.</dd>
</dl>
</li>
</ul>
<a id="setValue(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setValue</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;setValue&#8203;(java.lang.Object&nbsp;value)</pre>
<div class="block">This method will receive an object an try to interpret
  it or its contents to be set as value for this tensor.
  It will not necessarily replace the underlying data array object of this
  tensor itself, but also try to convert and copy the provided value
  into the data array of this tensor.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The value which may be a scalar or array and will be used to populate this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very tensor to enable method chaining.</dd>
</dl>
</li>
</ul>
<a id="getData()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getData</h4>
<pre class="methodSignature">public&nbsp;java.lang.Object&nbsp;getData()</pre>
<div class="block">This returns an unprocessed version of the underlying data of this tensor.
  If this tensor is outsourced (stored on a device), then the data will be loaded
  into an array and returned by this method.
  Do not expect the returned array to be actually stored within the tensor itself!
  Contrary to the <a href="#getValue()"><code>getValue()</code></a> method, this one will
  return the data in an unbiased form, where for example a virtual (see <a href="#isVirtual()"><code>isVirtual()</code></a>)
  tensor will have this method return an array of length 1.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An unbiased copy of the underlying data of this tensor.</dd>
</dl>
</li>
</ul>
<a id="getValue()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getValue</h4>
<pre class="methodSignature">public&nbsp;java.lang.Object&nbsp;getValue()</pre>
</li>
</ul>
<a id="mapTo(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapTo</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;T&gt;&nbsp;mapTo&#8203;(java.lang.Class&lt;T&gt;&nbsp;typeClass,
                        java.util.function.Function&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>,&#8203;T&gt;&nbsp;mapper)</pre>
</li>
</ul>
<a id="asImage(neureka.Tsr.ImageType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asImage</h4>
<pre class="methodSignature">public&nbsp;java.awt.image.BufferedImage&nbsp;asImage&#8203;(<a href="Tsr.ImageType.html" title="enum in neureka">Tsr.ImageType</a>&nbsp;type)</pre>
<div class="block">Turns this tensor into a <code>BufferedImage</code> based on the provided
  <a href="Tsr.ImageType.html" title="enum in neureka"><code>Tsr.ImageType</code></a> formatting choice.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The type of format used to create the buffered image.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>BufferedImage</code> populated with the contents of this tensor.</dd>
</dl>
</li>
</ul>
<a id="addToGradient(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addToGradient</h4>
<pre class="methodSignature">public final&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;addToGradient&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;error)</pre>
<div class="block">This method takes the provided <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance and adds its
  contents to the contents of the <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> which is set as gradient of this very <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>error</code> - The error gradient which ought to be added to the gradient of this tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very tensor instance to enable method chaining.</dd>
</dl>
</li>
</ul>
<a id="asType(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asType</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;T&nbsp;asType&#8203;(java.lang.Class&lt;T&gt;&nbsp;typeClass)</pre>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type parameter of the type that will be returned.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>typeClass</code> - The class which is the target of the type conversion.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An instance of the supplied type class.</dd>
</dl>
</li>
</ul>
<a id="getValueAs(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getValueAs</h4>
<pre class="methodSignature">public&nbsp;&lt;A&gt;&nbsp;A&nbsp;getValueAs&#8203;(java.lang.Class&lt;A&gt;&nbsp;arrayTypeClass)</pre>
</li>
</ul>
<a id="getDataAs(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDataAs</h4>
<pre class="methodSignature">public&nbsp;&lt;A&gt;&nbsp;A&nbsp;getDataAs&#8203;(java.lang.Class&lt;A&gt;&nbsp;arrayTypeClass)</pre>
</li>
</ul>
<a id="toString(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toString&#8203;(java.lang.String&nbsp;mode)</pre>
</li>
</ul>
<a id="toString(neureka.view.TsrStringSettings)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toString&#8203;(<a href="view/TsrStringSettings.html" title="class in neureka.view">TsrStringSettings</a>&nbsp;config)</pre>
</li>
</ul>
<a id="toString(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toString&#8203;(java.util.function.Consumer&lt;<a href="view/TsrStringSettings.html" title="class in neureka.view">TsrStringSettings</a>&gt;&nbsp;config)</pre>
<div class="block">This allows you to provide a lambda to configure how this tensor should be
  converted to <code>String</code> instances.
  The provided <code>Consumer</code> will receive a <a href="view/TsrStringSettings.html" title="class in neureka.view"><code>TsrStringSettings</code></a> instance
  which allows you to change various settings with the help of method chaining.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>config</code> - A consumer of the <a href="view/TsrStringSettings.html" title="class in neureka.view"><code>TsrStringSettings</code></a> ready to be configured.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The <code>String</code> representation of this tensor.</dd>
</dl>
</li>
</ul>
<a id="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a id="getVersion()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVersion</h4>
<pre class="methodSignature">public final&nbsp;int&nbsp;getVersion()</pre>
<div class="block">The version number is tracking how often this tensor has been mutated.
  This is especially useful for checking the correcting of autp-grad!</div>
</li>
</ul>
<a id="like(neureka.Tsr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>like</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="fluent/building/states/IterByOrIterFromOrAll.html" title="interface in neureka.fluent.building.states">IterByOrIterFromOrAll</a>&lt;V&gt;&nbsp;like&#8203;(<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;template)</pre>
<div class="block">Use this factory method to instantiate a new tensor with the same data type, shape
  and memory location (<a href="devices/Device.html" title="interface in neureka.devices"><code>Device</code></a> instance) as the provided template tensor.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>V</code> - The type parameter defining the value type of the provided as well as returned tensor.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>template</code> - The template tensor whose type, shape and location should be taken to construct a new tensor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Tsr.html" title="class in neureka"><code>Tsr</code></a> instance with the same data type, shape and memory location as the provided template.</dd>
</dl>
</li>
</ul>
<a id="ofRandom(java.lang.Class,int...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ofRandom</h4>
<pre class="methodSignature">public static&nbsp;&lt;V&gt;&nbsp;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;V&gt;&nbsp;ofRandom&#8203;(java.lang.Class&lt;V&gt;&nbsp;valueTypeClass,
                                  int...&nbsp;shape)</pre>
<div class="block">This factory method produces a randomly populated tensor of the provided
  type and shape using a hard coded default seed.
  If the provided type class is representing a
  floating point number type (like <code>Double</code> or <code>Float</code>) then the random numbers will
  be gaussian ("normally") distributed values with mean <code>0.0</code> and standard
  deviation <code>1.0</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>V</code> - The type parameter of the values stored by the returned tensor.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>valueTypeClass</code> - The type class of the values stored by the returned tensor.</dd>
<dd><code>shape</code> - The shape of the tensor produced by this factory method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A randomly filled tensor of the provided type.</dd>
</dl>
</li>
</ul>
<a id="getUnsafe()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getUnsafe</h4>
<pre class="methodSignature">public&nbsp;<a href="ndim/AbstractTensor.Unsafe.html" title="interface in neureka.ndim">AbstractTensor.Unsafe</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;&nbsp;getUnsafe()</pre>
<div class="block">This method exposes an API for mutating the state of this tensor.
  The usage of methods exposed by this API is generally discouraged
  because the exposed state can easily lead to broken tensors and exceptions...<br>
  <br>
  Use this in performance critical situations only.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ndim/AbstractTensor.html#getUnsafe()">getUnsafe</a></code>&nbsp;in class&nbsp;<code><a href="ndim/AbstractTensor.html" title="class in neureka.ndim">AbstractTensor</a>&lt;<a href="Tsr.html" title="class in neureka">Tsr</a>&lt;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;,&#8203;<a href="Tsr.html" title="type parameter in Tsr">V</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The unsafe API exposes methods for mutating the state of the tensor.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
