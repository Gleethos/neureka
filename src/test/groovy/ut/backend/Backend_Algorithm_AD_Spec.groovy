package ut.backend

import neureka.Neureka
import neureka.Tsr
import neureka.autograd.ADAgent
import neureka.backend.api.Operation
import neureka.calculus.args.Arg
import neureka.calculus.Function
import neureka.backend.api.ExecutionCall
import neureka.backend.api.Algorithm
import neureka.backend.standard.algorithms.Activation
import neureka.backend.standard.algorithms.Broadcast
import neureka.backend.standard.algorithms.Convolution
import neureka.backend.standard.algorithms.Operator
import neureka.devices.Device
import neureka.ndim.AbstractTensor
import neureka.ndim.config.NDConfiguration
import spock.lang.Specification

class Backend_Algorithm_AD_Spec extends Specification
{

    def 'Operator implementations behave as expected.'(
            Algorithm imp
    ){

        given : 'The current Neureka instance is being reset.'
            Neureka.get().reset()

        and : 'A mock Function.'
            def function = Mock(Function)
            def derivative = Mock(Tsr)
            function.executeDerive(*_) >> derivative
            def mutate = Mock(AbstractTensor.Unsafe)
            derivative.getUnsafe() >> mutate

        and : 'A mock ExecutionCall.'
            def call = Mock(ExecutionCall)
            call.inputs() >> new Tsr<?>[0]

        when : 'A new ADAgent is being instantiated by calling the given implementation with these arguments...'
            ADAgent agent = imp.supplyADAgentFor(
                                    function,
                                    call,
                                    true
                            )

        then : 'The agent is configured to perform forward-AD and it contains the derivative generated by the function!'
            agent.hasAction()
            agent.derivative() == derivative

        when : 'The agent generator is called once more with the forward flag set to false...'
            agent = imp.supplyADAgentFor(
                    function,
                    call,
                    false
            )

        then : 'The result is similar except the agent is not configured to perform forward-AD as was the case previously.'
            agent.hasAction()
            agent.derivative() == derivative

        where : 'The variable "imp" is from a List of OperationType implementations of type "Operator".'
            imp << Neureka.get().backend()
                    .getOperations()
                    .stream()
                    .filter(
                            e -> e.isOperator() && e.getOperator().length()==1 && e.supports( Operator.class )
                    ).map(
                    e -> e.getAlgorithm( Operator.class )
                    )
    }


    def 'Activation implementations behave as expected.'(
            Algorithm imp
    ){

        given : 'The current Neureka instance is being reset.'
            Neureka.get().reset()

        and : 'A mock Function.'
            def function = Mock(Function)
            def derivative = Mock(Tsr)
            def mutate = Mock(AbstractTensor.Unsafe)
            function.derive(*_) >> derivative
            function.executeDerive(*_) >> derivative
            derivative.getUnsafe() >> mutate

        and : 'A mock ExecutionCall.'
            var call = ExecutionCall.of().running(Mock(Operation)).algorithm(imp).on(Mock(Device))

        when :
            var suitability = imp.isSuitableFor(call)
        then :
            0 <= suitability && suitability <= 1

        when :
            var mode = imp.autoDiffModeFrom(call)
        then :
            mode != null

        where : 'The variable "imp" is from a List of OperationType implementations of type "Activation".'
            imp << Neureka.get().backend()
                    .getOperations()
                    .stream()
                    .filter( e -> e.supports( Activation.class ) )
                    .map( e -> e.getAlgorithm( Activation.class ) )
    }


    def 'Convolution implementations behave as expected.'( Algorithm imp ){

        given : 'The current Neureka instance is being reset.'
            Neureka.get().reset()

        and : 'A mock ExecutionCall.'
            var call = ExecutionCall.of().running(Mock(Operation)).algorithm(imp).on(Mock(Device))

        when :
            var suitability = imp.isSuitableFor(call)
        then :
            0 <= suitability && suitability <= 1

        when :
            var mode = imp.autoDiffModeFrom(call)
        then :
            mode != null

        where : 'The variable "imp" is from a List of Operation implementations of type "Convolution".'
            imp << Neureka.get().backend()
                                .getOperations()
                                .stream()
                                .filter(
                                        e ->
                                                e.isOperator() &&
                                                        e.getOperator().length()==1 &&
                                                            e.supports( Convolution.class )
                                ).map( e -> e.getAlgorithm( Convolution.class ) )
    }



    def 'Broadcast implementations behave as expected.'(
            Algorithm imp
    ){

        given : 'The current Neureka instance is being reset.'
            Neureka.get().reset()

        and : 'A mock Function.'
            def function = Mock( Function )
            def derivative = Mock( Tsr )
            def ndConf = Mock(NDConfiguration)
            function.derive(*_) >> derivative
            function.executeDerive(*_) >> derivative
            derivative.getNDConf() >> ndConf
            ndConf.shape() >> [1, 2]
            derivative.getValueClass() >> Float

        and : 'A mock ExecutionCall.'
            def call = Mock( ExecutionCall )
            def arg = Mock(Arg.Derivative)
            call.get(Arg.Derivative.class) >> arg


        when : 'A new ADAgent is being instantiated by calling the given implementation with these arguments...'
            ADAgent agent = imp.supplyADAgentFor(
                                function,
                                call,
                                true
                            )

        then : 'An exception is being thrown because implementations of type "Broadcast" can only perform reverse mode AD!'
            def exception = thrown( IllegalArgumentException )
            exception.message == "Broadcast implementation does not support forward-AD!"

        when : 'The agent generator is called once more with the forward flag set to false...'
            agent = imp.supplyADAgentFor(
                            function,
                            call,
                            false
                        )

        then :
            (0.._) * call.inputs() >> new Tsr[]{derivative, derivative}
            (0.._) * call.input(_) >> derivative
        and : 'No exception is being thrown and the agent is configured to perform backward-AD.'
            agent.hasAction()
            agent.derivative() == derivative || agent.derivative().toString({it.isMultiline=false}) == "(1x2):[  0.0 ,   0.0 ]"

        where : 'The variable "imp" is from a List of OperationType implementations of type "Convolution".'
            imp << Neureka.get().backend()
                                .getOperations()
                                .stream()
                                .filter(
                                        e ->
                                                e.isOperator() &&
                                                        e.supports( Broadcast.class )
                                )
                                .map( e -> e.getAlgorithm( Broadcast.class ) )
    }



}
