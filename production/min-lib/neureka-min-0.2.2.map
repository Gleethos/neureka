neureka.Component -> neureka.Component:
    void update(java.lang.Object,java.lang.Object) -> update
neureka.Neureka -> neureka.Neureka:
    java.util.Map _instances -> a
    java.lang.String _settings_source -> b
    java.lang.String _setup_source -> c
    java.lang.String _version -> d
    boolean _groovyAvailable -> e
    neureka.Neureka$Settings _settings -> f
    neureka.Neureka$Utility _utility -> g
    31:34:void <init>() -> <init>
    37:37:neureka.Neureka instance() -> instance
    41:42:void setContext(java.lang.Thread,neureka.Neureka) -> setContext
    45:52:neureka.Neureka instance(java.lang.Thread) -> instance
    57:59:neureka.Neureka instance(java.lang.Object) -> instance
    63:63:neureka.Neureka$Settings settings() -> settings
    67:68:neureka.Neureka$Settings settings(java.lang.Object) -> settings
    72:72:neureka.Neureka$Utility utility() -> utility
    76:76:java.lang.String version() -> version
    80:99:void reset() -> reset
    102:102:boolean _currentThreadIsAuthorized() -> a
    27:29:void <clinit>() -> <clinit>
neureka.Neureka$Settings -> neureka.Neureka$Settings:
    neureka.Neureka$Settings$Debug _debug -> b
    neureka.Neureka$Settings$AutoGrad _autoDiff -> c
    neureka.Neureka$Settings$Indexing _indexing -> d
    neureka.Neureka$Settings$View _view -> e
    neureka.Neureka$Settings$NDim _ndim -> f
    boolean _isLocked -> g
    neureka.Neureka this$0 -> a
    113:121:void <init>(neureka.Neureka) -> <init>
    124:124:neureka.Neureka$Settings$Debug debug() -> debug
    128:129:neureka.Neureka$Settings$Debug debug(java.lang.Object) -> debug
    133:133:neureka.Neureka$Settings$AutoGrad autoDiff() -> autoDiff
    137:138:neureka.Neureka$Settings$AutoGrad autoDiff(java.lang.Object) -> autoDiff
    142:142:neureka.Neureka$Settings$Indexing indexing() -> indexing
    146:147:neureka.Neureka$Settings$Indexing indexing(java.lang.Object) -> indexing
    151:151:neureka.Neureka$Settings$View view() -> view
    155:156:neureka.Neureka$Settings$View view(java.lang.Object) -> view
    160:160:neureka.Neureka$Settings$NDim ndim() -> ndim
    164:165:neureka.Neureka$Settings$NDim ndim(java.lang.Object) -> ndim
    169:169:boolean isLocked() -> isLocked
    173:174:void setIsLocked(boolean) -> setIsLocked
neureka.Neureka$Settings$AutoGrad -> neureka.Neureka$Settings$AutoGrad:
    boolean _isRetainingPendingErrorForJITProp -> a
    boolean _isApplyingGradientWhenTensorIsUsed -> b
    boolean _isApplyingGradientWhenRequested -> c
    neureka.Neureka$Settings this$1 -> d
    206:206:void <init>(neureka.Neureka$Settings) -> <init>
    236:236:boolean isRetainingPendingErrorForJITProp() -> isRetainingPendingErrorForJITProp
    240:242:void setIsRetainingPendingErrorForJITProp(boolean) -> setIsRetainingPendingErrorForJITProp
    245:245:boolean isApplyingGradientWhenTensorIsUsed() -> isApplyingGradientWhenTensorIsUsed
    249:251:void setIsApplyingGradientWhenTensorIsUsed(boolean) -> setIsApplyingGradientWhenTensorIsUsed
    254:254:boolean isApplyingGradientWhenRequested() -> isApplyingGradientWhenRequested
    258:260:void setIsApplyingGradientWhenRequested(boolean) -> setIsApplyingGradientWhenRequested
neureka.Neureka$Settings$Debug -> neureka.Neureka$Settings$Debug:
    boolean _isKeepingDerivativeTargetPayloads -> a
    neureka.Neureka$Settings this$1 -> b
    176:176:void <init>(neureka.Neureka$Settings) -> <init>
    196:196:boolean isKeepingDerivativeTargetPayloads() -> isKeepingDerivativeTargetPayloads
    200:202:void setIsKeepingDerivativeTargetPayloads(boolean) -> setIsKeepingDerivativeTargetPayloads
neureka.Neureka$Settings$Indexing -> neureka.Neureka$Settings$Indexing:
    boolean _isUsingLegacyIndexing -> a
    boolean _isUsingThoroughIndexing -> b
    neureka.Neureka$Settings this$1 -> c
    264:264:void <init>(neureka.Neureka$Settings) -> <init>
    271:271:boolean isUsingLegacyIndexing() -> isUsingLegacyIndexing
    275:277:void setIsUsingLegacyIndexing(boolean) -> setIsUsingLegacyIndexing
    280:280:boolean isUsingThoroughIndexing() -> isUsingThoroughIndexing
    284:286:void setIsUsingThoroughIndexing(boolean) -> setIsUsingThoroughIndexing
neureka.Neureka$Settings$NDim -> neureka.Neureka$Settings$NDim:
    boolean _isOnlyUsingDefaultNDConfiguration -> a
    neureka.Neureka$Settings this$1 -> b
    305:305:void <init>(neureka.Neureka$Settings) -> <init>
    315:315:boolean isOnlyUsingDefaultNDConfiguration() -> isOnlyUsingDefaultNDConfiguration
    319:321:void setIsOnlyUsingDefaultNDConfiguration(boolean) -> setIsOnlyUsingDefaultNDConfiguration
neureka.Neureka$Settings$View -> neureka.Neureka$Settings$View:
    boolean _isUsingLegacyView -> a
    neureka.Neureka$Settings this$1 -> b
    290:290:void <init>(neureka.Neureka$Settings) -> <init>
    295:295:boolean isUsingLegacyView() -> isUsingLegacyView
    299:301:void setIsUsingLegacyView(boolean) -> setIsUsingLegacyView
neureka.Neureka$Utility -> neureka.Neureka$Utility:
    327:327:void <init>() -> <init>
    337:350:java.lang.String readResource(java.lang.String) -> readResource
    355:359:java.lang.Object tryGroovyClosureOn(java.lang.Object,java.lang.Object) -> tryGroovyClosureOn
    363:373:void tryGroovyScriptsOn(neureka.Neureka) -> tryGroovyScriptsOn
    376:385:boolean isPresent(java.lang.String) -> isPresent
neureka.Tsr -> neureka.Tsr:
    neureka.unit.acceleration.Device _CPU -> a
    int _flags -> b
    43:45:neureka.Tsr setRqsGradient(boolean) -> setRqsGradient
    49:49:boolean rqsGradient() -> rqsGradient
    53:57:void _setRqsGradient(boolean) -> _setRqsGradient
    62:84:neureka.Tsr setIsOutsourced(boolean) -> setIsOutsourced
    88:88:boolean isOutsourced() -> isOutsourced
    92:96:void _setIsOutsourced(boolean) -> _setIsOutsourced
    101:121:neureka.Tsr setIsVirtual(boolean) -> setIsVirtual
    125:125:boolean isVirtual() -> isVirtual
    129:133:void _setIsVirtual(boolean) -> _setIsVirtual
    138:142:neureka.Tsr setGradientApplyRqd(boolean) -> setGradientApplyRqd
    146:146:boolean gradientApplyRqd() -> gradientApplyRqd
    162:171:neureka.Component _addOrReject(neureka.Component) -> _addOrReject
    178:178:boolean isEmpty() -> isEmpty
    182:182:boolean isUndefined() -> isUndefined
    186:187:boolean isSlice() -> isSlice
    191:192:int sliceCount() -> sliceCount
    196:197:boolean isSliceParent() -> isSliceParent
    201:201:boolean belongsToGraph() -> belongsToGraph
    205:205:boolean isLeave() -> isLeave
    209:209:boolean isBranch() -> isBranch
    219:220:neureka.unit.acceleration.Device device() -> device
    228:228:neureka.autograd.GraphNode graphNode() -> graphNode
    236:236:neureka.framing.IndexAlias index() -> index
    243:257:neureka.Tsr _become(neureka.Tsr) -> _become
    261:272:neureka.Tsr delete() -> delete
    282:294:void _configureFromNewShape(int[]) -> _configureFromNewShape
    33:300:void <init>() -> <init>
    33:305:void <init>(java.lang.Object) -> <init>
    33:316:void <init>(java.util.List,java.lang.String) -> <init>
    33:331:void <init>(java.util.List,java.util.List) -> <init>
    33:362:void <init>(java.util.List) -> <init>
    33:366:void <init>(java.lang.Object,java.lang.Object) -> <init>
    33:369:void <init>(java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:372:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:375:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:378:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:381:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:384:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:387:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:390:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:394:void <init>(int[],java.lang.String) -> <init>
    397:399:void _construct(int[],java.lang.String) -> a
    402:408:int[] _intArray(java.lang.Object[]) -> a
    412:419:double[] _doubleArray(java.lang.Object[]) -> b
    33:424:void <init>(java.lang.Object[]) -> <init>
    427:485:void _construct(java.lang.Object[]) -> c
    33:489:void <init>(double) -> <init>
    33:493:void <init>(int[]) -> <init>
    496:498:void _construct(int[]) -> a
    33:502:void <init>(int[],double) -> <init>
    505:510:void _construct(int[],double) -> a
    33:514:void <init>(int[],double[]) -> <init>
    517:524:void _construct(int[],double[]) -> a
    33:531:void <init>(neureka.Tsr,java.lang.String) -> <init>
    33:535:void <init>(neureka.Tsr[],java.lang.String) -> <init>
    33:539:void <init>(neureka.Tsr[],java.lang.String,boolean) -> <init>
    542:545:void _construct(neureka.Tsr[],java.lang.String,boolean) -> a
    557:560:neureka.Tsr backward(neureka.Tsr) -> backward
    569:570:neureka.Tsr backward(double) -> backward
    574:580:void applyGradient() -> applyGradient
    585:588:neureka.Tsr T() -> T
    592:592:neureka.Tsr plus(neureka.Tsr) -> plus
    595:595:neureka.Tsr plusAssign(neureka.Tsr) -> plusAssign
    598:598:neureka.Tsr plus(java.lang.Double) -> plus
    601:601:neureka.Tsr minus(neureka.Tsr) -> minus
    604:604:neureka.Tsr minusAssign(neureka.Tsr) -> minusAssign
    607:607:neureka.Tsr negative() -> negative
    610:610:neureka.Tsr multiply(neureka.Tsr) -> multiply
    613:613:neureka.Tsr timesAssign(neureka.Tsr) -> timesAssign
    616:616:neureka.Tsr multiply(java.lang.Double) -> multiply
    619:619:neureka.Tsr div(neureka.Tsr) -> div
    622:622:neureka.Tsr div(java.lang.Double) -> div
    625:625:neureka.Tsr divAssign(neureka.Tsr) -> divAssign
    628:628:neureka.Tsr mod(neureka.Tsr) -> mod
    631:631:neureka.Tsr modAssign(neureka.Tsr) -> modAssign
    634:634:neureka.Tsr power(neureka.Tsr) -> power
    637:637:neureka.Tsr power(java.lang.Double) -> power
    640:640:neureka.Tsr xor(neureka.Tsr) -> xor
    643:643:neureka.Tsr xor(java.lang.Double) -> xor
    646:655:neureka.Tsr dot(neureka.Tsr) -> dot
    658:662:boolean isCase(neureka.Tsr) -> isCase
    665:665:boolean contains(neureka.Tsr) -> contains
    669:681:neureka.Tsr label(java.lang.String[][]) -> label
    685:687:neureka.Tsr label(java.util.List) -> label
    691:692:neureka.Tsr label(java.util.Map) -> label
    696:707:neureka.Tsr putAt(java.lang.Object,neureka.Tsr) -> putAt
    711:711:double getAt(int[]) -> getAt
    715:716:java.lang.Object getAt(java.lang.Object,java.lang.Object) -> getAt
    720:799:java.lang.Object getAt(java.lang.Object) -> getAt
    814:888:int _configureSubsetFromRanges(java.lang.Object[],int[],int[],int) -> a
    997:999:neureka.Tsr setValue64(double[]) -> setValue64
    1003:1005:neureka.Tsr setValue32(float[]) -> setValue32
    1009:1020:neureka.Tsr setValue(java.lang.Object) -> setValue
    1024:1028:java.lang.Object getValue() -> getValue
    1032:1034:double[] gradient64() -> gradient64
    1038:1040:float[] gradient32() -> gradient32
    1044:1049:neureka.Tsr addToGradient(neureka.Tsr) -> addToGradient
    1053:1060:neureka.Tsr to32() -> to32
    1064:1071:neureka.Tsr to64() -> to64
    1075:1080:double value64(int) -> value64
    1085:1094:double[] value64() -> value64
    1098:1103:float value32(int) -> value32
    1108:1116:float[] value32() -> value32
    1120:1122:neureka.Tsr setValue(double[]) -> setValue
    1132:1132:java.lang.String toString(java.lang.String) -> toString
    1136:1198:java.lang.String _toString(java.lang.String,java.lang.String) -> _toString
    1202:1214:java.lang.String _stringified(double[],boolean,int) -> a
    1218:1218:java.lang.String toString() -> toString
    1223:1239:void makeFit(neureka.Tsr[]) -> makeFit
    1287:1287:void update(neureka.Tsr,neureka.Tsr) -> update
    21:21:void update(java.lang.Object,java.lang.Object) -> update
    1192:1194:void lambda$_toString$18(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1174:1184:void lambda$_toString$17(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1068:1068:void lambda$to64$16(neureka.Tsr) -> f
    1057:1057:void lambda$to32$15(neureka.Tsr) -> g
    1047:1047:void lambda$addToGradient$14(neureka.Tsr,neureka.unit.acceleration.Device) -> a
    1045:1045:void lambda$addToGradient$13(neureka.Tsr,neureka.Tsr) -> a
    659:659:void lambda$isCase$12(neureka.Tsr,boolean[],neureka.framing.Relation) -> a
    660:661:void lambda$isCase$11(neureka.Tsr,boolean[],neureka.Tsr) -> a
    576:579:void lambda$applyGradient$10(neureka.Tsr) -> h
    576:576:void lambda$applyGradient$9(neureka.optimization.Optimizer) -> a
    574:574:void lambda$applyGradient$8(neureka.autograd.JITProp) -> a
    557:557:void lambda$backward$7(neureka.Tsr,neureka.autograd.GraphNode) -> a
    270:270:void lambda$delete$6(neureka.Tsr) -> i
    263:266:void lambda$delete$5(neureka.autograd.GraphNode) -> a
    261:261:void lambda$delete$4(neureka.unit.acceleration.Device) -> a
    109:109:void lambda$setIsVirtual$3(neureka.Tsr) -> j
    69:79:void lambda$setIsOutsourced$2(neureka.unit.acceleration.Device) -> b
    74:74:void lambda$setIsOutsourced$1(neureka.Tsr) -> k
    75:77:void lambda$setIsOutsourced$0(neureka.Tsr,neureka.unit.acceleration.Device) -> b
    21:21:neureka.ndim.config.NDConfiguration access$000(neureka.Tsr) -> a
    21:21:neureka.ndim.config.NDConfiguration access$100(neureka.Tsr) -> b
    21:21:neureka.ndim.config.NDConfiguration access$200(neureka.Tsr) -> c
    21:21:neureka.ndim.config.NDConfiguration access$300(neureka.Tsr) -> d
    21:21:neureka.ndim.config.NDConfiguration access$402(neureka.Tsr,neureka.ndim.config.NDConfiguration) -> a
    21:21:neureka.ndim.config.NDConfiguration access$502(neureka.Tsr,neureka.ndim.config.NDConfiguration) -> b
    21:21:neureka.ndim.config.NDConfiguration access$600(neureka.Tsr) -> e
    23:23:void <clinit>() -> <clinit>
neureka.Tsr$Create -> neureka.Tsr$Create:
    1243:1243:void <init>() -> <init>
    1246:1246:neureka.Tsr E(int[]) -> E
    1250:1250:neureka.Tsr newRandom(int[]) -> newRandom
    1254:1255:neureka.Tsr newRandom(int[],long) -> newRandom
    1259:1263:neureka.Tsr newTsrLike(neureka.Tsr,double) -> newTsrLike
    1267:1271:neureka.Tsr newTsrLike(neureka.Tsr) -> newTsrLike
    1275:1277:neureka.Tsr _newEmptyLike(neureka.Tsr) -> a
neureka.Tsr$Exec -> neureka.Tsr$Exec:
    970:970:void <init>() -> <init>
    973:988:neureka.Tsr reshaped(neureka.Tsr,int[],boolean) -> reshaped
neureka.Tsr$IO -> neureka.Tsr$IO:
    893:893:void <init>() -> <init>
    896:898:double getFrom(neureka.Tsr,int) -> getFrom
    902:903:double getFrom(neureka.Tsr,int[]) -> getFrom
    907:909:void setInto(neureka.Tsr,int,double) -> setInto
    912:914:void setInto(neureka.Tsr,int[],double) -> setInto
    917:919:void addInto(neureka.Tsr,int,double) -> addInto
    922:924:void addInto(neureka.Tsr,int[],double) -> addInto
    927:929:neureka.Tsr addInto(neureka.Tsr,neureka.Tsr) -> addInto
    933:935:void subInto(neureka.Tsr,int,double) -> subInto
    938:940:void subInto(neureka.Tsr,int[],double) -> subInto
    943:954:void subInto(neureka.Tsr,neureka.Tsr) -> subInto
    957:959:void mulInto(neureka.Tsr,int,double) -> mulInto
    962:964:void mulInto(neureka.Tsr,int[],double) -> mulInto
neureka.unit.acceleration.AbstractDevice -> neureka.unit.acceleration.AbstractDevice:
    java.lang.ref.Cleaner CLEANER -> a
    10:10:void <init>() -> <init>
    void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    20:21:void update(neureka.Tsr,neureka.Tsr) -> update
    25:26:neureka.unit.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    30:31:void _cleaning(java.lang.Object,java.lang.Runnable) -> _cleaning
    35:36:neureka.unit.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    41:76:void _execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> _execute
    1195:1204:void _createNewDrainTensorIn(neureka.unit.acceleration.Device,neureka.Tsr[],neureka.calculus.environment.OperationType):195:204 -> _execute
    1195:1204:void _execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int):53 -> _execute
    80:163:neureka.Tsr _execute_recursively(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> a
    170:192:void _execute_tensor_scalar(neureka.Tsr,double,neureka.calculus.environment.OperationType,int) -> _execute_tensor_scalar
    10:10:void update(java.lang.Object,java.lang.Object) -> update
    12:12:void <clinit>() -> <clinit>
neureka.unit.acceleration.AbstractDevice$Utility -> neureka.unit.acceleration.AbstractDevice$Utility:
    208:208:void <init>() -> <init>
    211:217:neureka.Tsr[] _subset(neureka.Tsr[],int,int,int) -> _subset
    220:222:neureka.Tsr[] _without(neureka.Tsr[],int) -> _without
    226:238:neureka.Tsr[] _offsetted(neureka.Tsr[],int) -> _offsetted
neureka.unit.acceleration.Device -> neureka.unit.acceleration.Device:
    14:21:neureka.unit.acceleration.Device find(java.lang.String) -> find
    void dispose() -> dispose
    neureka.unit.acceleration.Device get(neureka.Tsr) -> get
    neureka.unit.acceleration.Device add(neureka.Tsr) -> add
    neureka.unit.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    boolean has(neureka.Tsr) -> has
    neureka.unit.acceleration.Device rmv(neureka.Tsr) -> rmv
    neureka.unit.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    neureka.unit.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    neureka.unit.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    neureka.unit.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    neureka.unit.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    double[] value64Of(neureka.Tsr) -> value64Of
    float[] value32Of(neureka.Tsr) -> value32Of
    java.util.Collection tensors() -> tensors
    17:17:void lambda$find$1(java.lang.String,neureka.unit.acceleration.Device[],neureka.unit.acceleration.opencl.OpenCLPlatform) -> a
    18:20:void lambda$find$0(java.lang.String,neureka.unit.acceleration.Device[],neureka.unit.acceleration.opencl.OpenCLDevice) -> a
neureka.unit.acceleration.host.HostCPU -> neureka.unit.acceleration.host.HostCPU:
    neureka.unit.acceleration.host.HostCPU _instance -> a
    neureka.unit.acceleration.host.HostCPU$NativeExecutor _executor -> b
    23:25:void <init>() -> <init>
    28:28:neureka.unit.acceleration.host.HostCPU instance() -> instance
    32:32:neureka.unit.acceleration.host.HostCPU$NativeExecutor getExecutor() -> getExecutor
    37:54:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    58:64:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    68:69:void dispose() -> dispose
    73:73:neureka.unit.acceleration.Device get(neureka.Tsr) -> get
    78:78:neureka.unit.acceleration.Device add(neureka.Tsr) -> add
    83:83:neureka.unit.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    88:88:boolean has(neureka.Tsr) -> has
    93:93:neureka.unit.acceleration.Device rmv(neureka.Tsr) -> rmv
    98:98:neureka.unit.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    103:103:neureka.unit.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    108:108:neureka.unit.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    113:113:double[] value64Of(neureka.Tsr) -> value64Of
    118:118:float[] value32Of(neureka.Tsr) -> value32Of
    123:123:java.util.Collection tensors() -> tensors
    18:19:void <clinit>() -> <clinit>
neureka.unit.acceleration.host.HostCPU$NativeExecutor -> neureka.unit.acceleration.host.HostCPU$NativeExecutor:
    java.util.concurrent.ThreadPoolExecutor _pool -> a
    130:132:void <init>(neureka.unit.acceleration.host.HostCPU) -> <init>
    135:135:java.util.concurrent.ThreadPoolExecutor getPool() -> getPool
    139:147:void activate(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> activate
    150:159:void broadcast(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> broadcast
    162:171:void convolve(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> convolve
    174:182:void scalar(neureka.Tsr[],double,int,neureka.calculus.environment.OperationType) -> scalar
    187:211:void _threaded(int,neureka.unit.acceleration.host.HostCPU$Range) -> a
    197:199:void lambda$_threaded$4(neureka.Neureka,neureka.unit.acceleration.host.HostCPU$Range,int,int) -> a
    177:179:void lambda$scalar$3(neureka.Tsr[],neureka.calculus.environment.OperationType,double,int,int,int) -> a
    165:168:void lambda$convolve$2(neureka.Tsr[],int,neureka.calculus.environment.OperationType,int,int) -> a
    153:156:void lambda$broadcast$1(neureka.Tsr[],int,neureka.calculus.environment.OperationType,int,int) -> b
    142:144:void lambda$activate$0(neureka.Tsr[],neureka.calculus.environment.OperationType,int,int,int) -> a
neureka.unit.acceleration.host.HostCPU$Range -> neureka.unit.acceleration.host.HostCPU$a:
    void execute(int,int) -> execute
neureka.unit.acceleration.host.Kernel -> neureka.unit.acceleration.host.Kernel:
    7:7:void <init>() -> <init>
    15:150:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$TertiaryNDXConsumer) -> convolve
    158:240:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$TertiaryNDXConsumer) -> broadcast
    248:261:void activate(neureka.Tsr,int,int,neureka.calculus.environment.Type$TertiaryNDXConsumer) -> a
neureka.unit.acceleration.opencl.OpenCLDevice -> neureka.unit.acceleration.opencl.OpenCLDevice:
    java.util.Set _tensors -> a
    org.jocl.cl_device_id _did -> b
    neureka.unit.acceleration.opencl.OpenCLPlatform _platform -> c
    org.jocl.cl_command_queue _queue -> d
    44:44:org.jocl.cl_device_id CLDeviceID() -> CLDeviceID
    39:81:void <init>(neureka.unit.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> <init>
    84:85:neureka.unit.acceleration.opencl.OpenCLDevice instance(neureka.unit.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> instance
    93:96:java.util.Collection tensors() -> tensors
    101:103:void dispose() -> dispose
    107:111:neureka.unit.acceleration.Device get(neureka.Tsr) -> get
    116:117:neureka.unit.acceleration.Device add(neureka.Tsr) -> add
    122:126:neureka.unit.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    130:201:void _add(neureka.Tsr,neureka.unit.acceleration.opencl.OpenCLDevice$cl_tsr) -> a
    205:205:boolean has(neureka.Tsr) -> has
    209:247:void _store(neureka.Tsr,neureka.unit.acceleration.opencl.OpenCLDevice$cl_tsr,int) -> a
    252:257:neureka.unit.acceleration.Device rmv(neureka.Tsr) -> rmv
    271:289:neureka.unit.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    293:299:void _releaseEvents(neureka.Tsr[]) -> a
    302:309:org.jocl.cl_event[] _getWaitList(neureka.Tsr[]) -> b
    314:334:neureka.unit.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    339:344:neureka.unit.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    349:365:double[] value64Of(neureka.Tsr) -> value64Of
    371:387:float[] value32Of(neureka.Tsr) -> value32Of
    394:470:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    474:500:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    504:504:java.lang.String name() -> name
    508:508:java.lang.String vendor() -> vendor
    512:512:java.lang.String version() -> version
    516:525:java.lang.String type() -> type
    529:529:int maxComputeUnits() -> maxComputeUnits
    533:533:long maxWorkItemSimensions() -> maxWorkItemSimensions
    537:537:long[] maxWorkItemSizes() -> maxWorkItemSizes
    541:541:long maxWorkGroupSize() -> maxWorkGroupSize
    545:545:long maxClockFrequenzy() -> maxClockFrequenzy
    549:549:int maxAddressBits() -> maxAddressBits
    553:553:long maxMemAllocSize() -> maxMemAllocSize
    557:557:long globalMemSize() -> globalMemSize
    561:561:int errorCorrectionSupport() -> errorCorrectionSupport
    565:565:int localMemType() -> localMemType
    569:569:long localMemSize() -> localMemSize
    573:573:long maxConstantBufferSize() -> maxConstantBufferSize
    577:577:long maxConstantBufferSizeKB() -> maxConstantBufferSizeKB
    591:591:int imageSupport() -> imageSupport
    595:595:int maxReadImageArgs() -> maxReadImageArgs
    599:599:int maxWriteImageArgs() -> maxWriteImageArgs
    603:603:long singleFPConfig() -> singleFPConfig
    607:607:long image2DMaxWidth() -> image2DMaxWidth
    611:611:long image2DMaxHeight() -> image2DMaxHeight
    615:615:long image3DMaxWidth() -> image3DMaxWidth
    619:619:long image3DMaxHeight() -> image3DMaxHeight
    623:623:long image3DMaxDepth() -> image3DMaxDepth
    627:627:int prefVecWidthChar() -> prefVecWidthChar
    631:631:int prefVecWidthShort() -> prefVecWidthShort
    635:635:int prefVecWidthInt() -> prefVecWidthInt
    639:639:int prefVecWidthLong() -> prefVecWidthLong
    643:643:int prefVecWidthFloat() -> prefVecWidthFloat
    647:647:int prefVecWidthDouble() -> prefVecWidthDouble
    146:148:void lambda$_add$3(org.jocl.cl_event,org.jocl.cl_mem) -> a
    133:133:void lambda$_add$2(org.jocl.cl_mem) -> a
    95:95:void lambda$tensors$1(java.util.Collection,java.util.Collection) -> a
    95:95:void lambda$tensors$0(java.util.Collection,neureka.Tsr) -> a
neureka.unit.acceleration.opencl.OpenCLDevice$DeviceQuery -> neureka.unit.acceleration.opencl.OpenCLDevice$DeviceQuery:
    650:650:void <init>() -> <init>
    659:659:int getInt(org.jocl.cl_device_id,int) -> getInt
    671:673:int[] getInts(org.jocl.cl_device_id,int,int) -> getInts
    684:684:long getLong(org.jocl.cl_device_id,int) -> getLong
    696:698:long[] getLongs(org.jocl.cl_device_id,int,int) -> getLongs
    710:718:java.lang.String getString(org.jocl.cl_device_id,int) -> getString
    730:738:java.lang.String getString(org.jocl.cl_platform_id,int) -> getString
    749:749:long getSize(org.jocl.cl_device_id,int) -> getSize
    763:777:long[] getSizes(org.jocl.cl_device_id,int,int) -> getSizes
neureka.unit.acceleration.opencl.OpenCLDevice$cl_config -> neureka.unit.acceleration.opencl.OpenCLDevice$a:
    org.jocl.cl_mem data -> a
    24:24:void <init>() -> <init>
neureka.unit.acceleration.opencl.OpenCLDevice$cl_tsr -> neureka.unit.acceleration.opencl.OpenCLDevice$b:
    int fp -> a
    neureka.unit.acceleration.opencl.OpenCLDevice$cl_config config -> b
    neureka.unit.acceleration.opencl.OpenCLDevice$cl_value value -> c
    28:30:void <init>() -> <init>
    28:28:void update(java.lang.Object,java.lang.Object) -> update
neureka.unit.acceleration.opencl.OpenCLDevice$cl_value -> neureka.unit.acceleration.opencl.OpenCLDevice$c:
    org.jocl.cl_mem data -> a
    int size -> b
    org.jocl.cl_event event -> c
    18:20:void <init>() -> <init>
neureka.unit.acceleration.opencl.OpenCLPlatform -> neureka.unit.acceleration.opencl.OpenCLPlatform:
    org.jocl.cl_platform_id _pid -> a
    java.util.Map _id_device -> b
    org.jocl.cl_context _context -> c
    java.util.Map _kernels -> d
    java.util.Map OPERATION_TO_KERNEL_MAPPING -> e
    61:61:java.lang.String kernelNameOf(neureka.calculus.environment.OperationType) -> kernelNameOf
    65:94:void <init>(org.jocl.cl_platform_id) -> <init>
    97:101:void recompile() -> recompile
    106:170:void _compile(org.jocl.cl_device_id[]) -> a
    178:254:java.util.Map _getParsedKernelsFromTemplate(java.lang.String,java.lang.String) -> a
    258:258:org.jocl.cl_platform_id getID() -> getID
    262:264:java.util.List getDevices() -> getDevices
    269:269:boolean has(org.jocl.cl_device_id) -> has
    272:272:neureka.unit.acceleration.opencl.OpenCLDevice get(org.jocl.cl_device_id) -> get
    275:276:void put(org.jocl.cl_device_id,neureka.unit.acceleration.opencl.OpenCLDevice) -> put
    280:280:java.util.Map getKernels() -> getKernels
    284:284:org.jocl.cl_context getContext() -> getContext
    288:288:java.util.List PLATFORMS() -> PLATFORMS
    263:263:void lambda$getDevices$4(java.util.List,org.jocl.cl_device_id,neureka.unit.acceleration.opencl.OpenCLDevice) -> a
    204:214:void lambda$_getParsedKernelsFromTemplate$3(java.lang.String[],java.lang.String,java.util.function.Function,java.util.function.Function,java.util.Map,java.lang.String,java.lang.String,java.lang.String) -> a
    198:201:java.lang.String lambda$_getParsedKernelsFromTemplate$2(java.lang.String) -> a
    184:194:java.lang.String lambda$_getParsedKernelsFromTemplate$1(java.lang.String) -> b
    137:139:void lambda$_compile$0(java.util.ArrayList,java.util.ArrayList,java.lang.String,java.lang.String) -> a
    18:58:void <clinit>() -> <clinit>
neureka.unit.acceleration.opencl.OpenCLPlatform$Parser -> neureka.unit.acceleration.opencl.OpenCLPlatform$a:
    void apply(java.lang.String,java.lang.String,java.lang.String) -> apply
neureka.unit.acceleration.opencl.OpenCLPlatform$_setup -> neureka.unit.acceleration.opencl.OpenCLPlatform$b:
    java.util.List PLATFORMS -> a
    293:293:void <clinit>() -> <clinit>
    1297:1308:java.util.List findAllPlatforms():297:308 -> <clinit>
    1297:1308:void <clinit>():293 -> <clinit>
neureka.unit.acceleration.opencl.utility.DeviceQuery -> neureka.unit.acceleration.opencl.utility.DeviceQuery:
    14:14:void <init>() -> <init>
    23:182:java.lang.String query() -> query
    1270:1278:java.lang.String getString(org.jocl.cl_platform_id,int):270:278 -> query
    1270:1278:java.lang.String query():38 -> query
    194:194:int getInt(org.jocl.cl_device_id,int) -> a
    207:209:int[] getInts(org.jocl.cl_device_id,int,int) -> a
    221:221:long getLong(org.jocl.cl_device_id,int) -> b
    234:236:long[] getLongs(org.jocl.cl_device_id,int,int) -> b
    249:257:java.lang.String getString(org.jocl.cl_device_id,int) -> c
    290:290:long getSize(org.jocl.cl_device_id,int) -> d
    305:324:long[] getSizes(org.jocl.cl_device_id,int,int) -> c
neureka.unit.acceleration.opencl.utility.WeakTensorReference -> neureka.unit.acceleration.opencl.utility.WeakTensorReference:
    int _hash -> a
    24:26:void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    30:30:int hashCode() -> hashCode
    35:35:boolean equals(java.lang.Object) -> equals
neureka.autograd.ADAgent -> neureka.autograd.ADAgent:
    neureka.autograd.ADAgent$ADAction _fad -> a
    neureka.autograd.ADAgent$ADAction _bad -> b
    java.util.function.Supplier _derivative -> c
    19:23:void <init>(java.util.function.Supplier,neureka.autograd.ADAgent$ADAction,neureka.autograd.ADAgent$ADAction) -> <init>
    26:30:void <init>(neureka.Tsr) -> <init>
    33:33:neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    38:38:neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    42:42:neureka.Tsr derivative() -> derivative
    46:46:boolean isForward() -> isForward
    51:57:java.lang.String toString() -> toString
    27:27:neureka.Tsr lambda$new$0(neureka.Tsr) -> a
neureka.autograd.ADAgent$ADAction -> neureka.autograd.ADAgent$ADAction:
    neureka.Tsr execute(neureka.autograd.GraphNode,neureka.Tsr) -> execute
neureka.autograd.GraphLock -> neureka.autograd.GraphLock:
    neureka.calculus.Function _owner -> a
    boolean _is_locked -> b
    22:31:void <init>(neureka.calculus.Function,neureka.Tsr[]) -> <init>
    37:37:boolean isLocked() -> isLocked
    45:46:void release() -> release
    53:53:java.lang.String toString() -> toString
neureka.autograd.GraphNode -> neureka.autograd.GraphNode:
    neureka.calculus.Function MUL -> a
    neureka.calculus.Function ADD -> b
    int _mode -> c
    boolean _relies_on_JIPProp -> d
    neureka.autograd.PendingError _pending_error -> e
    boolean _is_used_as_derivative -> f
    neureka.calculus.Function _function -> g
    neureka.autograd.GraphNode[] _parents -> h
    java.lang.ref.WeakReference _payload -> i
    java.util.TreeMap _targets_derivatives -> j
    neureka.autograd.GraphLock _lock -> k
    java.util.List _children -> l
    long _nid -> m
    37:37:boolean usesAD() -> usesAD
    46:46:boolean usesForwardAD() -> usesForwardAD
    55:55:boolean usesReverseAD() -> usesReverseAD
    83:83:boolean reliesOnJustInTimeProp() -> reliesOnJustInTimeProp
    97:99:neureka.autograd.PendingError getAndRemovePendingError() -> getAndRemovePendingError
    116:116:boolean isUsedAsDerivative() -> isUsedAsDerivative
    126:126:neureka.calculus.Function getFunction() -> getFunction
    137:137:neureka.autograd.GraphNode[] getParents() -> getParents
    157:157:neureka.Tsr getPayload() -> getPayload
    161:178:void _setPayload(neureka.Tsr) -> a
    189:190:void update(neureka.Tsr,neureka.Tsr) -> update
    206:206:neureka.autograd.GraphLock lock() -> lock
    215:215:java.util.List getChildren() -> getChildren
    224:224:long nid() -> nid
    235:236:void obtainLocking(neureka.autograd.GraphLock) -> obtainLocking
    242:245:void _attachChild(neureka.autograd.GraphNode) -> a
    254:254:boolean isCachable() -> isCachable
    263:263:boolean isLeave() -> isLeave
    267:271:boolean isGraphLeave() -> isGraphLeave
    278:278:boolean isVirtual() -> isVirtual
    86:307:void <init>(neureka.calculus.Function,java.lang.Object,java.util.function.Supplier) -> <init>
    310:376:void _construct(neureka.Tsr,neureka.calculus.Function,neureka.Tsr[],neureka.autograd.GraphLock) -> a
    390:409:int _modeOf(neureka.Tsr[],neureka.calculus.Function) -> a
    420:425:void _migrateAndOrApplyError(neureka.Tsr,java.util.function.Consumer) -> a
    438:450:void backward(neureka.Tsr) -> backward
    468:490:void _backward(neureka.Tsr,java.util.Set,boolean) -> a
    502:510:void _carryPendingBackPropToGradients(java.util.Set) -> a
    526:528:void backwardJIT(neureka.Tsr) -> backwardJIT
    531:557:void _backwardJIT(neureka.Tsr,neureka.autograd.GraphNode) -> a
    569:573:void _deleteDerivativesRecursively() -> a
    581:590:int _numberOfReverseModeADChildren() -> b
    597:597:int mode() -> mode
    604:604:neureka.calculus.Function function() -> function
    612:625:void put(neureka.autograd.GraphNode,java.lang.Object) -> put
    634:635:java.lang.Object get(neureka.autograd.GraphNode) -> get
    646:647:boolean has(neureka.autograd.GraphNode) -> has
    657:657:int size() -> size
    664:668:void forEachBackward(neureka.Tsr,java.util.function.BiConsumer) -> forEachBackward
    674:678:void forEachForward(neureka.Tsr,java.util.function.BiConsumer) -> forEachForward
    684:686:void forEachDerivative(java.util.function.BiConsumer) -> forEachDerivative
    692:694:void forEachTarget(java.util.function.Consumer) -> forEachTarget
    701:703:void forEach(neureka.Tsr,java.util.function.BiConsumer) -> forEach
    710:710:boolean hasDerivatives() -> hasDerivatives
    717:722:java.lang.String type() -> type
    727:727:java.lang.String toString() -> toString
    735:742:java.lang.String toString(java.lang.String) -> toString
    758:771:java.lang.String _toString(java.lang.String,boolean) -> a
    26:26:void update(java.lang.Object,java.lang.Object) -> update
    702:702:void lambda$forEach$15(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    693:693:void lambda$forEachTarget$14(java.util.function.Consumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    676:677:void lambda$forEachForward$13(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> b
    666:667:void lambda$forEachBackward$12(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> c
    612:612:int lambda$put$11(neureka.autograd.GraphNode,neureka.autograd.GraphNode) -> a
    554:554:void lambda$_backwardJIT$10(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> a
    553:553:void lambda$_backwardJIT$9(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> b
    533:538:void lambda$_backwardJIT$8(neureka.autograd.GraphNode,neureka.Tsr) -> a
    503:503:void lambda$_carryPendingBackPropToGradients$7(java.util.Set,neureka.autograd.GraphNode) -> a
    487:487:void lambda$_backward$6(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> a
    486:486:void lambda$_backward$5(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> b
    444:447:void lambda$backward$4(neureka.autograd.GraphNode) -> b
    441:441:void lambda$backward$3(java.util.Set,neureka.autograd.GraphNode) -> b
    360:363:void lambda$_construct$2(neureka.autograd.GraphNode,neureka.Tsr) -> b
    298:298:void lambda$new$1(neureka.autograd.JITProp) -> a
    166:176:void lambda$_setPayload$0() -> c
    28:29:void <clinit>() -> <clinit>
neureka.autograd.JITProp -> neureka.autograd.JITProp:
    java.util.Set _finished -> a
    java.util.Set _pending -> b
    16:20:void <init>(java.util.Set) -> <init>
    27:30:void addPending(java.util.Set) -> addPending
    37:46:void noteFinished(neureka.autograd.GraphNode) -> noteFinished
    49:49:int finishedCount() -> finishedCount
    53:53:int pendingCount() -> pendingCount
    61:71:void execute() -> execute
    78:78:boolean isDone() -> isDone
    86:88:java.lang.String toString() -> toString
    95:95:void update(neureka.Tsr,neureka.Tsr) -> update
    10:10:void update(java.lang.Object,java.lang.Object) -> update
    63:68:void lambda$execute$0(neureka.autograd.GraphNode) -> a
neureka.autograd.PendingError -> neureka.autograd.PendingError:
    int _toBeReceived -> a
    neureka.Tsr _error -> b
    11:14:void <init>(neureka.Tsr,int) -> <init>
    17:21:void accumulate(neureka.Tsr) -> accumulate
    24:24:boolean isFullyAccumulated() -> isFullyAccumulated
    28:28:neureka.Tsr getAccumulatedError() -> getAccumulatedError
neureka.calculus.Function -> neureka.calculus.Function:
    neureka.calculus.environment.Cache CACHE -> CACHE
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    61:61:neureka.calculus.Function create(java.lang.String) -> create
    65:65:neureka.calculus.Function create(java.lang.String,boolean) -> create
    neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    boolean doesAD() -> doesAD
    boolean isFlat() -> isFlat
    int id() -> id
    neureka.calculus.environment.OperationType type() -> type
    boolean dependsOn(int) -> dependsOn
    double call(double) -> call
    double invoke(double) -> invoke
    double call(double[],int) -> call
    double invoke(double[],int) -> invoke
    double call(double[]) -> call
    double invoke(double[]) -> invoke
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    neureka.Tsr call(neureka.Tsr) -> call
    neureka.Tsr invoke(neureka.Tsr) -> invoke
    neureka.Tsr call(java.util.List) -> call
    neureka.Tsr invoke(java.util.List) -> invoke
    neureka.Tsr call(neureka.Tsr[],int) -> call
    neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    neureka.Tsr call(neureka.Tsr[]) -> call
    neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    neureka.Tsr derive(neureka.Tsr[],int) -> derive
    java.lang.String toString() -> toString
    neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    18:35:void <clinit>() -> <clinit>
neureka.calculus.Function$Detached -> neureka.calculus.Function$Detached:
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function ADD -> ADD
    neureka.calculus.Function ADD_ASSIGN -> ADD_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    38:38:void <init>() -> <init>
    40:57:void <clinit>() -> <clinit>
neureka.calculus.Function$Setup -> neureka.calculus.Function$Setup:
    68:68:void <init>() -> <init>
    71:71:neureka.Tsr commit(neureka.Tsr[],java.lang.String,boolean) -> commit
    75:75:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],java.lang.String,boolean) -> commit
    79:79:neureka.Tsr commit(neureka.Tsr[],neureka.calculus.Function) -> commit
    83:83:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function) -> commit
    88:111:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier) -> commit
    93:93:neureka.Tsr lambda$commit$0(neureka.Tsr) -> a
neureka.calculus.environment.Cache -> neureka.calculus.environment.Cache:
    neureka.calculus.environment.Cache _cache -> a
    java.util.Map FUNCTIONS -> b
    java.util.Map PROCESSING -> c
    15:30:void <init>() -> <init>
    18:20:neureka.calculus.environment.Cache instance() -> instance
    27:27:java.util.Map FUNCTIONS() -> FUNCTIONS
    34:36:void free(neureka.autograd.GraphLock) -> free
    40:74:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier,int,int) -> preprocess
    79:92:neureka.Tsr _get(neureka.Tsr[],int,int) -> a
    97:108:void _put(neureka.Tsr,neureka.autograd.GraphNode,int,int) -> a
    111:111:int _keyed(int) -> a
    101:101:int lambda$_put$2(java.lang.Long,java.lang.Long) -> a
    60:60:neureka.Tsr lambda$preprocess$1(neureka.Tsr) -> a
    30:30:int lambda$new$0(neureka.autograd.GraphLock,neureka.autograd.GraphLock) -> a
    13:13:void <clinit>() -> <clinit>
neureka.calculus.environment.OperationType -> neureka.calculus.environment.OperationType:
    java.util.Map _LOOKUP -> a
    java.util.ArrayList _REGISTER -> b
    int _ID -> c
    int _id -> _id
    java.lang.String _name -> _name
    java.lang.String _identifier -> _identifier
    boolean _isOperation -> _isOperation
    boolean _isIndexer -> _isIndexer
    boolean _isConvection -> _isConvection
    boolean _isCommutative -> _isCommutative
    boolean _isAssociative -> _isAssociative
    neureka.calculus.environment.Type$Activation _activation -> _activation
    neureka.calculus.environment.Type$Convolution _convolution -> _convolution
    neureka.calculus.environment.Type$Broadcast _broadcast -> _broadcast
    neureka.calculus.environment.Type$Scalarization _scalarization -> _scalarization
    neureka.calculus.environment.Type$Operation _operation -> _operation
    26:26:java.util.ArrayList instances() -> instances
    30:30:neureka.calculus.environment.OperationType instance(int) -> instance
    34:34:neureka.calculus.environment.OperationType instance(java.lang.String) -> instance
    96:128:void <init>(java.lang.String,java.lang.String,boolean,boolean,boolean,boolean,boolean,neureka.calculus.environment.Type$Activation,neureka.calculus.environment.Type$Scalarization,neureka.calculus.environment.Type$Convolution,neureka.calculus.environment.Type$Broadcast,neureka.calculus.environment.Type$Operation) -> <init>
    131:131:neureka.calculus.environment.OperationType[] ALL() -> ALL
    135:135:int COUNT() -> COUNT
    142:142:java.lang.String getName() -> getName
    149:149:neureka.calculus.environment.Type$Activation getActivation() -> getActivation
    154:154:boolean supportsActivation() -> supportsActivation
    161:161:neureka.calculus.environment.Type$Scalarization getScalarization() -> getScalarization
    166:166:boolean supportsScalar() -> supportsScalar
    173:173:neureka.calculus.environment.Type$Convolution getConvolution() -> getConvolution
    178:178:boolean supportsConvolution() -> supportsConvolution
    185:185:neureka.calculus.environment.Type$Broadcast getBroadcast() -> getBroadcast
    190:190:boolean supportsBroadcast() -> supportsBroadcast
    197:197:neureka.calculus.environment.Type$Operation getOperation() -> getOperation
    202:202:boolean supportsOperation() -> supportsOperation
    209:209:int id() -> id
    214:214:java.lang.String identifier() -> identifier
    219:219:boolean isOperation() -> isOperation
    224:224:boolean isIndexer() -> isIndexer
    229:229:boolean isConvection() -> isConvection
    234:234:boolean isCommutative() -> isCommutative
    240:247:boolean allowsForward(neureka.Tsr[]) -> allowsForward
    253:286:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    287:287:neureka.Tsr lambda$getADAgentOf$10(neureka.autograd.GraphNode,neureka.Tsr) -> a
    287:287:neureka.Tsr lambda$getADAgentOf$9(neureka.autograd.GraphNode,neureka.Tsr) -> b
    287:287:neureka.Tsr lambda$getADAgentOf$8() -> a
    282:282:neureka.Tsr lambda$getADAgentOf$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    281:281:neureka.Tsr lambda$getADAgentOf$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    280:280:neureka.Tsr lambda$getADAgentOf$5(neureka.Tsr) -> a
    269:269:neureka.Tsr lambda$getADAgentOf$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    268:268:neureka.Tsr lambda$getADAgentOf$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    267:267:neureka.Tsr lambda$getADAgentOf$2(neureka.Tsr) -> b
    259:259:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    258:258:neureka.Tsr lambda$getADAgentOf$0(neureka.Tsr) -> c
    21:80:void <clinit>() -> <clinit>
neureka.calculus.environment.Type -> neureka.calculus.environment.Type:
    neureka.calculus.environment.Type$Activation getActivation() -> getActivation
    boolean supportsActivation() -> supportsActivation
    neureka.calculus.environment.Type$Scalarization getScalarization() -> getScalarization
    boolean supportsScalar() -> supportsScalar
    neureka.calculus.environment.Type$Convolution getConvolution() -> getConvolution
    boolean supportsConvolution() -> supportsConvolution
    neureka.calculus.environment.Type$Broadcast getBroadcast() -> getBroadcast
    boolean supportsBroadcast() -> supportsBroadcast
    neureka.calculus.environment.Type$Operation getOperation() -> getOperation
    boolean supportsOperation() -> supportsOperation
    java.lang.String getName() -> getName
    int id() -> id
    java.lang.String identifier() -> identifier
    boolean isOperation() -> isOperation
    boolean isIndexer() -> isIndexer
    boolean isConvection() -> isConvection
    boolean isCommutative() -> isCommutative
    boolean allowsForward(neureka.Tsr[]) -> allowsForward
    neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
neureka.calculus.environment.Type$Activation -> neureka.calculus.environment.Type$Activation:
    47:48:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$DefaultOperatorCreator) -> <init>
neureka.calculus.environment.Type$Broadcast -> neureka.calculus.environment.Type$Broadcast:
    61:62:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$DefaultOperatorCreator) -> <init>
neureka.calculus.environment.Type$Convolution -> neureka.calculus.environment.Type$Convolution:
    54:55:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$DefaultOperatorCreator) -> <init>
neureka.calculus.environment.Type$TertiaryNDXConsumer -> neureka.calculus.environment.Type$TertiaryNDXConsumer:
    double execute(int[],int[],int[]) -> execute
neureka.calculus.environment.Type$Operation -> neureka.calculus.environment.Type$Operation:
    75:76:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$DefaultOperatorCreator) -> <init>
neureka.calculus.environment.Type$DefaultOperatorCreator -> neureka.calculus.environment.Type$DefaultOperatorCreator:
    neureka.calculus.environment.Type$TertiaryNDXConsumer create(neureka.Tsr[],int) -> create
neureka.calculus.environment.Type$ScalarOperatorCreator -> neureka.calculus.environment.Type$ScalarOperatorCreator:
    neureka.calculus.environment.Type$TertiaryNDXConsumer create(neureka.Tsr[],double,int) -> create
neureka.calculus.environment.Type$Scalarization -> neureka.calculus.environment.Type$Scalarization:
    68:69:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$ScalarOperatorCreator) -> <init>
neureka.calculus.environment.Type$TypeComponent -> neureka.calculus.environment.Type$TypeComponent:
    java.lang.String _operation -> _operation
    java.lang.String _deriviation -> _deriviation
    java.lang.Object _creator -> _creator
    26:30:void <init>(java.lang.String,java.lang.String,java.lang.Object) -> <init>
    32:32:java.lang.String getAsString() -> getAsString
    35:35:java.lang.String getDeriviationAsString() -> getDeriviationAsString
    38:38:java.lang.Object getCreator() -> getCreator
neureka.calculus.environment.implementations.function.Absolute -> neureka.calculus.environment.implementations.function.Absolute:
    9:27:void <init>() -> <init>
    14:18:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    18:18:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:16:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Cosinus -> neureka.calculus.environment.implementations.function.Cosinus:
    9:25:void <init>() -> <init>
    14:16:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    16:16:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    15:15:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Gaussian -> neureka.calculus.environment.implementations.function.Gaussian:
    9:37:void <init>() -> <init>
    20:24:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    25:26:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Identity -> neureka.calculus.environment.implementations.function.Identity:
    9:25:void <init>() -> <init>
    13:15:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    15:15:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    14:14:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Ligmoid -> neureka.calculus.environment.implementations.function.Ligmoid:
    9:40:void <init>() -> <init>
    30:32:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    32:32:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    31:31:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Quadratic -> neureka.calculus.environment.implementations.function.Quadratic:
    9:35:void <init>() -> <init>
    21:27:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    27:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.ReLU -> neureka.calculus.environment.implementations.function.ReLU:
    8:41:void <init>() -> <init>
    21:28:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    29:30:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sigmoid -> neureka.calculus.environment.implementations.function.Sigmoid:
    9:38:void <init>() -> <init>
    21:25:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    26:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    23:23:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sinus -> neureka.calculus.environment.implementations.function.Sinus:
    9:25:void <init>() -> <init>
    15:17:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    17:17:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:16:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Tanh -> neureka.calculus.environment.implementations.function.Tanh:
    8:31:void <init>() -> <init>
    13:20:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    21:22:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:17:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.indexer.Product -> neureka.calculus.environment.implementations.indexer.Product:
    8:35:void <init>() -> <init>
    19:24:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    25:26:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.indexer.Summation -> neureka.calculus.environment.implementations.indexer.Summation:
    8:29:void <init>() -> <init>
    19:24:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    24:24:double lambda$new$1(int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.operator.Addition -> neureka.calculus.environment.implementations.operator.Addition:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    neureka.calculus.environment.Type$Broadcast _broadcast -> b
    26:96:void <init>() -> <init>
    35:37:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],double,int) -> a
    37:37:double lambda$new$4(int[],int[],int[]) -> a
    36:36:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:14:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> a
    14:14:double lambda$static$1(int[],int[],int[]) -> b
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:18:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Division -> neureka.calculus.environment.implementations.operator.Division:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    26:103:void <init>() -> <init>
    37:42:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$6(neureka.Tsr[],double,int) -> a
    42:42:double lambda$new$5(double,double[],neureka.Tsr[],int[],int[],int[]) -> a
    41:41:double lambda$new$4(double,int[],int[],int[]) -> a
    39:39:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:14:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> a
    15:18:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:7:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Modulo -> neureka.calculus.environment.implementations.operator.Modulo:
    9:46:void <init>() -> <init>
    18:23:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    24:30:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    21:21:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.operator.Multiplication -> neureka.calculus.environment.implementations.operator.Multiplication:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    24:129:void <init>() -> <init>
    89:94:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$11(neureka.Tsr[],int) -> a
    95:96:double lambda$new$10(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    92:92:double lambda$new$9(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    53:55:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$8(neureka.Tsr[],int) -> b
    55:55:double lambda$new$7(double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    31:36:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$6(neureka.Tsr[],double,int) -> a
    36:36:double lambda$new$5(double[],neureka.Tsr[],int[],int[],int[]) -> a
    35:35:double lambda$new$4(double,int[],int[],int[]) -> a
    33:33:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    10:15:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> c
    16:17:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    13:13:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> c
    8:8:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Power -> neureka.calculus.environment.implementations.operator.Power:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    33:116:void <init>() -> <init>
    42:49:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$6(neureka.Tsr[],double,int) -> a
    49:49:double lambda$new$5(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    47:47:double lambda$new$4(double,double[],neureka.Tsr[],int[],int[],int[]) -> a
    44:44:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> b
    9:14:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> a
    15:25:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    8:8:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Subtraction -> neureka.calculus.environment.implementations.operator.Subtraction:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    24:91:void <init>() -> <init>
    35:40:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$6(neureka.Tsr[],double,int) -> a
    40:40:double lambda$new$5(int[],int[],int[]) -> a
    39:39:double lambda$new$4(int[],int[],int[]) -> b
    37:37:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:16:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> a
    17:17:double lambda$static$1(int,int[],int[],int[]) -> a
    13:13:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:7:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.other.CopyLeft -> neureka.calculus.environment.implementations.other.CopyLeft:
    9:14:void <init>() -> <init>
neureka.calculus.environment.implementations.other.CopyRight -> neureka.calculus.environment.implementations.other.CopyRight:
    8:11:void <init>() -> <init>
neureka.calculus.environment.implementations.other.Randomization -> neureka.calculus.environment.implementations.other.Randomization:
    12:33:void <init>() -> <init>
    22:25:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$1(neureka.Tsr[],double,int) -> a
    25:25:double lambda$new$0(java.util.Random,int[],int[],int[]) -> a
neureka.calculus.environment.implementations.other.Reshape -> neureka.calculus.environment.implementations.other.Reshape:
    13:18:void <init>() -> <init>
    22:25:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    28:28:neureka.Tsr lambda$getADAgentOf$2(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    27:27:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    26:26:neureka.Tsr lambda$getADAgentOf$0() -> a
neureka.calculus.factory.AbstractFunction -> neureka.calculus.factory.AbstractFunction:
    neureka.calculus.environment.OperationType _type -> a
    boolean _isFlat -> b
    boolean _doAD -> c
    java.util.ArrayList _src -> d
    31:36:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    42:42:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    47:47:boolean isFlat() -> isFlat
    52:52:boolean doesAD() -> doesAD
    57:57:int id() -> id
    62:62:neureka.calculus.environment.OperationType type() -> type
    69:101:java.lang.String toString() -> toString
    106:109:boolean dependsOn(int) -> dependsOn
    116:116:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    128:138:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int) -> _tensor_activation
    1280:1283:neureka.unit.acceleration.Device _device(neureka.Tsr[]):280:283 -> _tensor_activation
    1280:1283:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):128 -> _tensor_activation
    1311:1326:boolean _shareGuestDevice(neureka.Tsr[]):311:326 -> _tensor_activation
    1311:1326:neureka.unit.acceleration.Device _device(neureka.Tsr[]):281 -> _tensor_activation
    1311:1326:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):128 -> _tensor_activation
    144:184:neureka.Tsr _recursie_breakdown_execution(neureka.Tsr[],int,int,neureka.unit.acceleration.Device) -> a
    189:262:neureka.Tsr _execution(neureka.Tsr[],int,int,neureka.unit.acceleration.Device) -> b
    266:276:neureka.Tsr _apply(neureka.unit.acceleration.Device,int,java.util.function.Supplier) -> a
    287:307:neureka.Tsr[] _src_acti(neureka.Tsr[],int,int,int) -> a
    332:354:double _scalar_activation(double,boolean) -> _scalar_activation
    361:381:double _scalar_activation(double[],int,int) -> _scalar_activation
    184:184:neureka.Tsr lambda$_recursie_breakdown_execution$2(neureka.Tsr[],int,int,neureka.unit.acceleration.Device) -> c
    136:136:neureka.Tsr lambda$_tensor_activation$1(neureka.Tsr[],int,int,neureka.unit.acceleration.Device) -> d
    131:131:neureka.Tsr lambda$_tensor_activation$0(neureka.Tsr[],int,int,neureka.unit.acceleration.Device) -> e
neureka.calculus.factory.AbstractFunction$Exec -> neureka.calculus.factory.AbstractFunction$Exec:
    385:385:void <init>() -> <init>
    390:397:double reLu(double,boolean) -> reLu
    403:406:double sigmoid(double,boolean) -> sigmoid
    412:415:double tanh(double,boolean) -> tanh
    421:422:double quadratic(double,boolean) -> quadratic
    427:428:double ligmoid(double,boolean) -> ligmoid
    433:434:double linear(double,boolean) -> linear
    439:440:double gaussian(double,boolean) -> gaussian
    445:446:double absolute(double,boolean) -> absolute
    451:452:double sinus(double,boolean) -> sinus
    457:458:double cosinus(double,boolean) -> cosinus
    462:474:double summation(double[],int,int,java.util.ArrayList) -> a
    479:501:double summation(double[],int,java.util.ArrayList) -> a
    508:527:double PI(double[],int,int,java.util.ArrayList) -> b
    533:552:double PI(double[],int,java.util.ArrayList) -> b
    561:582:double power(double[],int,int,java.util.ArrayList) -> c
    588:613:double power(double[],int,java.util.ArrayList) -> c
    619:636:double division(double[],int,int,java.util.ArrayList) -> d
    642:663:double division(double[],int,java.util.ArrayList) -> d
    669:687:double multiplication(double[],int,int,java.util.ArrayList) -> e
    693:711:double multiplication(double[],int,java.util.ArrayList) -> e
    726:734:double modulo(double[],int,int,java.util.ArrayList) -> f
    740:748:double modulo(double[],int,java.util.ArrayList) -> f
    754:770:double subtraction(double[],int,int,java.util.ArrayList) -> g
    776:792:double subtraction(double[],int,java.util.ArrayList) -> g
    798:810:double addition(double[],int,int,java.util.ArrayList) -> h
    816:828:double addition(double[],int,java.util.ArrayList) -> h
neureka.calculus.factory.BaseFunction -> neureka.calculus.factory.BaseFunction:
    7:7:void <init>() -> <init>
    11:11:double call(double) -> call
    16:16:neureka.Tsr call(neureka.Tsr) -> call
    23:23:neureka.Tsr call(java.util.List) -> call
    28:28:neureka.Tsr invoke(java.util.List) -> invoke
    35:35:double invoke(double) -> invoke
    40:40:double invoke(double[],int) -> invoke
    45:45:double invoke(double[]) -> invoke
    52:52:neureka.Tsr invoke(neureka.Tsr) -> invoke
    57:57:neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    62:62:neureka.Tsr invoke(neureka.Tsr[]) -> invoke
neureka.calculus.factory.assembly.FunctionBuilder -> neureka.calculus.factory.assembly.FunctionBuilder:
    11:11:void <init>() -> <init>
    20:36:neureka.calculus.Function build(neureka.calculus.environment.OperationType,int,boolean) -> build
    47:60:neureka.calculus.Function build(java.lang.String,boolean) -> build
    1069:1258:neureka.calculus.Function _build(java.lang.String,boolean):69:258 -> build
    1069:1258:neureka.calculus.Function build(java.lang.String,boolean):56 -> build
    268:275:java.util.List _rebindPairwise(java.util.List,int) -> a
neureka.calculus.factory.assembly.FunctionConstructor -> neureka.calculus.factory.assembly.FunctionConstructor:
    12:12:void <init>() -> <init>
    16:59:neureka.calculus.Function construct(int,java.util.ArrayList,boolean) -> construct
neureka.calculus.factory.assembly.FunctionConstructor$1 -> neureka.calculus.factory.assembly.FunctionConstructor$1:
    java.util.ArrayList val$sources -> a
    21:21:void <init>(int,boolean,java.util.ArrayList,boolean,java.util.ArrayList) -> <init>
    24:24:neureka.Tsr call(neureka.Tsr[],int) -> call
    28:28:neureka.Tsr call(neureka.Tsr[]) -> call
    32:32:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    36:36:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    41:41:double call(double[],int) -> call
    45:45:double call(double[]) -> call
    49:50:double derive(double[],int,int) -> derive
    54:55:double derive(double[],int) -> derive
    28:28:neureka.Tsr lambda$call$1(java.util.ArrayList,neureka.Tsr[]) -> a
    24:24:neureka.Tsr lambda$call$0(java.util.ArrayList,neureka.Tsr[],int) -> a
neureka.calculus.factory.assembly.FunctionConstructor$2 -> neureka.calculus.factory.assembly.FunctionConstructor$2:
    59:59:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    62:62:neureka.Tsr call(neureka.Tsr[],int) -> call
    66:66:neureka.Tsr call(neureka.Tsr[]) -> call
    70:70:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    74:74:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    79:79:double call(double[],int) -> call
    83:83:double call(double[]) -> call
    87:87:double derive(double[],int,int) -> derive
    91:91:double derive(double[],int) -> derive
    74:74:neureka.Tsr lambda$derive$3(neureka.Tsr[],int) -> a
    70:70:neureka.Tsr lambda$derive$2(neureka.Tsr[],int,int) -> a
    66:66:neureka.Tsr lambda$call$1(neureka.Tsr[]) -> a
    62:62:neureka.Tsr lambda$call$0(neureka.Tsr[],int) -> b
neureka.calculus.factory.assembly.FunctionParser -> neureka.calculus.factory.assembly.FunctionParser:
    10:10:void <init>() -> <init>
    12:16:int numberOfOperationsWithin(java.util.List) -> numberOfOperationsWithin
    20:30:java.lang.String parsedOperation(java.lang.String,int) -> parsedOperation
    34:55:java.lang.String parsedComponent(java.lang.String,int) -> parsedComponent
    59:62:boolean containsOperation(java.lang.String,java.util.List) -> containsOperation
    66:67:boolean isBasicOperation(java.lang.String) -> isBasicOperation
    71:78:java.lang.String groupBy(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> groupBy
    82:82:boolean isWeired(char) -> a
    87:89:java.lang.String removeHeadAndTail(java.lang.String) -> removeHeadAndTail
    93:132:java.lang.String cleanedHeadAndTail(java.lang.String) -> cleanedHeadAndTail
    136:185:java.lang.String unpackAndCorrect(java.lang.String) -> unpackAndCorrect
    189:199:java.lang.String assumptionBasedOn(java.lang.String) -> assumptionBasedOn
    203:216:double similarity(java.lang.String,java.lang.String) -> similarity
neureka.calculus.factory.components.FunctionConstant -> neureka.calculus.factory.components.FunctionConstant:
    double _value -> a
    9:9:void <init>() -> <init>
    13:13:double value() -> value
    20:20:boolean isFlat() -> isFlat
    25:25:boolean doesAD() -> doesAD
    30:30:int id() -> id
    35:35:neureka.calculus.environment.OperationType type() -> type
    40:40:boolean dependsOn(int) -> dependsOn
    46:59:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    66:66:double call(double[],int) -> call
    71:71:double call(double[]) -> call
    76:76:double derive(double[],int) -> derive
    81:81:double derive(double[],int,int) -> derive
    88:88:neureka.Tsr call(neureka.Tsr[],int) -> call
    93:93:neureka.Tsr call(neureka.Tsr[]) -> call
    98:98:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    103:103:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    110:110:java.lang.String toString() -> toString
    115:115:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionInput -> neureka.calculus.factory.components.FunctionInput:
    int _index -> a
    12:12:void <init>() -> <init>
    19:19:boolean providesGradient() -> providesGradient
    26:26:boolean isFlat() -> isFlat
    31:31:boolean doesAD() -> doesAD
    36:36:int id() -> id
    41:41:neureka.calculus.environment.OperationType type() -> type
    46:46:boolean dependsOn(int) -> dependsOn
    54:74:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    79:89:neureka.Tsr _extract(neureka.Tsr) -> a
    96:96:double call(double[],int) -> call
    101:101:double call(double[]) -> call
    106:106:double derive(double[],int) -> derive
    111:111:double derive(double[],int,int) -> derive
    118:118:neureka.Tsr call(neureka.Tsr[],int) -> call
    123:123:neureka.Tsr call(neureka.Tsr[]) -> call
    128:128:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    133:135:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    142:142:java.lang.String toString() -> toString
    146:146:int index() -> index
    151:151:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionVariable -> neureka.calculus.factory.components.FunctionVariable:
    boolean _providesGradient -> a
    10:12:void <init>() -> <init>
    15:15:boolean providesGradient() -> providesGradient
    20:20:boolean isFlat() -> isFlat
    25:25:boolean doesAD() -> doesAD
    30:30:int id() -> id
    35:35:neureka.calculus.environment.OperationType type() -> type
    40:40:boolean dependsOn(int) -> dependsOn
    46:47:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    54:54:double call(double[],int) -> call
    59:61:double call(double[]) -> call
    66:66:double derive(double[],int) -> derive
    71:72:double derive(double[],int,int) -> derive
    78:78:neureka.Tsr call(neureka.Tsr[],int) -> call
    83:85:neureka.Tsr call(neureka.Tsr[]) -> call
    90:90:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    95:95:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    102:102:java.lang.String toString() -> toString
    107:107:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.GradientProvider -> neureka.calculus.factory.components.GradientProvider:
    boolean providesGradient() -> providesGradient
neureka.framing.IndexAlias -> neureka.framing.IndexAlias:
    java.util.Map _mapping -> a
    13:23:void <init>(java.util.List) -> <init>
    25:28:void <init>(int) -> <init>
    30:43:void <init>(java.util.Map,neureka.Tsr) -> <init>
    46:46:int[] get(java.util.List) -> get
    50:61:int[] get(java.lang.Object[]) -> get
    66:68:int get(java.lang.Object,java.lang.Object) -> get
    73:76:void replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    79:85:void _initializeIdxmap(java.lang.Object,int,java.lang.Object,int) -> a
    89:92:void set(java.lang.Object,java.lang.Object,int) -> set
    96:100:java.util.List keysOf(java.lang.Object) -> keysOf
    104:108:java.util.List keysOf(java.lang.Object,int) -> keysOf
    112:120:java.lang.String _fixed(java.lang.String,int) -> a
    126:188:java.lang.String toString() -> toString
    195:195:void update(neureka.Tsr,neureka.Tsr) -> update
    8:8:void update(java.lang.Object,java.lang.Object) -> update
    159:174:void lambda$toString$6(java.lang.Object[],int[],java.lang.StringBuilder,int[],java.lang.Object,java.lang.Object) -> a
    162:163:void lambda$toString$5(int[],java.lang.Object[],java.lang.Object,java.lang.Integer) -> a
    141:147:void lambda$toString$4(int[],int[],java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    134:134:java.lang.Boolean lambda$toString$3(int,int,java.lang.Integer) -> a
    106:106:void lambda$keysOf$2(int,java.util.List,java.lang.Object,java.lang.Integer) -> a
    98:98:void lambda$keysOf$1(java.util.List,java.lang.Object,java.lang.Integer) -> a
    34:42:void lambda$new$0(neureka.Tsr,int[],java.lang.Object,java.util.List) -> a
neureka.framing.Relation -> neureka.framing.Relation:
    neureka.Tsr _parent -> a
    java.lang.ref.WeakReference[] _children -> b
    9:9:void <init>() -> <init>
    17:34:void update(neureka.Tsr,neureka.Tsr) -> update
    38:39:neureka.framing.Relation addParent(neureka.Tsr) -> addParent
    43:51:neureka.framing.Relation addChild(neureka.Tsr) -> addChild
    55:65:neureka.framing.Relation foreachChild(java.util.function.Consumer) -> foreachChild
    69:69:boolean hasParent() -> hasParent
    73:73:boolean hasChildren() -> hasChildren
    77:77:int childCount() -> childCount
    9:9:void update(java.lang.Object,java.lang.Object) -> update
neureka.ndim.AbstractComponentOwner -> neureka.ndim.AbstractComponentOwner:
    java.util.List _components -> _components
    19:24:void <init>() -> <init>
    31:36:java.lang.Object find(java.lang.Class) -> find
    45:53:java.lang.Object remove(java.lang.Class) -> remove
    62:62:boolean has(java.lang.Class) -> has
    71:83:java.lang.Object add(neureka.Component) -> add
    neureka.Component _addOrReject(neureka.Component) -> _addOrReject
    99:104:boolean forComponent(java.lang.Class,java.util.function.Consumer) -> forComponent
neureka.ndim.AbstractNDArray -> neureka.ndim.AbstractNDArray:
    neureka.ndim.config.NDConfiguration _conf -> _conf
    java.lang.Object _value -> _value
    25:25:void <init>() -> <init>
    34:34:boolean is64() -> is64
    38:38:boolean is32() -> is32
    44:44:int i_of_i(int) -> i_of_i
    48:48:int[] idx_of_i(int) -> idx_of_i
    52:52:int i_of_idx(int[]) -> i_of_idx
    58:58:neureka.ndim.config.NDConfiguration getNDConf() -> getNDConf
    64:64:int rank() -> rank
    68:68:java.util.List shape() -> shape
    72:72:int shape(int) -> shape
    76:76:java.util.List idxmap() -> idxmap
    80:80:java.util.List translation() -> translation
    84:84:java.util.List spread() -> spread
    88:88:java.util.List offset() -> offset
    92:92:int size() -> size
    96:98:java.util.List _asList(int[]) -> _asList
neureka.ndim.AbstractNDArray$Utility -> neureka.ndim.AbstractNDArray$Utility:
    108:108:void <init>() -> <init>
neureka.ndim.AbstractNDArray$Utility$Indexing -> neureka.ndim.AbstractNDArray$Utility$Indexing:
    142:142:void <init>() -> <init>
    147:150:void increment(int[],int[]) -> increment
    1154:1179:int _incrementAt(int,int[],int[]):154:179 -> increment
    1154:1179:void increment(int[],int[]):149 -> increment
    185:198:int[] newTlnOf(int[]) -> newTlnOf
    203:208:int[] rearrange(int[],int[]) -> rearrange
    213:218:int[] shpCheck(int[],neureka.Tsr) -> shpCheck
    223:229:int[] rearrange(int[],int[],int[]) -> rearrange
    234:255:int[][] makeFit(int[],int[]) -> makeFit
    260:262:int[] shpOfCon(int[],int[]) -> shpOfCon
    267:274:int[] shpOfBrc(int[],int[]) -> shpOfBrc
    279:281:int szeOfShp(int[]) -> szeOfShp
neureka.ndim.AbstractNDArray$Utility$Stringify -> neureka.ndim.AbstractNDArray$Utility$Stringify:
    110:110:void <init>() -> <init>
    114:128:java.lang.String formatFP(double) -> formatFP
    133:135:java.lang.String strConf(int[]) -> strConf
neureka.ndim.config.AbstractArrayBasedNDC -> neureka.ndim.config.AbstractArrayBasedNDC:
    java.util.Map _CACHED_INT_ARRAYS -> a
    7:7:void <init>() -> <init>
    21:44:int[] _cached(int[]) -> _cached
    16:17:void <clinit>() -> <clinit>
neureka.ndim.config.AbstractNDC -> neureka.ndim.config.AbstractNDC:
    java.util.Map _CONFS -> a
    16:16:void <init>() -> <init>
    32:36:long keyCode() -> keyCode
    42:46:boolean equals(neureka.ndim.config.NDConfiguration) -> equals
    58:71:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    1095:1101:boolean _isSimpleConfiguration(int[],int[],int[],int[],int[]):95:101 -> construct
    1095:1101:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]):58 -> construct
    76:84:neureka.ndim.config.NDConfiguration _cached(neureka.ndim.config.NDConfiguration) -> _cached
    108:113:java.lang.String toString() -> toString
    24:25:void <clinit>() -> <clinit>
neureka.ndim.config.NDConfiguration -> neureka.ndim.config.NDConfiguration:
    int rank() -> rank
    int[] shape() -> shape
    int shape(int) -> shape
    int[] idxmap() -> idxmap
    int idxmap(int) -> idxmap
    int[] translation() -> translation
    int translation(int) -> translation
    int[] spread() -> spread
    int spread(int) -> spread
    int[] offset() -> offset
    int offset(int) -> offset
    int i_of_i(int) -> i_of_i
    int[] idx_of_i(int) -> idx_of_i
    int i_of_idx(int[]) -> i_of_idx
    long keyCode() -> keyCode
    boolean equals(neureka.ndim.config.NDConfiguration) -> equals
neureka.ndim.config.complex.D1Configuration -> neureka.ndim.config.complex.D1Configuration:
    int _shape -> a
    int _translation -> b
    int _idxmap -> c
    int _spread -> d
    int _offset -> e
    39:39:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    48:54:void <init>(int,int,int,int,int) -> <init>
    58:58:int rank() -> rank
    63:63:int[] shape() -> shape
    68:68:int shape(int) -> shape
    73:73:int[] idxmap() -> idxmap
    78:78:int idxmap(int) -> idxmap
    83:83:int[] translation() -> translation
    88:88:int translation(int) -> translation
    93:93:int[] spread() -> spread
    98:98:int spread(int) -> spread
    103:103:int[] offset() -> offset
    108:108:int offset(int) -> offset
    114:114:int i_of_i(int) -> i_of_i
    119:119:int[] idx_of_i(int) -> idx_of_i
    123:123:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.complex.DefaultNDConfiguration -> neureka.ndim.config.complex.DefaultNDConfiguration:
    int[] _shape -> a
    int[] _translation -> b
    int[] _idxmap -> c
    int[] _spread -> d
    int[] _offset -> e
    28:34:void <init>(int[],int[],int[],int[],int[]) -> <init>
    43:43:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    72:72:int rank() -> rank
    77:77:int[] shape() -> shape
    82:82:int shape(int) -> shape
    87:87:int[] idxmap() -> idxmap
    92:92:int idxmap(int) -> idxmap
    97:97:int[] translation() -> translation
    102:102:int translation(int) -> translation
    107:107:int[] spread() -> spread
    112:112:int spread(int) -> spread
    117:117:int[] offset() -> offset
    122:122:int offset(int) -> offset
    130:130:int i_of_i(int) -> i_of_i
    135:147:int[] idx_of_i(int) -> idx_of_i
    152:154:int i_of_idx(int[]) -> i_of_idx
    19:20:void <clinit>() -> <clinit>
neureka.ndim.config.complex.ScalarConfiguration -> neureka.ndim.config.complex.ScalarConfiguration:
    int _shape -> a
    int _offset -> b
    27:27:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    33:36:void <init>(int,int) -> <init>
    40:40:int rank() -> rank
    45:45:int[] shape() -> shape
    50:50:int shape(int) -> shape
    55:55:int[] idxmap() -> idxmap
    60:60:int idxmap(int) -> idxmap
    65:65:int[] translation() -> translation
    70:70:int translation(int) -> translation
    75:75:int[] spread() -> spread
    80:80:int spread(int) -> spread
    85:85:int[] offset() -> offset
    90:90:int offset(int) -> offset
    96:96:int i_of_i(int) -> i_of_i
    101:101:int[] idx_of_i(int) -> idx_of_i
    106:106:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleD1Configuration -> neureka.ndim.config.simple.SimpleD1Configuration:
    int _shape -> a
    int _translation_and_idxmap -> b
    23:23:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    29:32:void <init>(int,int) -> <init>
    36:36:int rank() -> rank
    41:41:int[] shape() -> shape
    46:46:int shape(int) -> shape
    51:51:int[] idxmap() -> idxmap
    56:56:int idxmap(int) -> idxmap
    61:61:int[] translation() -> translation
    66:66:int translation(int) -> translation
    71:71:int[] spread() -> spread
    76:76:int spread(int) -> spread
    81:81:int[] offset() -> offset
    86:86:int offset(int) -> offset
    92:92:int i_of_i(int) -> i_of_i
    97:97:int[] idx_of_i(int) -> idx_of_i
    101:101:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleDefaultNDConfiguration -> neureka.ndim.config.simple.SimpleDefaultNDConfiguration:
    int[] _shape -> a
    int[] _translation_and_idxmap -> b
    14:17:void <init>(int[],int[]) -> <init>
    23:23:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    38:38:int rank() -> rank
    43:43:int[] shape() -> shape
    48:48:int shape(int) -> shape
    53:53:int[] idxmap() -> idxmap
    58:58:int idxmap(int) -> idxmap
    63:63:int[] translation() -> translation
    68:68:int translation(int) -> translation
    73:75:int[] spread() -> spread
    80:80:int spread(int) -> spread
    85:85:int[] offset() -> offset
    90:90:int offset(int) -> offset
    98:98:int i_of_i(int) -> i_of_i
    103:115:int[] idx_of_i(int) -> idx_of_i
    120:122:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleScalarConfiguration -> neureka.ndim.config.simple.SimpleScalarConfiguration:
    9:9:neureka.ndim.config.NDConfiguration construct() -> construct
    12:12:void <init>() -> <init>
    16:16:int rank() -> rank
    21:21:int[] shape() -> shape
    26:26:int shape(int) -> shape
    31:31:int[] idxmap() -> idxmap
    36:36:int idxmap(int) -> idxmap
    41:41:int[] translation() -> translation
    46:46:int translation(int) -> translation
    51:51:int[] spread() -> spread
    56:56:int spread(int) -> spread
    61:61:int[] offset() -> offset
    66:66:int offset(int) -> offset
    71:71:int i_of_i(int) -> i_of_i
    76:76:int[] idx_of_i(int) -> idx_of_i
    81:81:int i_of_idx(int[]) -> i_of_idx
neureka.optimization.Optimizer -> neureka.optimization.Optimizer:
    void optimize(neureka.Tsr) -> optimize
neureka.optimization.implementations.ADAM -> neureka.optimization.implementations.ADAM:
    neureka.Tsr m -> a
    neureka.Tsr v -> b
    40:41:void optimize(neureka.Tsr) -> optimize
    1029:1036:void _optimize(neureka.Tsr):29:36 -> optimize
    1029:1036:void optimize(neureka.Tsr):40 -> optimize
    46:46:void update(neureka.Tsr,neureka.Tsr) -> update
    7:7:void update(java.lang.Object,java.lang.Object) -> update
neureka.optimization.implementations.Template -> neureka.optimization.implementations.Template:
    6:6:void <init>() -> <init>
neureka.utility.DataHelper -> neureka.utility.DataHelper:
    5:5:void <init>() -> <init>
    9:9:double[] newSeededDoubleArray(java.lang.String,int) -> newSeededDoubleArray
    13:13:double[] newSeededDoubleArray(long,int) -> newSeededDoubleArray
    17:17:double[] seededDoubleArray(double[],java.lang.String) -> seededDoubleArray
    21:24:double[] seededDoubleArray(double[],long) -> seededDoubleArray
    28:28:float[] newSeededFloatArray(java.lang.String,int) -> newSeededFloatArray
    32:32:float[] newSeededFloatArray(long,int) -> newSeededFloatArray
    36:36:float[] seededFloatArray(float[],java.lang.String) -> seededFloatArray
    40:43:float[] seededFloatArray(float[],long) -> seededFloatArray
    48:51:long _longStringHash(java.lang.String) -> a
    55:58:float[] doubleToFloat(double[]) -> doubleToFloat
    62:65:double[] floatToDouble(float[]) -> floatToDouble
