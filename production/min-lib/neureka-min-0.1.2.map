neureka.Component -> neureka.Component:
    void update(java.lang.Object,java.lang.Object) -> update
neureka.Neureka -> neureka.Neureka:
    java.util.Map _instances -> a
    java.lang.String _settings_source -> b
    java.lang.String _setup_source -> c
    java.lang.String _version -> d
    neureka.Neureka$Settings _settings -> e
    neureka.Neureka$Utility _utility -> f
    28:31:void <init>() -> <init>
    34:34:neureka.Neureka instance() -> instance
    38:39:void setContext(java.lang.Thread,neureka.Neureka) -> setContext
    42:49:neureka.Neureka instance(java.lang.Thread) -> instance
    54:56:neureka.Neureka instance(groovy.lang.Closure) -> instance
    60:60:neureka.Neureka$Settings settings() -> settings
    64:66:neureka.Neureka$Settings settings(groovy.lang.Closure) -> settings
    70:70:neureka.Neureka$Utility utility() -> utility
    74:74:java.lang.String version() -> version
    78:95:void reset() -> reset
    98:98:boolean _currentThreadIsAuthorized() -> a
    25:26:void <clinit>() -> <clinit>
neureka.Neureka$Settings -> neureka.Neureka$Settings:
    neureka.Neureka$Settings$Debug _debug -> b
    neureka.Neureka$Settings$AutoDiff _autoDiff -> c
    neureka.Neureka$Settings$Indexing _indexing -> d
    neureka.Neureka$Settings$View _view -> e
    boolean _isLocked -> f
    neureka.Neureka this$0 -> a
    108:115:void <init>(neureka.Neureka) -> <init>
    118:118:neureka.Neureka$Settings$Debug debug() -> debug
    122:124:neureka.Neureka$Settings$Debug debug(groovy.lang.Closure) -> debug
    128:128:neureka.Neureka$Settings$AutoDiff autoDiff() -> autoDiff
    132:134:neureka.Neureka$Settings$AutoDiff autoDiff(groovy.lang.Closure) -> autoDiff
    138:138:neureka.Neureka$Settings$Indexing indexing() -> indexing
    142:144:neureka.Neureka$Settings$Indexing indexing(groovy.lang.Closure) -> indexing
    148:148:neureka.Neureka$Settings$View view() -> view
    152:154:neureka.Neureka$Settings$View view(groovy.lang.Closure) -> view
    158:158:boolean isLocked() -> isLocked
    162:163:void setIsLocked(boolean) -> setIsLocked
neureka.Neureka$Settings$AutoDiff -> neureka.Neureka$Settings$AutoDiff:
    boolean _retainPendingErrorForJITProp -> a
    boolean _applyGradientWhenTensorIsUsed -> b
    boolean _applyGradientWhenRequested -> c
    neureka.Neureka$Settings this$1 -> d
    195:195:void <init>(neureka.Neureka$Settings) -> <init>
    225:225:boolean retainPendingErrorForJITProp() -> retainPendingErrorForJITProp
    229:231:void setRetainPendingErrorForJITProp(boolean) -> setRetainPendingErrorForJITProp
    234:234:boolean applyGradientWhenTensorIsUsed() -> applyGradientWhenTensorIsUsed
    238:240:void setApplyGradientWhenTensorIsUsed(boolean) -> setApplyGradientWhenTensorIsUsed
    243:243:boolean applyGradientWhenRequested() -> applyGradientWhenRequested
    247:249:void setApplyGradientWhenRequested(boolean) -> setApplyGradientWhenRequested
neureka.Neureka$Settings$Debug -> neureka.Neureka$Settings$Debug:
    boolean _keepDerivativeTargetPayloads -> a
    neureka.Neureka$Settings this$1 -> b
    165:165:void <init>(neureka.Neureka$Settings) -> <init>
    185:185:boolean keepDerivativeTargetPayloads() -> keepDerivativeTargetPayloads
    189:191:void setKeepDerivativeTargetPayloads(boolean) -> setKeepDerivativeTargetPayloads
neureka.Neureka$Settings$Indexing -> neureka.Neureka$Settings$Indexing:
    boolean _legacyIndexing -> a
    boolean _thoroughIndexing -> b
    neureka.Neureka$Settings this$1 -> c
    253:253:void <init>(neureka.Neureka$Settings) -> <init>
    260:260:boolean legacy() -> legacy
    264:266:void setLegacy(boolean) -> setLegacy
    269:269:boolean thorough() -> thorough
    273:275:void setThorough(boolean) -> setThorough
neureka.Neureka$Settings$View -> neureka.Neureka$Settings$View:
    boolean _legacyView -> a
    neureka.Neureka$Settings this$1 -> b
    279:279:void <init>(neureka.Neureka$Settings) -> <init>
    285:285:boolean legacy() -> legacy
    289:291:void setLegacy(boolean) -> setLegacy
neureka.Neureka$Utility -> neureka.Neureka$Utility:
    297:297:void <init>() -> <init>
    307:320:java.lang.String readResource(java.lang.String) -> readResource
neureka.Tsr -> neureka.Tsr:
    neureka.acceleration.Device _CPU -> a
    int _flags -> b
    43:45:neureka.Tsr setRqsGradient(boolean) -> setRqsGradient
    49:49:boolean rqsGradient() -> rqsGradient
    53:57:void _setRqsGradient(boolean) -> _setRqsGradient
    62:84:neureka.Tsr setIsOutsourced(boolean) -> setIsOutsourced
    88:88:boolean isOutsourced() -> isOutsourced
    92:96:void _setIsOutsourced(boolean) -> _setIsOutsourced
    101:121:neureka.Tsr setIsVirtual(boolean) -> setIsVirtual
    125:125:boolean isVirtual() -> isVirtual
    129:133:void _setIsVirtual(boolean) -> _setIsVirtual
    138:142:neureka.Tsr setGradientApplyRqd(boolean) -> setGradientApplyRqd
    146:146:boolean gradientApplyRqd() -> gradientApplyRqd
    162:168:neureka.Component _addOrReject(neureka.Component) -> _addOrReject
    175:175:boolean isEmpty() -> isEmpty
    179:179:boolean isUndefined() -> isUndefined
    183:184:boolean isSlice() -> isSlice
    188:189:int sliceCount() -> sliceCount
    193:194:boolean isSliceParent() -> isSliceParent
    198:198:boolean belongsToGraph() -> belongsToGraph
    202:202:boolean isLeave() -> isLeave
    206:206:boolean isBranch() -> isBranch
    216:217:neureka.acceleration.Device device() -> device
    225:225:neureka.autograd.GraphNode graphNode() -> graphNode
    233:233:neureka.framing.IndexAlias index() -> index
    240:264:neureka.Tsr _become(neureka.Tsr) -> _become
    268:282:neureka.Tsr delete() -> delete
    292:312:void _configureFromNewShape(int[]) -> _configureFromNewShape
    33:318:void <init>() -> <init>
    33:323:void <init>(java.lang.Object) -> <init>
    33:334:void <init>(java.util.List,java.lang.String) -> <init>
    33:349:void <init>(java.util.List,java.util.List) -> <init>
    33:380:void <init>(java.util.List) -> <init>
    33:384:void <init>(java.lang.Object,java.lang.Object) -> <init>
    33:387:void <init>(java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:390:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:393:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:396:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:399:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:402:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:405:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:408:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:412:void <init>(int[],java.lang.String) -> <init>
    415:417:void _construct(int[],java.lang.String) -> a
    420:426:int[] _intArray(java.lang.Object[]) -> a
    430:437:double[] _doubleArray(java.lang.Object[]) -> b
    33:442:void <init>(java.lang.Object[]) -> <init>
    445:503:void _construct(java.lang.Object[]) -> c
    33:507:void <init>(double) -> <init>
    33:511:void <init>(int[]) -> <init>
    514:516:void _construct(int[]) -> a
    33:520:void <init>(int[],double) -> <init>
    523:528:void _construct(int[],double) -> a
    33:532:void <init>(int[],double[]) -> <init>
    535:542:void _construct(int[],double[]) -> a
    33:549:void <init>(neureka.Tsr,java.lang.String) -> <init>
    33:553:void <init>(neureka.Tsr[],java.lang.String) -> <init>
    33:557:void <init>(neureka.Tsr[],java.lang.String,boolean) -> <init>
    560:563:void _construct(neureka.Tsr[],java.lang.String,boolean) -> a
    575:578:neureka.Tsr backward(neureka.Tsr) -> backward
    587:588:neureka.Tsr backward(double) -> backward
    592:598:void applyGradient() -> applyGradient
    603:606:neureka.Tsr T() -> T
    610:610:neureka.Tsr plus(neureka.Tsr) -> plus
    613:613:neureka.Tsr plusAssign(neureka.Tsr) -> plusAssign
    616:616:neureka.Tsr plus(java.lang.Double) -> plus
    619:619:neureka.Tsr minus(neureka.Tsr) -> minus
    622:622:neureka.Tsr minusAssign(neureka.Tsr) -> minusAssign
    625:625:neureka.Tsr negative() -> negative
    628:628:neureka.Tsr multiply(neureka.Tsr) -> multiply
    631:631:neureka.Tsr timesAssign(neureka.Tsr) -> timesAssign
    634:634:neureka.Tsr multiply(java.lang.Double) -> multiply
    637:637:neureka.Tsr div(neureka.Tsr) -> div
    640:640:neureka.Tsr div(java.lang.Double) -> div
    643:643:neureka.Tsr divAssign(neureka.Tsr) -> divAssign
    646:646:neureka.Tsr mod(neureka.Tsr) -> mod
    649:649:neureka.Tsr modAssign(neureka.Tsr) -> modAssign
    652:652:neureka.Tsr power(neureka.Tsr) -> power
    655:655:neureka.Tsr power(java.lang.Double) -> power
    658:658:neureka.Tsr xor(neureka.Tsr) -> xor
    661:661:neureka.Tsr xor(java.lang.Double) -> xor
    664:673:neureka.Tsr dot(neureka.Tsr) -> dot
    676:680:boolean isCase(neureka.Tsr) -> isCase
    683:683:boolean contains(neureka.Tsr) -> contains
    687:699:neureka.Tsr label(java.lang.String[][]) -> label
    703:705:neureka.Tsr label(java.util.List) -> label
    709:710:neureka.Tsr label(java.util.Map) -> label
    714:725:neureka.Tsr putAt(java.lang.Object,neureka.Tsr) -> putAt
    729:729:double getAt(int[]) -> getAt
    733:734:java.lang.Object getAt(java.lang.Object,java.lang.Object) -> getAt
    738:807:java.lang.Object getAt(java.lang.Object) -> getAt
    822:896:int _configureSubsetFromRanges(java.lang.Object[],int[],int[],int) -> a
    1005:1007:neureka.Tsr setValue64(double[]) -> setValue64
    1011:1013:neureka.Tsr setValue32(float[]) -> setValue32
    1017:1028:neureka.Tsr setValue(java.lang.Object) -> setValue
    1032:1036:java.lang.Object getValue() -> getValue
    1040:1042:double[] gradient64() -> gradient64
    1046:1048:float[] gradient32() -> gradient32
    1052:1057:neureka.Tsr addToGradient(neureka.Tsr) -> addToGradient
    1061:1068:neureka.Tsr to32() -> to32
    1072:1079:neureka.Tsr to64() -> to64
    1083:1088:double value64(int) -> value64
    1093:1102:double[] value64() -> value64
    1106:1111:float value32(int) -> value32
    1116:1124:float[] value32() -> value32
    1128:1130:neureka.Tsr setValue(double[]) -> setValue
    1140:1140:java.lang.String toString(java.lang.String) -> toString
    1144:1206:java.lang.String _toString(java.lang.String,java.lang.String) -> _toString
    1210:1222:java.lang.String _stringified(double[],boolean,int) -> a
    1226:1226:java.lang.String toString() -> toString
    1231:1247:void makeFit(neureka.Tsr[]) -> makeFit
    1300:1300:void update(neureka.Tsr,neureka.Tsr) -> update
    21:21:void update(java.lang.Object,java.lang.Object) -> update
    1200:1202:void lambda$_toString$18(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1182:1192:void lambda$_toString$17(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1076:1076:void lambda$to64$16(neureka.Tsr) -> f
    1065:1065:void lambda$to32$15(neureka.Tsr) -> g
    1055:1055:void lambda$addToGradient$14(neureka.Tsr,neureka.acceleration.Device) -> a
    1053:1053:void lambda$addToGradient$13(neureka.Tsr,neureka.Tsr) -> a
    677:677:void lambda$isCase$12(neureka.Tsr,boolean[],neureka.framing.Relation) -> a
    678:679:void lambda$isCase$11(neureka.Tsr,boolean[],neureka.Tsr) -> a
    594:597:void lambda$applyGradient$10(neureka.Tsr) -> h
    594:594:void lambda$applyGradient$9(neureka.optimization.Optimizer) -> a
    592:592:void lambda$applyGradient$8(neureka.autograd.JITProp) -> a
    575:575:void lambda$backward$7(neureka.Tsr,neureka.autograd.GraphNode) -> a
    280:280:void lambda$delete$6(neureka.Tsr) -> i
    270:273:void lambda$delete$5(neureka.autograd.GraphNode) -> a
    268:268:void lambda$delete$4(neureka.acceleration.Device) -> a
    109:109:void lambda$setIsVirtual$3(neureka.Tsr) -> j
    69:79:void lambda$setIsOutsourced$2(neureka.acceleration.Device) -> b
    74:74:void lambda$setIsOutsourced$1(neureka.Tsr) -> k
    75:77:void lambda$setIsOutsourced$0(neureka.Tsr,neureka.acceleration.Device) -> b
    21:21:neureka.abstraction.NDConfiguration access$000(neureka.Tsr) -> a
    21:21:neureka.abstraction.NDConfiguration access$100(neureka.Tsr) -> b
    21:21:neureka.abstraction.NDConfiguration access$200(neureka.Tsr) -> c
    21:21:neureka.abstraction.NDConfiguration access$300(neureka.Tsr) -> d
    21:21:neureka.abstraction.NDConfiguration access$402(neureka.Tsr,neureka.abstraction.NDConfiguration) -> a
    21:21:neureka.abstraction.NDConfiguration access$502(neureka.Tsr,neureka.abstraction.NDConfiguration) -> b
    21:21:neureka.abstraction.NDConfiguration access$600(neureka.Tsr) -> e
    23:23:void <clinit>() -> <clinit>
neureka.Tsr$Create -> neureka.Tsr$Create:
    1251:1251:void <init>() -> <init>
    1254:1254:neureka.Tsr E(int[]) -> E
    1258:1258:neureka.Tsr newRandom(int[]) -> newRandom
    1262:1263:neureka.Tsr newRandom(int[],long) -> newRandom
    1267:1271:neureka.Tsr newTsrLike(neureka.Tsr,double) -> newTsrLike
    1275:1279:neureka.Tsr newTsrLike(neureka.Tsr) -> newTsrLike
    1283:1290:neureka.Tsr _newEmptyLike(neureka.Tsr) -> a
neureka.Tsr$Exec -> neureka.Tsr$Exec:
    978:978:void <init>() -> <init>
    981:996:neureka.Tsr reshaped(neureka.Tsr,int[],boolean) -> reshaped
neureka.Tsr$IO -> neureka.Tsr$IO:
    901:901:void <init>() -> <init>
    904:906:double getFrom(neureka.Tsr,int) -> getFrom
    910:911:double getFrom(neureka.Tsr,int[]) -> getFrom
    915:917:void setInto(neureka.Tsr,int,double) -> setInto
    920:922:void setInto(neureka.Tsr,int[],double) -> setInto
    925:927:void addInto(neureka.Tsr,int,double) -> addInto
    930:932:void addInto(neureka.Tsr,int[],double) -> addInto
    935:937:neureka.Tsr addInto(neureka.Tsr,neureka.Tsr) -> addInto
    941:943:void subInto(neureka.Tsr,int,double) -> subInto
    946:948:void subInto(neureka.Tsr,int[],double) -> subInto
    951:962:void subInto(neureka.Tsr,neureka.Tsr) -> subInto
    965:967:void mulInto(neureka.Tsr,int,double) -> mulInto
    970:972:void mulInto(neureka.Tsr,int[],double) -> mulInto
neureka.abstraction.AbstractComponentOwner -> neureka.abstraction.AbstractComponentOwner:
    java.util.List _components -> _components
    19:24:void <init>() -> <init>
    31:36:java.lang.Object find(java.lang.Class) -> find
    45:53:java.lang.Object remove(java.lang.Class) -> remove
    62:62:boolean has(java.lang.Class) -> has
    71:83:java.lang.Object add(neureka.Component) -> add
    neureka.Component _addOrReject(neureka.Component) -> _addOrReject
    99:104:boolean forComponent(java.lang.Class,java.util.function.Consumer) -> forComponent
neureka.abstraction.AbstractNDArray -> neureka.abstraction.AbstractNDArray:
    neureka.abstraction.NDConfiguration _conf -> _conf
    java.lang.Object _value -> _value
    22:22:void <init>() -> <init>
    31:31:boolean is64() -> is64
    35:35:boolean is32() -> is32
    41:41:int i_of_i(int) -> i_of_i
    45:45:int[] idx_of_i(int) -> idx_of_i
    49:49:int i_of_idx(int[]) -> i_of_idx
    55:55:int[] shape() -> shape
    59:59:int shape(int) -> shape
    63:63:int rank() -> rank
    67:67:int[] idxmap() -> idxmap
    71:71:int[] translation() -> translation
    75:75:int[] spread() -> spread
    79:79:int[] offset() -> offset
    83:83:int size() -> size
neureka.abstraction.AbstractNDArray$Utility -> neureka.abstraction.AbstractNDArray$Utility:
    94:94:void <init>() -> <init>
neureka.abstraction.AbstractNDArray$Utility$Indexing -> neureka.abstraction.AbstractNDArray$Utility$Indexing:
    128:128:void <init>() -> <init>
    133:136:void increment(int[],int[]) -> increment
    1140:1165:int _incrementAt(int,int[],int[]):140:165 -> increment
    1140:1165:void increment(int[],int[]):135 -> increment
    171:184:int[] newTlnOf(int[]) -> newTlnOf
    189:194:int[] rearrange(int[],int[]) -> rearrange
    199:204:int[] shpCheck(int[],neureka.Tsr) -> shpCheck
    209:215:int[] rearrange(int[],int[],int[]) -> rearrange
    220:241:int[][] makeFit(int[],int[]) -> makeFit
    246:248:int[] shpOfCon(int[],int[]) -> shpOfCon
    253:260:int[] shpOfBrc(int[],int[]) -> shpOfBrc
    265:267:int szeOfShp(int[]) -> szeOfShp
neureka.abstraction.AbstractNDArray$Utility$Stringify -> neureka.abstraction.AbstractNDArray$Utility$Stringify:
    96:96:void <init>() -> <init>
    100:114:java.lang.String formatFP(double) -> formatFP
    119:121:java.lang.String strConf(int[]) -> strConf
neureka.abstraction.DefaultNDConfiguration -> neureka.abstraction.DefaultNDConfiguration:
    java.util.Map _CONFIGS -> a
    java.util.Map _CONFS -> b
    int[] _shape -> c
    int[] _translation -> d
    int[] _idxmap -> e
    int[] _spread -> f
    int[] _offset -> g
    29:35:void <init>(int[],int[],int[],int[],int[]) -> <init>
    44:58:neureka.abstraction.DefaultNDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    1203:1203:long _key():203:203 -> construct
    1203:1203:neureka.abstraction.DefaultNDConfiguration construct(int[],int[],int[],int[],int[]):45 -> construct
    88:88:int rank() -> rank
    93:93:int[] shape() -> shape
    98:98:int shape(int) -> shape
    103:103:int[] idxmap() -> idxmap
    108:108:int idxmap(int) -> idxmap
    113:113:int[] translation() -> translation
    118:118:int translation(int) -> translation
    123:123:int[] spread() -> spread
    128:128:int spread(int) -> spread
    133:133:int[] offset() -> offset
    138:138:int offset(int) -> offset
    146:146:int i_of_i(int) -> i_of_i
    151:163:int[] idx_of_i(int) -> idx_of_i
    167:169:int i_of_idx(int[]) -> i_of_idx
    175:198:int[] _cached(int[]) -> a
    19:21:void <clinit>() -> <clinit>
neureka.abstraction.NDConfiguration -> neureka.abstraction.NDConfiguration:
    int rank() -> rank
    int[] shape() -> shape
    int shape(int) -> shape
    int[] idxmap() -> idxmap
    int idxmap(int) -> idxmap
    int[] translation() -> translation
    int translation(int) -> translation
    int[] spread() -> spread
    int spread(int) -> spread
    int[] offset() -> offset
    int offset(int) -> offset
    int i_of_i(int) -> i_of_i
    int[] idx_of_i(int) -> idx_of_i
    int i_of_idx(int[]) -> i_of_idx
    44:44:neureka.abstraction.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
neureka.acceleration.AbstractDevice -> neureka.acceleration.AbstractDevice:
    java.lang.ref.Cleaner CLEANER -> a
    10:10:void <init>() -> <init>
    void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    20:21:void update(neureka.Tsr,neureka.Tsr) -> update
    25:26:neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    30:31:void _cleaning(java.lang.Object,java.lang.Runnable) -> _cleaning
    35:36:neureka.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    41:76:void _execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> _execute
    1195:1204:void _createNewDrainTensorIn(neureka.acceleration.Device,neureka.Tsr[],neureka.calculus.environment.OperationType):195:204 -> _execute
    1195:1204:void _execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int):53 -> _execute
    80:163:neureka.Tsr _execute_recursively(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> a
    170:192:void _execute_tensor_scalar(neureka.Tsr,double,neureka.calculus.environment.OperationType,int) -> _execute_tensor_scalar
    10:10:void update(java.lang.Object,java.lang.Object) -> update
    12:12:void <clinit>() -> <clinit>
neureka.acceleration.AbstractDevice$Utility -> neureka.acceleration.AbstractDevice$Utility:
    208:208:void <init>() -> <init>
    211:217:neureka.Tsr[] _subset(neureka.Tsr[],int,int,int) -> _subset
    220:222:neureka.Tsr[] _without(neureka.Tsr[],int) -> _without
    226:238:neureka.Tsr[] _offsetted(neureka.Tsr[],int) -> _offsetted
neureka.acceleration.Device -> neureka.acceleration.Device:
    14:21:neureka.acceleration.Device find(java.lang.String) -> find
    void dispose() -> dispose
    neureka.acceleration.Device get(neureka.Tsr) -> get
    neureka.acceleration.Device add(neureka.Tsr) -> add
    neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    boolean has(neureka.Tsr) -> has
    neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    neureka.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    double[] value64Of(neureka.Tsr) -> value64Of
    float[] value32Of(neureka.Tsr) -> value32Of
    java.util.Collection tensors() -> tensors
    17:17:void lambda$find$1(java.lang.String,neureka.acceleration.Device[],neureka.acceleration.opencl.OpenCLPlatform) -> a
    18:20:void lambda$find$0(java.lang.String,neureka.acceleration.Device[],neureka.acceleration.opencl.OpenCLDevice) -> a
neureka.acceleration.host.HostCPU -> neureka.acceleration.host.HostCPU:
    neureka.acceleration.host.HostCPU _instance -> a
    neureka.acceleration.host.HostCPU$NativeExecutor _executor -> b
    23:25:void <init>() -> <init>
    28:28:neureka.acceleration.host.HostCPU instance() -> instance
    32:32:neureka.acceleration.host.HostCPU$NativeExecutor getExecutor() -> getExecutor
    37:54:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    58:64:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    68:69:void dispose() -> dispose
    73:73:neureka.acceleration.Device get(neureka.Tsr) -> get
    78:78:neureka.acceleration.Device add(neureka.Tsr) -> add
    83:83:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    88:88:boolean has(neureka.Tsr) -> has
    93:93:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    98:98:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    103:103:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    108:108:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    113:113:double[] value64Of(neureka.Tsr) -> value64Of
    118:118:float[] value32Of(neureka.Tsr) -> value32Of
    123:123:java.util.Collection tensors() -> tensors
    18:19:void <clinit>() -> <clinit>
neureka.acceleration.host.HostCPU$NativeExecutor -> neureka.acceleration.host.HostCPU$NativeExecutor:
    java.util.concurrent.ThreadPoolExecutor _pool -> a
    130:132:void <init>(neureka.acceleration.host.HostCPU) -> <init>
    135:135:java.util.concurrent.ThreadPoolExecutor getPool() -> getPool
    139:147:void activate(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> activate
    150:159:void broadcast(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> broadcast
    162:171:void convolve(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> convolve
    174:182:void scalar(neureka.Tsr[],double,int,neureka.calculus.environment.OperationType) -> scalar
    187:211:void _threaded(int,neureka.acceleration.host.HostCPU$Range) -> a
    197:199:void lambda$_threaded$4(neureka.Neureka,neureka.acceleration.host.HostCPU$Range,int,int) -> a
    177:179:void lambda$scalar$3(neureka.Tsr[],neureka.calculus.environment.OperationType,double,int,int,int) -> a
    165:168:void lambda$convolve$2(neureka.Tsr[],int,neureka.calculus.environment.OperationType,int,int) -> a
    153:156:void lambda$broadcast$1(neureka.Tsr[],int,neureka.calculus.environment.OperationType,int,int) -> b
    142:144:void lambda$activate$0(neureka.Tsr[],neureka.calculus.environment.OperationType,int,int,int) -> a
neureka.acceleration.host.HostCPU$Range -> neureka.acceleration.host.HostCPU$a:
    void execute(int,int) -> execute
neureka.acceleration.host.Kernel -> neureka.acceleration.host.Kernel:
    7:7:void <init>() -> <init>
    15:150:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$DefaultOperator) -> convolve
    158:240:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$DefaultOperator) -> broadcast
    248:261:void activate(neureka.Tsr,int,int,neureka.calculus.environment.Type$DefaultOperator) -> a
neureka.acceleration.opencl.OpenCLDevice -> neureka.acceleration.opencl.OpenCLDevice:
    java.util.Set _tensors -> a
    org.jocl.cl_device_id _did -> b
    neureka.acceleration.opencl.OpenCLPlatform _platform -> c
    org.jocl.cl_command_queue _queue -> d
    44:44:org.jocl.cl_device_id CLDeviceID() -> CLDeviceID
    39:81:void <init>(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> <init>
    84:85:neureka.acceleration.opencl.OpenCLDevice instance(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> instance
    93:96:java.util.Collection tensors() -> tensors
    101:103:void dispose() -> dispose
    107:111:neureka.acceleration.Device get(neureka.Tsr) -> get
    116:117:neureka.acceleration.Device add(neureka.Tsr) -> add
    122:126:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    130:201:void _add(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr) -> a
    205:205:boolean has(neureka.Tsr) -> has
    209:247:void _store(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr,int) -> a
    252:257:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    271:289:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    293:299:void _releaseEvents(neureka.Tsr[]) -> a
    302:309:org.jocl.cl_event[] _getWaitList(neureka.Tsr[]) -> b
    314:334:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    339:344:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    349:365:double[] value64Of(neureka.Tsr) -> value64Of
    371:387:float[] value32Of(neureka.Tsr) -> value32Of
    394:470:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    474:500:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    504:504:java.lang.String name() -> name
    508:508:java.lang.String vendor() -> vendor
    512:512:java.lang.String version() -> version
    516:525:java.lang.String type() -> type
    529:529:int maxComputeUnits() -> maxComputeUnits
    533:533:long maxWorkItemSimensions() -> maxWorkItemSimensions
    537:537:long[] maxWorkItemSizes() -> maxWorkItemSizes
    541:541:long maxWorkGroupSize() -> maxWorkGroupSize
    545:545:long maxClockFrequenzy() -> maxClockFrequenzy
    549:549:int maxAddressBits() -> maxAddressBits
    553:553:long maxMemAllocSize() -> maxMemAllocSize
    557:557:long globalMemSize() -> globalMemSize
    561:561:int errorCorrectionSupport() -> errorCorrectionSupport
    565:565:int localMemType() -> localMemType
    569:569:long localMemSize() -> localMemSize
    573:573:long maxConstantBufferSize() -> maxConstantBufferSize
    577:577:long maxConstantBufferSizeKB() -> maxConstantBufferSizeKB
    591:591:int imageSupport() -> imageSupport
    595:595:int maxReadImageArgs() -> maxReadImageArgs
    599:599:int maxWriteImageArgs() -> maxWriteImageArgs
    603:603:long singleFPConfig() -> singleFPConfig
    607:607:long image2DMaxWidth() -> image2DMaxWidth
    611:611:long image2DMaxHeight() -> image2DMaxHeight
    615:615:long image3DMaxWidth() -> image3DMaxWidth
    619:619:long image3DMaxHeight() -> image3DMaxHeight
    623:623:long image3DMaxDepth() -> image3DMaxDepth
    627:627:int prefVecWidthChar() -> prefVecWidthChar
    631:631:int prefVecWidthShort() -> prefVecWidthShort
    635:635:int prefVecWidthInt() -> prefVecWidthInt
    639:639:int prefVecWidthLong() -> prefVecWidthLong
    643:643:int prefVecWidthFloat() -> prefVecWidthFloat
    647:647:int prefVecWidthDouble() -> prefVecWidthDouble
    146:148:void lambda$_add$3(org.jocl.cl_event,org.jocl.cl_mem) -> a
    133:133:void lambda$_add$2(org.jocl.cl_mem) -> a
    95:95:void lambda$tensors$1(java.util.Collection,java.util.Collection) -> a
    95:95:void lambda$tensors$0(java.util.Collection,neureka.Tsr) -> a
neureka.acceleration.opencl.OpenCLDevice$DeviceQuery -> neureka.acceleration.opencl.OpenCLDevice$DeviceQuery:
    650:650:void <init>() -> <init>
    659:659:int getInt(org.jocl.cl_device_id,int) -> getInt
    671:673:int[] getInts(org.jocl.cl_device_id,int,int) -> getInts
    684:684:long getLong(org.jocl.cl_device_id,int) -> getLong
    696:698:long[] getLongs(org.jocl.cl_device_id,int,int) -> getLongs
    710:718:java.lang.String getString(org.jocl.cl_device_id,int) -> getString
    730:738:java.lang.String getString(org.jocl.cl_platform_id,int) -> getString
    749:749:long getSize(org.jocl.cl_device_id,int) -> getSize
    763:777:long[] getSizes(org.jocl.cl_device_id,int,int) -> getSizes
neureka.acceleration.opencl.OpenCLDevice$cl_config -> neureka.acceleration.opencl.OpenCLDevice$a:
    org.jocl.cl_mem data -> a
    24:24:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLDevice$cl_tsr -> neureka.acceleration.opencl.OpenCLDevice$b:
    int fp -> a
    neureka.acceleration.opencl.OpenCLDevice$cl_config config -> b
    neureka.acceleration.opencl.OpenCLDevice$cl_value value -> c
    28:30:void <init>() -> <init>
    28:28:void update(java.lang.Object,java.lang.Object) -> update
neureka.acceleration.opencl.OpenCLDevice$cl_value -> neureka.acceleration.opencl.OpenCLDevice$c:
    org.jocl.cl_mem data -> a
    int size -> b
    org.jocl.cl_event event -> c
    18:20:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLPlatform -> neureka.acceleration.opencl.OpenCLPlatform:
    org.jocl.cl_platform_id _pid -> a
    java.util.Map _id_device -> b
    org.jocl.cl_context _context -> c
    java.util.Map _kernels -> d
    java.util.Map OPERATION_TO_KERNEL_MAPPING -> e
    61:61:java.lang.String kernelNameOf(neureka.calculus.environment.OperationType) -> kernelNameOf
    65:94:void <init>(org.jocl.cl_platform_id) -> <init>
    97:101:void recompile() -> recompile
    106:170:void _compile(org.jocl.cl_device_id[]) -> a
    178:254:java.util.Map _getParsedKernelsFromTemplate(java.lang.String,java.lang.String) -> a
    258:258:org.jocl.cl_platform_id getID() -> getID
    262:264:java.util.List getDevices() -> getDevices
    269:269:boolean has(org.jocl.cl_device_id) -> has
    272:272:neureka.acceleration.opencl.OpenCLDevice get(org.jocl.cl_device_id) -> get
    275:276:void put(org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> put
    280:280:java.util.Map getKernels() -> getKernels
    284:284:org.jocl.cl_context getContext() -> getContext
    288:288:java.util.List PLATFORMS() -> PLATFORMS
    263:263:void lambda$getDevices$4(java.util.List,org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> a
    204:214:void lambda$_getParsedKernelsFromTemplate$3(java.lang.String[],java.lang.String,java.util.function.Function,java.util.function.Function,java.util.Map,java.lang.String,java.lang.String,java.lang.String) -> a
    198:201:java.lang.String lambda$_getParsedKernelsFromTemplate$2(java.lang.String) -> a
    184:194:java.lang.String lambda$_getParsedKernelsFromTemplate$1(java.lang.String) -> b
    137:139:void lambda$_compile$0(java.util.ArrayList,java.util.ArrayList,java.lang.String,java.lang.String) -> a
    18:58:void <clinit>() -> <clinit>
neureka.acceleration.opencl.OpenCLPlatform$Parser -> neureka.acceleration.opencl.OpenCLPlatform$a:
    void apply(java.lang.String,java.lang.String,java.lang.String) -> apply
neureka.acceleration.opencl.OpenCLPlatform$_setup -> neureka.acceleration.opencl.OpenCLPlatform$b:
    java.util.List PLATFORMS -> a
    293:293:void <clinit>() -> <clinit>
    1297:1308:java.util.List findAllPlatforms():297:308 -> <clinit>
    1297:1308:void <clinit>():293 -> <clinit>
neureka.acceleration.opencl.utility.DeviceQuery -> neureka.acceleration.opencl.utility.DeviceQuery:
    14:14:void <init>() -> <init>
    23:182:java.lang.String query() -> query
    1270:1278:java.lang.String getString(org.jocl.cl_platform_id,int):270:278 -> query
    1270:1278:java.lang.String query():38 -> query
    194:194:int getInt(org.jocl.cl_device_id,int) -> a
    207:209:int[] getInts(org.jocl.cl_device_id,int,int) -> a
    221:221:long getLong(org.jocl.cl_device_id,int) -> b
    234:236:long[] getLongs(org.jocl.cl_device_id,int,int) -> b
    249:257:java.lang.String getString(org.jocl.cl_device_id,int) -> c
    290:290:long getSize(org.jocl.cl_device_id,int) -> d
    305:324:long[] getSizes(org.jocl.cl_device_id,int,int) -> c
neureka.acceleration.opencl.utility.WeakTensorReference -> neureka.acceleration.opencl.utility.WeakTensorReference:
    int _hash -> a
    24:26:void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    30:30:int hashCode() -> hashCode
    35:35:boolean equals(java.lang.Object) -> equals
neureka.autograd.ADAgent -> neureka.autograd.ADAgent:
    neureka.autograd.ADAgent$ADAction _fad -> a
    neureka.autograd.ADAgent$ADAction _bad -> b
    java.util.function.Supplier _derivative -> c
    19:23:void <init>(java.util.function.Supplier,neureka.autograd.ADAgent$ADAction,neureka.autograd.ADAgent$ADAction) -> <init>
    26:30:void <init>(neureka.Tsr) -> <init>
    33:33:neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    38:38:neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    42:42:neureka.Tsr derivative() -> derivative
    46:46:boolean isForward() -> isForward
    51:57:java.lang.String toString() -> toString
    27:27:neureka.Tsr lambda$new$0(neureka.Tsr) -> a
neureka.autograd.ADAgent$ADAction -> neureka.autograd.ADAgent$ADAction:
    neureka.Tsr execute(neureka.autograd.GraphNode,neureka.Tsr) -> execute
neureka.autograd.GraphLock -> neureka.autograd.GraphLock:
    neureka.calculus.Function _owner -> a
    boolean _is_locked -> b
    22:31:void <init>(neureka.calculus.Function,neureka.Tsr[]) -> <init>
    37:37:boolean isLocked() -> isLocked
    45:46:void release() -> release
    53:53:java.lang.String toString() -> toString
neureka.autograd.GraphNode -> neureka.autograd.GraphNode:
    neureka.calculus.Function MUL -> a
    neureka.calculus.Function ADD -> b
    int _mode -> c
    boolean _relies_on_JIPProp -> d
    neureka.autograd.PendingError _pending_error -> e
    boolean _is_used_as_derivative -> f
    neureka.calculus.Function _function -> g
    neureka.autograd.GraphNode[] _parents -> h
    java.lang.ref.WeakReference _payload -> i
    java.util.TreeMap _targets_derivatives -> j
    neureka.autograd.GraphLock _lock -> k
    java.util.List _children -> l
    long _nid -> m
    37:37:boolean usesAD() -> usesAD
    46:46:boolean usesForwardAD() -> usesForwardAD
    55:55:boolean usesReverseAD() -> usesReverseAD
    83:83:boolean reliesOnJustInTimeProp() -> reliesOnJustInTimeProp
    97:99:neureka.autograd.PendingError getAndRemovePendingError() -> getAndRemovePendingError
    116:116:boolean isUsedAsDerivative() -> isUsedAsDerivative
    126:126:neureka.calculus.Function getFunction() -> getFunction
    137:137:neureka.autograd.GraphNode[] getParents() -> getParents
    157:157:neureka.Tsr getPayload() -> getPayload
    161:178:void _setPayload(neureka.Tsr) -> a
    189:190:void update(neureka.Tsr,neureka.Tsr) -> update
    206:206:neureka.autograd.GraphLock lock() -> lock
    215:215:java.util.List getChildren() -> getChildren
    224:224:long nid() -> nid
    235:236:void obtainLocking(neureka.autograd.GraphLock) -> obtainLocking
    242:245:void _attachChild(neureka.autograd.GraphNode) -> a
    254:254:boolean isCachable() -> isCachable
    263:263:boolean isLeave() -> isLeave
    267:271:boolean isGraphLeave() -> isGraphLeave
    278:278:boolean isVirtual() -> isVirtual
    86:307:void <init>(neureka.calculus.Function,java.lang.Object,java.util.function.Supplier) -> <init>
    310:376:void _construct(neureka.Tsr,neureka.calculus.Function,neureka.Tsr[],neureka.autograd.GraphLock) -> a
    390:409:int _modeOf(neureka.Tsr[],neureka.calculus.Function) -> a
    420:425:void _migrateAndOrApplyError(neureka.Tsr,java.util.function.Consumer) -> a
    438:450:void backward(neureka.Tsr) -> backward
    468:490:void _backward(neureka.Tsr,java.util.Set,boolean) -> a
    502:510:void _carryPendingBackPropToGradients(java.util.Set) -> a
    526:528:void backwardJIT(neureka.Tsr) -> backwardJIT
    531:557:void _backwardJIT(neureka.Tsr,neureka.autograd.GraphNode) -> a
    569:573:void _deleteDerivativesRecursively() -> a
    581:590:int _numberOfReverseModeADChildren() -> b
    597:597:int mode() -> mode
    604:604:neureka.calculus.Function function() -> function
    612:625:void put(neureka.autograd.GraphNode,java.lang.Object) -> put
    634:635:java.lang.Object get(neureka.autograd.GraphNode) -> get
    646:647:boolean has(neureka.autograd.GraphNode) -> has
    657:657:int size() -> size
    664:668:void forEachBackward(neureka.Tsr,java.util.function.BiConsumer) -> forEachBackward
    674:678:void forEachForward(neureka.Tsr,java.util.function.BiConsumer) -> forEachForward
    684:686:void forEachDerivative(java.util.function.BiConsumer) -> forEachDerivative
    692:694:void forEachTarget(java.util.function.Consumer) -> forEachTarget
    701:703:void forEach(neureka.Tsr,java.util.function.BiConsumer) -> forEach
    710:710:boolean hasDerivatives() -> hasDerivatives
    717:722:java.lang.String type() -> type
    727:727:java.lang.String toString() -> toString
    735:742:java.lang.String toString(java.lang.String) -> toString
    758:771:java.lang.String _toString(java.lang.String,boolean) -> a
    26:26:void update(java.lang.Object,java.lang.Object) -> update
    702:702:void lambda$forEach$15(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    693:693:void lambda$forEachTarget$14(java.util.function.Consumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    676:677:void lambda$forEachForward$13(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> b
    666:667:void lambda$forEachBackward$12(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> c
    612:612:int lambda$put$11(neureka.autograd.GraphNode,neureka.autograd.GraphNode) -> a
    554:554:void lambda$_backwardJIT$10(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> a
    553:553:void lambda$_backwardJIT$9(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> b
    533:538:void lambda$_backwardJIT$8(neureka.autograd.GraphNode,neureka.Tsr) -> a
    503:503:void lambda$_carryPendingBackPropToGradients$7(java.util.Set,neureka.autograd.GraphNode) -> a
    487:487:void lambda$_backward$6(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> a
    486:486:void lambda$_backward$5(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> b
    444:447:void lambda$backward$4(neureka.autograd.GraphNode) -> b
    441:441:void lambda$backward$3(java.util.Set,neureka.autograd.GraphNode) -> b
    360:363:void lambda$_construct$2(neureka.autograd.GraphNode,neureka.Tsr) -> b
    298:298:void lambda$new$1(neureka.autograd.JITProp) -> a
    166:176:void lambda$_setPayload$0() -> c
    28:29:void <clinit>() -> <clinit>
neureka.autograd.JITProp -> neureka.autograd.JITProp:
    java.util.Set _finished -> a
    java.util.Set _pending -> b
    16:20:void <init>(java.util.Set) -> <init>
    27:30:void addPending(java.util.Set) -> addPending
    37:46:void noteFinished(neureka.autograd.GraphNode) -> noteFinished
    49:49:int finishedCount() -> finishedCount
    53:53:int pendingCount() -> pendingCount
    61:71:void execute() -> execute
    78:78:boolean isDone() -> isDone
    86:88:java.lang.String toString() -> toString
    95:95:void update(neureka.Tsr,neureka.Tsr) -> update
    10:10:void update(java.lang.Object,java.lang.Object) -> update
    63:68:void lambda$execute$0(neureka.autograd.GraphNode) -> a
neureka.autograd.PendingError -> neureka.autograd.PendingError:
    int _toBeReceived -> a
    neureka.Tsr _error -> b
    11:14:void <init>(neureka.Tsr,int) -> <init>
    17:21:void accumulate(neureka.Tsr) -> accumulate
    24:24:boolean isFullyAccumulated() -> isFullyAccumulated
    28:28:neureka.Tsr getAccumulatedError() -> getAccumulatedError
neureka.calculus.Function -> neureka.calculus.Function:
    neureka.calculus.environment.Cache CACHE -> CACHE
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    60:60:neureka.calculus.Function create(java.lang.String) -> create
    64:64:neureka.calculus.Function create(java.lang.String,boolean) -> create
    neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    boolean doesAD() -> doesAD
    boolean isFlat() -> isFlat
    int id() -> id
    neureka.calculus.environment.OperationType type() -> type
    boolean dependsOn(int) -> dependsOn
    double call(double) -> call
    double activate(double) -> activate
    double call(double[],int) -> call
    double activate(double[],int) -> activate
    double call(double[]) -> call
    double activate(double[]) -> activate
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    neureka.Tsr call(neureka.Tsr) -> call
    neureka.Tsr activate(neureka.Tsr) -> activate
    neureka.Tsr call(neureka.Tsr[],int) -> call
    neureka.Tsr activate(neureka.Tsr[],int) -> activate
    neureka.Tsr call(neureka.Tsr[]) -> call
    neureka.Tsr activate(neureka.Tsr[]) -> activate
    neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    neureka.Tsr derive(neureka.Tsr[],int) -> derive
    java.lang.String toString() -> toString
    neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    17:34:void <clinit>() -> <clinit>
neureka.calculus.Function$Detached -> neureka.calculus.Function$Detached:
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function ADD -> ADD
    neureka.calculus.Function ADD_ASSIGN -> ADD_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    37:37:void <init>() -> <init>
    39:56:void <clinit>() -> <clinit>
neureka.calculus.Function$Setup -> neureka.calculus.Function$Setup:
    67:67:void <init>() -> <init>
    70:70:neureka.Tsr commit(neureka.Tsr[],java.lang.String,boolean) -> commit
    74:74:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],java.lang.String,boolean) -> commit
    78:78:neureka.Tsr commit(neureka.Tsr[],neureka.calculus.Function) -> commit
    82:82:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function) -> commit
    87:110:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier) -> commit
    92:92:neureka.Tsr lambda$commit$0(neureka.Tsr) -> a
neureka.calculus.environment.Cache -> neureka.calculus.environment.Cache:
    neureka.calculus.environment.Cache _cache -> a
    java.util.Map FUNCTIONS -> b
    java.util.Map PROCESSING -> c
    15:30:void <init>() -> <init>
    18:20:neureka.calculus.environment.Cache instance() -> instance
    27:27:java.util.Map FUNCTIONS() -> FUNCTIONS
    34:36:void free(neureka.autograd.GraphLock) -> free
    40:74:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier,int,int) -> preprocess
    79:92:neureka.Tsr _get(neureka.Tsr[],int,int) -> a
    97:108:void _put(neureka.Tsr,neureka.autograd.GraphNode,int,int) -> a
    111:111:int _keyed(int) -> a
    101:101:int lambda$_put$2(java.lang.Long,java.lang.Long) -> a
    60:60:neureka.Tsr lambda$preprocess$1(neureka.Tsr) -> a
    30:30:int lambda$new$0(neureka.autograd.GraphLock,neureka.autograd.GraphLock) -> a
    13:13:void <clinit>() -> <clinit>
neureka.calculus.environment.OperationType -> neureka.calculus.environment.OperationType:
    java.util.Map _LOOKUP -> a
    java.util.ArrayList _REGISTER -> b
    int _ID -> c
    int _id -> _id
    java.lang.String _name -> _name
    java.lang.String _identifier -> _identifier
    boolean _isOperation -> _isOperation
    boolean _isIndexer -> _isIndexer
    boolean _isConvection -> _isConvection
    boolean _isCommutative -> _isCommutative
    boolean _isAssociative -> _isAssociative
    neureka.calculus.environment.Type$Activation _activation -> _activation
    neureka.calculus.environment.Type$Convolution _convolution -> _convolution
    neureka.calculus.environment.Type$Broadcast _broadcast -> _broadcast
    neureka.calculus.environment.Type$Scalarization _scalarization -> _scalarization
    neureka.calculus.environment.Type$Operation _operation -> _operation
    26:26:java.util.ArrayList instances() -> instances
    30:30:neureka.calculus.environment.OperationType instance(int) -> instance
    34:34:neureka.calculus.environment.OperationType instance(java.lang.String) -> instance
    96:128:void <init>(java.lang.String,java.lang.String,boolean,boolean,boolean,boolean,boolean,neureka.calculus.environment.Type$Activation,neureka.calculus.environment.Type$Scalarization,neureka.calculus.environment.Type$Convolution,neureka.calculus.environment.Type$Broadcast,neureka.calculus.environment.Type$Operation) -> <init>
    131:131:neureka.calculus.environment.OperationType[] ALL() -> ALL
    135:135:int COUNT() -> COUNT
    142:142:java.lang.String getName() -> getName
    149:149:neureka.calculus.environment.Type$Activation getActivation() -> getActivation
    154:154:boolean supportsActivation() -> supportsActivation
    161:161:neureka.calculus.environment.Type$Scalarization getScalarization() -> getScalarization
    166:166:boolean supportsScalar() -> supportsScalar
    173:173:neureka.calculus.environment.Type$Convolution getConvolution() -> getConvolution
    178:178:boolean supportsConvolution() -> supportsConvolution
    185:185:neureka.calculus.environment.Type$Broadcast getBroadcast() -> getBroadcast
    190:190:boolean supportsBroadcast() -> supportsBroadcast
    197:197:neureka.calculus.environment.Type$Operation getOperation() -> getOperation
    202:202:boolean supportsOperation() -> supportsOperation
    209:209:int id() -> id
    214:214:java.lang.String identifier() -> identifier
    219:219:boolean isOperation() -> isOperation
    224:224:boolean isIndexer() -> isIndexer
    229:229:boolean isConvection() -> isConvection
    234:234:boolean isCommutative() -> isCommutative
    240:247:boolean allowsForward(neureka.Tsr[]) -> allowsForward
    253:286:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    287:287:neureka.Tsr lambda$getADAgentOf$10(neureka.autograd.GraphNode,neureka.Tsr) -> a
    287:287:neureka.Tsr lambda$getADAgentOf$9(neureka.autograd.GraphNode,neureka.Tsr) -> b
    287:287:neureka.Tsr lambda$getADAgentOf$8() -> a
    282:282:neureka.Tsr lambda$getADAgentOf$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    281:281:neureka.Tsr lambda$getADAgentOf$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    280:280:neureka.Tsr lambda$getADAgentOf$5(neureka.Tsr) -> a
    269:269:neureka.Tsr lambda$getADAgentOf$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    268:268:neureka.Tsr lambda$getADAgentOf$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    267:267:neureka.Tsr lambda$getADAgentOf$2(neureka.Tsr) -> b
    259:259:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    258:258:neureka.Tsr lambda$getADAgentOf$0(neureka.Tsr) -> c
    21:80:void <clinit>() -> <clinit>
neureka.calculus.environment.Type -> neureka.calculus.environment.Type:
    neureka.calculus.environment.Type$Activation getActivation() -> getActivation
    boolean supportsActivation() -> supportsActivation
    neureka.calculus.environment.Type$Scalarization getScalarization() -> getScalarization
    boolean supportsScalar() -> supportsScalar
    neureka.calculus.environment.Type$Convolution getConvolution() -> getConvolution
    boolean supportsConvolution() -> supportsConvolution
    neureka.calculus.environment.Type$Broadcast getBroadcast() -> getBroadcast
    boolean supportsBroadcast() -> supportsBroadcast
    neureka.calculus.environment.Type$Operation getOperation() -> getOperation
    boolean supportsOperation() -> supportsOperation
    java.lang.String getName() -> getName
    int id() -> id
    java.lang.String identifier() -> identifier
    boolean isOperation() -> isOperation
    boolean isIndexer() -> isIndexer
    boolean isConvection() -> isConvection
    boolean isCommutative() -> isCommutative
    boolean allowsForward(neureka.Tsr[]) -> allowsForward
    neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
neureka.calculus.environment.Type$Activation -> neureka.calculus.environment.Type$Activation:
    47:48:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$Broadcast -> neureka.calculus.environment.Type$Broadcast:
    61:62:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$Convolution -> neureka.calculus.environment.Type$Convolution:
    54:55:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$DefaultOperator -> neureka.calculus.environment.Type$DefaultOperator:
    double execute(int[],int[],int[]) -> execute
neureka.calculus.environment.Type$Operation -> neureka.calculus.environment.Type$Operation:
    75:76:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$OperatorCreator -> neureka.calculus.environment.Type$OperatorCreator:
    neureka.calculus.environment.Type$DefaultOperator create(neureka.Tsr[],int) -> create
neureka.calculus.environment.Type$ScalarOperatorCreator -> neureka.calculus.environment.Type$ScalarOperatorCreator:
    neureka.calculus.environment.Type$DefaultOperator create(neureka.Tsr[],double,int) -> create
neureka.calculus.environment.Type$Scalarization -> neureka.calculus.environment.Type$Scalarization:
    68:69:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$ScalarOperatorCreator) -> <init>
neureka.calculus.environment.Type$TypeComponent -> neureka.calculus.environment.Type$TypeComponent:
    java.lang.String _operation -> _operation
    java.lang.String _deriviation -> _deriviation
    java.lang.Object _creator -> _creator
    26:30:void <init>(java.lang.String,java.lang.String,java.lang.Object) -> <init>
    32:32:java.lang.String getAsString() -> getAsString
    35:35:java.lang.String getDeriviationAsString() -> getDeriviationAsString
    38:38:java.lang.Object getCreator() -> getCreator
neureka.calculus.environment.implementations.function.Absolute -> neureka.calculus.environment.implementations.function.Absolute:
    9:27:void <init>() -> <init>
    14:18:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    18:18:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:16:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Cosinus -> neureka.calculus.environment.implementations.function.Cosinus:
    9:25:void <init>() -> <init>
    14:16:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    16:16:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    15:15:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Gaussian -> neureka.calculus.environment.implementations.function.Gaussian:
    9:37:void <init>() -> <init>
    20:24:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    25:26:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Identity -> neureka.calculus.environment.implementations.function.Identity:
    9:25:void <init>() -> <init>
    13:15:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    15:15:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    14:14:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Ligmoid -> neureka.calculus.environment.implementations.function.Ligmoid:
    9:40:void <init>() -> <init>
    30:32:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    32:32:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    31:31:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Quadratic -> neureka.calculus.environment.implementations.function.Quadratic:
    9:35:void <init>() -> <init>
    21:27:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    27:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.ReLU -> neureka.calculus.environment.implementations.function.ReLU:
    8:41:void <init>() -> <init>
    21:28:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    29:30:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sigmoid -> neureka.calculus.environment.implementations.function.Sigmoid:
    9:38:void <init>() -> <init>
    21:25:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    26:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    23:23:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sinus -> neureka.calculus.environment.implementations.function.Sinus:
    9:25:void <init>() -> <init>
    15:17:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    17:17:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:16:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Tanh -> neureka.calculus.environment.implementations.function.Tanh:
    8:31:void <init>() -> <init>
    13:20:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    21:22:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:17:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.indexer.Product -> neureka.calculus.environment.implementations.indexer.Product:
    8:35:void <init>() -> <init>
    19:24:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    25:26:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.indexer.Summation -> neureka.calculus.environment.implementations.indexer.Summation:
    8:29:void <init>() -> <init>
    19:24:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    24:24:double lambda$new$1(int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.operator.Addition -> neureka.calculus.environment.implementations.operator.Addition:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    neureka.calculus.environment.Type$Broadcast _broadcast -> b
    26:96:void <init>() -> <init>
    35:37:neureka.calculus.environment.Type$DefaultOperator lambda$new$5(neureka.Tsr[],double,int) -> a
    37:37:double lambda$new$4(int[],int[],int[]) -> a
    36:36:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:14:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    14:14:double lambda$static$1(int[],int[],int[]) -> b
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:18:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Division -> neureka.calculus.environment.implementations.operator.Division:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    26:103:void <init>() -> <init>
    37:42:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    42:42:double lambda$new$5(double,double[],neureka.Tsr[],int[],int[],int[]) -> a
    41:41:double lambda$new$4(double,int[],int[],int[]) -> a
    39:39:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:14:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    15:18:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:7:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Modulo -> neureka.calculus.environment.implementations.operator.Modulo:
    9:46:void <init>() -> <init>
    18:23:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    24:30:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    21:21:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.operator.Multiplication -> neureka.calculus.environment.implementations.operator.Multiplication:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    24:129:void <init>() -> <init>
    89:94:neureka.calculus.environment.Type$DefaultOperator lambda$new$11(neureka.Tsr[],int) -> a
    95:96:double lambda$new$10(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    92:92:double lambda$new$9(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    53:55:neureka.calculus.environment.Type$DefaultOperator lambda$new$8(neureka.Tsr[],int) -> b
    55:55:double lambda$new$7(double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    31:36:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    36:36:double lambda$new$5(double[],neureka.Tsr[],int[],int[],int[]) -> a
    35:35:double lambda$new$4(double,int[],int[],int[]) -> a
    33:33:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    10:15:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> c
    16:17:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    13:13:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> c
    8:8:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Power -> neureka.calculus.environment.implementations.operator.Power:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    33:116:void <init>() -> <init>
    42:49:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    49:49:double lambda$new$5(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    47:47:double lambda$new$4(double,double[],neureka.Tsr[],int[],int[],int[]) -> a
    44:44:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> b
    9:14:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    15:25:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    8:8:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Subtraction -> neureka.calculus.environment.implementations.operator.Subtraction:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    24:91:void <init>() -> <init>
    35:40:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    40:40:double lambda$new$5(int[],int[],int[]) -> a
    39:39:double lambda$new$4(int[],int[],int[]) -> b
    37:37:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:16:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    17:17:double lambda$static$1(int,int[],int[],int[]) -> a
    13:13:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:7:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.other.CopyLeft -> neureka.calculus.environment.implementations.other.CopyLeft:
    9:14:void <init>() -> <init>
neureka.calculus.environment.implementations.other.CopyRight -> neureka.calculus.environment.implementations.other.CopyRight:
    8:11:void <init>() -> <init>
neureka.calculus.environment.implementations.other.Randomization -> neureka.calculus.environment.implementations.other.Randomization:
    12:33:void <init>() -> <init>
    22:25:neureka.calculus.environment.Type$DefaultOperator lambda$new$1(neureka.Tsr[],double,int) -> a
    25:25:double lambda$new$0(java.util.Random,int[],int[],int[]) -> a
neureka.calculus.environment.implementations.other.Reshape -> neureka.calculus.environment.implementations.other.Reshape:
    13:18:void <init>() -> <init>
    22:25:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    28:28:neureka.Tsr lambda$getADAgentOf$2(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    27:27:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    26:26:neureka.Tsr lambda$getADAgentOf$0() -> a
neureka.calculus.factory.AbstractFunction -> neureka.calculus.factory.AbstractFunction:
    neureka.calculus.environment.OperationType _type -> a
    boolean _isFlat -> b
    boolean _doAD -> c
    java.util.ArrayList _src -> d
    29:34:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    38:38:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    43:43:boolean isFlat() -> isFlat
    48:48:boolean doesAD() -> doesAD
    53:53:int id() -> id
    58:58:neureka.calculus.environment.OperationType type() -> type
    63:63:neureka.Tsr call(neureka.Tsr) -> call
    68:68:neureka.Tsr call(neureka.Tsr[],int) -> call
    73:73:neureka.Tsr call(neureka.Tsr[]) -> call
    79:79:double call(double) -> call
    83:83:double call(double[],int) -> call
    87:87:double call(double[]) -> call
    95:127:java.lang.String toString() -> toString
    132:135:boolean dependsOn(int) -> dependsOn
    141:141:neureka.Tsr activate(neureka.Tsr) -> activate
    146:146:double activate(double) -> activate
    153:153:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    165:175:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int) -> _tensor_activation
    1317:1320:neureka.acceleration.Device _device(neureka.Tsr[]):317:320 -> _tensor_activation
    1317:1320:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):165 -> _tensor_activation
    1348:1363:boolean _shareGuestDevice(neureka.Tsr[]):348:363 -> _tensor_activation
    1348:1363:neureka.acceleration.Device _device(neureka.Tsr[]):318 -> _tensor_activation
    1348:1363:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):165 -> _tensor_activation
    181:221:neureka.Tsr _recursie_breakdown_execution(neureka.Tsr[],int,int,neureka.acceleration.Device) -> a
    226:299:neureka.Tsr _execution(neureka.Tsr[],int,int,neureka.acceleration.Device) -> b
    303:313:neureka.Tsr _apply(neureka.acceleration.Device,int,java.util.function.Supplier) -> a
    324:344:neureka.Tsr[] _src_acti(neureka.Tsr[],int,int,int) -> a
    368:390:double _scalar_activation(double,boolean) -> _scalar_activation
    396:416:double _scalar_activation(double[],int,int) -> _scalar_activation
    221:221:neureka.Tsr lambda$_recursie_breakdown_execution$2(neureka.Tsr[],int,int,neureka.acceleration.Device) -> c
    173:173:neureka.Tsr lambda$_tensor_activation$1(neureka.Tsr[],int,int,neureka.acceleration.Device) -> d
    168:168:neureka.Tsr lambda$_tensor_activation$0(neureka.Tsr[],int,int,neureka.acceleration.Device) -> e
neureka.calculus.factory.AbstractFunction$Exec -> neureka.calculus.factory.AbstractFunction$Exec:
    420:420:void <init>() -> <init>
    426:433:double reLu(double,boolean) -> reLu
    440:443:double sigmoid(double,boolean) -> sigmoid
    450:453:double tanh(double,boolean) -> tanh
    460:461:double quadratic(double,boolean) -> quadratic
    467:468:double ligmoid(double,boolean) -> ligmoid
    474:475:double linear(double,boolean) -> linear
    481:482:double gaussian(double,boolean) -> gaussian
    488:489:double absolute(double,boolean) -> absolute
    495:496:double sinus(double,boolean) -> sinus
    502:503:double cosinus(double,boolean) -> cosinus
    509:521:double summation(double[],int,int,java.util.ArrayList) -> a
    526:548:double summation(double[],int,java.util.ArrayList) -> a
    556:575:double PI(double[],int,int,java.util.ArrayList) -> b
    581:602:double PI(double[],int,java.util.ArrayList) -> b
    612:633:double power(double[],int,int,java.util.ArrayList) -> c
    639:664:double power(double[],int,java.util.ArrayList) -> c
    671:688:double division(double[],int,int,java.util.ArrayList) -> d
    694:715:double division(double[],int,java.util.ArrayList) -> d
    722:740:double multiplication(double[],int,int,java.util.ArrayList) -> e
    746:764:double multiplication(double[],int,java.util.ArrayList) -> e
    783:791:double modulo(double[],int,int,java.util.ArrayList) -> f
    797:805:double modulo(double[],int,java.util.ArrayList) -> f
    812:828:double subtraction(double[],int,int,java.util.ArrayList) -> g
    834:850:double subtraction(double[],int,java.util.ArrayList) -> g
    857:869:double addition(double[],int,int,java.util.ArrayList) -> h
    875:887:double addition(double[],int,java.util.ArrayList) -> h
neureka.calculus.factory.assembly.FunctionBuilder -> neureka.calculus.factory.assembly.FunctionBuilder:
    11:11:void <init>() -> <init>
    20:36:neureka.calculus.Function build(neureka.calculus.environment.OperationType,int,boolean) -> build
    47:60:neureka.calculus.Function build(java.lang.String,boolean) -> build
    1069:1258:neureka.calculus.Function _build(java.lang.String,boolean):69:258 -> build
    1069:1258:neureka.calculus.Function build(java.lang.String,boolean):56 -> build
    268:275:java.util.List _rebindPairwise(java.util.List,int) -> a
neureka.calculus.factory.assembly.FunctionConstructor -> neureka.calculus.factory.assembly.FunctionConstructor:
    12:12:void <init>() -> <init>
    16:59:neureka.calculus.Function construct(int,java.util.ArrayList,boolean) -> construct
neureka.calculus.factory.assembly.FunctionConstructor$1 -> neureka.calculus.factory.assembly.FunctionConstructor$1:
    java.util.ArrayList val$sources -> a
    21:21:void <init>(int,boolean,java.util.ArrayList,boolean,java.util.ArrayList) -> <init>
    24:24:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    28:28:neureka.Tsr activate(neureka.Tsr[]) -> activate
    32:32:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    36:36:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    41:41:double activate(double[],int) -> activate
    45:45:double activate(double[]) -> activate
    49:50:double derive(double[],int,int) -> derive
    54:55:double derive(double[],int) -> derive
    28:28:neureka.Tsr lambda$activate$1(java.util.ArrayList,neureka.Tsr[]) -> a
    24:24:neureka.Tsr lambda$activate$0(java.util.ArrayList,neureka.Tsr[],int) -> a
neureka.calculus.factory.assembly.FunctionConstructor$2 -> neureka.calculus.factory.assembly.FunctionConstructor$2:
    59:59:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    62:62:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    66:66:neureka.Tsr activate(neureka.Tsr[]) -> activate
    70:70:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    74:74:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    79:79:double activate(double[],int) -> activate
    83:83:double activate(double[]) -> activate
    87:87:double derive(double[],int,int) -> derive
    91:91:double derive(double[],int) -> derive
    74:74:neureka.Tsr lambda$derive$3(neureka.Tsr[],int) -> a
    70:70:neureka.Tsr lambda$derive$2(neureka.Tsr[],int,int) -> a
    66:66:neureka.Tsr lambda$activate$1(neureka.Tsr[]) -> a
    62:62:neureka.Tsr lambda$activate$0(neureka.Tsr[],int) -> b
neureka.calculus.factory.assembly.FunctionParser -> neureka.calculus.factory.assembly.FunctionParser:
    10:10:void <init>() -> <init>
    12:16:int numberOfOperationsWithin(java.util.List) -> numberOfOperationsWithin
    20:30:java.lang.String parsedOperation(java.lang.String,int) -> parsedOperation
    34:55:java.lang.String parsedComponent(java.lang.String,int) -> parsedComponent
    59:62:boolean containsOperation(java.lang.String,java.util.List) -> containsOperation
    66:67:boolean isBasicOperation(java.lang.String) -> isBasicOperation
    71:78:java.lang.String groupBy(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> groupBy
    82:82:boolean isWeired(char) -> a
    87:89:java.lang.String removeHeadAndTail(java.lang.String) -> removeHeadAndTail
    93:132:java.lang.String cleanedHeadAndTail(java.lang.String) -> cleanedHeadAndTail
    136:185:java.lang.String unpackAndCorrect(java.lang.String) -> unpackAndCorrect
    189:199:java.lang.String assumptionBasedOn(java.lang.String) -> assumptionBasedOn
    203:216:double similarity(java.lang.String,java.lang.String) -> similarity
neureka.calculus.factory.components.FunctionConstant -> neureka.calculus.factory.components.FunctionConstant:
    double _value -> a
    8:8:void <init>() -> <init>
    12:12:double value() -> value
    17:17:boolean isFlat() -> isFlat
    22:22:boolean doesAD() -> doesAD
    27:27:int id() -> id
    32:32:neureka.calculus.environment.OperationType type() -> type
    37:37:boolean dependsOn(int) -> dependsOn
    43:56:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    62:62:double call(double) -> call
    66:66:double call(double[],int) -> call
    70:70:double call(double[]) -> call
    75:75:neureka.Tsr call(neureka.Tsr) -> call
    80:80:neureka.Tsr call(neureka.Tsr[],int) -> call
    85:85:neureka.Tsr call(neureka.Tsr[]) -> call
    90:90:double activate(double) -> activate
    95:95:double activate(double[],int) -> activate
    100:100:double activate(double[]) -> activate
    105:105:double derive(double[],int) -> derive
    110:110:double derive(double[],int,int) -> derive
    117:117:neureka.Tsr activate(neureka.Tsr) -> activate
    122:122:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    127:127:neureka.Tsr activate(neureka.Tsr[]) -> activate
    132:132:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    137:137:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    143:143:java.lang.String toString() -> toString
    149:149:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionInput -> neureka.calculus.factory.components.FunctionInput:
    int _index -> a
    11:11:void <init>() -> <init>
    16:16:boolean providesGradient() -> providesGradient
    21:21:boolean isFlat() -> isFlat
    26:26:boolean doesAD() -> doesAD
    31:31:int id() -> id
    36:36:neureka.calculus.environment.OperationType type() -> type
    41:41:boolean dependsOn(int) -> dependsOn
    48:68:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    73:83:neureka.Tsr _extract(neureka.Tsr) -> a
    90:90:double call(double) -> call
    94:94:double call(double[],int) -> call
    98:98:double call(double[]) -> call
    103:103:neureka.Tsr call(neureka.Tsr) -> call
    108:108:neureka.Tsr call(neureka.Tsr[],int) -> call
    113:113:neureka.Tsr call(neureka.Tsr[]) -> call
    118:118:double activate(double) -> activate
    123:123:double activate(double[],int) -> activate
    128:128:double activate(double[]) -> activate
    133:133:double derive(double[],int) -> derive
    138:138:double derive(double[],int,int) -> derive
    145:145:neureka.Tsr activate(neureka.Tsr) -> activate
    150:150:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    155:155:neureka.Tsr activate(neureka.Tsr[]) -> activate
    160:160:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    165:167:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    174:174:java.lang.String toString() -> toString
    178:178:int index() -> index
    183:183:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionVariable -> neureka.calculus.factory.components.FunctionVariable:
    boolean _providesGradient -> a
    9:11:void <init>() -> <init>
    14:14:boolean providesGradient() -> providesGradient
    19:19:boolean isFlat() -> isFlat
    24:24:boolean doesAD() -> doesAD
    29:29:int id() -> id
    34:34:neureka.calculus.environment.OperationType type() -> type
    39:39:boolean dependsOn(int) -> dependsOn
    45:46:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    52:52:double activate(double) -> activate
    57:57:double activate(double[],int) -> activate
    61:63:double activate(double[]) -> activate
    68:68:double call(double) -> call
    72:72:double call(double[],int) -> call
    76:76:double call(double[]) -> call
    81:81:double derive(double[],int) -> derive
    86:87:double derive(double[],int,int) -> derive
    93:93:neureka.Tsr call(neureka.Tsr) -> call
    98:98:neureka.Tsr call(neureka.Tsr[],int) -> call
    103:103:neureka.Tsr call(neureka.Tsr[]) -> call
    108:108:neureka.Tsr activate(neureka.Tsr) -> activate
    113:113:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    118:120:neureka.Tsr activate(neureka.Tsr[]) -> activate
    125:125:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    130:130:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    137:137:java.lang.String toString() -> toString
    142:142:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.GradientProvider -> neureka.calculus.factory.components.GradientProvider:
    boolean providesGradient() -> providesGradient
neureka.framing.IndexAlias -> neureka.framing.IndexAlias:
    java.util.Map _mapping -> a
    13:23:void <init>(java.util.List) -> <init>
    25:28:void <init>(int) -> <init>
    30:43:void <init>(java.util.Map,neureka.Tsr) -> <init>
    46:46:int[] get(java.util.List) -> get
    50:61:int[] get(java.lang.Object[]) -> get
    66:68:int get(java.lang.Object,java.lang.Object) -> get
    73:76:void replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    79:85:void _initializeIdxmap(java.lang.Object,int,java.lang.Object,int) -> a
    89:92:void set(java.lang.Object,java.lang.Object,int) -> set
    96:100:java.util.List keysOf(java.lang.Object) -> keysOf
    104:108:java.util.List keysOf(java.lang.Object,int) -> keysOf
    112:120:java.lang.String _fixed(java.lang.String,int) -> a
    126:188:java.lang.String toString() -> toString
    195:195:void update(neureka.Tsr,neureka.Tsr) -> update
    8:8:void update(java.lang.Object,java.lang.Object) -> update
    159:174:void lambda$toString$6(java.lang.Object[],int[],java.lang.StringBuilder,int[],java.lang.Object,java.lang.Object) -> a
    162:163:void lambda$toString$5(int[],java.lang.Object[],java.lang.Object,java.lang.Integer) -> a
    141:147:void lambda$toString$4(int[],int[],java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    134:134:java.lang.Boolean lambda$toString$3(int,int,java.lang.Integer) -> a
    106:106:void lambda$keysOf$2(int,java.util.List,java.lang.Object,java.lang.Integer) -> a
    98:98:void lambda$keysOf$1(java.util.List,java.lang.Object,java.lang.Integer) -> a
    34:42:void lambda$new$0(neureka.Tsr,int[],java.lang.Object,java.util.List) -> a
neureka.framing.Relation -> neureka.framing.Relation:
    neureka.Tsr _parent -> a
    java.lang.ref.WeakReference[] _children -> b
    9:9:void <init>() -> <init>
    17:34:void update(neureka.Tsr,neureka.Tsr) -> update
    38:39:neureka.framing.Relation addParent(neureka.Tsr) -> addParent
    43:51:neureka.framing.Relation addChild(neureka.Tsr) -> addChild
    55:65:neureka.framing.Relation foreachChild(java.util.function.Consumer) -> foreachChild
    69:69:boolean hasParent() -> hasParent
    73:73:boolean hasChildren() -> hasChildren
    77:77:int childCount() -> childCount
    9:9:void update(java.lang.Object,java.lang.Object) -> update
neureka.optimization.Optimizer -> neureka.optimization.Optimizer:
    void optimize(neureka.Tsr) -> optimize
neureka.optimization.implementations.ADAM -> neureka.optimization.implementations.ADAM:
    neureka.Tsr m -> a
    neureka.Tsr v -> b
    40:41:void optimize(neureka.Tsr) -> optimize
    1029:1036:void _optimize(neureka.Tsr):29:36 -> optimize
    1029:1036:void optimize(neureka.Tsr):40 -> optimize
    46:46:void update(neureka.Tsr,neureka.Tsr) -> update
    7:7:void update(java.lang.Object,java.lang.Object) -> update
neureka.optimization.implementations.Template -> neureka.optimization.implementations.Template:
    6:6:void <init>() -> <init>
neureka.utility.DataHelper -> neureka.utility.DataHelper:
    5:5:void <init>() -> <init>
    9:9:double[] newSeededDoubleArray(java.lang.String,int) -> newSeededDoubleArray
    13:13:double[] newSeededDoubleArray(long,int) -> newSeededDoubleArray
    17:17:double[] seededDoubleArray(double[],java.lang.String) -> seededDoubleArray
    21:24:double[] seededDoubleArray(double[],long) -> seededDoubleArray
    28:28:float[] newSeededFloatArray(java.lang.String,int) -> newSeededFloatArray
    32:32:float[] newSeededFloatArray(long,int) -> newSeededFloatArray
    36:36:float[] seededFloatArray(float[],java.lang.String) -> seededFloatArray
    40:43:float[] seededFloatArray(float[],long) -> seededFloatArray
    48:51:long _longStringHash(java.lang.String) -> a
    55:58:float[] doubleToFloat(double[]) -> doubleToFloat
    62:65:double[] floatToDouble(float[]) -> floatToDouble
