neureka.Component -> neureka.Component:
    void update(java.lang.Object,java.lang.Object) -> update
neureka.Neureka -> neureka.Neureka:
    java.util.Map _instances -> a
    java.lang.String _settings_source -> b
    java.lang.String _setup_source -> c
    java.lang.String _version -> d
    boolean _groovyAvailable -> e
    boolean _openCLAvailable -> f
    neureka.Neureka$Settings _settings -> g
    neureka.Neureka$Utility _utility -> h
    33:36:void <init>() -> <init>
    39:39:neureka.Neureka instance() -> instance
    43:44:void setContext(java.lang.Thread,neureka.Neureka) -> setContext
    47:54:neureka.Neureka instance(java.lang.Thread) -> instance
    59:61:neureka.Neureka instance(java.lang.Object) -> instance
    65:65:boolean canAccessGroovy() -> canAccessGroovy
    69:69:boolean canAccessOpenCL() -> canAccessOpenCL
    73:73:neureka.Neureka$Settings settings() -> settings
    77:78:neureka.Neureka$Settings settings(java.lang.Object) -> settings
    82:82:neureka.Neureka$Utility utility() -> utility
    86:86:java.lang.String version() -> version
    90:109:void reset() -> reset
    112:112:boolean _currentThreadIsAuthorized() -> a
    28:31:void <clinit>() -> <clinit>
neureka.Neureka$Settings -> neureka.Neureka$Settings:
    neureka.Neureka$Settings$Debug _debug -> b
    neureka.Neureka$Settings$AutoGrad _autograd -> c
    neureka.Neureka$Settings$Indexing _indexing -> d
    neureka.Neureka$Settings$View _view -> e
    neureka.Neureka$Settings$NDim _ndim -> f
    boolean _isLocked -> g
    neureka.Neureka this$0 -> a
    123:131:void <init>(neureka.Neureka) -> <init>
    134:134:neureka.Neureka$Settings$Debug debug() -> debug
    138:139:neureka.Neureka$Settings$Debug debug(java.lang.Object) -> debug
    143:143:neureka.Neureka$Settings$AutoGrad autograd() -> autograd
    147:148:neureka.Neureka$Settings$AutoGrad autograd(java.lang.Object) -> autograd
    152:152:neureka.Neureka$Settings$Indexing indexing() -> indexing
    156:157:neureka.Neureka$Settings$Indexing indexing(java.lang.Object) -> indexing
    161:161:neureka.Neureka$Settings$View view() -> view
    165:166:neureka.Neureka$Settings$View view(java.lang.Object) -> view
    170:170:neureka.Neureka$Settings$NDim ndim() -> ndim
    174:175:neureka.Neureka$Settings$NDim ndim(java.lang.Object) -> ndim
    179:179:boolean isLocked() -> isLocked
    183:184:void setIsLocked(boolean) -> setIsLocked
neureka.Neureka$Settings$AutoGrad -> neureka.Neureka$Settings$AutoGrad:
    boolean _isRetainingPendingErrorForJITProp -> a
    boolean _isApplyingGradientWhenTensorIsUsed -> b
    boolean _isApplyingGradientWhenRequested -> c
    neureka.Neureka$Settings this$1 -> d
    216:243:void <init>(neureka.Neureka$Settings) -> <init>
    246:246:boolean isRetainingPendingErrorForJITProp() -> isRetainingPendingErrorForJITProp
    250:252:void setIsRetainingPendingErrorForJITProp(boolean) -> setIsRetainingPendingErrorForJITProp
    255:255:boolean isApplyingGradientWhenTensorIsUsed() -> isApplyingGradientWhenTensorIsUsed
    259:261:void setIsApplyingGradientWhenTensorIsUsed(boolean) -> setIsApplyingGradientWhenTensorIsUsed
    264:264:boolean isApplyingGradientWhenRequested() -> isApplyingGradientWhenRequested
    268:270:void setIsApplyingGradientWhenRequested(boolean) -> setIsApplyingGradientWhenRequested
neureka.Neureka$Settings$Debug -> neureka.Neureka$Settings$Debug:
    boolean _isKeepingDerivativeTargetPayloads -> a
    neureka.Neureka$Settings this$1 -> b
    186:203:void <init>(neureka.Neureka$Settings) -> <init>
    206:206:boolean isKeepingDerivativeTargetPayloads() -> isKeepingDerivativeTargetPayloads
    210:212:void setIsKeepingDerivativeTargetPayloads(boolean) -> setIsKeepingDerivativeTargetPayloads
neureka.Neureka$Settings$Indexing -> neureka.Neureka$Settings$Indexing:
    boolean _isUsingLegacyIndexing -> a
    boolean _isUsingThoroughIndexing -> b
    neureka.Neureka$Settings this$1 -> c
    274:276:void <init>(neureka.Neureka$Settings) -> <init>
    281:281:boolean isUsingLegacyIndexing() -> isUsingLegacyIndexing
    285:287:void setIsUsingLegacyIndexing(boolean) -> setIsUsingLegacyIndexing
    290:290:boolean isUsingThoroughIndexing() -> isUsingThoroughIndexing
    294:296:void setIsUsingThoroughIndexing(boolean) -> setIsUsingThoroughIndexing
neureka.Neureka$Settings$NDim -> neureka.Neureka$Settings$NDim:
    boolean _isOnlyUsingDefaultNDConfiguration -> a
    neureka.Neureka$Settings this$1 -> b
    315:322:void <init>(neureka.Neureka$Settings) -> <init>
    325:325:boolean isOnlyUsingDefaultNDConfiguration() -> isOnlyUsingDefaultNDConfiguration
    329:331:void setIsOnlyUsingDefaultNDConfiguration(boolean) -> setIsOnlyUsingDefaultNDConfiguration
neureka.Neureka$Settings$View -> neureka.Neureka$Settings$View:
    boolean _isUsingLegacyView -> a
    neureka.Neureka$Settings this$1 -> b
    300:302:void <init>(neureka.Neureka$Settings) -> <init>
    305:305:boolean isUsingLegacyView() -> isUsingLegacyView
    309:311:void setIsUsingLegacyView(boolean) -> setIsUsingLegacyView
neureka.Neureka$Utility -> neureka.Neureka$Utility:
    337:337:void <init>() -> <init>
    347:360:java.lang.String readResource(java.lang.String) -> readResource
    365:369:java.lang.Object tryGroovyClosureOn(java.lang.Object,java.lang.Object) -> tryGroovyClosureOn
    373:383:void tryGroovyScriptsOn(neureka.Neureka) -> tryGroovyScriptsOn
    386:398:boolean isPresent(java.lang.String) -> isPresent
neureka.Tsr -> neureka.Tsr:
    neureka.acceleration.Device _CPU -> a
    int _flags -> b
    45:47:neureka.Tsr setRqsGradient(boolean) -> setRqsGradient
    51:51:boolean rqsGradient() -> rqsGradient
    55:59:void _setRqsGradient(boolean) -> _setRqsGradient
    64:86:neureka.Tsr setIsOutsourced(boolean) -> setIsOutsourced
    90:90:boolean isOutsourced() -> isOutsourced
    94:98:void _setIsOutsourced(boolean) -> _setIsOutsourced
    103:123:neureka.Tsr setIsVirtual(boolean) -> setIsVirtual
    127:127:boolean isVirtual() -> isVirtual
    131:135:void _setIsVirtual(boolean) -> _setIsVirtual
    140:144:neureka.Tsr setGradientApplyRqd(boolean) -> setGradientApplyRqd
    148:148:boolean gradientApplyRqd() -> gradientApplyRqd
    165:188:neureka.Component _addOrReject(neureka.Component) -> _addOrReject
    203:206:neureka.Component _removeOrReject(neureka.Component) -> _removeOrReject
    213:213:boolean isEmpty() -> isEmpty
    217:217:boolean isUndefined() -> isUndefined
    221:222:boolean isSlice() -> isSlice
    226:227:int sliceCount() -> sliceCount
    231:232:boolean isSliceParent() -> isSliceParent
    236:236:boolean belongsToGraph() -> belongsToGraph
    240:240:boolean isLeave() -> isLeave
    244:244:boolean isBranch() -> isBranch
    254:255:neureka.acceleration.Device device() -> device
    263:263:neureka.autograd.GraphNode graphNode() -> graphNode
    271:271:neureka.framing.IndexAlias index() -> index
    278:292:neureka.Tsr _become(neureka.Tsr) -> _become
    296:307:neureka.Tsr delete() -> delete
    317:333:void _configureFromNewShape(int[],boolean) -> _configureFromNewShape
    35:339:void <init>() -> <init>
    35:344:void <init>(java.lang.Object) -> <init>
    35:352:void <init>(java.lang.String,java.util.List) -> <init>
    35:369:void <init>(java.util.List,java.lang.String) -> <init>
    35:384:void <init>(java.util.List,java.util.List) -> <init>
    35:415:void <init>(java.util.List) -> <init>
    35:419:void <init>(java.lang.Object,java.lang.Object) -> <init>
    35:422:void <init>(java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:425:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:428:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:431:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:434:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:437:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:440:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:443:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:447:void <init>(int[],java.lang.String) -> <init>
    450:452:void _construct(int[],java.lang.String) -> a
    455:461:int[] _intArray(java.lang.Object[]) -> a
    465:472:double[] _doubleArray(java.lang.Object[]) -> b
    35:477:void <init>(java.lang.Object[]) -> <init>
    480:541:void _construct(java.lang.Object[]) -> c
    35:545:void <init>(double) -> <init>
    35:549:void <init>(int[]) -> <init>
    552:554:void _construct(int[]) -> a
    35:558:void <init>(int[],double) -> <init>
    561:566:void _construct(int[],double) -> a
    35:570:void <init>(int[],double[]) -> <init>
    573:580:void _construct(int[],double[]) -> a
    35:587:void <init>(neureka.Tsr,java.lang.String) -> <init>
    35:591:void <init>(neureka.Tsr[],java.lang.String) -> <init>
    35:595:void <init>(neureka.Tsr[],java.lang.String,boolean) -> <init>
    598:601:void _construct(neureka.Tsr[],java.lang.String,boolean) -> a
    613:616:neureka.Tsr backward(neureka.Tsr) -> backward
    625:626:neureka.Tsr backward(double) -> backward
    630:636:void applyGradient() -> applyGradient
    641:644:neureka.Tsr T() -> T
    648:648:neureka.Tsr plus(neureka.Tsr) -> plus
    651:651:neureka.Tsr plusAssign(neureka.Tsr) -> plusAssign
    654:654:neureka.Tsr plus(java.lang.Double) -> plus
    657:657:neureka.Tsr minus(neureka.Tsr) -> minus
    660:660:neureka.Tsr minusAssign(neureka.Tsr) -> minusAssign
    663:663:neureka.Tsr negative() -> negative
    666:666:neureka.Tsr multiply(neureka.Tsr) -> multiply
    669:669:neureka.Tsr timesAssign(neureka.Tsr) -> timesAssign
    672:672:neureka.Tsr multiply(java.lang.Double) -> multiply
    675:675:neureka.Tsr div(neureka.Tsr) -> div
    678:678:neureka.Tsr div(java.lang.Double) -> div
    681:681:neureka.Tsr divAssign(neureka.Tsr) -> divAssign
    684:684:neureka.Tsr mod(neureka.Tsr) -> mod
    687:687:neureka.Tsr modAssign(neureka.Tsr) -> modAssign
    690:690:neureka.Tsr power(neureka.Tsr) -> power
    693:693:neureka.Tsr power(java.lang.Double) -> power
    696:696:neureka.Tsr xor(neureka.Tsr) -> xor
    699:699:neureka.Tsr xor(java.lang.Double) -> xor
    702:711:neureka.Tsr dot(neureka.Tsr) -> dot
    714:718:boolean isCase(neureka.Tsr) -> isCase
    721:721:boolean contains(neureka.Tsr) -> contains
    725:737:neureka.Tsr label(java.lang.String[][]) -> label
    741:743:neureka.Tsr label(java.util.List) -> label
    747:748:neureka.Tsr label(java.util.Map) -> label
    752:763:neureka.Tsr putAt(java.lang.Object,neureka.Tsr) -> putAt
    767:767:double getAt(int[]) -> getAt
    771:772:java.lang.Object getAt(java.lang.Object,java.lang.Object) -> getAt
    776:855:java.lang.Object getAt(java.lang.Object) -> getAt
    870:944:int _configureSubsetFromRanges(java.lang.Object[],int[],int[],int) -> a
    1053:1057:neureka.Tsr setValue64(double[]) -> setValue64
    1061:1065:neureka.Tsr setValue32(float[]) -> setValue32
    1069:1080:neureka.Tsr setValue(java.lang.Object) -> setValue
    1084:1088:java.lang.Object getValue() -> getValue
    1092:1094:double[] gradient64() -> gradient64
    1098:1100:float[] gradient32() -> gradient32
    1104:1109:neureka.Tsr addToGradient(neureka.Tsr) -> addToGradient
    1113:1120:neureka.Tsr to32() -> to32
    1124:1131:neureka.Tsr to64() -> to64
    1135:1140:double value64(int) -> value64
    1145:1154:double[] value64() -> value64
    1158:1163:float value32(int) -> value32
    1168:1176:float[] value32() -> value32
    1184:1184:java.lang.String toString(java.lang.String) -> toString
    1188:1250:java.lang.String _toString(java.lang.String,java.lang.String) -> _toString
    1254:1266:java.lang.String _stringified(double[],boolean,int) -> a
    1270:1270:java.lang.String toString() -> toString
    1275:1291:void makeFit(neureka.Tsr[]) -> makeFit
    1339:1339:void update(neureka.Tsr,neureka.Tsr) -> update
    23:23:void update(java.lang.Object,java.lang.Object) -> update
    1244:1246:void lambda$_toString$20(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1226:1236:void lambda$_toString$19(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1107:1107:void lambda$addToGradient$18(neureka.Tsr,neureka.acceleration.Device) -> a
    1105:1105:void lambda$addToGradient$17(neureka.Tsr,neureka.Tsr) -> a
    715:715:void lambda$isCase$16(neureka.Tsr,boolean[],neureka.framing.Relation) -> a
    716:717:void lambda$isCase$15(neureka.Tsr,boolean[],neureka.Tsr) -> a
    632:635:void lambda$applyGradient$14(neureka.Tsr) -> f
    632:632:void lambda$applyGradient$13(neureka.optimization.Optimizer) -> a
    630:630:void lambda$applyGradient$12(neureka.autograd.JITProp) -> a
    613:613:void lambda$backward$11(neureka.Tsr,neureka.autograd.GraphNode) -> a
    364:364:neureka.Tsr[] lambda$new$10(int) -> a
    348:348:neureka.Tsr[] lambda$new$9(int) -> b
    305:305:void lambda$delete$8(neureka.Tsr) -> g
    298:301:void lambda$delete$7(neureka.autograd.GraphNode) -> a
    296:296:void lambda$delete$6(neureka.acceleration.Device) -> a
    174:174:void lambda$_addOrReject$5(neureka.Tsr) -> h
    172:172:void lambda$_addOrReject$4(neureka.Tsr) -> i
    110:110:void lambda$setIsVirtual$3(neureka.Tsr) -> j
    71:81:void lambda$setIsOutsourced$2(neureka.acceleration.Device) -> b
    76:76:void lambda$setIsOutsourced$1(neureka.Tsr) -> k
    77:79:void lambda$setIsOutsourced$0(neureka.Tsr,neureka.acceleration.Device) -> b
    23:23:neureka.ndim.config.NDConfiguration access$000(neureka.Tsr) -> a
    23:23:neureka.ndim.config.NDConfiguration access$100(neureka.Tsr) -> b
    23:23:neureka.ndim.config.NDConfiguration access$200(neureka.Tsr) -> c
    23:23:neureka.ndim.config.NDConfiguration access$300(neureka.Tsr) -> d
    23:23:neureka.ndim.config.NDConfiguration access$402(neureka.Tsr,neureka.ndim.config.NDConfiguration) -> a
    23:23:neureka.ndim.config.NDConfiguration access$502(neureka.Tsr,neureka.ndim.config.NDConfiguration) -> b
    23:23:neureka.ndim.config.NDConfiguration access$600(neureka.Tsr) -> e
    25:25:void <clinit>() -> <clinit>
neureka.Tsr$Create -> neureka.Tsr$Create:
    1295:1295:void <init>() -> <init>
    1298:1298:neureka.Tsr E(int[]) -> E
    1302:1302:neureka.Tsr newRandom(int[]) -> newRandom
    1306:1307:neureka.Tsr newRandom(int[],long) -> newRandom
    1311:1315:neureka.Tsr newTsrLike(neureka.Tsr,double) -> newTsrLike
    1319:1323:neureka.Tsr newTsrLike(neureka.Tsr) -> newTsrLike
    1327:1329:neureka.Tsr _newEmptyLike(neureka.Tsr) -> a
neureka.Tsr$Exec -> neureka.Tsr$Exec:
    1026:1026:void <init>() -> <init>
    1029:1044:neureka.Tsr reshaped(neureka.Tsr,int[],boolean) -> reshaped
neureka.Tsr$IO -> neureka.Tsr$IO:
    949:949:void <init>() -> <init>
    952:954:double getFrom(neureka.Tsr,int) -> getFrom
    958:959:double getFrom(neureka.Tsr,int[]) -> getFrom
    963:965:void setInto(neureka.Tsr,int,double) -> setInto
    968:970:void setInto(neureka.Tsr,int[],double) -> setInto
    973:975:void addInto(neureka.Tsr,int,double) -> addInto
    978:980:void addInto(neureka.Tsr,int[],double) -> addInto
    983:985:neureka.Tsr addInto(neureka.Tsr,neureka.Tsr) -> addInto
    989:991:void subInto(neureka.Tsr,int,double) -> subInto
    994:996:void subInto(neureka.Tsr,int[],double) -> subInto
    999:1010:void subInto(neureka.Tsr,neureka.Tsr) -> subInto
    1013:1015:void mulInto(neureka.Tsr,int,double) -> mulInto
    1018:1020:void mulInto(neureka.Tsr,int[],double) -> mulInto
neureka.acceleration.AbstractDevice -> neureka.acceleration.AbstractDevice:
    java.lang.ref.Cleaner CLEANER -> a
    11:11:void <init>() -> <init>
    void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    21:22:void update(neureka.Tsr,neureka.Tsr) -> update
    26:27:neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    31:32:void _cleaning(java.lang.Object,java.lang.Runnable) -> _cleaning
    37:53:neureka.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    1070:1080:void _createNewDrainTensorIn(neureka.acceleration.Device,neureka.Tsr[],neureka.calculus.environment.OperationType):70:80 -> execute
    1070:1080:neureka.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int):50 -> execute
    58:64:neureka.Tsr _execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> a
    11:11:void update(java.lang.Object,java.lang.Object) -> update
    62:62:void lambda$_execute$0(neureka.calculus.environment.ExecutionCall) -> a
    13:13:void <clinit>() -> <clinit>
neureka.acceleration.Device -> neureka.acceleration.Device:
    28:39:neureka.acceleration.Device find(java.lang.String) -> find
    void dispose() -> dispose
    neureka.acceleration.Device get(neureka.Tsr) -> get
    neureka.acceleration.Device add(neureka.Tsr) -> add
    neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    boolean has(neureka.Tsr) -> has
    neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    neureka.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    double[] value64Of(neureka.Tsr) -> value64Of
    float[] value32Of(neureka.Tsr) -> value32Of
    java.util.Collection tensors() -> tensors
    31:31:void lambda$find$1(java.lang.String,neureka.acceleration.Device[],neureka.acceleration.opencl.OpenCLPlatform) -> a
    32:34:void lambda$find$0(java.lang.String,neureka.acceleration.Device[],neureka.acceleration.opencl.OpenCLDevice) -> a
neureka.acceleration.host.HostCPU -> neureka.acceleration.host.HostCPU:
    neureka.acceleration.host.HostCPU _instance -> a
    neureka.acceleration.host.HostCPU$NativeExecutor _executor -> b
    25:27:void <init>() -> <init>
    30:30:neureka.acceleration.host.HostCPU instance() -> instance
    34:34:neureka.acceleration.host.HostCPU$NativeExecutor getExecutor() -> getExecutor
    40:48:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    64:68:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    72:73:void dispose() -> dispose
    77:77:neureka.acceleration.Device get(neureka.Tsr) -> get
    82:82:neureka.acceleration.Device add(neureka.Tsr) -> add
    87:87:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    92:92:boolean has(neureka.Tsr) -> has
    97:97:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    102:102:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    107:107:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    112:112:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    117:117:double[] value64Of(neureka.Tsr) -> value64Of
    122:122:float[] value32Of(neureka.Tsr) -> value32Of
    127:127:java.util.Collection tensors() -> tensors
    20:21:void <clinit>() -> <clinit>
neureka.acceleration.host.HostCPU$NativeExecutor -> neureka.acceleration.host.HostCPU$NativeExecutor:
    java.util.concurrent.ThreadPoolExecutor _pool -> a
    134:138:void <init>(neureka.acceleration.host.HostCPU) -> <init>
    142:142:java.util.concurrent.ThreadPoolExecutor getPool() -> getPool
    149:173:void threaded(int,neureka.acceleration.host.HostCPU$Range) -> threaded
    159:161:void lambda$threaded$0(neureka.Neureka,neureka.acceleration.host.HostCPU$Range,int,int) -> a
neureka.acceleration.host.HostCPU$Range -> neureka.acceleration.host.HostCPU$Range:
    void execute(int,int) -> execute
neureka.acceleration.host.execution.HostExecutor -> neureka.acceleration.host.execution.HostExecutor:
    neureka.calculus.environment.ExecutorFor$ExecutionOn _creator -> a
    int _arity -> b
    18:21:void <init>(neureka.calculus.environment.ExecutorFor$ExecutionOn,int) -> <init>
    26:26:neureka.calculus.environment.ExecutorFor$ExecutionOn getExecution() -> getExecution
    31:31:int arity() -> arity
neureka.acceleration.opencl.KernelBuilder -> neureka.acceleration.opencl.KernelBuilder:
    org.jocl.cl_command_queue _queue -> a
    org.jocl.cl_kernel _kernel -> b
    int _argId -> c
    java.util.List _inputs -> d
    18:23:void <init>(org.jocl.cl_kernel,org.jocl.cl_command_queue) -> <init>
    32:37:neureka.acceleration.opencl.KernelBuilder pass(neureka.Tsr) -> pass
    41:43:neureka.acceleration.opencl.KernelBuilder pass(int) -> pass
    47:49:neureka.acceleration.opencl.KernelBuilder pass(float) -> pass
    54:69:void call(int) -> call
    1081:1088:org.jocl.cl_event[] _getWaitList(neureka.Tsr[]):81:88 -> call
    1081:1088:void call(int):54 -> call
    72:78:void _releaseEvents(neureka.Tsr[]) -> a
neureka.acceleration.opencl.OpenCLDevice -> neureka.acceleration.opencl.OpenCLDevice:
    java.util.Set _tensors -> a
    org.jocl.cl_device_id _did -> b
    neureka.acceleration.opencl.OpenCLPlatform _platform -> c
    org.jocl.cl_command_queue _queue -> d
    47:47:org.jocl.cl_device_id CLDeviceID() -> CLDeviceID
    42:84:void <init>(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> <init>
    87:88:neureka.acceleration.opencl.OpenCLDevice instance(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> instance
    96:99:java.util.Collection tensors() -> tensors
    104:106:void dispose() -> dispose
    110:114:neureka.acceleration.Device get(neureka.Tsr) -> get
    119:123:neureka.acceleration.Device add(neureka.Tsr) -> add
    128:132:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    137:208:void _add(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr) -> a
    212:212:boolean has(neureka.Tsr) -> has
    216:254:void _store(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr,int) -> a
    259:264:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    278:296:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    321:341:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    346:351:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    356:372:double[] value64Of(neureka.Tsr) -> value64Of
    378:394:float[] value32Of(neureka.Tsr) -> value32Of
    399:401:neureka.acceleration.opencl.KernelBuilder getKernel(neureka.calculus.environment.ExecutionCall) -> getKernel
    407:415:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    420:430:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    434:434:java.lang.String name() -> name
    438:438:java.lang.String vendor() -> vendor
    442:442:java.lang.String version() -> version
    446:455:java.lang.String type() -> type
    459:459:int maxComputeUnits() -> maxComputeUnits
    463:463:long maxWorkItemSimensions() -> maxWorkItemSimensions
    467:467:long[] maxWorkItemSizes() -> maxWorkItemSizes
    471:471:long maxWorkGroupSize() -> maxWorkGroupSize
    475:475:long maxClockFrequenzy() -> maxClockFrequenzy
    479:479:int maxAddressBits() -> maxAddressBits
    483:483:long maxMemAllocSize() -> maxMemAllocSize
    487:487:long globalMemSize() -> globalMemSize
    491:491:int errorCorrectionSupport() -> errorCorrectionSupport
    495:495:int localMemType() -> localMemType
    499:499:long localMemSize() -> localMemSize
    503:503:long maxConstantBufferSize() -> maxConstantBufferSize
    507:507:long maxConstantBufferSizeKB() -> maxConstantBufferSizeKB
    521:521:int imageSupport() -> imageSupport
    525:525:int maxReadImageArgs() -> maxReadImageArgs
    529:529:int maxWriteImageArgs() -> maxWriteImageArgs
    533:533:long singleFPConfig() -> singleFPConfig
    537:537:long image2DMaxWidth() -> image2DMaxWidth
    541:541:long image2DMaxHeight() -> image2DMaxHeight
    545:545:long image3DMaxWidth() -> image3DMaxWidth
    549:549:long image3DMaxHeight() -> image3DMaxHeight
    553:553:long image3DMaxDepth() -> image3DMaxDepth
    557:557:int prefVecWidthChar() -> prefVecWidthChar
    561:561:int prefVecWidthShort() -> prefVecWidthShort
    565:565:int prefVecWidthInt() -> prefVecWidthInt
    569:569:int prefVecWidthLong() -> prefVecWidthLong
    573:573:int prefVecWidthFloat() -> prefVecWidthFloat
    577:577:int prefVecWidthDouble() -> prefVecWidthDouble
    153:155:void lambda$_add$3(org.jocl.cl_event,org.jocl.cl_mem) -> a
    140:140:void lambda$_add$2(org.jocl.cl_mem) -> a
    98:98:void lambda$tensors$1(java.util.Collection,java.util.Collection) -> a
    98:98:void lambda$tensors$0(java.util.Collection,neureka.Tsr) -> a
neureka.acceleration.opencl.OpenCLDevice$DeviceQuery -> neureka.acceleration.opencl.OpenCLDevice$DeviceQuery:
    580:580:void <init>() -> <init>
    589:589:int getInt(org.jocl.cl_device_id,int) -> getInt
    601:603:int[] getInts(org.jocl.cl_device_id,int,int) -> getInts
    614:614:long getLong(org.jocl.cl_device_id,int) -> getLong
    626:628:long[] getLongs(org.jocl.cl_device_id,int,int) -> getLongs
    640:648:java.lang.String getString(org.jocl.cl_device_id,int) -> getString
    660:668:java.lang.String getString(org.jocl.cl_platform_id,int) -> getString
    679:679:long getSize(org.jocl.cl_device_id,int) -> getSize
    693:707:long[] getSizes(org.jocl.cl_device_id,int,int) -> getSizes
neureka.acceleration.opencl.OpenCLDevice$cl_config -> neureka.acceleration.opencl.OpenCLDevice$a:
    org.jocl.cl_mem data -> a
    27:27:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLDevice$cl_tsr -> neureka.acceleration.opencl.OpenCLDevice$b:
    int fp -> a
    neureka.acceleration.opencl.OpenCLDevice$cl_config config -> b
    neureka.acceleration.opencl.OpenCLDevice$cl_value value -> c
    31:33:void <init>() -> <init>
    31:31:void update(java.lang.Object,java.lang.Object) -> update
neureka.acceleration.opencl.OpenCLDevice$cl_value -> neureka.acceleration.opencl.OpenCLDevice$c:
    org.jocl.cl_mem data -> a
    int size -> b
    org.jocl.cl_event event -> c
    21:23:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLPlatform -> neureka.acceleration.opencl.OpenCLPlatform:
    org.jocl.cl_platform_id _pid -> a
    java.util.Map _id_device -> b
    org.jocl.cl_context _context -> c
    java.util.Map _kernels -> d
    java.util.Map OPERATION_TO_KERNEL_MAPPING -> e
    63:63:java.lang.String kernelNameOf(neureka.calculus.environment.OperationType) -> kernelNameOf
    68:97:void <init>(org.jocl.cl_platform_id) -> <init>
    100:104:void recompile() -> recompile
    109:201:void _compile(org.jocl.cl_device_id[]) -> a
    208:208:org.jocl.cl_platform_id getID() -> getID
    212:214:java.util.List getDevices() -> getDevices
    218:218:boolean has(org.jocl.cl_device_id) -> has
    221:221:neureka.acceleration.opencl.OpenCLDevice get(org.jocl.cl_device_id) -> get
    224:225:void put(org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> put
    229:229:java.util.Map getKernels() -> getKernels
    233:233:org.jocl.cl_context getContext() -> getContext
    237:237:java.util.List PLATFORMS() -> PLATFORMS
    213:213:void lambda$getDevices$1(java.util.List,org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> a
    168:170:void lambda$_compile$0(java.util.ArrayList,java.util.ArrayList,java.lang.String,java.lang.String) -> a
    20:60:void <clinit>() -> <clinit>
neureka.acceleration.opencl.OpenCLPlatform$_setup -> neureka.acceleration.opencl.OpenCLPlatform$a:
    java.util.List PLATFORMS -> a
    242:242:void <clinit>() -> <clinit>
    1246:1257:java.util.List findAllPlatforms():246:257 -> <clinit>
    1246:1257:void <clinit>():242 -> <clinit>
neureka.acceleration.opencl.execution.CLExecutor -> neureka.acceleration.opencl.execution.CLExecutor:
    java.util.function.Function _aliasSwapper -> a
    java.util.function.Function asAdvanced -> b
    java.lang.String _source -> c
    java.lang.String _name -> d
    neureka.calculus.environment.ExecutorFor$ExecutionOn _lambda -> e
    int _arity -> f
    48:48:java.lang.String getSource() -> getSource
    51:51:java.lang.String getName() -> getName
    56:56:neureka.calculus.environment.ExecutorFor$ExecutionOn getExecution() -> getExecution
    61:61:int arity() -> arity
    19:70:void <init>(neureka.calculus.environment.ExecutorFor$ExecutionOn,int) -> <init>
    19:105:void <init>(neureka.calculus.environment.ExecutorFor$ExecutionOn,int,java.lang.String,java.lang.String,java.lang.String,neureka.calculus.environment.OperationType) -> <init>
    1118:1146:java.util.Map _getParsedKernelsFromTemplate(java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.calculus.environment.OperationType):118:146 -> <init>
    1118:1146:void <init>(neureka.calculus.environment.ExecutorFor$ExecutionOn,int,java.lang.String,java.lang.String,java.lang.String,neureka.calculus.environment.OperationType):94 -> <init>
    124:134:void lambda$_getParsedKernelsFromTemplate$2(java.lang.String[],java.lang.String,java.util.Map,java.lang.String,java.lang.String,java.lang.String) -> a
    36:39:java.lang.String lambda$new$1(java.lang.String) -> a
    21:31:java.lang.String lambda$new$0(java.lang.String) -> b
neureka.acceleration.opencl.execution.CLExecutor$Parser -> neureka.acceleration.opencl.execution.CLExecutor$a:
    void apply(java.lang.String,java.lang.String,java.lang.String) -> apply
neureka.acceleration.opencl.utility.DeviceQuery -> neureka.acceleration.opencl.utility.DeviceQuery:
    14:14:void <init>() -> <init>
    23:182:java.lang.String query() -> query
    1270:1278:java.lang.String getString(org.jocl.cl_platform_id,int):270:278 -> query
    1270:1278:java.lang.String query():38 -> query
    194:194:int getInt(org.jocl.cl_device_id,int) -> a
    207:209:int[] getInts(org.jocl.cl_device_id,int,int) -> a
    221:221:long getLong(org.jocl.cl_device_id,int) -> b
    234:236:long[] getLongs(org.jocl.cl_device_id,int,int) -> b
    249:257:java.lang.String getString(org.jocl.cl_device_id,int) -> c
    290:290:long getSize(org.jocl.cl_device_id,int) -> d
    305:324:long[] getSizes(org.jocl.cl_device_id,int,int) -> c
neureka.acceleration.opencl.utility.WeakTensorReference -> neureka.acceleration.opencl.utility.WeakTensorReference:
    int _hash -> a
    24:26:void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    30:30:int hashCode() -> hashCode
    35:35:boolean equals(java.lang.Object) -> equals
neureka.autograd.ADAgent -> neureka.autograd.ADAgent:
    neureka.autograd.ADAgent$ADAction _fad -> a
    neureka.autograd.ADAgent$ADAction _bad -> b
    java.util.function.Supplier _derivative -> c
    19:23:void <init>(java.util.function.Supplier,neureka.autograd.ADAgent$ADAction,neureka.autograd.ADAgent$ADAction) -> <init>
    26:30:void <init>(neureka.Tsr) -> <init>
    33:33:neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    38:38:neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    42:42:neureka.Tsr derivative() -> derivative
    46:46:boolean isForward() -> isForward
    51:57:java.lang.String toString() -> toString
    27:27:neureka.Tsr lambda$new$0(neureka.Tsr) -> a
neureka.autograd.ADAgent$ADAction -> neureka.autograd.ADAgent$ADAction:
    neureka.Tsr execute(neureka.autograd.GraphNode,neureka.Tsr) -> execute
neureka.autograd.GraphLock -> neureka.autograd.GraphLock:
    neureka.calculus.Function _owner -> a
    boolean _is_locked -> b
    22:31:void <init>(neureka.calculus.Function,neureka.Tsr[]) -> <init>
    37:37:boolean isLocked() -> isLocked
    45:46:void release() -> release
    53:53:java.lang.String toString() -> toString
neureka.autograd.GraphNode -> neureka.autograd.GraphNode:
    neureka.calculus.Function MUL -> a
    neureka.calculus.Function ADD -> b
    int _mode -> c
    boolean _relies_on_JIPProp -> d
    neureka.autograd.PendingError _pending_error -> e
    boolean _is_used_as_derivative -> f
    neureka.calculus.Function _function -> g
    neureka.autograd.GraphNode[] _parents -> h
    java.lang.ref.WeakReference _payload -> i
    java.util.TreeMap _targets_derivatives -> j
    neureka.autograd.GraphLock _lock -> k
    java.util.List _children -> l
    long _nid -> m
    37:37:boolean usesAD() -> usesAD
    46:46:boolean usesForwardAD() -> usesForwardAD
    55:55:boolean usesReverseAD() -> usesReverseAD
    83:83:boolean reliesOnJustInTimeProp() -> reliesOnJustInTimeProp
    97:99:neureka.autograd.PendingError getAndRemovePendingError() -> getAndRemovePendingError
    116:116:boolean isUsedAsDerivative() -> isUsedAsDerivative
    126:126:neureka.calculus.Function getFunction() -> getFunction
    137:137:neureka.autograd.GraphNode[] getParents() -> getParents
    157:157:neureka.Tsr getPayload() -> getPayload
    161:178:void _setPayload(neureka.Tsr) -> a
    189:190:void update(neureka.Tsr,neureka.Tsr) -> update
    206:206:neureka.autograd.GraphLock lock() -> lock
    215:215:java.util.List getChildren() -> getChildren
    224:224:long nid() -> nid
    235:236:void obtainLocking(neureka.autograd.GraphLock) -> obtainLocking
    242:245:void _attachChild(neureka.autograd.GraphNode) -> a
    254:254:boolean isCachable() -> isCachable
    263:263:boolean isLeave() -> isLeave
    267:271:boolean isGraphLeave() -> isGraphLeave
    278:278:boolean isVirtual() -> isVirtual
    86:307:void <init>(neureka.calculus.Function,java.lang.Object,java.util.function.Supplier) -> <init>
    310:376:void _construct(neureka.Tsr,neureka.calculus.Function,neureka.Tsr[],neureka.autograd.GraphLock) -> a
    390:409:int _modeOf(neureka.Tsr[],neureka.calculus.Function) -> a
    420:425:void _migrateAndOrApplyError(neureka.Tsr,java.util.function.Consumer) -> a
    438:450:void backward(neureka.Tsr) -> backward
    468:490:void _backward(neureka.Tsr,java.util.Set,boolean) -> a
    502:510:void _carryPendingBackPropToGradients(java.util.Set) -> a
    526:528:void backwardJIT(neureka.Tsr) -> backwardJIT
    531:557:void _backwardJIT(neureka.Tsr,neureka.autograd.GraphNode) -> a
    569:573:void _deleteDerivativesRecursively() -> a
    581:590:int _numberOfReverseModeADChildren() -> b
    597:597:int mode() -> mode
    604:604:neureka.calculus.Function function() -> function
    612:625:void put(neureka.autograd.GraphNode,java.lang.Object) -> put
    634:635:java.lang.Object get(neureka.autograd.GraphNode) -> get
    646:647:boolean has(neureka.autograd.GraphNode) -> has
    657:657:int size() -> size
    664:668:void forEachBackward(neureka.Tsr,java.util.function.BiConsumer) -> forEachBackward
    674:678:void forEachForward(neureka.Tsr,java.util.function.BiConsumer) -> forEachForward
    684:686:void forEachDerivative(java.util.function.BiConsumer) -> forEachDerivative
    692:694:void forEachTarget(java.util.function.Consumer) -> forEachTarget
    701:703:void forEach(neureka.Tsr,java.util.function.BiConsumer) -> forEach
    710:710:boolean hasDerivatives() -> hasDerivatives
    717:722:java.lang.String type() -> type
    727:727:java.lang.String toString() -> toString
    735:742:java.lang.String toString(java.lang.String) -> toString
    758:771:java.lang.String _toString(java.lang.String,boolean) -> a
    26:26:void update(java.lang.Object,java.lang.Object) -> update
    702:702:void lambda$forEach$15(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    693:693:void lambda$forEachTarget$14(java.util.function.Consumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    676:677:void lambda$forEachForward$13(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> b
    666:667:void lambda$forEachBackward$12(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> c
    612:612:int lambda$put$11(neureka.autograd.GraphNode,neureka.autograd.GraphNode) -> a
    554:554:void lambda$_backwardJIT$10(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> a
    553:553:void lambda$_backwardJIT$9(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> b
    533:538:void lambda$_backwardJIT$8(neureka.autograd.GraphNode,neureka.Tsr) -> a
    503:503:void lambda$_carryPendingBackPropToGradients$7(java.util.Set,neureka.autograd.GraphNode) -> a
    487:487:void lambda$_backward$6(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> a
    486:486:void lambda$_backward$5(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> b
    444:447:void lambda$backward$4(neureka.autograd.GraphNode) -> b
    441:441:void lambda$backward$3(java.util.Set,neureka.autograd.GraphNode) -> b
    360:363:void lambda$_construct$2(neureka.autograd.GraphNode,neureka.Tsr) -> b
    298:298:void lambda$new$1(neureka.autograd.JITProp) -> a
    166:176:void lambda$_setPayload$0() -> c
    28:29:void <clinit>() -> <clinit>
neureka.autograd.JITProp -> neureka.autograd.JITProp:
    java.util.Set _finished -> a
    java.util.Set _pending -> b
    16:20:void <init>(java.util.Set) -> <init>
    27:30:void addPending(java.util.Set) -> addPending
    37:46:void noteFinished(neureka.autograd.GraphNode) -> noteFinished
    49:49:int finishedCount() -> finishedCount
    53:53:int pendingCount() -> pendingCount
    61:71:void execute() -> execute
    78:78:boolean isDone() -> isDone
    86:88:java.lang.String toString() -> toString
    95:95:void update(neureka.Tsr,neureka.Tsr) -> update
    10:10:void update(java.lang.Object,java.lang.Object) -> update
    63:68:void lambda$execute$0(neureka.autograd.GraphNode) -> a
neureka.autograd.PendingError -> neureka.autograd.PendingError:
    int _toBeReceived -> a
    neureka.Tsr _error -> b
    11:14:void <init>(neureka.Tsr,int) -> <init>
    17:21:void accumulate(neureka.Tsr) -> accumulate
    24:24:boolean isFullyAccumulated() -> isFullyAccumulated
    28:28:neureka.Tsr getAccumulatedError() -> getAccumulatedError
neureka.calculus.Function -> neureka.calculus.Function:
    neureka.calculus.environment.Cache CACHE -> CACHE
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    61:61:neureka.calculus.Function create(java.lang.String) -> create
    65:65:neureka.calculus.Function create(java.lang.String,boolean) -> create
    neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    boolean doesAD() -> doesAD
    boolean isFlat() -> isFlat
    int id() -> id
    neureka.calculus.environment.OperationType type() -> type
    boolean dependsOn(int) -> dependsOn
    double call(double) -> call
    double invoke(double) -> invoke
    double call(double[],int) -> call
    double invoke(double[],int) -> invoke
    double call(double[]) -> call
    double invoke(double[]) -> invoke
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    neureka.Tsr call(neureka.Tsr) -> call
    neureka.Tsr invoke(neureka.Tsr) -> invoke
    neureka.Tsr call(java.util.List) -> call
    neureka.Tsr invoke(java.util.List) -> invoke
    neureka.Tsr call(neureka.Tsr[],int) -> call
    neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    neureka.Tsr call(neureka.Tsr[]) -> call
    neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    neureka.Tsr derive(neureka.Tsr[],int) -> derive
    neureka.Tsr derive(java.util.List,int,int) -> derive
    neureka.Tsr derive(java.util.List,int) -> derive
    java.lang.String toString() -> toString
    neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    18:35:void <clinit>() -> <clinit>
neureka.calculus.Function$Detached -> neureka.calculus.Function$Detached:
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function ADD -> ADD
    neureka.calculus.Function ADD_ASSIGN -> ADD_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    38:38:void <init>() -> <init>
    40:57:void <clinit>() -> <clinit>
neureka.calculus.Function$Setup -> neureka.calculus.Function$Setup:
    68:68:void <init>() -> <init>
    71:71:neureka.Tsr commit(neureka.Tsr[],java.lang.String,boolean) -> commit
    75:75:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],java.lang.String,boolean) -> commit
    79:79:neureka.Tsr commit(neureka.Tsr[],neureka.calculus.Function) -> commit
    83:83:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function) -> commit
    88:111:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier) -> commit
    93:93:neureka.Tsr lambda$commit$0(neureka.Tsr) -> a
neureka.calculus.environment.Cache -> neureka.calculus.environment.Cache:
    neureka.calculus.environment.Cache _cache -> a
    java.util.Map FUNCTIONS -> b
    java.util.Map PROCESSING -> c
    15:30:void <init>() -> <init>
    19:21:neureka.calculus.environment.Cache instance() -> instance
    27:27:java.util.Map FUNCTIONS() -> FUNCTIONS
    34:36:void free(neureka.autograd.GraphLock) -> free
    40:74:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier,int,int) -> preprocess
    79:92:neureka.Tsr _get(neureka.Tsr[],int,int) -> a
    97:108:void _put(neureka.Tsr,neureka.autograd.GraphNode,int,int) -> a
    111:111:int _keyed(int) -> a
    101:101:int lambda$_put$2(java.lang.Long,java.lang.Long) -> a
    60:60:neureka.Tsr lambda$preprocess$1(neureka.Tsr) -> a
    30:30:int lambda$new$0(neureka.autograd.GraphLock,neureka.autograd.GraphLock) -> a
    13:13:void <clinit>() -> <clinit>
neureka.calculus.environment.ExecutionCall -> neureka.calculus.environment.ExecutionCall:
    neureka.acceleration.Device _device -> a
    neureka.Tsr[] _tsrs -> b
    int _d -> c
    neureka.calculus.environment.OperationType _type -> d
    25:30:void <init>(neureka.acceleration.Device,neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> <init>
    31:31:neureka.acceleration.Device getDevice() -> getDevice
    32:32:neureka.Tsr[] getTensors() -> getTensors
    33:33:neureka.Tsr getTensor(int) -> getTensor
    34:34:int getDerivativeIndex() -> getDerivativeIndex
    35:35:neureka.calculus.environment.OperationType getType() -> getType
    36:36:neureka.calculus.environment.OperationTypeImplementation getImplementation() -> getImplementation
neureka.calculus.environment.ExecutorFor -> neureka.calculus.environment.ExecutorFor:
    neureka.calculus.environment.ExecutorFor$ExecutionOn getExecution() -> getExecution
    int arity() -> arity
neureka.calculus.environment.ExecutorFor$ExecutionOn -> neureka.calculus.environment.ExecutorFor$ExecutionOn:
    void call(neureka.calculus.environment.ExecutionCall) -> call
neureka.calculus.environment.OperationType -> neureka.calculus.environment.OperationType:
    java.util.Map _LOOKUP -> a
    java.util.ArrayList _REGISTER -> b
    int _ID -> c
    int _id -> _id
    java.lang.String _name -> _name
    java.lang.String _identifier -> _identifier
    int _arity -> _arity
    boolean _isOperation -> _isOperation
    boolean _isIndexer -> _isIndexer
    boolean _isConvection -> _isConvection
    boolean _isCommutative -> _isCommutative
    boolean _isAssociative -> _isAssociative
    java.util.Map _implementations -> d
    28:28:java.util.ArrayList instances() -> instances
    32:32:neureka.calculus.environment.OperationType instance(int) -> instance
    36:36:neureka.calculus.environment.OperationType instance(java.lang.String) -> instance
    55:121:void <init>(java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean,boolean) -> <init>
    124:124:neureka.calculus.environment.OperationType[] ALL() -> ALL
    128:128:int COUNT() -> COUNT
    135:135:java.lang.String getName() -> getName
    142:142:neureka.calculus.environment.executors.AbstractOperationTypeImplementation getImplementation(java.lang.Class) -> getImplementation
    146:146:boolean supportsImplementation(java.lang.Class) -> supportsImplementation
    150:151:neureka.calculus.environment.Type setImplementation(java.lang.Class,neureka.calculus.environment.executors.AbstractOperationTypeImplementation) -> setImplementation
    158:161:neureka.calculus.environment.OperationTypeImplementation implementationOf(neureka.calculus.environment.ExecutionCall) -> implementationOf
    168:168:int id() -> id
    173:173:java.lang.String identifier() -> identifier
    178:178:int arity() -> arity
    183:183:boolean isOperation() -> isOperation
    188:188:boolean isIndexer() -> isIndexer
    193:193:boolean isConvection() -> isConvection
    198:198:boolean isCommutative() -> isCommutative
    204:211:boolean allowsForward(neureka.Tsr[]) -> allowsForward
    217:250:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    251:251:neureka.Tsr lambda$getADAgentOf$10(neureka.autograd.GraphNode,neureka.Tsr) -> a
    251:251:neureka.Tsr lambda$getADAgentOf$9(neureka.autograd.GraphNode,neureka.Tsr) -> b
    251:251:neureka.Tsr lambda$getADAgentOf$8() -> a
    246:246:neureka.Tsr lambda$getADAgentOf$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    245:245:neureka.Tsr lambda$getADAgentOf$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    244:244:neureka.Tsr lambda$getADAgentOf$5(neureka.Tsr) -> a
    233:233:neureka.Tsr lambda$getADAgentOf$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    232:232:neureka.Tsr lambda$getADAgentOf$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    231:231:neureka.Tsr lambda$getADAgentOf$2(neureka.Tsr) -> b
    223:223:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    222:222:neureka.Tsr lambda$getADAgentOf$0(neureka.Tsr) -> c
    23:83:void <clinit>() -> <clinit>
neureka.calculus.environment.OperationTypeFactory -> neureka.calculus.environment.OperationTypeFactory:
    3:3:void <init>() -> <init>
neureka.calculus.environment.OperationTypeImplementation -> neureka.calculus.environment.OperationTypeImplementation:
    java.lang.Object setExecutor(java.lang.Class,neureka.calculus.environment.ExecutorFor) -> setExecutor
    neureka.calculus.environment.ExecutorFor getExecutor(java.lang.Class) -> getExecutor
    boolean canHandle(neureka.calculus.environment.ExecutionCall) -> canHandle
    neureka.Tsr reduce(neureka.calculus.environment.ExecutionCall,java.util.function.Consumer) -> reduce
    java.util.List getCallPipeline() -> getCallPipeline
neureka.calculus.environment.OperationTypeImplementation$CallPipe -> neureka.calculus.environment.OperationTypeImplementation$CallPipe:
    neureka.calculus.environment.ExecutionCall run(neureka.calculus.environment.ExecutionCall) -> run
neureka.calculus.environment.Type -> neureka.calculus.environment.Type:
    neureka.calculus.environment.OperationTypeImplementation implementationOf(neureka.calculus.environment.ExecutionCall) -> implementationOf
    java.lang.String getName() -> getName
    neureka.calculus.environment.executors.AbstractOperationTypeImplementation getImplementation(java.lang.Class) -> getImplementation
    boolean supportsImplementation(java.lang.Class) -> supportsImplementation
    neureka.calculus.environment.Type setImplementation(java.lang.Class,neureka.calculus.environment.executors.AbstractOperationTypeImplementation) -> setImplementation
    int id() -> id
    java.lang.String identifier() -> identifier
    int arity() -> arity
    boolean isOperation() -> isOperation
    boolean isIndexer() -> isIndexer
    boolean isConvection() -> isConvection
    boolean isCommutative() -> isCommutative
    boolean allowsForward(neureka.Tsr[]) -> allowsForward
    neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
neureka.calculus.environment.Type$DefaultOperatorCreator -> neureka.calculus.environment.Type$DefaultOperatorCreator:
    java.lang.Object create(neureka.Tsr[],int) -> create
neureka.calculus.environment.Type$PrimaryNDXConsumer -> neureka.calculus.environment.Type$PrimaryNDXConsumer:
    double execute(int[]) -> execute
neureka.calculus.environment.Type$ScalarOperatorCreator -> neureka.calculus.environment.Type$ScalarOperatorCreator:
    java.lang.Object create(neureka.Tsr[],double,int) -> create
neureka.calculus.environment.Type$SecondaryNDXConsumer -> neureka.calculus.environment.Type$SecondaryNDXConsumer:
    double execute(int[],int[]) -> execute
neureka.calculus.environment.Type$TertiaryNDXConsumer -> neureka.calculus.environment.Type$TertiaryNDXConsumer:
    double execute(int[],int[],int[]) -> execute
neureka.calculus.environment.executors.AbstractOperationTypeImplementation -> neureka.calculus.environment.executors.AbstractOperationTypeImplementation:
    java.util.Map _executions -> _executions
    java.util.List _callPipe -> _callPipe
    31:35:void <init>() -> <init>
    39:43:java.lang.Object setExecutor(java.lang.Class,neureka.calculus.environment.ExecutorFor) -> setExecutor
    48:48:neureka.calculus.environment.ExecutorFor getExecutor(java.lang.Class) -> getExecutor
    53:53:java.util.List getCallPipeline() -> getCallPipeline
    63:63:neureka.Tsr reduce(neureka.acceleration.Device,neureka.Tsr[],neureka.calculus.environment.OperationType,int,java.util.function.Consumer) -> a
    73:200:neureka.Tsr reduce(neureka.calculus.environment.ExecutionCall,java.util.function.Consumer) -> reduce
    86:86:void lambda$reduce$1(neureka.Tsr) -> a
    34:34:neureka.calculus.environment.ExecutionCall lambda$new$0(neureka.calculus.environment.ExecutionCall) -> a
neureka.calculus.environment.executors.AbstractOperationTypeImplementation$Utility -> neureka.calculus.environment.executors.AbstractOperationTypeImplementation$Utility:
    203:203:void <init>() -> <init>
    206:212:neureka.Tsr[] _subset(neureka.Tsr[],int,int,int) -> _subset
    215:217:neureka.Tsr[] _without(neureka.Tsr[],int) -> _without
    221:233:neureka.Tsr[] _offsetted(neureka.Tsr[],int) -> _offsetted
neureka.calculus.environment.executors.Activation -> neureka.calculus.environment.executors.Activation:
    11:11:void <init>() -> <init>
    15:16:boolean canHandle(neureka.calculus.environment.ExecutionCall) -> canHandle
    22:22:java.lang.String getKernelSource() -> getKernelSource
    31:44:void activate(neureka.Tsr,int,int,neureka.calculus.environment.Type$TertiaryNDXConsumer) -> activate
neureka.calculus.environment.executors.Broadcast -> neureka.calculus.environment.executors.Broadcast:
    11:11:void <init>() -> <init>
    16:30:boolean canHandle(neureka.calculus.environment.ExecutionCall) -> canHandle
    34:34:java.lang.String getKernelSource() -> getKernelSource
    43:125:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$TertiaryNDXConsumer) -> broadcast
neureka.calculus.environment.executors.Convolution -> neureka.calculus.environment.executors.Convolution:
    11:11:void <init>() -> <init>
    15:15:boolean canHandle(neureka.calculus.environment.ExecutionCall) -> canHandle
    20:20:java.lang.String getKernelSource() -> getKernelSource
    29:164:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$TertiaryNDXConsumer) -> convolve
neureka.calculus.environment.executors.Operation -> neureka.calculus.environment.executors.Operation:
    11:11:void <init>() -> <init>
    15:17:boolean canHandle(neureka.calculus.environment.ExecutionCall) -> canHandle
    21:21:java.lang.String getKernelSource() -> getKernelSource
    32:42:void operate(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$PrimaryNDXConsumer) -> operate
neureka.calculus.environment.executors.Scalarization -> neureka.calculus.environment.executors.Scalarization:
    11:11:void <init>() -> <init>
    16:16:boolean canHandle(neureka.calculus.environment.ExecutionCall) -> canHandle
    21:21:java.lang.String getKernelSource() -> getKernelSource
    31:42:void scalarize(neureka.Tsr,int,int,neureka.calculus.environment.Type$PrimaryNDXConsumer) -> scalarize
neureka.calculus.environment.implementations.function.Absolute -> neureka.calculus.environment.implementations.function.Absolute:
    neureka.calculus.environment.Type$DefaultOperatorCreator _activationCreator -> a
    10:62:void <init>() -> <init>
    45:53:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> a
    29:31:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> b
    33:36:void lambda$new$3(neureka.calculus.environment.ExecutionCall,int,int) -> a
    12:14:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    14:14:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    13:13:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Cosinus -> neureka.calculus.environment.implementations.function.Cosinus:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    10:71:void <init>() -> <init>
    53:61:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> a
    37:39:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> b
    41:44:void lambda$new$3(neureka.calculus.environment.ExecutionCall,int,int) -> a
    12:14:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    14:14:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    13:13:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Gaussian -> neureka.calculus.environment.implementations.function.Gaussian:
    13:80:void <init>() -> <init>
    55:63:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> a
    39:41:void lambda$new$4(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    43:46:void lambda$new$3(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> a
    19:23:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    24:25:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    21:21:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Identity -> neureka.calculus.environment.implementations.function.Identity:
    14:116:void <init>() -> <init>
    96:105:void lambda$new$11(neureka.calculus.environment.ExecutionCall) -> a
    77:89:void lambda$new$10(neureka.calculus.environment.Type$ScalarOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    82:85:void lambda$new$9(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$ScalarOperatorCreator,double,int,int) -> a
    68:69:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$8(neureka.Tsr[],double,int) -> a
    69:69:double lambda$new$7(double,int[]) -> a
    68:68:double lambda$new$6(double,int[]) -> b
    46:56:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> b
    30:32:void lambda$new$4(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    34:37:void lambda$new$3(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> a
    18:20:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    20:20:double lambda$new$1(int[],int[],int[]) -> a
    19:19:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.function.Ligmoid -> neureka.calculus.environment.implementations.function.Ligmoid:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    11:84:void <init>() -> <init>
    48:56:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> a
    32:34:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> b
    36:39:void lambda$new$3(neureka.calculus.environment.ExecutionCall,int,int) -> a
    13:15:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    15:15:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    14:14:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Quadratic -> neureka.calculus.environment.implementations.function.Quadratic:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    11:78:void <init>() -> <init>
    59:67:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> a
    43:45:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> b
    47:50:void lambda$new$3(neureka.calculus.environment.ExecutionCall,int,int) -> a
    13:19:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    19:19:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:17:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.ReLU -> neureka.calculus.environment.implementations.function.ReLU:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    11:82:void <init>() -> <init>
    63:71:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> a
    47:49:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> b
    51:54:void lambda$new$3(neureka.calculus.environment.ExecutionCall,int,int) -> a
    13:20:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    21:22:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:17:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sigmoid -> neureka.calculus.environment.implementations.function.Sigmoid:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    11:85:void <init>() -> <init>
    64:72:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> a
    48:50:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> b
    52:55:void lambda$new$3(neureka.calculus.environment.ExecutionCall,int,int) -> a
    13:17:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    18:19:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    15:15:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sinus -> neureka.calculus.environment.implementations.function.Sinus:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    11:67:void <init>() -> <init>
    46:54:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> a
    30:32:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> b
    34:37:void lambda$new$3(neureka.calculus.environment.ExecutionCall,int,int) -> a
    13:15:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    15:15:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    14:14:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Tanh -> neureka.calculus.environment.implementations.function.Tanh:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    11:85:void <init>() -> <init>
    64:72:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> a
    48:50:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> b
    52:55:void lambda$new$3(neureka.calculus.environment.ExecutionCall,int,int) -> a
    14:21:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    22:23:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    17:18:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.indexer.Product -> neureka.calculus.environment.implementations.indexer.Product:
    13:143:void <init>() -> <init>
    122:130:void lambda$new$11(neureka.calculus.environment.ExecutionCall) -> a
    106:108:void lambda$new$10(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    110:113:void lambda$new$9(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> a
    94:96:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$8(neureka.Tsr[],int) -> a
    96:96:double lambda$new$7(double[],neureka.Tsr[],int[],int[],int[]) -> a
    95:95:double lambda$new$6(double[],neureka.Tsr[],int[],int[],int[]) -> b
    70:79:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> b
    51:53:void lambda$new$4(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> b
    55:61:void lambda$new$3(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> b
    31:36:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> b
    37:38:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    34:34:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.indexer.Summation -> neureka.calculus.environment.implementations.indexer.Summation:
    11:132:void <init>() -> <init>
    114:122:void lambda$new$11(neureka.calculus.environment.ExecutionCall) -> a
    98:100:void lambda$new$10(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    102:105:void lambda$new$9(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> a
    86:88:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$8(neureka.Tsr[],int) -> a
    88:88:double lambda$new$7(double[],neureka.Tsr[],int[],int[],int[]) -> a
    87:87:double lambda$new$6(double[],neureka.Tsr[],int[],int[],int[]) -> b
    61:70:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> b
    42:44:void lambda$new$4(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> b
    46:52:void lambda$new$3(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> b
    27:30:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> b
    30:30:double lambda$new$1(int[],int[],int[]) -> a
    29:29:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.operator.Addition -> neureka.calculus.environment.implementations.operator.Addition:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    neureka.calculus.environment.executors.Broadcast _broadcast -> b
    22:220:void <init>() -> <init>
    174:183:void lambda$new$18(neureka.calculus.environment.ExecutionCall) -> a
    156:167:void lambda$new$17(neureka.calculus.environment.Type$ScalarOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    161:164:void lambda$new$16(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$ScalarOperatorCreator,double,int,int) -> a
    142:146:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$15(neureka.Tsr[],double,int) -> a
    146:146:double lambda$new$14(int[]) -> a
    145:145:double lambda$new$13(int[]) -> b
    143:143:double lambda$new$12(double[],neureka.Tsr[],double,int[]) -> a
    116:125:void lambda$new$11(neureka.calculus.environment.ExecutionCall) -> b
    100:102:void lambda$new$10(neureka.calculus.environment.ExecutionCall) -> c
    104:107:void lambda$new$9(neureka.calculus.environment.ExecutionCall,int,int) -> a
    72:81:void lambda$new$8(neureka.calculus.environment.ExecutionCall) -> d
    53:55:void lambda$new$7(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    57:63:void lambda$new$6(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> a
    39:42:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    42:42:double lambda$new$4(int[]) -> c
    41:41:double lambda$new$3(double[],neureka.Tsr[],double[],int[]) -> a
    12:15:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> b
    15:15:double lambda$static$1(int[],int[],int[]) -> a
    14:14:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    10:18:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Division -> neureka.calculus.environment.implementations.operator.Division:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    31:234:void <init>() -> <init>
    184:193:void lambda$new$15(neureka.calculus.environment.ExecutionCall) -> a
    166:177:void lambda$new$14(neureka.calculus.environment.Type$ScalarOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    171:174:void lambda$new$13(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$ScalarOperatorCreator,double,int,int) -> a
    149:154:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$12(neureka.Tsr[],double,int) -> a
    154:154:double lambda$new$11(double,double[],neureka.Tsr[],int[]) -> a
    153:153:double lambda$new$10(double,int[]) -> a
    151:151:double lambda$new$9(double[],neureka.Tsr[],double,int[]) -> a
    121:130:void lambda$new$8(neureka.calculus.environment.ExecutionCall) -> b
    105:107:void lambda$new$7(neureka.calculus.environment.ExecutionCall) -> c
    109:112:void lambda$new$6(neureka.calculus.environment.ExecutionCall,int,int) -> a
    70:79:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> d
    51:53:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> e
    55:61:void lambda$new$3(neureka.calculus.environment.ExecutionCall,int,int) -> b
    13:18:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> a
    19:22:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    16:16:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    11:11:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Modulo -> neureka.calculus.environment.implementations.operator.Modulo:
    13:232:void <init>() -> <init>
    198:207:void lambda$new$18(neureka.calculus.environment.ExecutionCall) -> a
    180:191:void lambda$new$17(neureka.calculus.environment.Type$ScalarOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    185:188:void lambda$new$16(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$ScalarOperatorCreator,double,int,int) -> a
    163:168:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$15(neureka.Tsr[],double,int) -> a
    168:168:double lambda$new$14(double,double[],neureka.Tsr[],int[]) -> a
    167:167:double lambda$new$13(double,int[]) -> a
    165:165:double lambda$new$12(double[],neureka.Tsr[],double,int[]) -> a
    135:144:void lambda$new$11(neureka.calculus.environment.ExecutionCall) -> b
    119:121:void lambda$new$10(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    123:126:void lambda$new$9(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> a
    93:98:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$8(neureka.Tsr[],int) -> a
    99:105:double lambda$new$7(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    96:96:double lambda$new$6(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    63:72:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> c
    44:46:void lambda$new$4(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> b
    48:54:void lambda$new$3(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> b
    22:26:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> b
    27:30:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[]) -> a
    24:24:double lambda$new$0(double[],neureka.Tsr[],double[],int[]) -> a
neureka.calculus.environment.implementations.operator.Multiplication -> neureka.calculus.environment.implementations.operator.Multiplication:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    27:381:void <init>() -> <init>
    354:363:void lambda$new$32(neureka.calculus.environment.ExecutionCall) -> a
    335:337:void lambda$new$31(neureka.calculus.environment.ExecutionCall) -> b
    339:343:void lambda$new$30(neureka.calculus.environment.ExecutionCall,int,int) -> a
    312:317:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$29(neureka.Tsr[],int) -> a
    318:319:double lambda$new$28(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    315:315:double lambda$new$27(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    285:294:void lambda$new$26(neureka.calculus.environment.ExecutionCall) -> c
    269:271:void lambda$new$25(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    273:276:void lambda$new$24(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> a
    240:249:void lambda$new$23(neureka.calculus.environment.ExecutionCall) -> d
    224:226:void lambda$new$22(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> b
    228:231:void lambda$new$21(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> b
    209:211:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$20(neureka.Tsr[],int) -> b
    211:211:double lambda$new$19(double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    182:191:void lambda$new$18(neureka.calculus.environment.ExecutionCall) -> e
    164:175:void lambda$new$17(neureka.calculus.environment.Type$ScalarOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    169:172:void lambda$new$16(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$ScalarOperatorCreator,double,int,int) -> a
    148:152:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$15(neureka.Tsr[],double,int) -> a
    152:152:double lambda$new$14(double[],neureka.Tsr[],int[]) -> a
    151:151:double lambda$new$13(double,int[]) -> a
    149:149:double lambda$new$12(double[],neureka.Tsr[],double,int[]) -> a
    121:130:void lambda$new$11(neureka.calculus.environment.ExecutionCall) -> f
    105:107:void lambda$new$10(neureka.calculus.environment.ExecutionCall) -> g
    109:112:void lambda$new$9(neureka.calculus.environment.ExecutionCall,int,int) -> b
    75:84:void lambda$new$8(neureka.calculus.environment.ExecutionCall) -> h
    56:58:void lambda$new$7(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> c
    60:66:void lambda$new$6(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> c
    37:42:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> c
    43:44:double lambda$new$4(int,double[],neureka.Tsr[],double[],int[]) -> a
    40:40:double lambda$new$3(double[],neureka.Tsr[],double[],int[]) -> a
    13:18:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> d
    19:20:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    16:16:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> c
    11:11:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Power -> neureka.calculus.environment.implementations.operator.Power:
    neureka.calculus.environment.Type$DefaultOperatorCreator _creator -> a
    37:254:void <init>() -> <init>
    209:218:void lambda$new$18(neureka.calculus.environment.ExecutionCall) -> a
    191:202:void lambda$new$17(neureka.calculus.environment.Type$ScalarOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    196:199:void lambda$new$16(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$ScalarOperatorCreator,double,int,int) -> a
    170:177:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$15(neureka.Tsr[],double,int) -> a
    177:177:double lambda$new$14(double[],neureka.Tsr[],double,int[]) -> a
    175:175:double lambda$new$13(double,double[],neureka.Tsr[],int[]) -> a
    172:172:double lambda$new$12(double[],neureka.Tsr[],double,int[]) -> b
    142:151:void lambda$new$11(neureka.calculus.environment.ExecutionCall) -> b
    126:128:void lambda$new$10(neureka.calculus.environment.ExecutionCall) -> c
    130:133:void lambda$new$9(neureka.calculus.environment.ExecutionCall,int,int) -> a
    92:101:void lambda$new$8(neureka.calculus.environment.ExecutionCall) -> d
    73:75:void lambda$new$7(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    77:83:void lambda$new$6(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> a
    44:49:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    50:60:double lambda$new$4(int,double[],neureka.Tsr[],double[],int[]) -> a
    47:47:double lambda$new$3(double[],neureka.Tsr[],double[],int[]) -> a
    13:18:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> b
    19:29:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    16:16:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    11:11:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Subtraction -> neureka.calculus.environment.implementations.operator.Subtraction:
    13:173:void <init>() -> <init>
    118:127:void lambda$new$12(neureka.calculus.environment.ExecutionCall) -> a
    99:111:void lambda$new$11(neureka.calculus.environment.Type$ScalarOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    105:108:void lambda$new$10(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$ScalarOperatorCreator,double,int,int) -> a
    84:87:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$9(neureka.Tsr[],double,int) -> a
    87:87:double lambda$new$8(int[]) -> a
    87:87:double lambda$new$7(int[]) -> b
    85:85:double lambda$new$6(double[],neureka.Tsr[],double,int[]) -> a
    56:65:void lambda$new$5(neureka.calculus.environment.ExecutionCall) -> b
    37:39:void lambda$new$4(neureka.calculus.environment.Type$DefaultOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    41:47:void lambda$new$3(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$DefaultOperatorCreator,int,int) -> a
    22:26:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    26:26:double lambda$new$1(int,int[]) -> a
    25:25:double lambda$new$0(double[],neureka.Tsr[],double[],int[]) -> a
neureka.calculus.environment.implementations.other.CopyLeft -> neureka.calculus.environment.implementations.other.CopyLeft:
    16:68:void <init>() -> <init>
    52:63:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> a
    34:45:void lambda$new$3(neureka.calculus.environment.ExecutionCall) -> b
    22:24:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    24:24:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    23:23:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.other.CopyRight -> neureka.calculus.environment.implementations.other.CopyRight:
    16:66:void <init>() -> <init>
    50:61:void lambda$new$4(neureka.calculus.environment.ExecutionCall) -> a
    32:43:void lambda$new$3(neureka.calculus.environment.ExecutionCall) -> b
    20:22:neureka.calculus.environment.Type$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    22:22:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    21:21:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.other.Randomization -> neureka.calculus.environment.implementations.other.Randomization:
    15:58:void <init>() -> <init>
    39:41:void lambda$new$3(neureka.calculus.environment.Type$ScalarOperatorCreator,neureka.calculus.environment.ExecutionCall) -> a
    43:49:void lambda$new$2(neureka.calculus.environment.ExecutionCall,neureka.calculus.environment.Type$ScalarOperatorCreator,int,int) -> a
    23:23:neureka.calculus.environment.Type$PrimaryNDXConsumer lambda$new$1(neureka.Tsr[],double,int) -> a
    24:28:double lambda$new$0(double,int[]) -> a
neureka.calculus.environment.implementations.other.Reshape -> neureka.calculus.environment.implementations.other.Reshape:
    13:17:void <init>() -> <init>
    21:24:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    27:27:neureka.Tsr lambda$getADAgentOf$2(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    26:26:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    25:25:neureka.Tsr lambda$getADAgentOf$0() -> a
neureka.calculus.factory.AbstractFunction -> neureka.calculus.factory.AbstractFunction:
    neureka.calculus.environment.OperationType _type -> a
    boolean _isFlat -> b
    boolean _doAD -> c
    java.util.ArrayList _src -> d
    34:39:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    45:45:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    50:50:boolean isFlat() -> isFlat
    55:55:boolean doesAD() -> doesAD
    60:60:int id() -> id
    65:65:neureka.calculus.environment.OperationType type() -> type
    73:118:java.lang.String toString() -> toString
    123:124:boolean dependsOn(int) -> dependsOn
    131:131:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    143:153:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int) -> _tensor_activation
    1319:1322:neureka.acceleration.Device _device(neureka.Tsr[]):319:322 -> _tensor_activation
    1319:1322:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):143 -> _tensor_activation
    1326:1341:boolean _shareGuestDevice(neureka.Tsr[]):326:341 -> _tensor_activation
    1326:1341:neureka.acceleration.Device _device(neureka.Tsr[]):320 -> _tensor_activation
    1326:1341:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):143 -> _tensor_activation
    159:199:neureka.Tsr _recursie_breakdown_execution(neureka.Tsr[],int,int,neureka.acceleration.Device) -> a
    205:277:neureka.Tsr _execution(neureka.Tsr[],int,int,neureka.acceleration.Device) -> b
    281:291:neureka.Tsr _apply(neureka.acceleration.Device,int,java.util.function.Supplier) -> a
    295:315:neureka.Tsr[] _src_acti(neureka.Tsr[],int,int,int) -> a
    347:369:double _scalar_activation(double,boolean) -> _scalar_activation
    376:396:double _scalar_activation(double[],int,int) -> _scalar_activation
    199:199:neureka.Tsr lambda$_recursie_breakdown_execution$3(neureka.Tsr[],int,int,neureka.acceleration.Device) -> c
    151:151:neureka.Tsr lambda$_tensor_activation$2(neureka.Tsr[],int,int,neureka.acceleration.Device) -> d
    146:146:neureka.Tsr lambda$_tensor_activation$1(neureka.Tsr[],int,int,neureka.acceleration.Device) -> e
    73:73:java.lang.String lambda$toString$0(neureka.calculus.Function) -> a
neureka.calculus.factory.AbstractFunction$Exec -> neureka.calculus.factory.AbstractFunction$Exec:
    400:400:void <init>() -> <init>
    405:412:double reLu(double,boolean) -> reLu
    418:421:double sigmoid(double,boolean) -> sigmoid
    427:430:double tanh(double,boolean) -> tanh
    436:437:double quadratic(double,boolean) -> quadratic
    442:443:double ligmoid(double,boolean) -> ligmoid
    448:449:double linear(double,boolean) -> linear
    454:455:double gaussian(double,boolean) -> gaussian
    460:461:double absolute(double,boolean) -> absolute
    466:467:double sinus(double,boolean) -> sinus
    472:473:double cosinus(double,boolean) -> cosinus
    477:489:double summation(double[],int,int,java.util.ArrayList) -> a
    494:516:double summation(double[],int,java.util.ArrayList) -> a
    523:542:double PI(double[],int,int,java.util.ArrayList) -> b
    548:567:double PI(double[],int,java.util.ArrayList) -> b
    576:597:double power(double[],int,int,java.util.ArrayList) -> c
    603:628:double power(double[],int,java.util.ArrayList) -> c
    634:651:double division(double[],int,int,java.util.ArrayList) -> d
    657:678:double division(double[],int,java.util.ArrayList) -> d
    684:702:double multiplication(double[],int,int,java.util.ArrayList) -> e
    708:726:double multiplication(double[],int,java.util.ArrayList) -> e
    741:749:double modulo(double[],int,int,java.util.ArrayList) -> f
    755:763:double modulo(double[],int,java.util.ArrayList) -> f
    769:785:double subtraction(double[],int,int,java.util.ArrayList) -> g
    791:807:double subtraction(double[],int,java.util.ArrayList) -> g
    813:825:double addition(double[],int,int,java.util.ArrayList) -> h
    831:843:double addition(double[],int,java.util.ArrayList) -> h
neureka.calculus.factory.BaseFunction -> neureka.calculus.factory.BaseFunction:
    20:20:void <init>() -> <init>
    24:24:double call(double) -> call
    29:29:neureka.Tsr call(neureka.Tsr) -> call
    36:36:neureka.Tsr call(java.util.List) -> call
    41:41:neureka.Tsr invoke(java.util.List) -> invoke
    48:48:double invoke(double) -> invoke
    53:53:double invoke(double[],int) -> invoke
    58:58:double invoke(double[]) -> invoke
    65:65:neureka.Tsr invoke(neureka.Tsr) -> invoke
    70:70:neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    75:75:neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    82:82:neureka.Tsr derive(java.util.List,int,int) -> derive
    87:87:neureka.Tsr derive(java.util.List,int) -> derive
neureka.calculus.factory.assembly.FunctionBuilder -> neureka.calculus.factory.assembly.FunctionBuilder:
    10:10:void <init>() -> <init>
    19:35:neureka.calculus.Function build(neureka.calculus.environment.OperationType,int,boolean) -> build
    46:59:neureka.calculus.Function build(java.lang.String,boolean) -> build
    68:266:neureka.calculus.Function _build(java.lang.String,boolean) -> a
    276:283:java.util.List _rebindPairwise(java.util.List,int) -> a
neureka.calculus.factory.assembly.FunctionConstructor -> neureka.calculus.factory.assembly.FunctionConstructor:
    14:14:void <init>() -> <init>
    18:71:neureka.calculus.Function construct(int,java.util.ArrayList,boolean) -> construct
neureka.calculus.factory.assembly.FunctionConstructor$1 -> neureka.calculus.factory.assembly.FunctionConstructor$1:
    java.util.ArrayList val$sources -> a
    33:33:void <init>(int,boolean,java.util.ArrayList,boolean,java.util.ArrayList) -> <init>
    36:36:neureka.Tsr call(neureka.Tsr[],int) -> call
    40:40:neureka.Tsr call(neureka.Tsr[]) -> call
    44:44:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    48:48:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    53:53:double call(double[],int) -> call
    57:57:double call(double[]) -> call
    61:62:double derive(double[],int,int) -> derive
    66:67:double derive(double[],int) -> derive
    40:40:neureka.Tsr lambda$call$1(java.util.ArrayList,neureka.Tsr[]) -> a
    36:36:neureka.Tsr lambda$call$0(java.util.ArrayList,neureka.Tsr[],int) -> a
neureka.calculus.factory.assembly.FunctionConstructor$2 -> neureka.calculus.factory.assembly.FunctionConstructor$2:
    71:71:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    74:74:neureka.Tsr call(neureka.Tsr[],int) -> call
    78:78:neureka.Tsr call(neureka.Tsr[]) -> call
    82:82:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    86:86:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    91:91:double call(double[],int) -> call
    95:95:double call(double[]) -> call
    99:99:double derive(double[],int,int) -> derive
    103:103:double derive(double[],int) -> derive
    86:86:neureka.Tsr lambda$derive$3(neureka.Tsr[],int) -> a
    82:82:neureka.Tsr lambda$derive$2(neureka.Tsr[],int,int) -> a
    78:78:neureka.Tsr lambda$call$1(neureka.Tsr[]) -> a
    74:74:neureka.Tsr lambda$call$0(neureka.Tsr[],int) -> b
neureka.calculus.factory.assembly.FunctionParser -> neureka.calculus.factory.assembly.FunctionParser:
    boolean $assertionsDisabled -> a
    12:12:void <init>() -> <init>
    15:19:int numberOfOperationsWithin(java.util.List) -> numberOfOperationsWithin
    23:31:java.lang.String parsedOperation(java.lang.String,int) -> parsedOperation
    35:57:java.lang.String findComponentIn(java.lang.String,int) -> findComponentIn
    61:84:java.util.List findParametersIn(java.lang.String,int) -> findParametersIn
    88:89:boolean isBasicOperation(java.lang.String) -> isBasicOperation
    93:100:java.lang.String groupBy(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> groupBy
    104:104:boolean isForbiddenChar(char) -> a
    109:144:java.lang.String cleanedHeadAndTail(java.lang.String) -> cleanedHeadAndTail
    148:197:java.lang.String unpackAndCorrect(java.lang.String) -> unpackAndCorrect
    201:211:java.lang.String assumptionBasedOn(java.lang.String) -> assumptionBasedOn
    215:247:double similarity(java.lang.String,java.lang.String) -> similarity
    12:12:void <clinit>() -> <clinit>
neureka.calculus.factory.components.FunctionConstant -> neureka.calculus.factory.components.FunctionConstant:
    double _value -> a
    9:9:void <init>() -> <init>
    13:13:double value() -> value
    20:20:boolean isFlat() -> isFlat
    25:25:boolean doesAD() -> doesAD
    30:30:int id() -> id
    35:35:neureka.calculus.environment.OperationType type() -> type
    40:40:boolean dependsOn(int) -> dependsOn
    46:59:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    66:66:double call(double[],int) -> call
    71:71:double call(double[]) -> call
    76:76:double derive(double[],int) -> derive
    81:81:double derive(double[],int,int) -> derive
    88:88:neureka.Tsr call(neureka.Tsr[],int) -> call
    93:93:neureka.Tsr call(neureka.Tsr[]) -> call
    98:98:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    103:103:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    110:110:java.lang.String toString() -> toString
    115:115:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionInput -> neureka.calculus.factory.components.FunctionInput:
    int _index -> a
    12:12:void <init>() -> <init>
    19:19:boolean providesGradient() -> providesGradient
    26:26:boolean isFlat() -> isFlat
    31:31:boolean doesAD() -> doesAD
    36:36:int id() -> id
    41:41:neureka.calculus.environment.OperationType type() -> type
    46:46:boolean dependsOn(int) -> dependsOn
    54:74:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    79:89:neureka.Tsr _extract(neureka.Tsr) -> a
    96:96:double call(double[],int) -> call
    101:101:double call(double[]) -> call
    106:106:double derive(double[],int) -> derive
    111:111:double derive(double[],int,int) -> derive
    118:118:neureka.Tsr call(neureka.Tsr[],int) -> call
    123:123:neureka.Tsr call(neureka.Tsr[]) -> call
    128:128:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    133:135:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    142:142:java.lang.String toString() -> toString
    146:146:int index() -> index
    151:151:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionVariable -> neureka.calculus.factory.components.FunctionVariable:
    boolean _providesGradient -> a
    10:12:void <init>() -> <init>
    15:15:boolean providesGradient() -> providesGradient
    20:20:boolean isFlat() -> isFlat
    25:25:boolean doesAD() -> doesAD
    30:30:int id() -> id
    35:35:neureka.calculus.environment.OperationType type() -> type
    40:40:boolean dependsOn(int) -> dependsOn
    46:47:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    54:54:double call(double[],int) -> call
    59:61:double call(double[]) -> call
    66:66:double derive(double[],int) -> derive
    71:72:double derive(double[],int,int) -> derive
    78:78:neureka.Tsr call(neureka.Tsr[],int) -> call
    83:85:neureka.Tsr call(neureka.Tsr[]) -> call
    90:90:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    95:95:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    102:102:java.lang.String toString() -> toString
    107:107:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.GradientProvider -> neureka.calculus.factory.components.GradientProvider:
    boolean providesGradient() -> providesGradient
neureka.framing.IndexAlias -> neureka.framing.IndexAlias:
    java.util.Map _mapping -> a
    13:23:void <init>(java.util.List) -> <init>
    25:28:void <init>(int) -> <init>
    30:43:void <init>(java.util.Map,neureka.Tsr) -> <init>
    46:46:int[] get(java.util.List) -> get
    50:61:int[] get(java.lang.Object[]) -> get
    66:68:int get(java.lang.Object,java.lang.Object) -> get
    73:76:void replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    79:85:void _initializeIdxmap(java.lang.Object,int,java.lang.Object,int) -> a
    89:92:void set(java.lang.Object,java.lang.Object,int) -> set
    96:100:java.util.List keysOf(java.lang.Object) -> keysOf
    104:108:java.util.List keysOf(java.lang.Object,int) -> keysOf
    112:120:java.lang.String _fixed(java.lang.String,int) -> a
    126:188:java.lang.String toString() -> toString
    195:195:void update(neureka.Tsr,neureka.Tsr) -> update
    8:8:void update(java.lang.Object,java.lang.Object) -> update
    159:174:void lambda$toString$6(java.lang.Object[],int[],java.lang.StringBuilder,int[],java.lang.Object,java.lang.Object) -> a
    162:163:void lambda$toString$5(int[],java.lang.Object[],java.lang.Object,java.lang.Integer) -> a
    141:147:void lambda$toString$4(int[],int[],java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    134:134:java.lang.Boolean lambda$toString$3(int,int,java.lang.Integer) -> a
    106:106:void lambda$keysOf$2(int,java.util.List,java.lang.Object,java.lang.Integer) -> a
    98:98:void lambda$keysOf$1(java.util.List,java.lang.Object,java.lang.Integer) -> a
    34:42:void lambda$new$0(neureka.Tsr,int[],java.lang.Object,java.util.List) -> a
neureka.framing.Relation -> neureka.framing.Relation:
    neureka.Tsr _parent -> a
    java.lang.ref.WeakReference[] _children -> b
    9:9:void <init>() -> <init>
    17:34:void update(neureka.Tsr,neureka.Tsr) -> update
    38:39:neureka.framing.Relation addParent(neureka.Tsr) -> addParent
    44:52:neureka.framing.Relation addChild(neureka.Tsr) -> addChild
    57:67:neureka.framing.Relation foreachChild(java.util.function.Consumer) -> foreachChild
    71:75:neureka.Tsr findRootTensor() -> findRootTensor
    80:80:boolean hasParent() -> hasParent
    84:84:boolean hasChildren() -> hasChildren
    88:88:int childCount() -> childCount
    9:9:void update(java.lang.Object,java.lang.Object) -> update
neureka.ndim.AbstractComponentOwner -> neureka.ndim.AbstractComponentOwner:
    java.util.List _components -> _components
    19:24:void <init>() -> <init>
    31:36:java.lang.Object find(java.lang.Class) -> find
    45:53:java.lang.Object remove(java.lang.Class) -> remove
    62:62:boolean has(java.lang.Class) -> has
    72:83:java.lang.Object add(neureka.Component) -> add
    neureka.Component _addOrReject(neureka.Component) -> _addOrReject
    neureka.Component _removeOrReject(neureka.Component) -> _removeOrReject
    106:110:boolean forComponent(java.lang.Class,java.util.function.Consumer) -> forComponent
neureka.ndim.AbstractNDArray -> neureka.ndim.AbstractNDArray:
    neureka.ndim.config.NDConfiguration _conf -> _conf
    java.lang.Object _value -> _value
    25:25:void <init>() -> <init>
    34:34:boolean is64() -> is64
    38:38:boolean is32() -> is32
    44:44:int i_of_i(int) -> i_of_i
    48:48:int[] idx_of_i(int) -> idx_of_i
    52:52:int i_of_idx(int[]) -> i_of_idx
    58:58:neureka.ndim.config.NDConfiguration getNDConf() -> getNDConf
    64:64:int rank() -> rank
    68:68:java.util.List shape() -> shape
    72:72:int shape(int) -> shape
    76:76:java.util.List idxmap() -> idxmap
    80:80:java.util.List translation() -> translation
    84:84:java.util.List spread() -> spread
    88:88:java.util.List offset() -> offset
    92:92:int size() -> size
    96:98:java.util.List _asList(int[]) -> _asList
neureka.ndim.AbstractNDArray$Utility -> neureka.ndim.AbstractNDArray$Utility:
    108:108:void <init>() -> <init>
neureka.ndim.AbstractNDArray$Utility$Indexing -> neureka.ndim.AbstractNDArray$Utility$Indexing:
    142:142:void <init>() -> <init>
    147:150:void increment(int[],int[]) -> increment
    1154:1179:int _incrementAt(int,int[],int[]):154:179 -> increment
    1154:1179:void increment(int[],int[]):149 -> increment
    185:198:int[] newTlnOf(int[]) -> newTlnOf
    203:208:int[] rearrange(int[],int[]) -> rearrange
    213:218:int[] shpCheck(int[],neureka.Tsr) -> shpCheck
    223:229:int[] rearrange(int[],int[],int[]) -> rearrange
    234:255:int[][] makeFit(int[],int[]) -> makeFit
    260:262:int[] shpOfCon(int[],int[]) -> shpOfCon
    267:274:int[] shpOfBrc(int[],int[]) -> shpOfBrc
    279:281:int szeOfShp(int[]) -> szeOfShp
neureka.ndim.AbstractNDArray$Utility$Stringify -> neureka.ndim.AbstractNDArray$Utility$Stringify:
    110:110:void <init>() -> <init>
    114:128:java.lang.String formatFP(double) -> formatFP
    133:135:java.lang.String strConf(int[]) -> strConf
neureka.ndim.config.AbstractNDC -> neureka.ndim.config.AbstractNDC:
    java.util.Map _CACHED_NDCS -> a
    java.util.Map _CACHED_INT_ARRAYS -> b
    13:13:void <init>() -> <init>
    36:59:int[] _cacheArray(int[]) -> _cacheArray
    68:72:long keyCode() -> keyCode
    78:82:boolean equals(neureka.ndim.config.NDConfiguration) -> equals
    94:118:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    1142:1148:boolean _isSimpleConfiguration(int[],int[],int[],int[],int[]):142:148 -> construct
    1142:1148:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]):97 -> construct
    123:131:neureka.ndim.config.NDConfiguration _cached(neureka.ndim.config.NDConfiguration) -> _cached
    155:160:java.lang.String toString() -> toString
    21:32:void <clinit>() -> <clinit>
neureka.ndim.config.NDConfiguration -> neureka.ndim.config.NDConfiguration:
    int rank() -> rank
    int[] shape() -> shape
    int shape(int) -> shape
    int[] idxmap() -> idxmap
    int idxmap(int) -> idxmap
    int[] translation() -> translation
    int translation(int) -> translation
    int[] spread() -> spread
    int spread(int) -> spread
    int[] offset() -> offset
    int offset(int) -> offset
    int i_of_i(int) -> i_of_i
    int[] idx_of_i(int) -> idx_of_i
    int i_of_idx(int[]) -> i_of_idx
    long keyCode() -> keyCode
    boolean equals(neureka.ndim.config.NDConfiguration) -> equals
neureka.ndim.config.complex.D1Configuration -> neureka.ndim.config.complex.D1Configuration:
    int _shape -> a
    int _translation -> b
    int _idxmap -> c
    int _spread -> d
    int _offset -> e
    39:39:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    48:54:void <init>(int,int,int,int,int) -> <init>
    58:58:int rank() -> rank
    63:63:int[] shape() -> shape
    68:68:int shape(int) -> shape
    73:73:int[] idxmap() -> idxmap
    78:78:int idxmap(int) -> idxmap
    83:83:int[] translation() -> translation
    88:88:int translation(int) -> translation
    93:93:int[] spread() -> spread
    98:98:int spread(int) -> spread
    103:103:int[] offset() -> offset
    108:108:int offset(int) -> offset
    114:114:int i_of_i(int) -> i_of_i
    119:119:int[] idx_of_i(int) -> idx_of_i
    123:123:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.complex.D2Configuration -> neureka.ndim.config.complex.D2Configuration:
    int _shape1 -> a
    int _shape2 -> b
    int _translation1 -> c
    int _translation2 -> d
    int _idxmap1 -> e
    int _idxmap2 -> f
    int _spread1 -> g
    int _spread2 -> h
    int _offset1 -> i
    int _offset2 -> j
    15:26:void <init>(int[],int[],int[],int[],int[]) -> <init>
    35:35:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    69:69:int rank() -> rank
    74:74:int[] shape() -> shape
    79:79:int shape(int) -> shape
    84:84:int[] idxmap() -> idxmap
    89:89:int idxmap(int) -> idxmap
    94:94:int[] translation() -> translation
    99:99:int translation(int) -> translation
    104:104:int[] spread() -> spread
    109:109:int spread(int) -> spread
    114:114:int[] offset() -> offset
    119:119:int offset(int) -> offset
    127:131:int i_of_i(int) -> i_of_i
    138:148:int[] idx_of_i(int) -> idx_of_i
    153:156:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.complex.D3Configuration -> neureka.ndim.config.complex.D3Configuration:
    int _shape1 -> a
    int _shape2 -> b
    int _shape3 -> c
    int _translation1 -> d
    int _translation2 -> e
    int _translation3 -> f
    int _idxmap1 -> g
    int _idxmap2 -> h
    int _idxmap3 -> i
    int _spread1 -> j
    int _spread2 -> k
    int _spread3 -> l
    int _offset1 -> m
    int _offset2 -> n
    int _offset3 -> o
    15:31:void <init>(int[],int[],int[],int[],int[]) -> <init>
    40:40:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    79:79:int rank() -> rank
    84:84:int[] shape() -> shape
    89:89:int shape(int) -> shape
    94:94:int[] idxmap() -> idxmap
    99:99:int idxmap(int) -> idxmap
    104:104:int[] translation() -> translation
    109:109:int translation(int) -> translation
    114:114:int[] spread() -> spread
    119:119:int spread(int) -> spread
    124:124:int[] offset() -> offset
    129:129:int offset(int) -> offset
    138:151:int i_of_i(int) -> i_of_i
    159:172:int[] idx_of_i(int) -> idx_of_i
    177:177:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.complex.DefaultNDConfiguration -> neureka.ndim.config.complex.DefaultNDConfiguration:
    int[] _shape -> a
    int[] _translation -> b
    int[] _idxmap -> c
    int[] _spread -> d
    int[] _offset -> e
    16:22:void <init>(int[],int[],int[],int[],int[]) -> <init>
    31:31:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    60:60:int rank() -> rank
    65:65:int[] shape() -> shape
    70:70:int shape(int) -> shape
    75:75:int[] idxmap() -> idxmap
    80:80:int idxmap(int) -> idxmap
    85:85:int[] translation() -> translation
    90:90:int translation(int) -> translation
    95:95:int[] spread() -> spread
    100:100:int spread(int) -> spread
    105:105:int[] offset() -> offset
    110:110:int offset(int) -> offset
    118:118:int i_of_i(int) -> i_of_i
    123:135:int[] idx_of_i(int) -> idx_of_i
    140:142:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.complex.ScalarConfiguration -> neureka.ndim.config.complex.ScalarConfiguration:
    int _shape -> a
    int _offset -> b
    27:27:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    33:36:void <init>(int,int) -> <init>
    40:40:int rank() -> rank
    45:45:int[] shape() -> shape
    50:50:int shape(int) -> shape
    55:55:int[] idxmap() -> idxmap
    60:60:int idxmap(int) -> idxmap
    65:65:int[] translation() -> translation
    70:70:int translation(int) -> translation
    75:75:int[] spread() -> spread
    80:80:int spread(int) -> spread
    85:85:int[] offset() -> offset
    90:90:int offset(int) -> offset
    96:96:int i_of_i(int) -> i_of_i
    101:101:int[] idx_of_i(int) -> idx_of_i
    106:106:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleD1Configuration -> neureka.ndim.config.simple.SimpleD1Configuration:
    int _shape -> a
    int _translation_and_idxmap -> b
    23:23:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    29:32:void <init>(int,int) -> <init>
    36:36:int rank() -> rank
    41:41:int[] shape() -> shape
    46:46:int shape(int) -> shape
    51:51:int[] idxmap() -> idxmap
    56:56:int idxmap(int) -> idxmap
    61:61:int[] translation() -> translation
    66:66:int translation(int) -> translation
    71:71:int[] spread() -> spread
    76:76:int spread(int) -> spread
    81:81:int[] offset() -> offset
    86:86:int offset(int) -> offset
    92:92:int i_of_i(int) -> i_of_i
    97:97:int[] idx_of_i(int) -> idx_of_i
    101:101:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleD2Configuration -> neureka.ndim.config.simple.SimpleD2Configuration:
    int _shape1 -> a
    int _shape2 -> b
    int _translation1 -> c
    int _translation2 -> d
    13:18:void <init>(int[],int[]) -> <init>
    24:24:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    41:41:int rank() -> rank
    46:46:int[] shape() -> shape
    51:51:int shape(int) -> shape
    56:56:int[] idxmap() -> idxmap
    61:61:int idxmap(int) -> idxmap
    66:66:int[] translation() -> translation
    71:71:int translation(int) -> translation
    76:76:int[] spread() -> spread
    81:81:int spread(int) -> spread
    86:86:int[] offset() -> offset
    91:91:int offset(int) -> offset
    99:103:int i_of_i(int) -> i_of_i
    110:120:int[] idx_of_i(int) -> idx_of_i
    125:128:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleD3Configuration -> neureka.ndim.config.simple.SimpleD3Configuration:
    int _shape1 -> a
    int _shape2 -> b
    int _shape3 -> c
    int _translation1 -> d
    int _translation2 -> e
    int _translation3 -> f
    13:20:void <init>(int[],int[]) -> <init>
    26:26:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    44:44:int rank() -> rank
    49:49:int[] shape() -> shape
    54:54:int shape(int) -> shape
    59:59:int[] idxmap() -> idxmap
    64:64:int idxmap(int) -> idxmap
    69:69:int[] translation() -> translation
    74:74:int translation(int) -> translation
    79:79:int[] spread() -> spread
    84:84:int spread(int) -> spread
    89:89:int[] offset() -> offset
    94:94:int offset(int) -> offset
    103:116:int i_of_i(int) -> i_of_i
    124:137:int[] idx_of_i(int) -> idx_of_i
    142:142:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleDefaultNDConfiguration -> neureka.ndim.config.simple.SimpleDefaultNDConfiguration:
    int[] _shape -> a
    int[] _translation_and_idxmap -> b
    14:17:void <init>(int[],int[]) -> <init>
    23:23:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    38:38:int rank() -> rank
    43:43:int[] shape() -> shape
    48:48:int shape(int) -> shape
    53:53:int[] idxmap() -> idxmap
    58:58:int idxmap(int) -> idxmap
    63:63:int[] translation() -> translation
    68:68:int translation(int) -> translation
    73:75:int[] spread() -> spread
    80:80:int spread(int) -> spread
    85:85:int[] offset() -> offset
    90:90:int offset(int) -> offset
    98:98:int i_of_i(int) -> i_of_i
    103:115:int[] idx_of_i(int) -> idx_of_i
    120:122:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleScalarConfiguration -> neureka.ndim.config.simple.SimpleScalarConfiguration:
    9:9:neureka.ndim.config.NDConfiguration construct() -> construct
    12:12:void <init>() -> <init>
    16:16:int rank() -> rank
    21:21:int[] shape() -> shape
    26:26:int shape(int) -> shape
    31:31:int[] idxmap() -> idxmap
    36:36:int idxmap(int) -> idxmap
    41:41:int[] translation() -> translation
    46:46:int translation(int) -> translation
    51:51:int[] spread() -> spread
    56:56:int spread(int) -> spread
    61:61:int[] offset() -> offset
    66:66:int offset(int) -> offset
    71:71:int i_of_i(int) -> i_of_i
    76:76:int[] idx_of_i(int) -> idx_of_i
    81:81:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.virtual.VirtualNDConfiguration -> neureka.ndim.config.virtual.VirtualNDConfiguration:
    int[] _shape -> a
    12:14:void <init>(int[]) -> <init>
    19:19:neureka.ndim.config.NDConfiguration construct(int[]) -> construct
    24:24:int rank() -> rank
    29:29:int[] shape() -> shape
    34:34:int shape(int) -> shape
    39:39:int[] idxmap() -> idxmap
    44:44:int idxmap(int) -> idxmap
    49:49:int[] translation() -> translation
    54:54:int translation(int) -> translation
    59:59:int[] spread() -> spread
    64:64:int spread(int) -> spread
    69:69:int[] offset() -> offset
    74:74:int offset(int) -> offset
    79:79:int i_of_i(int) -> i_of_i
    84:84:int[] idx_of_i(int) -> idx_of_i
    89:89:int i_of_idx(int[]) -> i_of_idx
neureka.optimization.Optimizer -> neureka.optimization.Optimizer:
    void optimize(neureka.Tsr) -> optimize
neureka.optimization.implementations.ADAM -> neureka.optimization.implementations.ADAM:
    neureka.Tsr m -> a
    neureka.Tsr v -> b
    40:41:void optimize(neureka.Tsr) -> optimize
    1029:1036:void _optimize(neureka.Tsr):29:36 -> optimize
    1029:1036:void optimize(neureka.Tsr):40 -> optimize
    46:46:void update(neureka.Tsr,neureka.Tsr) -> update
    7:7:void update(java.lang.Object,java.lang.Object) -> update
neureka.optimization.implementations.Template -> neureka.optimization.implementations.Template:
    6:6:void <init>() -> <init>
neureka.utility.DataHelper -> neureka.utility.DataHelper:
    5:5:void <init>() -> <init>
    9:9:double[] newSeededDoubleArray(java.lang.String,int) -> newSeededDoubleArray
    13:13:double[] newSeededDoubleArray(long,int) -> newSeededDoubleArray
    17:17:double[] seededDoubleArray(double[],java.lang.String) -> seededDoubleArray
    21:24:double[] seededDoubleArray(double[],long) -> seededDoubleArray
    28:28:float[] newSeededFloatArray(java.lang.String,int) -> newSeededFloatArray
    32:32:float[] newSeededFloatArray(long,int) -> newSeededFloatArray
    36:36:float[] seededFloatArray(float[],java.lang.String) -> seededFloatArray
    40:43:float[] seededFloatArray(float[],long) -> seededFloatArray
    48:51:long _longStringHash(java.lang.String) -> a
    55:58:float[] doubleToFloat(double[]) -> doubleToFloat
    62:65:double[] floatToDouble(float[]) -> floatToDouble
