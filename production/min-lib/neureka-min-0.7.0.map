neureka.Component -> neureka.Component:
    boolean update(neureka.Component$OwnerChangeRequest) -> update
neureka.Component$IsBeing -> neureka.Component$IsBeing:
    neureka.Component$IsBeing REMOVED -> REMOVED
    neureka.Component$IsBeing ADDED -> ADDED
    neureka.Component$IsBeing REPLACED -> REPLACED
    neureka.Component$IsBeing UPDATED -> UPDATED
    neureka.Component$IsBeing[] $VALUES -> a
    18:18:neureka.Component$IsBeing[] values() -> values
    18:18:neureka.Component$IsBeing valueOf(java.lang.String) -> valueOf
    18:18:void <init>(java.lang.String,int) -> <init>
    18:18:void <clinit>() -> <clinit>
neureka.Component$OwnerChangeRequest -> neureka.Component$OwnerChangeRequest:
    java.lang.Object getOldOwner() -> getOldOwner
    java.lang.Object getNewOwner() -> getNewOwner
    boolean executeChange() -> executeChange
    62:65:neureka.Component$IsBeing type() -> type
neureka.Neureka -> neureka.Neureka:
    java.lang.ThreadLocal _INSTANCES -> a
    org.slf4j.Logger log -> b
    java.lang.String _VERSION -> c
    boolean _OPENCL_AVAILABLE -> d
    neureka.Neureka$Settings _settings -> e
    neureka.Neureka$Utility _utility -> f
    neureka.backend.api.OperationContext _context -> g
    boolean $assertionsDisabled -> h
    102:121:neureka.backend.api.OperationContext context() -> context
    124:127:void <init>() -> <init>
    138:146:neureka.Neureka get() -> get
    160:161:void set(neureka.Neureka) -> set
    164:166:neureka.Neureka configure(java.lang.Object) -> configure
    173:173:boolean canAccessOpenCL() -> canAccessOpenCL
    180:180:neureka.Neureka$Settings settings() -> settings
    184:185:neureka.Neureka$Settings settings(java.lang.Object) -> settings
    192:192:neureka.Neureka$Utility utility() -> utility
    199:199:java.lang.String version() -> version
    209:220:void reset() -> reset
    227:227:java.lang.String toString() -> toString
    231:231:neureka.backend.api.OperationContext getContext() -> getContext
    235:236:void setContext(neureka.backend.api.OperationContext) -> setContext
    67:67:boolean access$200(neureka.Neureka) -> a
    1223:1223:boolean _currentThreadIsNotAuthorized():223:223 -> a
    1223:1223:boolean access$200(neureka.Neureka):67 -> a
    67:86:void <clinit>() -> <clinit>
neureka.Neureka$Settings -> neureka.Neureka$Settings:
    neureka.Neureka$Settings$Debug _debug -> b
    neureka.Neureka$Settings$AutoGrad _autograd -> c
    neureka.Neureka$Settings$Indexing _indexing -> d
    neureka.Neureka$Settings$View _view -> e
    neureka.Neureka$Settings$NDim _ndim -> f
    neureka.Neureka$Settings$DType _dtype -> g
    boolean _isLocked -> h
    neureka.Neureka this$0 -> a
    250:259:void <init>(neureka.Neureka) -> <init>
    262:262:neureka.Neureka$Settings$Debug debug() -> debug
    266:267:neureka.Neureka$Settings$Debug debug(java.lang.Object) -> debug
    271:271:neureka.Neureka$Settings$AutoGrad autograd() -> autograd
    275:276:neureka.Neureka$Settings$AutoGrad autograd(java.lang.Object) -> autograd
    280:280:neureka.Neureka$Settings$Indexing indexing() -> indexing
    284:285:neureka.Neureka$Settings$Indexing indexing(java.lang.Object) -> indexing
    289:289:neureka.Neureka$Settings$View view() -> view
    293:294:neureka.Neureka$Settings$View view(java.lang.Object) -> view
    298:298:neureka.Neureka$Settings$NDim ndim() -> ndim
    302:303:neureka.Neureka$Settings$NDim ndim(java.lang.Object) -> ndim
    307:307:neureka.Neureka$Settings$DType dtype() -> dtype
    311:312:neureka.Neureka$Settings$DType dtype(java.lang.Object) -> dtype
    316:316:boolean isLocked() -> isLocked
    320:321:void setIsLocked(boolean) -> setIsLocked
    324:324:java.lang.String toString() -> toString
    241:241:void <init>(neureka.Neureka,byte) -> <init>
    241:241:boolean access$100(neureka.Neureka$Settings) -> a
neureka.Neureka$Settings$AutoGrad -> neureka.Neureka$Settings$AutoGrad:
    boolean _isPreventingInlineOperations -> a
    boolean _isRetainingPendingErrorForJITProp -> b
    boolean _isApplyingGradientWhenTensorIsUsed -> c
    boolean _isApplyingGradientWhenRequested -> d
    neureka.Neureka$Settings this$1 -> e
    377:382:void <init>(neureka.Neureka$Settings) -> <init>
    390:390:boolean isPreventingInlineOperations() -> isPreventingInlineOperations
    399:401:void setIsPreventingInlineOperations(boolean) -> setIsPreventingInlineOperations
    414:414:boolean isRetainingPendingErrorForJITProp() -> isRetainingPendingErrorForJITProp
    428:430:void setIsRetainingPendingErrorForJITProp(boolean) -> setIsRetainingPendingErrorForJITProp
    438:438:boolean isApplyingGradientWhenTensorIsUsed() -> isApplyingGradientWhenTensorIsUsed
    447:449:void setIsApplyingGradientWhenTensorIsUsed(boolean) -> setIsApplyingGradientWhenTensorIsUsed
    472:472:boolean isApplyingGradientWhenRequested() -> isApplyingGradientWhenRequested
    484:486:void setIsApplyingGradientWhenRequested(boolean) -> setIsApplyingGradientWhenRequested
    489:489:java.lang.String toString() -> toString
neureka.Neureka$Settings$DType -> neureka.Neureka$Settings$DType:
    java.lang.Class _defaultDataTypeClass -> a
    boolean _isAutoConvertingExternalDataToJVMTypes -> b
    neureka.Neureka$Settings this$1 -> c
    584:588:void <init>(neureka.Neureka$Settings) -> <init>
    591:591:java.lang.Class getDefaultDataTypeClass() -> getDefaultDataTypeClass
    595:597:void setDefaultDataTypeClass(java.lang.Class) -> setDefaultDataTypeClass
    600:600:boolean getIsAutoConvertingExternalDataToJVMTypes() -> getIsAutoConvertingExternalDataToJVMTypes
    604:606:void setIsAutoConvertingExternalDataToJVMTypes(boolean) -> setIsAutoConvertingExternalDataToJVMTypes
    609:609:java.lang.String toString() -> toString
neureka.Neureka$Settings$Debug -> neureka.Neureka$Settings$Debug:
    boolean _isKeepingDerivativeTargetPayloads -> a
    neureka.Neureka$Settings this$1 -> b
    328:330:void <init>(neureka.Neureka$Settings) -> <init>
    348:348:boolean isKeepingDerivativeTargetPayloads() -> isKeepingDerivativeTargetPayloads
    367:369:void setIsKeepingDerivativeTargetPayloads(boolean) -> setIsKeepingDerivativeTargetPayloads
    372:372:java.lang.String toString() -> toString
neureka.Neureka$Settings$Indexing -> neureka.Neureka$Settings$Indexing:
    boolean _isUsingArrayBasedIndexing -> a
    neureka.Neureka$Settings this$1 -> b
    494:496:void <init>(neureka.Neureka$Settings) -> <init>
    499:499:boolean isUsingArrayBasedIndexing() -> isUsingArrayBasedIndexing
    503:505:void setIsUsingArrayBasedIndexing(boolean) -> setIsUsingArrayBasedIndexing
    508:508:java.lang.String toString() -> toString
neureka.Neureka$Settings$NDim -> neureka.Neureka$Settings$NDim:
    boolean _isOnlyUsingDefaultNDConfiguration -> a
    neureka.Neureka$Settings this$1 -> b
    560:567:void <init>(neureka.Neureka$Settings) -> <init>
    570:570:boolean isOnlyUsingDefaultNDConfiguration() -> isOnlyUsingDefaultNDConfiguration
    574:576:void setIsOnlyUsingDefaultNDConfiguration(boolean) -> setIsOnlyUsingDefaultNDConfiguration
    579:579:java.lang.String toString() -> toString
neureka.Neureka$Settings$View -> neureka.Neureka$Settings$View:
    boolean _isUsingLegacyView -> a
    java.util.Map _asString -> b
    neureka.Neureka$Settings this$1 -> c
    515:528:void <init>(neureka.Neureka$Settings) -> <init>
    534:534:boolean isUsingLegacyView() -> isUsingLegacyView
    538:540:void setIsUsingLegacyView(boolean) -> setIsUsingLegacyView
    543:543:java.util.Map getAsString() -> getAsString
    547:548:void setAsString(java.util.Map) -> setAsString
    551:552:void setAsString(java.lang.String) -> setAsString
    555:555:java.lang.String toString() -> toString
neureka.Neureka$Utility -> neureka.Neureka$Utility:
    615:615:void <init>() -> <init>
    626:639:java.lang.String readResource(java.lang.String) -> readResource
    650:664:boolean isPresent(java.lang.String) -> isPresent
neureka.Tsr -> neureka.Tsr:
    neureka.devices.Device _CPU -> a
    int _flags -> b
    int _version -> c
    boolean $assertionsDisabled -> d
    198:198:neureka.Tsr newInstance() -> newInstance
    153:208:void <init>() -> <init>
    217:217:neureka.Tsr of(java.lang.Object[]) -> of
    153:224:void <init>(java.lang.Object[]) -> <init>
    228:304:void _construct(java.lang.Object[]) -> a
    323:323:neureka.Tsr of(java.util.List,java.lang.Object) -> of
    153:328:void <init>(java.util.List,java.lang.Object) -> <init>
    341:343:neureka.Tsr of(java.util.List,java.lang.String) -> of
    347:349:neureka.Tsr of(java.util.List,java.util.List) -> of
    355:356:neureka.Tsr of(int[],java.util.List) -> of
    370:391:neureka.Tsr of(java.util.List) -> of
    396:396:neureka.Tsr ofShape(java.util.List) -> ofShape
    401:402:neureka.Tsr ofShape(java.lang.Number[]) -> ofShape
    153:410:void <init>(java.util.List) -> <init>
    418:418:neureka.utility.fluent.TensorBuilder of(java.lang.Class) -> of
    420:420:neureka.utility.fluent.TensorBuilder ofDoubles() -> ofDoubles
    422:422:neureka.utility.fluent.TensorBuilder ofFloats() -> ofFloats
    424:424:neureka.utility.fluent.TensorBuilder ofInts() -> ofInts
    426:426:neureka.Tsr of(double) -> of
    153:428:void <init>(double) -> <init>
    430:430:neureka.Tsr of(float[]) -> of
    153:432:void <init>(float[]) -> <init>
    434:434:neureka.Tsr of(int[],java.lang.String) -> of
    153:443:void <init>(int[],java.lang.String) -> <init>
    445:445:neureka.Tsr ofShape(int[]) -> ofShape
    153:447:void <init>(int[]) -> <init>
    449:449:neureka.Tsr of(int[],double) -> of
    153:451:void <init>(int[],double) -> <init>
    453:453:neureka.Tsr of(int[],double[]) -> of
    153:455:void <init>(int[],double[]) -> <init>
    457:457:neureka.Tsr of(neureka.dtype.DataType,int[]) -> of
    153:464:void <init>(int[],neureka.dtype.DataType) -> <init>
    466:466:neureka.Tsr of(java.lang.Class,int[],java.lang.Object) -> of
    468:468:neureka.Tsr of(java.lang.Class,java.util.List,java.lang.Object) -> of
    153:475:void <init>(int[],java.lang.Class,java.lang.Object) -> <init>
    478:480:neureka.Tsr of(java.lang.Class,java.util.List,java.util.List) -> of
    498:498:neureka.Tsr of(neureka.dtype.DataType,int[],java.lang.Object) -> of
    153:500:void <init>(int[],neureka.dtype.DataType,java.lang.Object) -> <init>
    503:506:neureka.Tsr of(neureka.dtype.DataType,java.util.List,java.util.List) -> of
    514:515:void _construct$1c8ec8fd(int[],boolean) -> a
    518:524:int[] _intArray(java.lang.Object[]) -> b
    529:536:double[] _doubleArray(java.lang.Object[]) -> c
    561:563:neureka.Tsr of(neureka.dtype.DataType,java.util.List,neureka.ndim.Initializer) -> of
    584:584:neureka.Tsr of(neureka.dtype.DataType,int[],neureka.ndim.Initializer) -> of
    153:598:void <init>(int[],neureka.dtype.DataType,neureka.ndim.Initializer) -> <init>
    2608:2611:void _constructFromInitializer(int[],neureka.dtype.DataType,neureka.ndim.Initializer):608:611 -> <init>
    2608:2611:void <init>(int[],neureka.dtype.DataType,neureka.ndim.Initializer):597 -> <init>
    640:650:neureka.Tsr of(java.lang.String,java.util.List) -> of
    674:674:neureka.Tsr of(java.lang.String,neureka.Tsr) -> of
    695:695:neureka.Tsr of(java.lang.String,neureka.Tsr[]) -> of
    722:722:neureka.Tsr of(java.lang.String,boolean,neureka.Tsr[]) -> of
    747:749:void _construct(neureka.Tsr[],java.lang.String,boolean) -> a
    773:774:neureka.Tsr _constructFunctional(neureka.Tsr,neureka.Tsr[],java.lang.String,boolean) -> a
    790:792:neureka.Tsr setRqsGradient(boolean) -> setRqsGradient
    796:796:boolean rqsGradient() -> rqsGradient
    800:804:void _setRqsGradient(boolean) -> _setRqsGradient
    813:855:neureka.Tsr setIsOutsourced(boolean) -> setIsOutsourced
    859:859:boolean isOutsourced() -> isOutsourced
    863:867:void _setIsOutsourced(boolean) -> _setIsOutsourced
    893:938:neureka.Tsr setIsVirtual(boolean) -> setIsVirtual
    955:955:boolean isVirtual() -> isVirtual
    966:970:void _setIsVirtual(boolean) -> _setIsVirtual
    995:1007:neureka.Tsr setGradientApplyRequested(boolean) -> setGradientApplyRequested
    1026:1026:boolean gradientApplyRequested() -> gradientApplyRequested
    1036:1036:boolean isDeleted() -> isDeleted
    1052:1066:neureka.Tsr delete() -> delete
    1092:1092:neureka.Component _setOrReject(neureka.Component) -> _setOrReject
    1112:1133:neureka.Component _removeOrReject(neureka.Component) -> _removeOrReject
    1149:1162:boolean update(neureka.Component$OwnerChangeRequest) -> update
    1184:1184:boolean isEmpty() -> isEmpty
    1195:1195:boolean isUndefined() -> isUndefined
    1205:1206:boolean isSlice() -> isSlice
    1218:1219:int sliceCount() -> sliceCount
    1229:1230:boolean isSliceParent() -> isSliceParent
    1244:1244:boolean belongsToGraph() -> belongsToGraph
    1258:1258:boolean isLeave() -> isLeave
    1272:1272:boolean isBranch() -> isBranch
    1282:1282:boolean hasGradient() -> hasGradient
    1295:1295:neureka.Tsr getGradient() -> getGradient
    1302:1303:neureka.devices.Device getDevice() -> getDevice
    1310:1310:neureka.autograd.GraphNode getGraphNode() -> getGraphNode
    1317:1317:neureka.framing.NDFrame frame() -> frame
    1344:1356:neureka.Tsr incrementVersionBecauseOf(neureka.backend.api.ExecutionCall) -> incrementVersionBecauseOf
    1380:1390:neureka.Tsr _become(neureka.Tsr) -> _become
    1410:1411:java.util.Iterator iterator() -> iterator
    1455:1458:neureka.Tsr backward(neureka.Tsr) -> backward
    1478:1479:neureka.Tsr backward(double) -> backward
    1497:1498:neureka.Tsr backward() -> backward
    1513:1534:void applyGradient() -> applyGradient
    1545:1546:void detach() -> detach
    1574:1575:neureka.Tsr label(java.lang.String[][]) -> label
    1599:1600:neureka.Tsr label(java.lang.String,java.lang.String[][]) -> label
    1612:1627:void _label(java.lang.String,java.lang.String[][]) -> a
    1647:1649:neureka.Tsr label(java.util.List) -> label
    1671:1673:neureka.Tsr label(java.lang.String,java.util.List) -> label
    1694:1695:neureka.Tsr label(java.util.Map) -> label
    1700:1701:neureka.Tsr label(java.lang.String,java.util.Map) -> label
    1717:1717:neureka.Tsr plus(neureka.Tsr) -> plus
    1721:1721:neureka.Tsr plusAssign(neureka.Tsr) -> plusAssign
    1725:1725:neureka.Tsr plus(java.lang.Double) -> plus
    1729:1729:neureka.Tsr minus(neureka.Tsr) -> minus
    1733:1733:neureka.Tsr minusAssign(neureka.Tsr) -> minusAssign
    1737:1737:neureka.Tsr negative() -> negative
    1741:1741:neureka.Tsr multiply(neureka.Tsr) -> multiply
    1745:1745:neureka.Tsr timesAssign(neureka.Tsr) -> timesAssign
    1749:1749:neureka.Tsr multiply(java.lang.Double) -> multiply
    1753:1753:neureka.Tsr div(neureka.Tsr) -> div
    1757:1757:neureka.Tsr div(java.lang.Double) -> div
    1761:1761:neureka.Tsr divAssign(neureka.Tsr) -> divAssign
    1765:1765:neureka.Tsr mod(neureka.Tsr) -> mod
    1769:1769:neureka.Tsr modAssign(neureka.Tsr) -> modAssign
    1773:1773:neureka.Tsr power(neureka.Tsr) -> power
    1777:1777:neureka.Tsr power(java.lang.Double) -> power
    1781:1781:neureka.Tsr xor(neureka.Tsr) -> xor
    1785:1785:neureka.Tsr xor(java.lang.Double) -> xor
    1802:1805:neureka.Tsr T() -> T
    1817:1819:neureka.Tsr mean() -> mean
    1830:1839:neureka.Tsr dot(neureka.Tsr) -> dot
    1853:1853:neureka.Tsr dimtrim() -> dimtrim
    1866:1870:boolean isCase(neureka.Tsr) -> isCase
    1883:1883:boolean contains(neureka.Tsr) -> contains
    1907:1907:java.lang.Object getAt(int[]) -> getAt
    1919:1920:neureka.Tsr getAt(java.lang.Object[]) -> getAt
    1932:1932:neureka.Tsr getAt(int) -> getAt
    1943:1943:java.lang.Object getValueAt(int) -> getValueAt
    1957:1957:java.lang.Object getValueAt(int[]) -> getValueAt
    1972:1973:neureka.Tsr setAt(int,java.lang.Object) -> setAt
    1977:1977:neureka.Tsr getAt(double) -> getAt
    1981:1981:neureka.Tsr getAt(java.math.BigDecimal) -> getAt
    1986:1988:neureka.Tsr getAt(java.util.Map) -> getAt
    1997:2004:neureka.Tsr shallowCopy() -> shallowCopy
    2016:2051:neureka.Tsr getAt(java.lang.Object) -> getAt
    2072:2072:neureka.utility.slicing.SliceBuilder slice() -> slice
    2089:2167:neureka.Tsr _sliceOf(int[],int[],int[]) -> a
    2190:2192:neureka.Tsr putAt(java.util.List,neureka.Tsr) -> putAt
    2206:2208:neureka.Tsr putAt(java.util.Map,neureka.Tsr) -> putAt
    2212:2217:void _putAtCheckFor(neureka.Tsr) -> b
    2221:2240:neureka.Tsr _putAt(neureka.Tsr,neureka.Tsr) -> a
    2252:2265:java.lang.Object getDataAt(int) -> getDataAt
    2277:2285:neureka.Tsr setDataAt(int,java.lang.Object) -> setDataAt
    2292:2301:void _setValue64(double[]) -> a
    2307:2316:void _setValue32(float[]) -> a
    2330:2359:neureka.Tsr setValue(java.lang.Object) -> setValue
    2363:2371:java.lang.Object getValue() -> getValue
    2382:2398:neureka.Tsr addToGradient(neureka.Tsr) -> addToGradient
    2421:2431:neureka.Tsr asType(java.lang.Class) -> asType
    2457:2468:neureka.Tsr toType(java.lang.Class) -> toType
    2472:2482:double value64(int) -> value64
    2487:2501:double[] value64() -> value64
    2505:2515:float value32(int) -> value32
    2520:2530:float[] value32() -> value32
    2536:2536:java.lang.String toString(java.lang.String) -> toString
    2540:2540:java.lang.String toString(java.util.Map,java.lang.String) -> toString
    2544:2544:java.lang.String toString(java.util.Map) -> toString
    2550:2550:java.lang.String _toString(java.lang.String,java.lang.String) -> _toString
    2556:2557:java.lang.String toString() -> toString
    2563:2592:void makeFit(neureka.Tsr[],boolean) -> makeFit
    2595:2595:int getVersion() -> getVersion
    135:135:java.lang.Object setDataAt(int,java.lang.Object) -> setDataAt
    135:135:java.lang.Object setIsVirtual(boolean) -> setIsVirtual
    2467:2467:void lambda$toType$26(java.lang.Class,neureka.Tsr) -> a
    2392:2397:void lambda$addToGradient$25(neureka.Tsr,neureka.devices.Device) -> a
    2386:2387:void lambda$addToGradient$24(neureka.Tsr,neureka.Tsr) -> b
    1867:1867:void lambda$isCase$23(neureka.Tsr,boolean[],neureka.framing.Relation) -> a
    1868:1869:void lambda$isCase$22(neureka.Tsr,boolean[],java.lang.Object) -> a
    1521:1532:void lambda$applyGradient$21(neureka.Tsr) -> c
    1521:1521:void lambda$applyGradient$20(neureka.optimization.Optimizer) -> a
    1455:1455:void lambda$backward$19(neureka.Tsr,neureka.autograd.GraphNode) -> a
    1059:1059:void lambda$delete$18(neureka.devices.Device) -> a
    1053:1058:void lambda$delete$17(neureka.autograd.GraphNode) -> a
    918:920:void lambda$setIsVirtual$16(neureka.Tsr) -> d
    821:849:void lambda$setIsOutsourced$15(neureka.devices.Device) -> b
    833:833:void lambda$setIsOutsourced$14(neureka.Tsr) -> e
    837:847:void lambda$setIsOutsourced$13(neureka.Tsr,neureka.devices.Device) -> b
    650:650:neureka.Tsr[] lambda$of$12(int) -> a
    650:650:neureka.Tsr lambda$of$11(java.lang.Object) -> a
    643:643:neureka.Tsr[] lambda$of$10(int) -> b
    640:640:boolean lambda$of$9(java.lang.Object) -> b
    563:563:int lambda$of$8(java.lang.Integer) -> a
    505:505:int lambda$of$7(java.lang.Integer) -> b
    480:480:int lambda$of$6(java.lang.Integer) -> c
    468:468:int lambda$of$5(java.lang.Integer) -> d
    409:409:java.util.List lambda$new$4(java.lang.Object) -> c
    390:390:int lambda$of$3(java.lang.Integer) -> e
    386:386:java.lang.Object lambda$of$2(java.lang.Object) -> d
    372:373:boolean lambda$of$1(java.lang.Object) -> e
    373:373:boolean lambda$of$0(java.lang.Object) -> f
    135:135:void <init>(int[],double,byte) -> <init>
    135:135:void access$100(neureka.Tsr,float[]) -> a
    135:135:void access$200(neureka.Tsr,double[]) -> a
    135:135:neureka.utility.NDAConstructor access$300(neureka.Tsr) -> a
    135:140:void <clinit>() -> <clinit>
neureka.Tsr$1 -> neureka.Tsr$1:
    int _count -> a
    int _size -> b
    neureka.ndim.iterators.NDIterator val$_ndi -> c
    neureka.Tsr this$0 -> d
    1412:1414:void <init>(neureka.Tsr,neureka.ndim.iterators.NDIterator) -> <init>
    1418:1418:boolean hasNext() -> hasNext
    1423:1426:java.lang.Object next() -> next
neureka.Tsr$Create -> neureka.Tsr$Create:
    2692:2692:void <init>() -> <init>
    2695:2695:neureka.Tsr E(java.util.List) -> E
    2699:2699:neureka.Tsr E(int[]) -> E
    2703:2703:neureka.Tsr newRandom(int[]) -> newRandom
    2707:2708:neureka.Tsr newRandom(int[],long) -> newRandom
    2712:2721:neureka.Tsr newTsrLike(neureka.Tsr,double) -> newTsrLike
    2725:2734:neureka.Tsr newTsrLike(neureka.Tsr) -> newTsrLike
    2738:2740:neureka.Tsr _newEmptyLike(neureka.Tsr) -> a
    2695:2695:int lambda$E$0(java.lang.Integer) -> a
neureka.Tsr$IO -> neureka.Tsr$IO:
    2608:2609:void <init>() -> <init>
    2612:2614:double getFrom(neureka.Tsr,int) -> getFrom
    2618:2619:double getFrom(neureka.Tsr,int[]) -> getFrom
    2623:2625:void setInto(neureka.Tsr,int,double) -> setInto
    2628:2630:void setInto(neureka.Tsr,int[],double) -> setInto
    2633:2635:void addInto(neureka.Tsr,int,double) -> addInto
    2638:2640:void addInto(neureka.Tsr,int[],double) -> addInto
    2643:2645:neureka.Tsr addInto(neureka.Tsr,neureka.Tsr) -> addInto
    2649:2651:void subInto(neureka.Tsr,int,double) -> subInto
    2654:2656:void subInto(neureka.Tsr,int[],double) -> subInto
    2659:2670:void subInto(neureka.Tsr,neureka.Tsr) -> subInto
    2673:2675:void mulInto(neureka.Tsr,int,double) -> mulInto
    2678:2680:void mulInto(neureka.Tsr,int[],double) -> mulInto
neureka.autograd.ADAgent -> neureka.autograd.ADAgent:
    neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    neureka.Tsr derivative() -> derivative
    boolean hasForward() -> hasForward
    boolean hasBackward() -> hasBackward
    java.lang.String toString() -> toString
neureka.autograd.DefaultADAgent -> neureka.autograd.DefaultADAgent:
    neureka.autograd.DefaultADAgent$ADAction _forward -> a
    neureka.autograd.DefaultADAgent$ADAction _backward -> b
    java.util.Map _context -> c
    33:34:neureka.autograd.DefaultADAgent setForward(neureka.autograd.DefaultADAgent$ADAction) -> setForward
    38:39:neureka.autograd.DefaultADAgent setBackward(neureka.autograd.DefaultADAgent$ADAction) -> setBackward
    62:66:void <init>(neureka.Tsr) -> <init>
    62:68:void <init>() -> <init>
    71:72:neureka.autograd.DefaultADAgent withContext(java.util.Map) -> withContext
    77:77:neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    82:82:neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    87:87:neureka.Tsr derivative() -> derivative
    92:92:boolean hasForward() -> hasForward
    97:97:boolean hasBackward() -> hasBackward
    111:114:java.lang.String toString() -> toString
    113:113:java.lang.String lambda$toString$0(java.lang.String) -> a
neureka.autograd.DefaultADAgent$ADAction -> neureka.autograd.DefaultADAgent$ADAction:
    neureka.Tsr execute(neureka.autograd.GraphNode,neureka.Tsr) -> execute
neureka.autograd.GraphLock -> neureka.autograd.GraphLock:
    neureka.calculus.Function _owner -> a
    boolean _isLocked -> b
    25:33:void <init>(neureka.calculus.Function) -> <init>
    40:41:void release() -> release
    48:48:java.lang.String toString() -> toString
    52:52:boolean isLocked() -> isLocked
neureka.autograd.GraphNode -> neureka.autograd.GraphNode:
    int _mode -> a
    boolean _allows_forward -> b
    boolean _allows_backward -> c
    boolean _reliesOnJustInTimeProp -> d
    neureka.autograd.PendingError _pendingError -> e
    boolean _isUsedAsDerivative -> f
    neureka.calculus.Function _function -> g
    neureka.autograd.GraphNode[] _parents -> h
    java.lang.ref.WeakReference _payload -> i
    int _payloadReferenceVersion -> j
    java.util.TreeMap _targets_derivatives -> k
    neureka.autograd.GraphLock _lock -> l
    java.util.List _children -> m
    long _nodeID -> n
    boolean $assertionsDisabled -> o
    87:87:boolean usesAD() -> usesAD
    96:96:boolean usesForwardAD() -> usesForwardAD
    105:105:boolean usesReverseAD() -> usesReverseAD
    168:170:neureka.autograd.PendingError getAndRemovePendingError() -> getAndRemovePendingError
    230:230:neureka.Tsr getPayload() -> getPayload
    234:251:void _setPayload(neureka.Tsr) -> a
    255:257:boolean update(neureka.Component$OwnerChangeRequest) -> update
    303:306:void _attachChild(neureka.autograd.GraphNode) -> a
    322:322:boolean isCacheable() -> isCacheable
    331:332:void obtainLocking(neureka.autograd.GraphLock) -> obtainLocking
    339:339:boolean isLeave() -> isLeave
    342:346:boolean isGraphLeave() -> isGraphLeave
    353:353:boolean isVirtual() -> isVirtual
    156:413:void <init>(neureka.calculus.Function,java.lang.Object,java.util.function.Supplier) -> <init>
    425:542:void _construct(neureka.Tsr,neureka.calculus.Function,neureka.backend.api.ExecutionCall,neureka.autograd.GraphLock) -> a
    560:581:int _modeOf$39c16ed1(neureka.backend.api.ExecutionCall) -> a
    592:608:void _migrateAndOrApplyError(neureka.Tsr,java.util.function.Consumer) -> a
    621:633:void backward(neureka.Tsr) -> backward
    651:672:void _backward(neureka.Tsr,java.util.Set,boolean) -> a
    684:692:void _carryPendingBackPropToGradients(java.util.Set) -> a
    708:710:void backwardJIT(neureka.Tsr) -> backwardJIT
    713:738:void _backwardJIT(neureka.Tsr,neureka.autograd.GraphNode) -> a
    750:754:void _deleteDerivativesRecursively() -> a
    762:771:int _numberOfReverseModeADChildren() -> b
    780:789:void put(neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> put
    798:799:java.util.List get(neureka.autograd.GraphNode) -> get
    810:811:boolean has(neureka.autograd.GraphNode) -> has
    820:820:int size() -> size
    826:830:void forEachDerivative(java.util.function.BiConsumer) -> forEachDerivative
    836:840:void forEachBackward(neureka.Tsr,java.util.function.BiConsumer) -> forEachBackward
    846:848:void forEachTarget(java.util.function.Consumer) -> forEachTarget
    854:862:void forEachTargetAgentPair(java.util.function.BiConsumer) -> forEachTargetAgentPair
    868:868:boolean hasDerivatives() -> hasDerivatives
    874:879:java.lang.String type() -> type
    883:883:java.lang.String toString() -> toString
    890:907:java.lang.String toString(java.lang.String) -> toString
    922:935:java.lang.String _toString(java.lang.String,boolean,java.lang.String) -> a
    966:966:int getMode() -> getMode
    968:968:boolean isReliesOnJustInTimeProp() -> isReliesOnJustInTimeProp
    970:970:neureka.autograd.PendingError getPendingError() -> getPendingError
    972:972:boolean isUsedAsDerivative() -> isUsedAsDerivative
    974:974:neureka.calculus.Function getFunction() -> getFunction
    976:976:neureka.autograd.GraphNode[] getParents() -> getParents
    978:978:int getPayloadReferenceVersion() -> getPayloadReferenceVersion
    980:980:neureka.autograd.GraphLock getLock() -> getLock
    982:982:java.util.List getChildren() -> getChildren
    987:987:long getNodeID() -> getNodeID
    858:858:void lambda$forEachTargetAgentPair$14(java.util.function.BiConsumer,neureka.autograd.GraphNode,java.util.List) -> a
    859:859:void lambda$forEachTargetAgentPair$13(java.util.function.BiConsumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    847:847:void lambda$forEachTarget$12(java.util.function.Consumer,neureka.autograd.GraphNode,java.util.List) -> a
    838:839:void lambda$forEachBackward$11(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,java.util.List) -> a
    828:828:void lambda$forEachDerivative$10(java.util.function.BiConsumer,neureka.autograd.GraphNode,java.util.List) -> b
    828:828:void lambda$forEachDerivative$9(java.util.function.BiConsumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> b
    780:780:int lambda$put$8(neureka.autograd.GraphNode,neureka.autograd.GraphNode) -> a
    735:735:void lambda$_backwardJIT$7(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> a
    715:720:void lambda$_backwardJIT$6(neureka.autograd.GraphNode,neureka.Tsr) -> a
    685:685:void lambda$_carryPendingBackPropToGradients$5(java.util.Set,neureka.autograd.GraphNode) -> a
    669:669:void lambda$_backward$4(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> a
    627:630:void lambda$backward$3(neureka.autograd.GraphNode) -> b
    624:624:void lambda$backward$2(java.util.Set,neureka.autograd.GraphNode) -> b
    496:515:void lambda$_construct$1(neureka.Tsr,neureka.backend.api.ExecutionCall,neureka.calculus.Function,int,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    239:249:void lambda$_setPayload$0() -> c
    66:66:void <clinit>() -> <clinit>
neureka.autograd.JITProp -> neureka.autograd.JITProp:
    java.util.Set _finished -> a
    java.util.Set _pending -> b
    16:20:void <init>(java.util.Set) -> <init>
    27:30:void addPending(java.util.Set) -> addPending
    37:46:void noteFinished(neureka.autograd.GraphNode) -> noteFinished
    49:49:int finishedCount() -> finishedCount
    53:53:int pendingCount() -> pendingCount
    66:76:void execute() -> execute
    82:82:boolean isDone() -> isDone
    90:92:java.lang.String toString() -> toString
    98:99:boolean update(neureka.Component$OwnerChangeRequest) -> update
    68:73:void lambda$execute$0(neureka.autograd.GraphNode) -> a
neureka.autograd.PendingError -> neureka.autograd.PendingError:
    int _toBeReceived -> a
    neureka.Tsr _accumulatedError -> b
    12:15:void <init>(neureka.Tsr,int) -> <init>
    18:22:void accumulate(neureka.Tsr) -> accumulate
    25:25:boolean isFullyAccumulated() -> isFullyAccumulated
    29:29:java.lang.String toString() -> toString
    33:33:int getToBeReceived() -> getToBeReceived
    37:37:neureka.Tsr getAccumulatedError() -> getAccumulatedError
neureka.backend.api.Algorithm -> neureka.backend.api.Algorithm:
    java.lang.String getName() -> getName
    float isSuitableFor(neureka.backend.api.ExecutionCall) -> isSuitableFor
    neureka.devices.Device findDeviceFor(neureka.backend.api.ExecutionCall) -> findDeviceFor
    boolean canPerformForwardADFor(neureka.backend.api.ExecutionCall) -> canPerformForwardADFor
    boolean canPerformBackwardADFor(neureka.backend.api.ExecutionCall) -> canPerformBackwardADFor
    neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> supplyADAgentFor
    neureka.Tsr handleInsteadOfDevice(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> handleInsteadOfDevice
    neureka.Tsr handleRecursivelyAccordingToArity(neureka.backend.api.ExecutionCall,java.util.function.Function) -> handleRecursivelyAccordingToArity
    neureka.backend.api.ExecutionCall instantiateNewTensorsForExecutionIn(neureka.backend.api.ExecutionCall) -> instantiateNewTensorsForExecutionIn
    neureka.Tsr recursiveReductionOf(neureka.backend.api.ExecutionCall,java.util.function.Consumer) -> recursiveReductionOf
    neureka.backend.api.Algorithm setImplementationFor(java.lang.Class,neureka.backend.api.ImplementationFor) -> setImplementationFor
    neureka.backend.api.ImplementationFor getImplementationFor(java.lang.Class) -> getImplementationFor
neureka.backend.api.Algorithm$ADAgentSupplier -> neureka.backend.api.Algorithm$ADAgentSupplier:
    neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> getADAgentOf
neureka.backend.api.Algorithm$BackwardADAnalyzer -> neureka.backend.api.Algorithm$BackwardADAnalyzer:
    boolean allowsBackward(neureka.backend.api.ExecutionCall) -> allowsBackward
neureka.backend.api.Algorithm$DeviceFinder -> neureka.backend.api.Algorithm$DeviceFinder:
    neureka.devices.Device findFor(neureka.backend.api.ExecutionCall) -> findFor
neureka.backend.api.Algorithm$DrainInstantiation -> neureka.backend.api.Algorithm$DrainInstantiation:
    neureka.backend.api.ExecutionCall handle(neureka.backend.api.ExecutionCall) -> handle
neureka.backend.api.Algorithm$ForwardADAnalyzer -> neureka.backend.api.Algorithm$ForwardADAnalyzer:
    boolean allowsForward(neureka.backend.api.ExecutionCall) -> allowsForward
neureka.backend.api.Algorithm$InitialCallHook -> neureka.backend.api.Algorithm$InitialCallHook:
    neureka.Tsr handle(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> handle
neureka.backend.api.Algorithm$RecursiveJunctor -> neureka.backend.api.Algorithm$RecursiveJunctor:
    neureka.Tsr handle(neureka.backend.api.ExecutionCall,java.util.function.Function) -> handle
neureka.backend.api.Algorithm$SuitabilityChecker -> neureka.backend.api.Algorithm$SuitabilityChecker:
    float canHandle(neureka.backend.api.ExecutionCall) -> canHandle
neureka.backend.api.ExecutionCall -> neureka.backend.api.ExecutionCall:
    neureka.devices.Device _device -> a
    int _derivativeIndex -> b
    neureka.backend.api.Operation _operation -> c
    neureka.Tsr[] _tensors -> d
    int _j -> e
    neureka.backend.api.Algorithm _algorithm -> f
    java.util.Map _context -> g
    boolean $assertionsDisabled -> h
    61:210:void <init>(neureka.devices.Device,int,neureka.backend.api.Operation,neureka.Tsr[],int,neureka.backend.api.Algorithm,java.util.Map) -> <init>
    88:88:neureka.backend.api.ExecutionCall$ExecutionCallBuilder builder() -> builder
    92:92:java.lang.String toString() -> toString
    96:96:neureka.devices.Device getDevice() -> getDevice
    101:101:neureka.devices.Device getDeviceFor(java.lang.Class) -> getDeviceFor
    105:105:int getDerivativeIndex() -> getDerivativeIndex
    109:109:neureka.backend.api.Operation getOperation() -> getOperation
    113:113:neureka.Tsr[] getTensors() -> getTensors
    117:117:int getJ() -> getJ
    121:121:java.util.Map getContext() -> getContext
    125:125:neureka.backend.api.ExecutionCall withTensors(neureka.Tsr[]) -> withTensors
    129:129:neureka.backend.api.ExecutionCall withJ(int) -> withJ
    149:157:neureka.backend.api.ExecutionCall withDevice(neureka.devices.Device) -> withDevice
    229:230:neureka.backend.api.ExecutionCall forDeviceType(java.lang.Class) -> forDeviceType
    236:236:neureka.Tsr getTsrOfType(java.lang.Class,int) -> getTsrOfType
    241:243:neureka.backend.api.Algorithm getAlgorithm() -> getAlgorithm
    247:247:boolean allowsForward() -> allowsForward
    251:251:boolean allowsBackward() -> allowsBackward
    256:260:neureka.autograd.ADAgent getADAgentFrom(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> getADAgentFrom
    264:265:void mutateArguments(neureka.backend.api.ExecutionCall$Mutator) -> mutateArguments
    268:269:java.lang.Object getAt(java.lang.Class) -> getAt
    273:274:java.lang.Object getAt(java.lang.String) -> getAt
    278:280:neureka.backend.api.ExecutionCall putAt(java.lang.String,java.lang.Object) -> putAt
    283:283:neureka.backend.api.ExecutionCall$Validator validate() -> validate
    59:59:int access$000() -> a
    59:59:int access$100() -> b
    59:59:neureka.backend.api.Algorithm access$200() -> c
    59:59:java.util.Map access$300() -> d
    59:59:void <init>(neureka.devices.Device,int,neureka.backend.api.Operation,neureka.Tsr[],int,neureka.backend.api.Algorithm,java.util.Map,byte) -> <init>
    59:59:neureka.Tsr[] access$500(neureka.backend.api.ExecutionCall) -> a
    59:59:neureka.devices.Device access$600(neureka.backend.api.ExecutionCall) -> b
    59:59:neureka.backend.api.Operation access$700(neureka.backend.api.ExecutionCall) -> c
    59:59:void <clinit>() -> <clinit>
neureka.backend.api.ExecutionCall$Argument -> neureka.backend.api.ExecutionCall$Argument:
    neureka.backend.api.ExecutionCall$Argument DERIVATIVE -> DERIVATIVE
    neureka.backend.api.ExecutionCall$Argument[] $VALUES -> a
    138:138:neureka.backend.api.ExecutionCall$Argument[] values() -> values
    138:138:neureka.backend.api.ExecutionCall$Argument valueOf(java.lang.String) -> valueOf
    138:138:void <init>(java.lang.String,int) -> <init>
    138:139:void <clinit>() -> <clinit>
neureka.backend.api.ExecutionCall$DeviceCondition -> neureka.backend.api.ExecutionCall$DeviceCondition:
    boolean check(neureka.devices.Device) -> check
neureka.backend.api.ExecutionCall$ExecutionCallBuilder -> neureka.backend.api.ExecutionCall$ExecutionCallBuilder:
    neureka.devices.Device device -> a
    int derivativeIndex$value -> b
    boolean derivativeIndex$set -> c
    neureka.backend.api.Operation operation -> d
    neureka.Tsr[] tensors -> e
    int j$value -> f
    boolean j$set -> g
    neureka.backend.api.Algorithm algorithm$value -> h
    boolean algorithm$set -> i
    java.util.Map context$value -> j
    boolean context$set -> k
    298:298:void <init>() -> <init>
    301:302:neureka.backend.api.ExecutionCall$ExecutionCallBuilder device(neureka.devices.Device) -> device
    306:308:neureka.backend.api.ExecutionCall$ExecutionCallBuilder derivativeIndex(int) -> derivativeIndex
    312:313:neureka.backend.api.ExecutionCall$ExecutionCallBuilder operation(neureka.backend.api.Operation) -> operation
    317:318:neureka.backend.api.ExecutionCall$ExecutionCallBuilder tensors(neureka.Tsr[]) -> tensors
    322:324:neureka.backend.api.ExecutionCall$ExecutionCallBuilder j(int) -> j
    328:330:neureka.backend.api.ExecutionCall$ExecutionCallBuilder algorithm(neureka.backend.api.Algorithm) -> algorithm
    334:336:neureka.backend.api.ExecutionCall$ExecutionCallBuilder context(java.util.Map) -> context
    340:356:neureka.backend.api.ExecutionCall build() -> build
    360:360:java.lang.String toString() -> toString
neureka.backend.api.ExecutionCall$Mutator -> neureka.backend.api.ExecutionCall$Mutator:
    neureka.Tsr[] mutate(neureka.Tsr[]) -> mutate
neureka.backend.api.ExecutionCall$OperationTypeCondition -> neureka.backend.api.ExecutionCall$OperationTypeCondition:
    boolean check(neureka.backend.api.Operation) -> check
neureka.backend.api.ExecutionCall$TensorCompare -> neureka.backend.api.ExecutionCall$TensorCompare:
    boolean check(neureka.Tsr,neureka.Tsr) -> check
neureka.backend.api.ExecutionCall$TensorCondition -> neureka.backend.api.ExecutionCall$TensorCondition:
    boolean check(neureka.Tsr) -> check
neureka.backend.api.ExecutionCall$Validator -> neureka.backend.api.ExecutionCall$Validator:
    boolean _isValid -> a
    neureka.backend.api.ExecutionCall this$0 -> b
    372:374:void <init>(neureka.backend.api.ExecutionCall) -> <init>
    382:382:float estimation() -> estimation
    386:387:neureka.backend.api.ExecutionCall$Validator first(neureka.backend.api.ExecutionCall$TensorCondition) -> first
    392:395:neureka.backend.api.ExecutionCall$Validator any(neureka.backend.api.ExecutionCall$TensorCondition) -> any
    400:404:neureka.backend.api.ExecutionCall$Validator anyNotNull(neureka.backend.api.ExecutionCall$TensorCondition) -> anyNotNull
    409:412:neureka.backend.api.ExecutionCall$Validator all(neureka.backend.api.ExecutionCall$TensorCondition) -> all
    417:421:neureka.backend.api.ExecutionCall$Validator allNotNull(neureka.backend.api.ExecutionCall$TensorCondition) -> allNotNull
    426:433:neureka.backend.api.ExecutionCall$Validator all(neureka.backend.api.ExecutionCall$TensorCompare) -> all
    438:439:neureka.backend.api.ExecutionCall$Validator forDevice(neureka.backend.api.ExecutionCall$DeviceCondition) -> forDevice
    443:444:neureka.backend.api.ExecutionCall$Validator forOperation(neureka.backend.api.ExecutionCall$OperationTypeCondition) -> forOperation
    448:448:boolean isValid() -> isValid
neureka.backend.api.ImplementationFor -> neureka.backend.api.ImplementationFor:
    void run(neureka.backend.api.ExecutionCall) -> run
neureka.backend.api.Operation -> neureka.backend.api.Operation:
    neureka.backend.api.Algorithm getAlgorithmFor(neureka.backend.api.ExecutionCall) -> getAlgorithmFor
    java.lang.String getFunction() -> getFunction
    neureka.backend.api.Operation setAlgorithm(java.lang.Class,neureka.backend.api.Algorithm) -> setAlgorithm
    126:126:neureka.backend.api.Operation setAlgorithm(neureka.backend.api.Algorithm) -> setAlgorithm
    neureka.backend.api.Algorithm getAlgorithm(java.lang.Class) -> getAlgorithm
    boolean supportsAlgorithm(java.lang.Class) -> supportsAlgorithm
    java.lang.String stringify(java.lang.String[]) -> stringify
    java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    java.lang.String getOperator() -> getOperator
    int getArity() -> getArity
    boolean isOperator() -> isOperator
    boolean isIndexer() -> isIndexer
    boolean isDifferentiable() -> isDifferentiable
    boolean isInline() -> isInline
    boolean supports(java.lang.Class) -> supports
    double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.api.Operation$DefaultOperatorCreator -> neureka.backend.api.Operation$DefaultOperatorCreator:
    java.lang.Object create(neureka.Tsr[],int) -> create
neureka.backend.api.Operation$PrimaryNDAConsumer -> neureka.backend.api.Operation$PrimaryNDAConsumer:
    double execute(int[]) -> execute
neureka.backend.api.Operation$PrimaryNDIConsumer -> neureka.backend.api.Operation$PrimaryNDIConsumer:
    double execute(neureka.ndim.iterators.NDIterator) -> execute
neureka.backend.api.Operation$ScalarOperatorCreator -> neureka.backend.api.Operation$ScalarOperatorCreator:
    java.lang.Object create(neureka.Tsr[],double,int) -> create
neureka.backend.api.Operation$SecondaryNDAConsumer -> neureka.backend.api.Operation$SecondaryNDAConsumer:
    double execute(int[],int[]) -> execute
neureka.backend.api.Operation$SecondaryNDIConsumer -> neureka.backend.api.Operation$SecondaryNDIConsumer:
    double execute(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> execute
neureka.backend.api.Operation$TertiaryNDAConsumer -> neureka.backend.api.Operation$TertiaryNDAConsumer:
    double execute(int[],int[],int[]) -> execute
neureka.backend.api.Operation$TertiaryNDIConsumer -> neureka.backend.api.Operation$TertiaryNDIConsumer:
    double execute(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> execute
neureka.backend.api.Operation$Utility -> neureka.backend.api.Operation$Utility:
    259:259:void <init>() -> <init>
    262:268:neureka.Tsr[] subset(neureka.Tsr[],int,int,int) -> subset
    272:274:neureka.Tsr[] without(neureka.Tsr[],int) -> without
    278:290:neureka.Tsr[] offsetted(neureka.Tsr[],int) -> offsetted
neureka.backend.api.OperationContext -> neureka.backend.api.OperationContext:
    org.slf4j.Logger log -> a
    java.util.Map _lookup -> b
    java.util.List _instances -> c
    int _size -> d
    neureka.calculus.Cache _functionCache -> e
    neureka.calculus.Functions _getAutogradFunction -> f
    neureka.calculus.Functions _getFunction -> g
    boolean $assertionsDisabled -> h
    78:78:neureka.backend.api.OperationContext$Runner runner() -> runner
    89:89:java.util.Map lookup() -> lookup
    100:100:java.util.List instances() -> instances
    105:105:int size() -> size
    110:110:neureka.calculus.Cache functionCache() -> functionCache
    119:120:neureka.calculus.Functions getFunction() -> getFunction
    130:131:neureka.calculus.Functions getAutogradFunction() -> getAutogradFunction
    57:143:void <init>() -> <init>
    154:175:neureka.backend.api.OperationContext addOperation(neureka.backend.api.Operation) -> addOperation
    183:183:boolean hasOperation(neureka.backend.api.Operation) -> hasOperation
    195:195:neureka.backend.api.Operation instance(int) -> instance
    205:205:neureka.backend.api.Operation instance(java.lang.String) -> instance
    216:220:neureka.backend.api.OperationContext clone() -> clone
    224:224:java.lang.String toString() -> toString
    229:229:neureka.Component _setOrReject(neureka.Component) -> _setOrReject
    234:234:neureka.Component _removeOrReject(neureka.Component) -> _removeOrReject
    38:38:java.lang.Object clone() -> clone
    38:38:org.slf4j.Logger access$100() -> a
    38:40:void <clinit>() -> <clinit>
neureka.backend.api.OperationContext$Runner -> neureka.backend.api.OperationContext$Runner:
    neureka.backend.api.OperationContext originalContext -> a
    neureka.backend.api.OperationContext visitedContext -> b
    256:260:void <init>(neureka.backend.api.OperationContext,neureka.backend.api.OperationContext) -> <init>
    272:275:neureka.backend.api.OperationContext$Runner run(java.lang.Runnable) -> run
    292:295:java.lang.Object runAndGet(java.util.function.Supplier) -> runAndGet
    314:314:java.lang.Object call(java.util.function.Supplier) -> call
    333:333:java.lang.Object invoke(java.util.function.Supplier) -> invoke
    251:251:void <init>(neureka.backend.api.OperationContext,neureka.backend.api.OperationContext,byte) -> <init>
neureka.backend.api.algorithms.AbstractBaseAlgorithm -> neureka.backend.api.algorithms.AbstractBaseAlgorithm:
    java.lang.String _name -> a
    java.util.Map _implementations -> _implementations
    24:26:void <init>(java.lang.String) -> <init>
    33:85:neureka.Tsr recursiveReductionOf(neureka.backend.api.ExecutionCall,java.util.function.Consumer) -> recursiveReductionOf
    93:97:neureka.backend.api.Algorithm setImplementationFor(java.lang.Class,neureka.backend.api.ImplementationFor) -> setImplementationFor
    102:102:neureka.backend.api.ImplementationFor getImplementationFor(java.lang.Class) -> getImplementationFor
    114:114:java.lang.String getName() -> getName
    69:69:neureka.Tsr lambda$recursiveReductionOf$2(java.util.function.Consumer,neureka.backend.api.ExecutionCall) -> a
    56:56:void lambda$recursiveReductionOf$1(neureka.Tsr) -> a
    49:53:void lambda$recursiveReductionOf$0(neureka.devices.Device,neureka.Tsr) -> a
neureka.backend.api.algorithms.AbstractFunctionalAlgorithm -> neureka.backend.api.algorithms.AbstractFunctionalAlgorithm:
    neureka.backend.api.Algorithm$SuitabilityChecker _isSuitableFor -> a
    neureka.backend.api.Algorithm$DeviceFinder _findDeviceFor -> b
    neureka.backend.api.Algorithm$ForwardADAnalyzer _canPerformForwardADFor -> c
    neureka.backend.api.Algorithm$BackwardADAnalyzer _canPerformBackwardADFor -> d
    neureka.backend.api.Algorithm$ADAgentSupplier _supplyADAgentFor -> e
    neureka.backend.api.Algorithm$InitialCallHook _handleInsteadOfDevice -> f
    neureka.backend.api.Algorithm$RecursiveJunctor _handleRecursivelyAccordingToArity -> g
    neureka.backend.api.Algorithm$DrainInstantiation _instantiateNewTensorsForExecutionIn -> h
    45:46:void <init>(java.lang.String) -> <init>
    52:52:float isSuitableFor(neureka.backend.api.ExecutionCall) -> isSuitableFor
    59:59:neureka.devices.Device findDeviceFor(neureka.backend.api.ExecutionCall) -> findDeviceFor
    66:66:boolean canPerformForwardADFor(neureka.backend.api.ExecutionCall) -> canPerformForwardADFor
    73:73:boolean canPerformBackwardADFor(neureka.backend.api.ExecutionCall) -> canPerformBackwardADFor
    80:80:neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> supplyADAgentFor
    87:87:neureka.Tsr handleInsteadOfDevice(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> handleInsteadOfDevice
    94:94:neureka.Tsr handleRecursivelyAccordingToArity(neureka.backend.api.ExecutionCall,java.util.function.Function) -> handleRecursivelyAccordingToArity
    101:101:neureka.backend.api.ExecutionCall instantiateNewTensorsForExecutionIn(neureka.backend.api.ExecutionCall) -> instantiateNewTensorsForExecutionIn
    107:107:neureka.backend.api.Algorithm build() -> build
    119:119:neureka.backend.api.Algorithm$SuitabilityChecker getIsSuitableFor() -> getIsSuitableFor
    131:131:neureka.backend.api.Algorithm$DeviceFinder getFindDeviceFor() -> getFindDeviceFor
    141:141:neureka.backend.api.Algorithm$ForwardADAnalyzer getCanPerformForwardADFor() -> getCanPerformForwardADFor
    151:151:neureka.backend.api.Algorithm$BackwardADAnalyzer getCanPerformBackwardADFor() -> getCanPerformBackwardADFor
    161:161:neureka.backend.api.Algorithm$ADAgentSupplier getSupplyADAgentFor() -> getSupplyADAgentFor
    176:176:neureka.backend.api.Algorithm$InitialCallHook getHandleInsteadOfDevice() -> getHandleInsteadOfDevice
    189:189:neureka.backend.api.Algorithm$RecursiveJunctor getHandleRecursivelyAccordingToArity() -> getHandleRecursivelyAccordingToArity
    201:201:neureka.backend.api.Algorithm$DrainInstantiation getInstantiateNewTensorsForExecutionIn() -> getInstantiateNewTensorsForExecutionIn
    213:214:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setIsSuitableFor(neureka.backend.api.Algorithm$SuitabilityChecker) -> setIsSuitableFor
    227:228:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setFindDeviceFor(neureka.backend.api.Algorithm$DeviceFinder) -> setFindDeviceFor
    239:240:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setCanPerformForwardADFor(neureka.backend.api.Algorithm$ForwardADAnalyzer) -> setCanPerformForwardADFor
    251:252:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setCanPerformBackwardADFor(neureka.backend.api.Algorithm$BackwardADAnalyzer) -> setCanPerformBackwardADFor
    263:264:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setSupplyADAgentFor(neureka.backend.api.Algorithm$ADAgentSupplier) -> setSupplyADAgentFor
    268:269:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setHandleInsteadOfDevice(neureka.backend.api.Algorithm$InitialCallHook) -> setHandleInsteadOfDevice
    273:274:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setHandleRecursivelyAccordingToArity(neureka.backend.api.Algorithm$RecursiveJunctor) -> setHandleRecursivelyAccordingToArity
    278:279:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setInstantiateNewTensorsForExecutionIn(neureka.backend.api.Algorithm$DrainInstantiation) -> setInstantiateNewTensorsForExecutionIn
neureka.backend.api.algorithms.GenericAlgorithm -> neureka.backend.api.algorithms.GenericAlgorithm:
    26:88:void <init>(java.lang.String,int,neureka.backend.api.Operation) -> <init>
    92:97:float isSuitableFor(neureka.backend.api.ExecutionCall) -> isSuitableFor
    106:106:neureka.devices.Device findDeviceFor(neureka.backend.api.ExecutionCall) -> findDeviceFor
    111:111:boolean canPerformForwardADFor(neureka.backend.api.ExecutionCall) -> canPerformForwardADFor
    116:116:boolean canPerformBackwardADFor(neureka.backend.api.ExecutionCall) -> canPerformBackwardADFor
    122:132:neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> supplyADAgentFor
    137:137:neureka.Tsr handleInsteadOfDevice(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> handleInsteadOfDevice
    143:143:neureka.Tsr handleRecursivelyAccordingToArity(neureka.backend.api.ExecutionCall,java.util.function.Function) -> handleRecursivelyAccordingToArity
    149:163:neureka.backend.api.ExecutionCall instantiateNewTensorsForExecutionIn(neureka.backend.api.ExecutionCall) -> instantiateNewTensorsForExecutionIn
    199:207:java.lang.Object tryExecute(java.lang.reflect.Method,java.lang.Object[],int) -> a
    213:237:java.lang.reflect.Method findMethod(java.lang.String,java.lang.Class) -> a
    187:194:void lambda$tryExecute$9(neureka.backend.api.ExecutionCall,java.lang.reflect.Method,int,int) -> a
    132:132:neureka.Tsr lambda$supplyADAgentFor$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    131:131:neureka.Tsr lambda$supplyADAgentFor$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    127:127:neureka.Tsr lambda$supplyADAgentFor$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    126:126:neureka.Tsr lambda$supplyADAgentFor$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    31:84:void lambda$new$4(neureka.backend.api.Operation,neureka.backend.api.ExecutionCall) -> a
    1167:1196:void tryExecute(neureka.backend.api.ExecutionCall,java.lang.Class):167:196 -> a
    1167:1196:void lambda$new$4(neureka.backend.api.Operation,neureka.backend.api.ExecutionCall):83 -> a
    72:79:void lambda$new$3(neureka.backend.api.ExecutionCall,int,int) -> a
    55:61:void lambda$new$2(double[],neureka.backend.api.ExecutionCall,neureka.calculus.Function,int,int) -> a
    44:44:java.lang.Class lambda$new$1(neureka.Tsr) -> a
    41:41:boolean lambda$new$0(neureka.Tsr) -> b
neureka.backend.api.implementations.AbstractImplementationFor -> neureka.backend.api.implementations.AbstractImplementationFor:
    neureka.backend.api.ImplementationFor _lambda -> a
    9:15:void <init>(neureka.backend.api.ImplementationFor,int) -> <init>
    21:22:void run(neureka.backend.api.ExecutionCall) -> run
neureka.backend.api.operations.AbstractOperation -> neureka.backend.api.operations.AbstractOperation:
    org.slf4j.Logger _LOG -> a
    java.lang.String _function -> _function
    java.lang.String _operator -> _operator
    int _arity -> _arity
    boolean _isIndexer -> _isIndexer
    boolean _isDifferentiable -> _isDifferentiable
    boolean _isInline -> _isInline
    boolean _isOperator -> _isOperator
    java.util.Map _algorithms -> b
    neureka.backend.api.Algorithm _defaultAlgorithm -> c
    56:112:void <init>(neureka.backend.api.operations.OperationBuilder) -> <init>
    56:114:void <init>() -> <init>
    131:141:neureka.backend.api.Algorithm getAlgorithm(java.lang.Class) -> getAlgorithm
    154:154:boolean supportsAlgorithm(java.lang.Class) -> supportsAlgorithm
    170:171:neureka.backend.api.Operation setAlgorithm(java.lang.Class,neureka.backend.api.Algorithm) -> setAlgorithm
    178:199:neureka.backend.api.Algorithm getAlgorithmFor(neureka.backend.api.ExecutionCall) -> getAlgorithmFor
    206:206:boolean supports(java.lang.Class) -> supports
    211:211:boolean isOperator() -> isOperator
    216:216:java.lang.String getFunction() -> getFunction
    220:220:java.lang.String getOperator() -> getOperator
    224:224:int getArity() -> getArity
    228:228:boolean isIndexer() -> isIndexer
    232:232:boolean isDifferentiable() -> isDifferentiable
    236:236:boolean isInline() -> isInline
    240:240:neureka.backend.api.Algorithm getDefaultAlgorithm() -> getDefaultAlgorithm
    136:136:neureka.backend.api.Algorithm lambda$getAlgorithm$1(java.util.Map$Entry) -> a
    135:135:boolean lambda$getAlgorithm$0(java.lang.Class,java.util.Map$Entry) -> a
    26:26:void <clinit>() -> <clinit>
neureka.backend.api.operations.OperationBuilder -> neureka.backend.api.operations.OperationBuilder:
    neureka.backend.api.operations.OperationBuilder$Stringifier _stringifier -> a
    neureka.backend.api.operations.OperationBuilder$Derivator _derivator -> b
    java.lang.String _function -> c
    java.lang.String _operator -> d
    java.lang.Integer _arity -> e
    java.lang.Boolean _isOperator -> f
    java.lang.Boolean _isIndexer -> g
    java.lang.Boolean _isDifferentiable -> h
    java.lang.Boolean _isInline -> i
    boolean _disposed -> j
    17:64:void <init>() -> <init>
    67:67:neureka.backend.api.operations.OperationBuilder$Stringifier getStringifier() -> getStringifier
    71:71:neureka.backend.api.operations.OperationBuilder$Derivator getDerivator() -> getDerivator
    75:75:java.lang.String getFunction() -> getFunction
    79:79:java.lang.String getOperator() -> getOperator
    83:83:java.lang.Integer getArity() -> getArity
    87:87:java.lang.Boolean getIsOperator() -> getIsOperator
    91:91:java.lang.Boolean getIsIndexer() -> getIsIndexer
    95:95:java.lang.Boolean getIsDifferentiable() -> getIsDifferentiable
    99:99:java.lang.Boolean getIsInline() -> getIsInline
    103:104:neureka.backend.api.operations.OperationBuilder setStringifier(neureka.backend.api.operations.OperationBuilder$Stringifier) -> setStringifier
    108:109:neureka.backend.api.operations.OperationBuilder setDerivator(neureka.backend.api.operations.OperationBuilder$Derivator) -> setDerivator
    113:114:neureka.backend.api.operations.OperationBuilder setFunction(java.lang.String) -> setFunction
    118:119:neureka.backend.api.operations.OperationBuilder setOperator(java.lang.String) -> setOperator
    123:124:neureka.backend.api.operations.OperationBuilder setArity(java.lang.Integer) -> setArity
    128:129:neureka.backend.api.operations.OperationBuilder setIsOperator(java.lang.Boolean) -> setIsOperator
    133:134:neureka.backend.api.operations.OperationBuilder setIsIndexer(java.lang.Boolean) -> setIsIndexer
    138:139:neureka.backend.api.operations.OperationBuilder setIsDifferentiable(java.lang.Boolean) -> setIsDifferentiable
    143:144:neureka.backend.api.operations.OperationBuilder setIsInline(java.lang.Boolean) -> setIsInline
    148:149:void dispose() -> dispose
    153:166:neureka.backend.api.Operation build() -> build
    17:17:neureka.backend.api.operations.OperationBuilder$Stringifier access$000(neureka.backend.api.operations.OperationBuilder) -> a
    17:17:neureka.backend.api.operations.OperationBuilder$Derivator access$100(neureka.backend.api.operations.OperationBuilder) -> b
neureka.backend.api.operations.OperationBuilder$1 -> neureka.backend.api.operations.OperationBuilder$1:
    neureka.backend.api.operations.OperationBuilder this$0 -> a
    166:166:void <init>(neureka.backend.api.operations.OperationBuilder,neureka.backend.api.operations.OperationBuilder) -> <init>
    169:169:java.lang.String stringify(java.lang.String[]) -> stringify
    174:174:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    179:179:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.api.operations.OperationBuilder$Derivator -> neureka.backend.api.operations.OperationBuilder$Derivator:
    java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
neureka.backend.api.operations.OperationBuilder$Stringifier -> neureka.backend.api.operations.OperationBuilder$Stringifier:
    java.lang.String stringify(java.lang.String[]) -> stringify
neureka.backend.standard.algorithms.Activation -> neureka.backend.standard.algorithms.Activation:
    17:51:void <init>() -> <init>
    54:54:java.lang.String getKernelSource() -> getKernelSource
    63:76:void activate(neureka.Tsr,neureka.Tsr,int,int,neureka.backend.api.Operation$TertiaryNDIConsumer) -> activate
    85:99:void activate(neureka.Tsr,int,int,neureka.backend.api.Operation$TertiaryNDAConsumer) -> activate
    34:48:neureka.backend.api.ExecutionCall lambda$new$7(neureka.backend.api.ExecutionCall) -> a
    31:31:neureka.Tsr lambda$new$6(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    30:30:neureka.Tsr lambda$new$5(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    25:28:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> b
    27:27:boolean lambda$new$3(neureka.Tsr,neureka.Tsr) -> a
    23:23:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> c
    19:21:float lambda$new$1(neureka.backend.api.ExecutionCall) -> d
    20:20:boolean lambda$new$0(neureka.Tsr) -> a
neureka.backend.standard.algorithms.Broadcast -> neureka.backend.standard.algorithms.Broadcast:
    boolean $assertionsDisabled -> a
    18:90:void <init>() -> <init>
    93:93:java.lang.String getKernelSource() -> getKernelSource
    102:188:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.Operation$TertiaryNDIConsumer) -> broadcast
    198:282:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.Operation$TertiaryNDAConsumer) -> broadcast
    62:87:neureka.backend.api.ExecutionCall lambda$new$3(neureka.backend.api.ExecutionCall) -> a
    46:57:neureka.Tsr lambda$new$2(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    22:41:float lambda$new$1(neureka.backend.api.ExecutionCall) -> b
    24:24:boolean lambda$new$0(neureka.Tsr) -> a
    14:14:void <clinit>() -> <clinit>
neureka.backend.standard.algorithms.Convolution -> neureka.backend.standard.algorithms.Convolution:
    16:22:void <init>() -> <init>
    26:26:java.lang.String getKernelSource() -> getKernelSource
    35:37:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.Operation$TertiaryNDIConsumer) -> convolve
    1115:1194:void _deConvolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,neureka.backend.api.Operation$TertiaryNDIConsumer):115:194 -> convolve
    1115:1194:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.Operation$TertiaryNDIConsumer):36 -> convolve
    45:108:void _convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,neureka.backend.api.Operation$TertiaryNDIConsumer) -> _convolve
    205:207:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.Operation$TertiaryNDAConsumer) -> convolve
    1216:1282:void _convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,neureka.backend.api.Operation$TertiaryNDAConsumer):216:282 -> convolve
    1216:1282:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.Operation$TertiaryNDAConsumer):205 -> convolve
    1290:1370:void _deConvolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,neureka.backend.api.Operation$TertiaryNDAConsumer):290:370 -> convolve
    1290:1370:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.Operation$TertiaryNDAConsumer):206 -> convolve
    18:20:float lambda$new$1(neureka.backend.api.ExecutionCall) -> a
    19:19:boolean lambda$new$0(neureka.Tsr) -> a
neureka.backend.standard.algorithms.GenericAlgorithm -> neureka.backend.standard.algorithms.GenericAlgorithm:
    8:9:void <init>(java.lang.String) -> <init>
neureka.backend.standard.algorithms.Operator -> neureka.backend.standard.algorithms.Operator:
    18:51:void <init>() -> <init>
    54:54:java.lang.String getKernelSource() -> getKernelSource
    64:85:void operate(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.Operation$SecondaryNDIConsumer) -> operate
    95:110:void operate(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.Operation$PrimaryNDAConsumer) -> operate
    34:48:neureka.backend.api.ExecutionCall lambda$new$7(neureka.backend.api.ExecutionCall) -> a
    31:31:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    30:30:boolean lambda$new$5(neureka.backend.api.ExecutionCall) -> b
    29:29:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> c
    21:26:float lambda$new$3(neureka.backend.api.ExecutionCall) -> d
    25:25:boolean lambda$new$2(neureka.Tsr) -> a
    24:24:boolean lambda$new$1(int,java.util.List,neureka.Tsr) -> a
    22:22:java.lang.Integer lambda$new$0(java.lang.Integer,java.lang.Integer) -> a
neureka.backend.standard.algorithms.Scalarization -> neureka.backend.standard.algorithms.Scalarization:
    boolean $assertionsDisabled -> a
    17:49:void <init>() -> <init>
    53:53:java.lang.String getKernelSource() -> getKernelSource
    63:75:void scalarize(neureka.Tsr,int,int,neureka.backend.api.Operation$PrimaryNDIConsumer) -> scalarize
    83:94:void scalarize(neureka.Tsr,int,int,neureka.backend.api.Operation$PrimaryNDAConsumer) -> scalarize
    32:46:neureka.backend.api.ExecutionCall lambda$new$3(neureka.backend.api.ExecutionCall) -> a
    19:28:float lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    22:22:boolean lambda$new$1(neureka.Tsr) -> a
    21:21:boolean lambda$new$0(neureka.Tsr) -> b
    13:13:void <clinit>() -> <clinit>
neureka.backend.standard.implementations.CLImplementation -> neureka.backend.standard.implementations.CLImplementation:
    java.util.function.Function _aliasSwapper -> a
    java.util.function.Function asAdvanced -> b
    java.lang.String _source -> c
    java.lang.String _name -> d
    20:54:void <init>(neureka.backend.api.ImplementationFor,int,java.lang.String,java.lang.String) -> <init>
    20:84:void <init>(neureka.backend.api.ImplementationFor,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> <init>
    1114:1142:java.util.Map _getParsedKernelsFromTemplate(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String):114:142 -> <init>
    1114:1142:void <init>(neureka.backend.api.ImplementationFor,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String):73 -> <init>
    87:87:neureka.backend.standard.implementations.CLImplementation$SourceBuilder fromSource() -> fromSource
    91:91:neureka.backend.standard.implementations.CLImplementation$Compiler compiler() -> compiler
    95:95:java.lang.String getSource() -> getSource
    99:99:java.lang.String getName() -> getName
    120:130:void lambda$_getParsedKernelsFromTemplate$2(java.lang.String[],java.lang.String,java.util.Map,java.lang.String,java.lang.String,java.lang.String) -> a
    37:40:java.lang.String lambda$new$1(java.lang.String) -> a
    22:32:java.lang.String lambda$new$0(java.lang.String) -> b
    17:17:void <init>(neureka.backend.api.ImplementationFor,int,java.lang.String,java.lang.String,byte) -> <init>
    17:17:void <init>(neureka.backend.api.ImplementationFor,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,byte) -> <init>
neureka.backend.standard.implementations.CLImplementation$Compiler -> neureka.backend.standard.implementations.CLImplementation$Compiler:
    neureka.backend.api.ImplementationFor lambda -> a
    int arity -> b
    java.lang.String kernelSource -> c
    java.lang.String activationSource -> d
    java.lang.String differentiationSource -> e
    java.lang.String type -> f
    172:172:void <init>() -> <init>
    174:174:neureka.backend.standard.implementations.CLImplementation$Compiler execution(neureka.backend.api.ImplementationFor) -> execution
    175:175:neureka.backend.standard.implementations.CLImplementation$Compiler arity(int) -> arity
    176:176:neureka.backend.standard.implementations.CLImplementation$Compiler kernelSource(java.lang.String) -> kernelSource
    177:177:neureka.backend.standard.implementations.CLImplementation$Compiler activationSource(java.lang.String) -> activationSource
    178:178:neureka.backend.standard.implementations.CLImplementation$Compiler differentiationSource(java.lang.String) -> differentiationSource
    179:179:neureka.backend.standard.implementations.CLImplementation$Compiler kernelPostfix(java.lang.String) -> kernelPostfix
    181:184:neureka.backend.standard.implementations.CLImplementation build() -> build
neureka.backend.standard.implementations.CLImplementation$Parser -> neureka.backend.standard.implementations.CLImplementation$a:
    void apply(java.lang.String,java.lang.String,java.lang.String) -> apply
neureka.backend.standard.implementations.CLImplementation$SourceBuilder -> neureka.backend.standard.implementations.CLImplementation$SourceBuilder:
    neureka.backend.api.ImplementationFor lambda -> a
    int arity -> b
    java.lang.String kernelName -> c
    java.lang.String kernelSource -> d
    155:155:void <init>() -> <init>
    157:157:neureka.backend.standard.implementations.CLImplementation$SourceBuilder lambda(neureka.backend.api.ImplementationFor) -> lambda
    158:158:neureka.backend.standard.implementations.CLImplementation$SourceBuilder arity(int) -> arity
    159:159:neureka.backend.standard.implementations.CLImplementation$SourceBuilder kernelName(java.lang.String) -> kernelName
    160:160:neureka.backend.standard.implementations.CLImplementation$SourceBuilder kernelSource(java.lang.String) -> kernelSource
    161:161:neureka.backend.standard.implementations.CLImplementation build() -> build
neureka.backend.standard.implementations.HostImplementation -> neureka.backend.standard.implementations.HostImplementation:
    20:21:void <init>(neureka.backend.api.ImplementationFor,int) -> <init>
neureka.backend.standard.operations.ConvUtil -> neureka.backend.standard.operations.ConvUtil:
    neureka.backend.standard.algorithms.Convolution conv -> a
    boolean $assertionsDisabled -> b
    12:12:void <init>() -> <init>
    17:107:neureka.backend.standard.algorithms.Convolution createDeconvolutionFor(java.lang.String) -> createDeconvolutionFor
    111:112:neureka.backend.standard.algorithms.Convolution getConv() -> getConv
    90:104:neureka.backend.api.ExecutionCall lambda$createDeconvolutionFor$6(neureka.backend.api.ExecutionCall) -> a
    55:84:neureka.Tsr lambda$createDeconvolutionFor$5(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    34:50:neureka.autograd.ADAgent lambda$createDeconvolutionFor$4(java.lang.String,neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    50:50:neureka.Tsr lambda$createDeconvolutionFor$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    49:49:neureka.Tsr lambda$createDeconvolutionFor$2(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    21:28:boolean lambda$createDeconvolutionFor$1(neureka.backend.api.ExecutionCall) -> b
    18:18:boolean lambda$createDeconvolutionFor$0(neureka.backend.api.ExecutionCall) -> c
    12:14:void <clinit>() -> <clinit>
neureka.backend.standard.operations.JunctionUtil -> neureka.backend.standard.operations.JunctionUtil:
    11:11:void <init>() -> <init>
    17:60:neureka.Tsr forConvolution(neureka.backend.api.ExecutionCall,java.util.function.Function) -> forConvolution
    68:114:neureka.Tsr forMultiplications(neureka.backend.api.ExecutionCall,java.util.function.Function) -> forMultiplications
    123:197:neureka.Tsr forDivisionsOrModuli(neureka.backend.api.ExecutionCall,java.util.function.Function) -> forDivisionsOrModuli
    204:204:neureka.Tsr forAdditions(neureka.backend.api.ExecutionCall,java.util.function.Function) -> forAdditions
    211:211:neureka.Tsr forSubtractions(neureka.backend.api.ExecutionCall,java.util.function.Function) -> forSubtractions
    219:253:neureka.Tsr _forAdditionsOrSubtractions(neureka.backend.api.ExecutionCall,java.util.function.Function,boolean) -> a
    58:58:neureka.Tsr[] lambda$forConvolution$1(neureka.Tsr[]) -> a
    55:55:neureka.Tsr[] lambda$forConvolution$0(neureka.Tsr[]) -> b
neureka.backend.standard.operations.function.Absolute -> neureka.backend.standard.operations.function.Absolute:
    neureka.backend.api.Operation$DefaultOperatorCreator _activationCreator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _activationXCreator -> b
    19:99:void <init>() -> <init>
    103:105:java.lang.String stringify(java.lang.String[]) -> stringify
    110:110:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    115:118:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    123:124:double calculate(double,boolean) -> calculate
    86:94:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    57:67:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    68:71:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    62:65:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    48:48:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    27:29:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    29:29:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    28:28:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:23:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    23:23:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    22:22:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Cosinus -> neureka.backend.standard.operations.function.Cosinus:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    19:101:void <init>() -> <init>
    105:107:java.lang.String stringify(java.lang.String[]) -> stringify
    112:112:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    117:120:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    125:126:double calculate(double,boolean) -> calculate
    87:95:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    58:68:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    69:72:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    63:66:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    48:48:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    27:29:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    29:29:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    28:28:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:23:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    23:23:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    22:22:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Gaussian -> neureka.backend.standard.operations.function.Gaussian:
    22:164:void <init>() -> <init>
    168:170:java.lang.String stringify(java.lang.String[]) -> stringify
    175:175:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    180:183:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    188:189:double calculate(double,boolean) -> calculate
    150:158:void lambda$new$15(neureka.backend.api.ExecutionCall) -> a
    108:118:void lambda$new$14(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    119:122:void lambda$new$13(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    113:116:void lambda$new$12(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    83:97:neureka.backend.api.ExecutionCall lambda$new$11(neureka.backend.api.ExecutionCall) -> b
    80:80:neureka.Tsr lambda$new$10(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    79:79:neureka.Tsr lambda$new$9(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    77:77:neureka.autograd.ADAgent lambda$new$8(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    67:72:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> c
    64:64:boolean lambda$new$6(neureka.backend.api.ExecutionCall) -> d
    51:55:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    56:57:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    53:53:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    36:40:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    41:42:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    38:38:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Identity -> neureka.backend.standard.operations.function.Identity:
    23:221:void <init>() -> <init>
    225:227:java.lang.String stringify(java.lang.String[]) -> stringify
    232:232:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    237:240:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    245:246:double calculate(double,boolean) -> calculate
    205:214:void lambda$new$27(neureka.backend.api.ExecutionCall) -> a
    180:192:void lambda$new$26(neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    185:188:void lambda$new$25(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> a
    155:169:neureka.backend.api.ExecutionCall lambda$new$24(neureka.backend.api.ExecutionCall) -> b
    152:152:neureka.Tsr lambda$new$23(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    151:151:neureka.Tsr lambda$new$22(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    149:149:neureka.autograd.ADAgent lambda$new$21(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    139:144:boolean lambda$new$20(neureka.backend.api.ExecutionCall) -> c
    136:136:boolean lambda$new$19(neureka.backend.api.ExecutionCall) -> d
    132:133:neureka.backend.api.Operation$PrimaryNDIConsumer lambda$new$18(neureka.Tsr[],double,int) -> a
    133:133:double lambda$new$17(double,neureka.ndim.iterators.NDIterator) -> a
    132:132:double lambda$new$16(double,neureka.ndim.iterators.NDIterator) -> b
    114:124:void lambda$new$15(neureka.backend.api.ExecutionCall) -> e
    85:95:void lambda$new$14(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    96:99:void lambda$new$13(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    90:93:void lambda$new$12(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    67:74:neureka.backend.api.ExecutionCall lambda$new$11(neureka.backend.api.ExecutionCall) -> f
    64:64:neureka.Tsr lambda$new$10(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    63:63:neureka.Tsr lambda$new$9(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> b
    61:61:neureka.autograd.ADAgent lambda$new$8(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    52:57:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> g
    49:49:boolean lambda$new$6(neureka.backend.api.ExecutionCall) -> h
    43:45:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    45:45:double lambda$new$4(int[],int[],int[]) -> a
    44:44:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> a
    36:38:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    38:38:double lambda$new$1(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    37:37:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
neureka.backend.standard.operations.function.Logarithm -> neureka.backend.standard.operations.function.Logarithm:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    19:101:void <init>() -> <init>
    105:107:java.lang.String stringify(java.lang.String[]) -> stringify
    112:113:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    118:121:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    126:127:double calculate(double,boolean) -> calculate
    87:95:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    58:68:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    69:72:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    63:66:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    48:48:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    27:29:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    29:29:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    28:28:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:23:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    23:23:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    22:22:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Quadratic -> neureka.backend.standard.operations.function.Quadratic:
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorNDI -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorNDX -> b
    19:111:void <init>() -> <init>
    115:117:java.lang.String stringify(java.lang.String[]) -> stringify
    122:122:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    127:130:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    135:136:double calculate(double,boolean) -> calculate
    96:104:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    66:76:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    77:80:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    71:74:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    56:56:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    32:38:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    38:38:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    35:36:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:27:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    27:27:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    24:25:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.ReLU -> neureka.backend.standard.operations.function.ReLU:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    19:121:void <init>() -> <init>
    125:127:java.lang.String stringify(java.lang.String[]) -> stringify
    132:132:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    137:140:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    146:153:double calculate(double,boolean) -> calculate
    106:114:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    77:87:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    88:91:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    82:85:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    67:67:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    37:44:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    45:46:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    40:41:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:28:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    29:30:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    24:25:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Sigmoid -> neureka.backend.standard.operations.function.Sigmoid:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    19:107:void <init>() -> <init>
    111:113:java.lang.String stringify(java.lang.String[]) -> stringify
    118:118:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    123:126:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    131:134:double calculate(double,boolean) -> calculate
    90:98:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    61:71:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    72:75:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    66:69:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    50:50:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    28:30:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    30:30:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    29:29:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:23:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    23:23:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    22:22:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Sinus -> neureka.backend.standard.operations.function.Sinus:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    20:136:void <init>() -> <init>
    140:142:java.lang.String stringify(java.lang.String[]) -> stringify
    147:147:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    152:155:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    160:161:double calculate(double,boolean) -> calculate
    119:127:void lambda$new$15(neureka.backend.api.ExecutionCall) -> a
    90:100:void lambda$new$14(neureka.backend.api.ExecutionCall) -> b
    101:104:void lambda$new$13(neureka.backend.api.ExecutionCall,int,int) -> a
    95:98:void lambda$new$12(neureka.backend.api.ExecutionCall,int,int) -> b
    65:79:neureka.backend.api.ExecutionCall lambda$new$11(neureka.backend.api.ExecutionCall) -> c
    62:62:neureka.Tsr lambda$new$10(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    61:61:neureka.Tsr lambda$new$9(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    60:60:neureka.autograd.ADAgent lambda$new$8(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    51:56:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> d
    48:48:boolean lambda$new$6(neureka.backend.api.ExecutionCall) -> e
    29:31:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    31:31:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    30:30:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    22:24:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    24:24:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    23:23:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Softplus -> neureka.backend.standard.operations.function.Softplus:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    20:127:void <init>() -> <init>
    131:133:java.lang.String stringify(java.lang.String[]) -> stringify
    138:138:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    143:146:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    151:152:double calculate(double,boolean) -> calculate
    111:119:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    62:72:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    73:76:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    67:70:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    50:50:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    29:31:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    31:31:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    30:30:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    22:24:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    24:24:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    23:23:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Tanh -> neureka.backend.standard.operations.function.Tanh:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    19:125:void <init>() -> <init>
    129:131:java.lang.String stringify(java.lang.String[]) -> stringify
    136:136:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    141:144:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    149:153:double calculate(double,boolean) -> calculate
    108:116:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    79:89:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    90:93:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    84:87:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    69:69:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    39:46:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    47:48:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    42:43:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    22:29:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    30:31:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    25:26:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.indexer.Product -> neureka.backend.standard.operations.indexer.Product:
    28:298:void <init>() -> <init>
    304:308:java.lang.String stringify(java.lang.String[]) -> stringify
    313:313:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    319:339:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    345:364:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    281:289:void lambda$new$39(neureka.backend.api.ExecutionCall) -> a
    251:261:void lambda$new$38(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    262:265:void lambda$new$37(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    256:259:void lambda$new$36(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    225:239:neureka.backend.api.ExecutionCall lambda$new$35(neureka.backend.api.ExecutionCall) -> b
    221:221:neureka.Tsr lambda$new$34(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    182:216:neureka.autograd.ADAgent lambda$new$33(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    216:216:neureka.Tsr lambda$new$32(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    215:215:neureka.Tsr lambda$new$31(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    209:209:neureka.Tsr lambda$new$30(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    208:208:neureka.Tsr lambda$new$29(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    196:196:neureka.Tsr lambda$new$28(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    195:195:neureka.Tsr lambda$new$27(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    187:187:neureka.Tsr lambda$new$26(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    186:186:neureka.Tsr lambda$new$25(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    178:178:boolean lambda$new$24(neureka.backend.api.ExecutionCall) -> c
    177:177:boolean lambda$new$23(neureka.backend.api.ExecutionCall) -> d
    171:173:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$22(neureka.Tsr[],int) -> a
    173:173:double lambda$new$21(double[],neureka.Tsr[],int[],int[],int[]) -> a
    172:172:double lambda$new$20(double[],neureka.Tsr[],int[],int[],int[]) -> b
    164:166:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$19(neureka.Tsr[],int) -> b
    166:166:double lambda$new$18(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    165:165:double lambda$new$17(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
    144:153:void lambda$new$16(neureka.backend.api.ExecutionCall) -> e
    109:122:void lambda$new$15(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> b
    123:129:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> c
    114:120:void lambda$new$13(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> d
    81:96:neureka.autograd.ADAgent lambda$new$12(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    96:96:neureka.Tsr lambda$new$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    95:95:neureka.Tsr lambda$new$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    86:86:neureka.Tsr lambda$new$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    85:85:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    77:77:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> f
    76:76:boolean lambda$new$6(neureka.backend.api.ExecutionCall) -> g
    63:68:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> c
    69:70:double lambda$new$4(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    66:66:double lambda$new$3(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    48:53:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> d
    54:55:double lambda$new$1(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    51:51:double lambda$new$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
neureka.backend.standard.operations.indexer.Summation -> neureka.backend.standard.operations.indexer.Summation:
    28:287:void <init>() -> <init>
    291:295:java.lang.String stringify(java.lang.String[]) -> stringify
    300:300:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    305:316:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    321:339:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    270:281:void lambda$new$39(neureka.backend.api.ExecutionCall) -> a
    240:250:void lambda$new$38(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    251:254:void lambda$new$37(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    245:248:void lambda$new$36(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    215:229:neureka.backend.api.ExecutionCall lambda$new$35(neureka.backend.api.ExecutionCall) -> b
    211:211:neureka.Tsr lambda$new$34(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    172:206:neureka.autograd.ADAgent lambda$new$33(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    206:206:neureka.Tsr lambda$new$32(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    205:205:neureka.Tsr lambda$new$31(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    199:199:neureka.Tsr lambda$new$30(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    198:198:neureka.Tsr lambda$new$29(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    186:186:neureka.Tsr lambda$new$28(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    185:185:neureka.Tsr lambda$new$27(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    177:177:neureka.Tsr lambda$new$26(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    176:176:neureka.Tsr lambda$new$25(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    168:168:boolean lambda$new$24(neureka.backend.api.ExecutionCall) -> c
    167:167:boolean lambda$new$23(neureka.backend.api.ExecutionCall) -> d
    161:163:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$22(neureka.Tsr[],int) -> a
    163:163:double lambda$new$21(double[],neureka.Tsr[],int[],int[],int[]) -> a
    162:162:double lambda$new$20(double[],neureka.Tsr[],int[],int[],int[]) -> b
    154:156:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$19(neureka.Tsr[],int) -> b
    156:156:double lambda$new$18(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    155:155:double lambda$new$17(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
    133:142:void lambda$new$16(neureka.backend.api.ExecutionCall) -> e
    97:110:void lambda$new$15(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> b
    111:117:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> c
    102:108:void lambda$new$13(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> d
    68:83:neureka.autograd.ADAgent lambda$new$12(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    83:83:neureka.Tsr lambda$new$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    82:82:neureka.Tsr lambda$new$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    73:73:neureka.Tsr lambda$new$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    72:72:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    64:64:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> f
    63:63:boolean lambda$new$6(neureka.backend.api.ExecutionCall) -> g
    56:59:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> c
    59:59:double lambda$new$4(int[],int[],int[]) -> a
    58:58:double lambda$new$3(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    47:50:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> d
    50:50:double lambda$new$1(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    49:49:double lambda$new$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
neureka.backend.standard.operations.linear.MatMul -> neureka.backend.standard.operations.linear.MatMul:
    26:253:void <init>() -> <init>
    258:265:java.lang.String stringify(java.lang.String[]) -> stringify
    270:270:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    275:275:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    198:211:void lambda$new$16(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    212:216:void lambda$new$15(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    203:207:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    172:186:neureka.backend.api.ExecutionCall lambda$new$13(neureka.backend.api.ExecutionCall) -> a
    135:166:neureka.Tsr lambda$new$12(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    122:130:neureka.autograd.ADAgent lambda$new$11(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    130:130:neureka.Tsr lambda$new$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    129:129:neureka.Tsr lambda$new$9(neureka.autograd.GraphNode,neureka.Tsr) -> a
    108:115:boolean lambda$new$8(neureka.backend.api.ExecutionCall) -> b
    105:105:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> c
    91:96:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$6(neureka.Tsr[],int) -> a
    97:98:double lambda$new$5(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    94:94:double lambda$new$4(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    77:82:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$3(neureka.Tsr[],int) -> b
    83:84:double lambda$new$2(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    80:80:double lambda$new$1(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    39:71:neureka.Tsr lambda$new$0(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
neureka.backend.standard.operations.linear.XConv -> neureka.backend.standard.operations.linear.XConv:
    19:117:void <init>() -> <init>
    122:129:java.lang.String stringify(java.lang.String[]) -> stringify
    134:134:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    139:139:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    102:111:void lambda$new$9(neureka.backend.api.ExecutionCall) -> a
    66:79:void lambda$new$8(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    80:84:void lambda$new$7(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    71:75:void lambda$new$6(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    45:50:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> a
    51:52:double lambda$new$4(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    48:48:double lambda$new$3(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    32:37:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    38:39:double lambda$new$1(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    35:35:double lambda$new$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
neureka.backend.standard.operations.linear.XConvLeft -> neureka.backend.standard.operations.linear.XConvLeft:
    12:23:void <init>() -> <init>
    27:34:java.lang.String stringify(java.lang.String[]) -> stringify
    39:39:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    44:44:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.linear.XConvRight -> neureka.backend.standard.operations.linear.XConvRight:
    12:23:void <init>() -> <init>
    27:34:java.lang.String stringify(java.lang.String[]) -> stringify
    39:39:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    44:44:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Addition -> neureka.backend.standard.operations.operator.Addition:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    neureka.backend.standard.algorithms.Broadcast _broadcast -> c
    84:325:void <init>() -> <init>
    330:337:java.lang.String stringify(java.lang.String[]) -> stringify
    342:347:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    352:365:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    371:383:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    344:344:neureka.calculus.Function lambda$asDerivative$44(int,neureka.calculus.Function) -> a
    343:343:boolean lambda$asDerivative$43(int,neureka.calculus.Function) -> b
    309:318:void lambda$new$42(neureka.backend.api.ExecutionCall) -> a
    277:295:void lambda$new$41(neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    289:292:void lambda$new$40(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> a
    283:286:void lambda$new$39(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> b
    264:268:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$38(neureka.Tsr[],double,int) -> a
    268:268:double lambda$new$37(int[]) -> a
    266:266:double lambda$new$36(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    256:259:neureka.backend.api.Operation$PrimaryNDIConsumer lambda$new$35(neureka.Tsr[],double,int) -> b
    259:259:double lambda$new$34(neureka.ndim.iterators.NDIterator) -> a
    257:257:double lambda$new$33(double[],double,neureka.ndim.iterators.NDIterator) -> a
    250:250:neureka.Tsr lambda$new$32(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    248:248:neureka.autograd.ADAgent lambda$new$31(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    245:245:boolean lambda$new$30(neureka.backend.api.ExecutionCall) -> b
    244:244:boolean lambda$new$29(neureka.backend.api.ExecutionCall) -> c
    225:234:void lambda$new$28(neureka.backend.api.ExecutionCall) -> d
    195:205:void lambda$new$27(neureka.backend.api.ExecutionCall) -> e
    206:209:void lambda$new$26(neureka.backend.api.ExecutionCall,int,int) -> a
    200:203:void lambda$new$25(neureka.backend.api.ExecutionCall,int,int) -> b
    170:180:void lambda$new$24(neureka.backend.api.ExecutionCall) -> f
    133:147:void lambda$new$23(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    148:154:void lambda$new$22(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    139:145:void lambda$new$21(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    121:121:neureka.autograd.ADAgent lambda$new$20(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    110:115:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$19(neureka.Tsr[],int) -> a
    115:115:double lambda$new$18(int[]) -> b
    114:114:double lambda$new$17(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    102:105:neureka.backend.api.Operation$SecondaryNDIConsumer lambda$new$16(neureka.Tsr[],int) -> b
    105:105:double lambda$new$15(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    104:104:double lambda$new$14(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    79:79:neureka.Tsr lambda$static$13(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    60:75:neureka.autograd.ADAgent lambda$static$12(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    75:75:neureka.Tsr lambda$static$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    74:74:neureka.Tsr lambda$static$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    65:65:neureka.Tsr lambda$static$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    64:64:neureka.Tsr lambda$static$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    50:55:boolean lambda$static$7(neureka.backend.api.ExecutionCall) -> g
    48:48:boolean lambda$static$6(neureka.backend.api.ExecutionCall) -> h
    38:43:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$static$5(neureka.Tsr[],int) -> c
    43:43:double lambda$static$4(int[],int[],int[]) -> a
    42:42:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    30:33:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> d
    33:33:double lambda$static$1(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    32:32:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    28:80:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.AdditionConv -> neureka.backend.standard.operations.operator.AdditionConv:
    16:79:void <init>() -> <init>
    83:90:java.lang.String stringify(java.lang.String[]) -> stringify
    95:95:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    100:100:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    67:74:neureka.backend.api.ExecutionCall lambda$new$9(neureka.backend.api.ExecutionCall) -> a
    64:64:neureka.Tsr lambda$new$8(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    63:63:neureka.Tsr lambda$new$7(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    43:59:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    59:59:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    58:58:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    48:48:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    47:47:neureka.Tsr lambda$new$2(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    32:37:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> b
    29:29:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> c
neureka.backend.standard.operations.operator.AdditionLeftConv -> neureka.backend.standard.operations.operator.AdditionLeftConv:
    10:20:void <init>() -> <init>
    24:24:java.lang.String stringify(java.lang.String[]) -> stringify
    29:29:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    34:34:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.AdditionRightConv -> neureka.backend.standard.operations.operator.AdditionRightConv:
    10:20:void <init>() -> <init>
    24:24:java.lang.String stringify(java.lang.String[]) -> stringify
    29:29:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    34:34:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Division -> neureka.backend.standard.operations.operator.Division:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    64:375:void <init>() -> <init>
    383:390:java.lang.String stringify(java.lang.String[]) -> stringify
    395:395:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    399:421:java.lang.String _asDerivative(neureka.calculus.Function[],int,int) -> a
    427:445:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    451:472:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    361:370:void lambda$new$43(neureka.backend.api.ExecutionCall) -> a
    324:342:void lambda$new$42(neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    336:339:void lambda$new$41(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> a
    330:333:void lambda$new$40(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> b
    314:314:neureka.Tsr lambda$new$39(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    312:312:neureka.autograd.ADAgent lambda$new$38(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    309:309:boolean lambda$new$37(neureka.backend.api.ExecutionCall) -> b
    308:308:boolean lambda$new$36(neureka.backend.api.ExecutionCall) -> c
    297:303:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$35(neureka.Tsr[],double,int) -> a
    303:303:double lambda$new$34(double,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    302:302:double lambda$new$33(double,int[]) -> a
    300:300:double lambda$new$32(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    286:291:neureka.backend.api.Operation$PrimaryNDIConsumer lambda$new$31(neureka.Tsr[],double,int) -> b
    291:291:double lambda$new$30(double,double[],neureka.ndim.iterators.NDIterator) -> a
    290:290:double lambda$new$29(double,neureka.ndim.iterators.NDIterator) -> a
    288:288:double lambda$new$28(double[],double,neureka.ndim.iterators.NDIterator) -> a
    266:275:void lambda$new$27(neureka.backend.api.ExecutionCall) -> d
    231:241:void lambda$new$26(neureka.backend.api.ExecutionCall) -> e
    242:245:void lambda$new$25(neureka.backend.api.ExecutionCall,int,int) -> a
    236:239:void lambda$new$24(neureka.backend.api.ExecutionCall,int,int) -> b
    203:218:neureka.autograd.ADAgent lambda$new$23(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    218:218:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    217:217:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    208:208:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    207:207:neureka.Tsr lambda$new$19(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    193:198:boolean lambda$new$18(neureka.backend.api.ExecutionCall) -> f
    191:191:boolean lambda$new$17(neureka.backend.api.ExecutionCall) -> g
    171:180:void lambda$new$16(neureka.backend.api.ExecutionCall) -> h
    129:142:void lambda$new$15(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    143:149:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    134:140:void lambda$new$13(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    117:117:neureka.autograd.ADAgent lambda$new$12(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    99:104:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$11(neureka.Tsr[],int) -> a
    105:108:double lambda$new$10(int,double[],neureka.Tsr[],double[],int[]) -> a
    102:102:double lambda$new$9(double[],neureka.Tsr[],double[],int[]) -> a
    82:87:neureka.backend.api.Operation$SecondaryNDIConsumer lambda$new$8(neureka.Tsr[],int) -> b
    88:91:double lambda$new$7(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    85:85:double lambda$new$6(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    45:52:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$static$5(neureka.Tsr[],int) -> c
    53:56:double lambda$static$4(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    50:50:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    28:33:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> d
    34:37:double lambda$static$1(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    31:31:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    26:43:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.DivisionConv -> neureka.backend.standard.operations.operator.DivisionConv:
    16:79:void <init>() -> <init>
    83:90:java.lang.String stringify(java.lang.String[]) -> stringify
    95:95:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    100:100:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    67:74:neureka.backend.api.ExecutionCall lambda$new$9(neureka.backend.api.ExecutionCall) -> a
    64:64:neureka.Tsr lambda$new$8(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    63:63:neureka.Tsr lambda$new$7(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    43:59:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    59:59:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    58:58:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    48:48:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    47:47:neureka.Tsr lambda$new$2(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    32:37:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> b
    29:29:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> c
neureka.backend.standard.operations.operator.DivisionLeftConv -> neureka.backend.standard.operations.operator.DivisionLeftConv:
    10:20:void <init>() -> <init>
    24:31:java.lang.String stringify(java.lang.String[]) -> stringify
    36:36:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    41:41:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.DivisionRightConv -> neureka.backend.standard.operations.operator.DivisionRightConv:
    10:20:void <init>() -> <init>
    24:31:java.lang.String stringify(java.lang.String[]) -> stringify
    36:36:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    41:41:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Modulo -> neureka.backend.standard.operations.operator.Modulo:
    27:388:void <init>() -> <init>
    394:401:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    408:415:java.lang.String stringify(java.lang.String[]) -> stringify
    420:420:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    425:434:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    373:382:void lambda$new$45(neureka.backend.api.ExecutionCall) -> a
    335:353:void lambda$new$44(neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    347:350:void lambda$new$43(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> a
    341:344:void lambda$new$42(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> b
    326:326:neureka.Tsr lambda$new$41(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    325:325:neureka.Tsr lambda$new$40(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    323:323:neureka.autograd.ADAgent lambda$new$39(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    313:318:boolean lambda$new$38(neureka.backend.api.ExecutionCall) -> b
    310:310:boolean lambda$new$37(neureka.backend.api.ExecutionCall) -> c
    299:305:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$36(neureka.Tsr[],double,int) -> a
    305:305:double lambda$new$35(double,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    304:304:double lambda$new$34(double,int[]) -> a
    302:302:double lambda$new$33(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    288:293:neureka.backend.api.Operation$PrimaryNDIConsumer lambda$new$32(neureka.Tsr[],double,int) -> b
    293:293:double lambda$new$31(double,double[],neureka.ndim.iterators.NDIterator) -> a
    292:292:double lambda$new$30(double,neureka.ndim.iterators.NDIterator) -> a
    290:290:double lambda$new$29(double[],double,neureka.ndim.iterators.NDIterator) -> a
    268:277:void lambda$new$28(neureka.backend.api.ExecutionCall) -> d
    232:242:void lambda$new$27(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    243:246:void lambda$new$26(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    237:240:void lambda$new$25(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    223:223:neureka.Tsr lambda$new$24(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    204:219:neureka.autograd.ADAgent lambda$new$23(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    219:219:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    218:218:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    209:209:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    208:208:neureka.Tsr lambda$new$19(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    193:198:boolean lambda$new$18(neureka.backend.api.ExecutionCall) -> e
    190:190:boolean lambda$new$17(neureka.backend.api.ExecutionCall) -> f
    173:180:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$new$16(neureka.Tsr[],int) -> a
    181:184:double lambda$new$15(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    178:178:double lambda$new$14(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    153:158:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$13(neureka.Tsr[],int) -> b
    159:165:double lambda$new$12(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    156:156:double lambda$new$11(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    131:140:void lambda$new$10(neureka.backend.api.ExecutionCall) -> g
    90:103:void lambda$new$9(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> b
    104:110:void lambda$new$8(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> c
    95:101:void lambda$new$7(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> d
    79:79:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    60:66:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$5(neureka.Tsr[],int) -> c
    67:70:double lambda$new$4(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    64:64:double lambda$new$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    45:49:neureka.backend.api.Operation$SecondaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> d
    50:53:double lambda$new$1(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    47:47:double lambda$new$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
neureka.backend.standard.operations.operator.Multiplication -> neureka.backend.standard.operations.operator.Multiplication:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    neureka.backend.api.Operation$DefaultOperatorCreator xBCCreator -> xBCCreator
    neureka.backend.api.Operation$DefaultOperatorCreator xBCCreatorX -> xBCCreatorX
    72:387:void <init>() -> <init>
    393:400:java.lang.String stringify(java.lang.String[]) -> stringify
    405:417:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    422:441:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    447:465:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    408:413:java.lang.String lambda$asDerivative$54(int,neureka.calculus.Function[],neureka.calculus.Function) -> a
    411:411:boolean lambda$asDerivative$53(neureka.calculus.Function,neureka.calculus.Function) -> a
    406:406:boolean lambda$asDerivative$52(int,neureka.calculus.Function) -> a
    372:381:void lambda$new$51(neureka.backend.api.ExecutionCall) -> a
    340:358:void lambda$new$50(neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    352:355:void lambda$new$49(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> a
    346:349:void lambda$new$48(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> b
    330:330:neureka.Tsr lambda$new$47(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    305:326:neureka.autograd.ADAgent lambda$new$46(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    326:326:neureka.Tsr lambda$new$45(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    325:325:neureka.Tsr lambda$new$44(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    318:318:neureka.Tsr lambda$new$43(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    309:309:neureka.Tsr lambda$new$42(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    301:301:boolean lambda$new$41(neureka.backend.api.ExecutionCall) -> b
    300:300:boolean lambda$new$40(neureka.backend.api.ExecutionCall) -> c
    290:295:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$39(neureka.Tsr[],double,int) -> a
    295:295:double lambda$new$38(double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    294:294:double lambda$new$37(double,int[]) -> a
    292:292:double lambda$new$36(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    280:284:neureka.backend.api.Operation$PrimaryNDIConsumer lambda$new$35(neureka.Tsr[],double,int) -> b
    284:284:double lambda$new$34(double[],neureka.ndim.iterators.NDIterator) -> a
    283:283:double lambda$new$33(double,neureka.ndim.iterators.NDIterator) -> a
    281:281:double lambda$new$32(double[],double,neureka.ndim.iterators.NDIterator) -> a
    257:266:void lambda$new$31(neureka.backend.api.ExecutionCall) -> d
    227:237:void lambda$new$30(neureka.backend.api.ExecutionCall) -> e
    238:241:void lambda$new$29(neureka.backend.api.ExecutionCall,int,int) -> a
    232:235:void lambda$new$28(neureka.backend.api.ExecutionCall,int,int) -> b
    198:213:neureka.autograd.ADAgent lambda$new$27(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    213:213:neureka.Tsr lambda$new$26(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    212:212:neureka.Tsr lambda$new$25(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    203:203:neureka.Tsr lambda$new$24(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    202:202:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    194:194:boolean lambda$new$22(neureka.backend.api.ExecutionCall) -> f
    193:193:boolean lambda$new$21(neureka.backend.api.ExecutionCall) -> g
    173:182:void lambda$new$20(neureka.backend.api.ExecutionCall) -> h
    137:150:void lambda$new$19(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    151:157:void lambda$new$18(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    142:148:void lambda$new$17(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    126:126:neureka.autograd.ADAgent lambda$new$16(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    107:116:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$15(neureka.Tsr[],int) -> a
    117:118:double lambda$new$14(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    114:114:double lambda$new$13(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    90:97:neureka.backend.api.Operation$SecondaryNDIConsumer lambda$new$12(neureka.Tsr[],int) -> b
    98:99:double lambda$new$11(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    95:95:double lambda$new$10(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    63:67:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$static$9(neureka.Tsr[],int) -> c
    67:67:double lambda$static$8(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    56:58:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$static$7(neureka.Tsr[],int) -> d
    58:58:double lambda$static$6(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    40:47:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$static$5(neureka.Tsr[],int) -> e
    48:49:double lambda$static$4(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    45:45:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> b
    32:35:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> f
    35:35:double lambda$static$1(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    34:34:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
    30:61:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.MultiplicationLeftConv -> neureka.backend.standard.operations.operator.MultiplicationLeftConv:
    20:130:void <init>() -> <init>
    134:134:java.lang.String stringify(java.lang.String[]) -> stringify
    139:139:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    144:144:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    116:125:void lambda$new$12(neureka.backend.api.ExecutionCall) -> a
    87:97:void lambda$new$11(neureka.backend.api.ExecutionCall) -> b
    98:101:void lambda$new$10(neureka.backend.api.ExecutionCall,int,int) -> a
    92:95:void lambda$new$9(neureka.backend.api.ExecutionCall,int,int) -> b
    68:75:neureka.backend.api.ExecutionCall lambda$new$8(neureka.backend.api.ExecutionCall) -> c
    65:65:neureka.Tsr lambda$new$7(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    64:64:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    45:60:neureka.autograd.ADAgent lambda$new$5(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    60:60:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    59:59:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    49:49:neureka.Tsr lambda$new$2(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    35:40:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> d
    32:32:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> e
neureka.backend.standard.operations.operator.MultiplicationRightConv -> neureka.backend.standard.operations.operator.MultiplicationRightConv:
    21:134:void <init>() -> <init>
    138:138:java.lang.String stringify(java.lang.String[]) -> stringify
    143:143:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    148:148:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    119:128:void lambda$new$13(neureka.backend.api.ExecutionCall) -> a
    89:99:void lambda$new$12(neureka.backend.api.ExecutionCall) -> b
    100:103:void lambda$new$11(neureka.backend.api.ExecutionCall,int,int) -> a
    94:97:void lambda$new$10(neureka.backend.api.ExecutionCall,int,int) -> b
    70:78:neureka.backend.api.ExecutionCall lambda$new$9(neureka.backend.api.ExecutionCall) -> c
    67:67:neureka.Tsr lambda$new$8(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    66:66:neureka.Tsr lambda$new$7(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    47:62:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    62:62:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    61:61:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    52:52:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    51:51:neureka.Tsr lambda$new$2(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    36:41:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> d
    33:33:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> e
neureka.backend.standard.operations.operator.Power -> neureka.backend.standard.operations.operator.Power:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    75:482:void <init>() -> <init>
    491:496:java.lang.String stringify(java.lang.String[]) -> stringify
    501:530:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    535:557:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    563:588:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    504:504:java.lang.String lambda$asDerivative$45(neureka.calculus.Function[],int) -> a
    466:475:void lambda$new$44(neureka.backend.api.ExecutionCall) -> a
    428:446:void lambda$new$43(neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    440:443:void lambda$new$42(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> a
    434:437:void lambda$new$41(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> b
    418:418:neureka.Tsr lambda$new$40(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    416:416:neureka.autograd.ADAgent lambda$new$39(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    413:413:boolean lambda$new$38(neureka.backend.api.ExecutionCall) -> b
    412:412:boolean lambda$new$37(neureka.backend.api.ExecutionCall) -> c
    402:407:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$36(neureka.Tsr[],double,int) -> a
    407:407:double lambda$new$35(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    406:406:double lambda$new$34(double,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    404:404:double lambda$new$33(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> b
    392:396:neureka.backend.api.Operation$PrimaryNDIConsumer lambda$new$32(neureka.Tsr[],double,int) -> b
    396:396:double lambda$new$31(double[],double,neureka.ndim.iterators.NDIterator) -> a
    395:395:double lambda$new$30(double,double[],neureka.ndim.iterators.NDIterator) -> a
    393:393:double lambda$new$29(double[],double,neureka.ndim.iterators.NDIterator) -> b
    372:381:void lambda$new$28(neureka.backend.api.ExecutionCall) -> d
    336:346:void lambda$new$27(neureka.backend.api.ExecutionCall) -> e
    347:350:void lambda$new$26(neureka.backend.api.ExecutionCall,int,int) -> a
    341:344:void lambda$new$25(neureka.backend.api.ExecutionCall,int,int) -> b
    308:323:neureka.autograd.ADAgent lambda$new$24(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    323:323:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    322:322:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    313:313:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    312:312:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    304:304:boolean lambda$new$19(neureka.backend.api.ExecutionCall) -> f
    303:303:boolean lambda$new$18(neureka.backend.api.ExecutionCall) -> g
    282:293:void lambda$new$17(neureka.backend.api.ExecutionCall) -> h
    240:253:void lambda$new$16(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    254:260:void lambda$new$15(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    245:251:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    230:230:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    133:221:neureka.Tsr lambda$new$12(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    114:121:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$11(neureka.Tsr[],int) -> a
    123:126:double lambda$new$10(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int,int[]) -> a
    119:119:double lambda$new$9(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    91:96:neureka.backend.api.Operation$SecondaryNDIConsumer lambda$new$8(neureka.Tsr[],int) -> b
    98:107:double lambda$new$7(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    94:94:double lambda$new$6(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    54:61:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$static$5(neureka.Tsr[],int) -> c
    62:67:double lambda$static$4(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    59:59:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    31:35:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> d
    36:46:double lambda$static$1(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    33:33:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    29:52:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.PowerConv -> neureka.backend.standard.operations.operator.PowerConv:
    16:80:void <init>() -> <init>
    84:91:java.lang.String stringify(java.lang.String[]) -> stringify
    96:96:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    101:101:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    67:75:neureka.backend.api.ExecutionCall lambda$new$9(neureka.backend.api.ExecutionCall) -> a
    64:64:neureka.Tsr lambda$new$8(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    63:63:neureka.Tsr lambda$new$7(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    43:59:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    59:59:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    58:58:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    48:48:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    47:47:neureka.Tsr lambda$new$2(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    33:38:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> b
    30:30:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> c
neureka.backend.standard.operations.operator.PowerLeftConv -> neureka.backend.standard.operations.operator.PowerLeftConv:
    10:20:void <init>() -> <init>
    24:24:java.lang.String stringify(java.lang.String[]) -> stringify
    29:29:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    34:34:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.PowerRightConv -> neureka.backend.standard.operations.operator.PowerRightConv:
    10:20:void <init>() -> <init>
    24:24:java.lang.String stringify(java.lang.String[]) -> stringify
    29:29:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    34:34:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Subtraction -> neureka.backend.standard.operations.operator.Subtraction:
    neureka.backend.api.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.Operation$DefaultOperatorCreator _creatorX -> b
    60:335:void <init>() -> <init>
    341:348:java.lang.String stringify(java.lang.String[]) -> stringify
    353:358:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    363:380:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    386:402:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    356:356:neureka.calculus.Function lambda$asDerivative$45(int,neureka.calculus.Function) -> a
    355:355:boolean lambda$asDerivative$44(int,neureka.calculus.Function) -> b
    321:330:void lambda$new$43(neureka.backend.api.ExecutionCall) -> a
    292:302:void lambda$new$42(neureka.backend.api.ExecutionCall) -> b
    303:306:void lambda$new$41(neureka.backend.api.ExecutionCall,int,int) -> a
    297:300:void lambda$new$40(neureka.backend.api.ExecutionCall,int,int) -> b
    263:278:neureka.autograd.ADAgent lambda$new$39(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    278:278:neureka.Tsr lambda$new$38(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    277:277:neureka.Tsr lambda$new$37(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    268:268:neureka.Tsr lambda$new$36(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    267:267:neureka.Tsr lambda$new$35(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    259:259:boolean lambda$new$34(neureka.backend.api.ExecutionCall) -> c
    258:258:boolean lambda$new$33(neureka.backend.api.ExecutionCall) -> d
    239:248:void lambda$new$32(neureka.backend.api.ExecutionCall) -> e
    201:220:void lambda$new$31(neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    214:217:void lambda$new$30(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> a
    208:211:void lambda$new$29(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> b
    191:191:neureka.Tsr lambda$new$28(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    189:189:neureka.autograd.ADAgent lambda$new$27(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    186:186:boolean lambda$new$26(neureka.backend.api.ExecutionCall) -> f
    185:185:boolean lambda$new$25(neureka.backend.api.ExecutionCall) -> g
    178:181:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$24(neureka.Tsr[],double,int) -> a
    181:181:double lambda$new$23(int[]) -> a
    181:181:double lambda$new$22(int[]) -> b
    180:180:double lambda$new$21(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    171:173:neureka.backend.api.Operation$PrimaryNDIConsumer lambda$new$20(neureka.Tsr[],double,int) -> b
    173:173:double lambda$new$19(neureka.ndim.iterators.NDIterator) -> a
    173:173:double lambda$new$18(neureka.ndim.iterators.NDIterator) -> b
    172:172:double lambda$new$17(double[],double,neureka.ndim.iterators.NDIterator) -> a
    151:160:void lambda$new$16(neureka.backend.api.ExecutionCall) -> h
    110:123:void lambda$new$15(neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    124:130:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> a
    115:121:void lambda$new$13(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$DefaultOperatorCreator,int,int) -> b
    99:99:neureka.autograd.ADAgent lambda$new$12(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    87:93:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$11(neureka.Tsr[],int) -> a
    93:93:double lambda$new$10(int,int[]) -> a
    92:92:double lambda$new$9(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    79:83:neureka.backend.api.Operation$SecondaryNDIConsumer lambda$new$8(neureka.Tsr[],int) -> b
    83:83:double lambda$new$7(int,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    82:82:double lambda$new$6(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    44:51:neureka.backend.api.Operation$TertiaryNDAConsumer lambda$static$5(neureka.Tsr[],int) -> c
    52:53:double lambda$static$4(int,int[],int[],int[]) -> a
    49:49:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    30:35:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> d
    36:37:double lambda$static$1(int,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    33:33:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    28:42:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.SubtractionConv -> neureka.backend.standard.operations.operator.SubtractionConv:
    10:20:void <init>() -> <init>
    24:31:java.lang.String stringify(java.lang.String[]) -> stringify
    36:36:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    41:41:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.SubtractionLeftConv -> neureka.backend.standard.operations.operator.SubtractionLeftConv:
    10:20:void <init>() -> <init>
    24:24:java.lang.String stringify(java.lang.String[]) -> stringify
    29:29:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    34:34:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.SubtractionRightConv -> neureka.backend.standard.operations.operator.SubtractionRightConv:
    10:20:void <init>() -> <init>
    24:24:java.lang.String stringify(java.lang.String[]) -> stringify
    29:29:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    34:34:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.other.CopyLeft -> neureka.backend.standard.operations.other.CopyLeft:
    20:186:void <init>() -> <init>
    191:196:java.lang.String stringify(java.lang.String[]) -> stringify
    201:201:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    206:206:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    178:183:void lambda$new$22(neureka.backend.api.ExecutionCall) -> a
    166:171:void lambda$new$21(neureka.backend.api.ExecutionCall) -> b
    145:153:neureka.backend.api.ExecutionCall lambda$new$20(neureka.backend.api.ExecutionCall) -> c
    141:141:neureka.Tsr lambda$new$19(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    140:140:neureka.Tsr lambda$new$18(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    138:138:neureka.autograd.ADAgent lambda$new$17(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    135:135:boolean lambda$new$16(neureka.backend.api.ExecutionCall) -> d
    134:134:boolean lambda$new$15(neureka.backend.api.ExecutionCall) -> e
    118:127:void lambda$new$14(neureka.backend.api.ExecutionCall) -> f
    87:105:void lambda$new$13(neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    99:102:void lambda$new$12(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> a
    93:96:void lambda$new$11(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,double,int,int) -> b
    75:77:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$10(neureka.Tsr[],double,int) -> a
    76:76:double lambda$new$9(double[],neureka.Tsr[],double,int[]) -> a
    68:70:neureka.backend.api.Operation$PrimaryNDIConsumer lambda$new$8(neureka.Tsr[],double,int) -> b
    69:69:double lambda$new$7(double[],double,neureka.ndim.iterators.NDIterator) -> a
    51:61:neureka.backend.api.ExecutionCall lambda$new$6(neureka.backend.api.ExecutionCall) -> g
    47:47:neureka.Tsr lambda$new$5(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    46:46:neureka.Tsr lambda$new$4(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> b
    44:44:neureka.autograd.ADAgent lambda$new$3(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    41:41:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> h
    40:40:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> i
    35:37:float lambda$new$0(neureka.backend.api.ExecutionCall) -> j
neureka.backend.standard.operations.other.CopyRight -> neureka.backend.standard.operations.other.CopyRight:
    19:106:void <init>() -> <init>
    110:117:java.lang.String stringify(java.lang.String[]) -> stringify
    122:122:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    127:127:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    89:103:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    68:83:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    49:58:neureka.backend.api.ExecutionCall lambda$new$8(neureka.backend.api.ExecutionCall) -> c
    46:46:neureka.Tsr lambda$new$7(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    45:45:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    43:43:neureka.autograd.ADAgent lambda$new$5(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    40:40:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> d
    39:39:boolean lambda$new$3(neureka.backend.api.ExecutionCall) -> e
    32:34:neureka.backend.api.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> a
    34:34:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    33:33:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.other.DimFit -> neureka.backend.standard.operations.other.DimFit:
    boolean $assertionsDisabled -> a
    18:118:void <init>() -> <init>
    123:127:java.lang.String stringify(java.lang.String[]) -> stringify
    132:132:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    137:137:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    111:111:neureka.backend.api.ExecutionCall lambda$new$6(neureka.backend.api.ExecutionCall) -> a
    110:110:neureka.Tsr lambda$new$5(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    53:95:neureka.Tsr lambda$new$4(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    39:45:neureka.autograd.ADAgent lambda$new$3(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    32:32:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    31:31:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    30:30:float lambda$new$0(neureka.backend.api.ExecutionCall) -> d
    13:13:void <clinit>() -> <clinit>
neureka.backend.standard.operations.other.DimTrim -> neureka.backend.standard.operations.other.DimTrim:
    boolean $assertionsDisabled -> a
    23:78:void <init>() -> <init>
    81:120:neureka.Tsr pad(neureka.Tsr,int[],boolean) -> pad
    125:154:neureka.Tsr trim(neureka.Tsr,int[],boolean) -> trim
    160:164:java.lang.String stringify(java.lang.String[]) -> stringify
    169:169:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    174:174:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    149:149:int lambda$trim$18(java.lang.Integer) -> a
    148:148:int lambda$trim$17(java.lang.Integer) -> b
    147:147:int lambda$trim$16(java.lang.Integer) -> c
    146:146:int lambda$trim$15(java.lang.Integer) -> d
    145:145:int lambda$trim$14(java.lang.Integer) -> e
    117:117:int lambda$pad$13(java.lang.Integer) -> f
    116:116:int lambda$pad$12(java.lang.Integer) -> g
    115:115:int lambda$pad$11(java.lang.Integer) -> h
    114:114:int lambda$pad$10(java.lang.Integer) -> i
    113:113:int lambda$pad$9(java.lang.Integer) -> j
    70:70:neureka.backend.api.ExecutionCall lambda$new$8(neureka.backend.api.ExecutionCall) -> a
    69:69:neureka.Tsr lambda$new$7(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    55:65:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    41:49:neureka.autograd.ADAgent lambda$new$5(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    49:49:neureka.Tsr lambda$new$4(int,int,neureka.autograd.GraphNode,neureka.Tsr) -> a
    48:48:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    37:37:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    36:36:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    35:35:float lambda$new$0(neureka.backend.api.ExecutionCall) -> d
    18:18:void <clinit>() -> <clinit>
neureka.backend.standard.operations.other.Randomization -> neureka.backend.standard.operations.other.Randomization:
    22:126:void <init>() -> <init>
    130:134:java.lang.String stringify(java.lang.String[]) -> stringify
    139:139:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    144:144:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    96:110:void lambda$new$12(neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    111:117:void lambda$new$11(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,int,int) -> a
    101:107:void lambda$new$10(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation$ScalarOperatorCreator,int,int) -> b
    78:86:neureka.backend.api.ExecutionCall lambda$new$9(neureka.backend.api.ExecutionCall) -> a
    75:75:neureka.Tsr lambda$new$8(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    74:74:neureka.Tsr lambda$new$7(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    72:72:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    60:67:boolean lambda$new$5(neureka.backend.api.ExecutionCall) -> b
    57:57:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> c
    47:47:neureka.backend.api.Operation$PrimaryNDAConsumer lambda$new$3(neureka.Tsr[],double,int) -> a
    48:52:double lambda$new$2(double,int[]) -> a
    35:35:neureka.backend.api.Operation$PrimaryNDIConsumer lambda$new$1(neureka.Tsr[],double,int) -> b
    36:41:double lambda$new$0(double,neureka.ndim.iterators.NDIterator) -> a
neureka.backend.standard.operations.other.Reshape -> neureka.backend.standard.operations.other.Reshape:
    24:74:void <init>() -> <init>
    79:88:neureka.Tsr reshaped(neureka.Tsr,int[],boolean) -> reshaped
    93:107:int[] invert(int[]) -> invert
    112:140:java.lang.String stringify(java.lang.String[]) -> stringify
    145:145:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    151:151:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    116:118:java.lang.Boolean lambda$stringify$9(java.lang.String) -> a
    66:66:neureka.backend.api.ExecutionCall lambda$new$8(neureka.backend.api.ExecutionCall) -> a
    65:65:neureka.Tsr lambda$new$7(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    53:62:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    43:48:neureka.autograd.ADAgent lambda$new$5(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    48:48:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    47:47:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    38:38:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    37:37:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    36:36:float lambda$new$0(neureka.backend.api.ExecutionCall) -> d
neureka.calculus.AbstractBaseFunction -> neureka.calculus.AbstractBaseFunction:
    46:46:void <init>() -> <init>
    51:51:double call(double) -> call
    56:56:neureka.Tsr call(neureka.Tsr) -> call
    63:63:neureka.Tsr call(java.util.List) -> call
    68:68:neureka.Tsr invoke(java.util.List) -> invoke
    75:75:double invoke(double) -> invoke
    80:80:double invoke(double[],int) -> invoke
    85:85:double invoke(double[]) -> invoke
    92:92:neureka.Tsr invoke(neureka.Tsr) -> invoke
    97:97:neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    102:102:neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    109:109:neureka.Tsr derive(java.util.List,int,int) -> derive
    114:114:neureka.Tsr derive(java.util.List,int) -> derive
    121:121:neureka.Tsr call(neureka.Tsr[],int) -> call
    126:126:neureka.Tsr call(neureka.Tsr[]) -> call
    131:131:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    136:136:neureka.Tsr derive(neureka.Tsr[],int) -> derive
neureka.calculus.Cache -> neureka.calculus.Cache:
    neureka.calculus.Cache _cache -> a
    org.slf4j.Logger _log -> b
    java.util.Map functionCache -> c
    java.util.Map functionResultCache -> d
    48:67:void <init>() -> <init>
    56:58:neureka.calculus.Cache instance() -> instance
    64:64:java.util.Map functions() -> functions
    71:73:void free(neureka.autograd.GraphLock) -> free
    81:112:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier,int,int) -> preprocess
    117:125:neureka.Tsr _get(neureka.Tsr[],int,int) -> a
    130:146:void _put(neureka.Tsr,neureka.autograd.GraphNode,int,int) -> a
    150:156:long _keyOf(neureka.Tsr[],int,int) -> b
    160:160:int _keyed(int) -> a
    141:141:int lambda$_put$2(java.lang.Long,java.lang.Long) -> a
    100:100:java.lang.Object lambda$preprocess$1(neureka.Tsr) -> a
    67:67:int lambda$new$0(neureka.autograd.GraphLock,neureka.autograd.GraphLock) -> a
    47:47:void <clinit>() -> <clinit>
neureka.calculus.Function -> neureka.calculus.Function:
    80:80:neureka.calculus.Function of(java.lang.String) -> of
    94:94:neureka.calculus.Function of(java.lang.String,boolean) -> of
    neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    boolean isDoingAD() -> isDoingAD
    boolean isFlat() -> isFlat
    neureka.backend.api.Operation getOperation() -> getOperation
    boolean dependsOn(int) -> dependsOn
    neureka.calculus.Function getDerivative(int) -> getDerivative
    java.util.List getSubFunctions() -> getSubFunctions
    182:182:java.util.List getAllFunctions() -> getAllFunctions
    186:192:int numberOfArgs() -> numberOfArgs
    196:198:java.util.List _unpack(java.util.List) -> _unpack
    202:204:void __unpack(java.util.List,java.util.List) -> __unpack
    double call(double) -> call
    double invoke(double) -> invoke
    double call(double[],int) -> call
    double invoke(double[],int) -> invoke
    double call(double[]) -> call
    double invoke(double[]) -> invoke
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    neureka.Tsr execute(neureka.Tsr[]) -> execute
    neureka.Tsr execute(neureka.Tsr[],int) -> execute
    neureka.Tsr executeDerive(neureka.Tsr[],int,int) -> executeDerive
    neureka.Tsr executeDerive(neureka.Tsr[],int) -> executeDerive
    neureka.Tsr call(neureka.Tsr) -> call
    neureka.Tsr invoke(neureka.Tsr) -> invoke
    neureka.Tsr call(java.util.List) -> call
    neureka.Tsr invoke(java.util.List) -> invoke
    neureka.Tsr call(neureka.Tsr[],int) -> call
    neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    neureka.Tsr call(neureka.Tsr[]) -> call
    neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    neureka.Tsr derive(neureka.Tsr[],int) -> derive
    neureka.Tsr derive(java.util.List,int,int) -> derive
    neureka.Tsr derive(java.util.List,int) -> derive
    java.lang.String toString() -> toString
    189:189:neureka.calculus.implementations.FunctionInput lambda$numberOfArgs$1(neureka.calculus.Function) -> a
    188:188:boolean lambda$numberOfArgs$0(neureka.calculus.Function) -> b
neureka.calculus.Function$Setup -> neureka.calculus.Function$Setup:
    101:101:void <init>() -> <init>
    105:105:neureka.Tsr commit(neureka.Tsr[],java.lang.String,boolean) -> commit
    110:110:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],java.lang.String,boolean) -> commit
    115:115:neureka.Tsr commit(neureka.Tsr[],neureka.calculus.Function) -> commit
    120:120:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function) -> commit
    125:149:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier) -> commit
    130:130:java.lang.Object lambda$commit$0(neureka.Tsr) -> a
neureka.calculus.Functions -> neureka.calculus.Functions:
    neureka.calculus.Function dimTrim -> a
    neureka.calculus.Function idy -> b
    neureka.calculus.Function conv -> c
    neureka.calculus.Function plus -> d
    neureka.calculus.Function plusAssign -> e
    neureka.calculus.Function minus -> f
    neureka.calculus.Function minusAssign -> g
    neureka.calculus.Function div -> h
    neureka.calculus.Function divAssign -> i
    neureka.calculus.Function pow -> j
    neureka.calculus.Function powAssign -> k
    neureka.calculus.Function mul -> l
    neureka.calculus.Function mulAssign -> m
    neureka.calculus.Function add -> n
    neureka.calculus.Function addAssign -> o
    neureka.calculus.Function mod -> p
    neureka.calculus.Function modAssign -> q
    neureka.calculus.Function neg -> r
    24:43:void <init>(boolean) -> <init>
    46:46:neureka.calculus.Function getDimTrim() -> getDimTrim
    48:48:neureka.calculus.Function getIdy() -> getIdy
    50:50:neureka.calculus.Function getConv() -> getConv
    52:52:neureka.calculus.Function getPlus() -> getPlus
    54:54:neureka.calculus.Function getPlusAssign() -> getPlusAssign
    56:56:neureka.calculus.Function getMinus() -> getMinus
    58:58:neureka.calculus.Function getMinusAssign() -> getMinusAssign
    60:60:neureka.calculus.Function getDiv() -> getDiv
    62:62:neureka.calculus.Function getDivAssign() -> getDivAssign
    64:64:neureka.calculus.Function getPow() -> getPow
    66:66:neureka.calculus.Function getPowAssign() -> getPowAssign
    68:68:neureka.calculus.Function getMul() -> getMul
    70:70:neureka.calculus.Function getMulAssign() -> getMulAssign
    72:72:neureka.calculus.Function getAdd() -> getAdd
    74:74:neureka.calculus.Function getAddAssign() -> getAddAssign
    76:76:neureka.calculus.Function getMod() -> getMod
    78:78:neureka.calculus.Function getModAssign() -> getModAssign
    80:80:neureka.calculus.Function getNeg() -> getNeg
    83:83:neureka.calculus.Function dimTrim() -> dimTrim
    87:87:neureka.calculus.Function idy() -> idy
    91:91:neureka.calculus.Function conv() -> conv
    95:95:neureka.calculus.Function plus() -> plus
    99:99:neureka.calculus.Function plusAssign() -> plusAssign
    103:103:neureka.calculus.Function minus() -> minus
    107:107:neureka.calculus.Function minusAssign() -> minusAssign
    111:111:neureka.calculus.Function div() -> div
    115:115:neureka.calculus.Function divAssign() -> divAssign
    119:119:neureka.calculus.Function pow() -> pow
    123:123:neureka.calculus.Function powAssign() -> powAssign
    127:127:neureka.calculus.Function mul() -> mul
    131:131:neureka.calculus.Function mulAssign() -> mulAssign
    135:135:neureka.calculus.Function add() -> add
    139:139:neureka.calculus.Function addAssign() -> addAssign
    143:143:neureka.calculus.Function mod() -> mod
    147:147:neureka.calculus.Function modAssign() -> modAssign
    151:151:neureka.calculus.Function neg() -> neg
neureka.calculus.assembly.FunctionBuilder -> neureka.calculus.assembly.FunctionBuilder:
    org.slf4j.Logger _LOG -> a
    java.util.regex.Pattern variablePattern -> b
    java.util.regex.Pattern inputPattern -> c
    java.util.regex.Pattern constantPattern -> d
    java.util.regex.Pattern reshapePattern -> e
    neureka.backend.api.OperationContext _context -> f
    boolean $assertionsDisabled -> g
    34:36:void <init>(neureka.backend.api.OperationContext) -> <init>
    46:53:neureka.calculus.Function build(neureka.backend.api.Operation,int,boolean) -> build
    63:81:neureka.calculus.Function build(java.lang.String,boolean) -> build
    91:197:neureka.calculus.Function _build(java.lang.String,boolean) -> a
    202:237:neureka.calculus.Function _buildFunction(java.lang.String,boolean) -> b
    246:299:neureka.calculus.Function _buildOperators(java.util.List,java.util.List,boolean) -> a
    303:315:java.util.List _groupAccordingToArity(int,java.util.List,java.lang.String) -> a
    306:306:int lambda$_groupAccordingToArity$2(int) -> a
    50:50:java.lang.String lambda$build$1(int) -> b
    48:48:int lambda$build$0(int) -> c
    20:29:void <clinit>() -> <clinit>
neureka.calculus.assembly.FunctionParser -> neureka.calculus.assembly.FunctionParser:
    boolean $assertionsDisabled -> a
    15:15:void <init>() -> <init>
    19:23:int numberOfOperationsWithin(java.util.List) -> numberOfOperationsWithin
    28:36:java.lang.String parsedOperation(java.lang.String,int) -> parsedOperation
    41:75:java.lang.String findComponentIn(java.lang.String,int) -> findComponentIn
    80:103:java.util.List findParametersIn(java.lang.String,int) -> findParametersIn
    108:110:boolean isAnOperation(java.lang.String) -> isAnOperation
    120:127:java.lang.String groupBy(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> groupBy
    132:132:boolean isForbiddenChar(char) -> a
    138:177:java.lang.String cleanedHeadAndTail(java.lang.String) -> cleanedHeadAndTail
    182:235:java.lang.String unpackAndCorrect(java.lang.String) -> unpackAndCorrect
    246:256:java.lang.String assumptionBasedOn(java.lang.String) -> assumptionBasedOn
    268:302:double similarity(java.lang.String,java.lang.String) -> similarity
    15:15:void <clinit>() -> <clinit>
neureka.calculus.implementations.FunctionConstant -> neureka.calculus.implementations.FunctionConstant:
    double _value -> a
    23:23:void <init>() -> <init>
    27:27:double value() -> value
    34:34:boolean isFlat() -> isFlat
    39:39:boolean isDoingAD() -> isDoingAD
    44:44:neureka.backend.api.operations.AbstractOperation getOperation() -> getOperation
    49:49:boolean dependsOn(int) -> dependsOn
    54:54:neureka.calculus.Function getDerivative(int) -> getDerivative
    58:58:java.util.List getSubFunctions() -> getSubFunctions
    63:76:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    83:83:double call(double[],int) -> call
    88:88:double call(double[]) -> call
    93:93:double derive(double[],int) -> derive
    98:98:double derive(double[],int,int) -> derive
    105:105:neureka.Tsr execute(neureka.Tsr[]) -> execute
    110:110:neureka.Tsr execute(neureka.Tsr[],int) -> execute
    115:115:neureka.Tsr executeDerive(neureka.Tsr[],int,int) -> executeDerive
    120:120:neureka.Tsr executeDerive(neureka.Tsr[],int) -> executeDerive
    127:127:java.lang.String toString() -> toString
    23:23:neureka.backend.api.Operation getOperation() -> getOperation
neureka.calculus.implementations.FunctionInput -> neureka.calculus.implementations.FunctionInput:
    int _index -> a
    30:30:void <init>() -> <init>
    37:37:boolean providesGradient() -> providesGradient
    44:44:boolean isFlat() -> isFlat
    49:49:boolean isDoingAD() -> isDoingAD
    54:54:neureka.backend.api.operations.AbstractOperation getOperation() -> getOperation
    59:59:boolean dependsOn(int) -> dependsOn
    64:64:neureka.calculus.Function getDerivative(int) -> getDerivative
    68:68:java.util.List getSubFunctions() -> getSubFunctions
    75:90:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    95:106:neureka.Tsr _extract(neureka.Tsr) -> a
    113:113:double call(double[],int) -> call
    118:118:double call(double[]) -> call
    123:123:double derive(double[],int) -> derive
    128:128:double derive(double[],int,int) -> derive
    135:135:neureka.Tsr execute(neureka.Tsr[],int) -> execute
    140:140:neureka.Tsr execute(neureka.Tsr[]) -> execute
    145:145:neureka.Tsr executeDerive(neureka.Tsr[],int,int) -> executeDerive
    150:152:neureka.Tsr executeDerive(neureka.Tsr[],int) -> executeDerive
    159:159:java.lang.String toString() -> toString
    163:163:int index() -> index
    30:30:neureka.backend.api.Operation getOperation() -> getOperation
neureka.calculus.implementations.FunctionNode -> neureka.calculus.implementations.FunctionNode:
    org.slf4j.Logger _LOG -> a
    neureka.backend.api.Operation _operation -> b
    boolean _isFlat -> c
    boolean _isDoingAD -> d
    neureka.calculus.Function[] _src -> e
    43:63:void <init>(neureka.backend.api.Operation,java.util.List,boolean) -> <init>
    69:69:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    77:81:java.lang.String toString() -> toString
    87:88:boolean dependsOn(int) -> dependsOn
    93:93:neureka.calculus.Function getDerivative(int) -> getDerivative
    97:97:java.util.List getSubFunctions() -> getSubFunctions
    111:134:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int) -> _tensor_activation
    1353:1357:neureka.devices.Device _deviceFor(neureka.Tsr[]):353:357 -> _tensor_activation
    1353:1357:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):112 -> _tensor_activation
    1362:1374:boolean _shareGuestDevice(neureka.Tsr[]):362:374 -> _tensor_activation
    1362:1374:neureka.devices.Device _deviceFor(neureka.Tsr[]):355 -> _tensor_activation
    1362:1374:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):112 -> _tensor_activation
    140:144:neureka.Tsr __flat_execution(neureka.backend.api.ExecutionCall) -> a
    149:182:neureka.Tsr __deep_activation(neureka.backend.api.ExecutionCall) -> b
    216:318:neureka.Tsr _deep_derivative(neureka.backend.api.ExecutionCall) -> c
    323:348:neureka.Tsr[] srcActivation(neureka.Tsr[],int,int,int) -> srcActivation
    381:381:neureka.Tsr execute(neureka.Tsr[]) -> execute
    386:386:neureka.Tsr execute(neureka.Tsr[],int) -> execute
    391:391:neureka.Tsr executeDerive(neureka.Tsr[],int,int) -> executeDerive
    396:396:neureka.Tsr executeDerive(neureka.Tsr[],int) -> executeDerive
    403:403:double call(double[],int) -> call
    408:408:double call(double[]) -> call
    413:413:double derive(double[],int,int) -> derive
    418:418:double derive(double[],int) -> derive
    422:422:neureka.backend.api.Operation getOperation() -> getOperation
    426:426:boolean isFlat() -> isFlat
    430:430:boolean isDoingAD() -> isDoingAD
    396:396:neureka.Tsr lambda$executeDerive$8(neureka.Tsr[],int) -> a
    391:391:neureka.Tsr lambda$executeDerive$7(neureka.Tsr[],int,int) -> a
    386:386:neureka.Tsr lambda$execute$6(neureka.Tsr[],int) -> b
    381:381:neureka.Tsr lambda$execute$5(neureka.Tsr[]) -> a
    219:297:neureka.Tsr lambda$_deep_derivative$4(neureka.backend.api.ExecutionCall) -> d
    2197:2211:int ___indexOfFoundDerivative(neureka.Tsr[]):197:211 -> d
    2197:2211:neureka.Tsr lambda$_deep_derivative$4(neureka.backend.api.ExecutionCall):247 -> d
    167:167:java.lang.String[] lambda$__deep_activation$3(int) -> a
    167:167:java.lang.String lambda$__deep_activation$2(int) -> b
    129:129:java.lang.Object lambda$_tensor_activation$1(neureka.backend.api.ExecutionCall) -> e
    79:79:java.lang.String lambda$toString$0(neureka.calculus.Function) -> a
    26:26:void <clinit>() -> <clinit>
neureka.calculus.implementations.FunctionVariable -> neureka.calculus.implementations.FunctionVariable:
    boolean _providesGradient -> a
    26:28:void <init>() -> <init>
    31:31:boolean providesGradient() -> providesGradient
    36:36:boolean isFlat() -> isFlat
    41:41:boolean isDoingAD() -> isDoingAD
    46:46:neureka.backend.api.operations.AbstractOperation getOperation() -> getOperation
    51:51:boolean dependsOn(int) -> dependsOn
    56:56:neureka.calculus.Function getDerivative(int) -> getDerivative
    60:60:java.util.List getSubFunctions() -> getSubFunctions
    66:67:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    75:75:double call(double[],int) -> call
    80:82:double call(double[]) -> call
    87:87:double derive(double[],int) -> derive
    92:93:double derive(double[],int,int) -> derive
    99:99:neureka.Tsr execute(neureka.Tsr[],int) -> execute
    104:106:neureka.Tsr execute(neureka.Tsr[]) -> execute
    111:111:neureka.Tsr executeDerive(neureka.Tsr[],int,int) -> executeDerive
    116:116:neureka.Tsr executeDerive(neureka.Tsr[],int) -> executeDerive
    123:123:java.lang.String toString() -> toString
    26:26:neureka.backend.api.Operation getOperation() -> getOperation
neureka.devices.AbstractBaseDevice -> neureka.devices.AbstractBaseDevice:
    47:47:void <init>() -> <init>
    51:53:int size() -> size
    58:58:boolean isEmpty() -> isEmpty
    63:63:boolean contains(neureka.Tsr) -> contains
    68:68:java.util.Iterator iterator() -> iterator
    73:73:java.lang.Object[] toArray(java.util.function.IntFunction) -> toArray
    78:78:java.util.Spliterator spliterator() -> spliterator
neureka.devices.AbstractDevice -> neureka.devices.AbstractDevice:
    neureka.utility.NeurekaCleaner _CLEANER -> a
    org.slf4j.Logger _log -> _log
    67:69:void <init>() -> <init>
    void _execute(neureka.Tsr[],int,neureka.backend.api.Operation) -> _execute
    89:102:boolean update(neureka.Component$OwnerChangeRequest) -> update
    107:108:neureka.devices.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    112:113:void _cleaning(java.lang.Object,java.lang.Runnable) -> _cleaning
    126:138:neureka.devices.Device execute(neureka.backend.api.ExecutionCall) -> execute
    143:144:neureka.devices.Storage store(neureka.Tsr) -> store
    136:136:void lambda$execute$0(neureka.backend.api.ExecutionCall) -> a
    63:63:void <clinit>() -> <clinit>
neureka.devices.Device -> neureka.devices.Device:
    81:116:neureka.devices.Device find(java.lang.String) -> find
    void dispose() -> dispose
    neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    boolean has(neureka.Tsr) -> has
    neureka.devices.Device free(neureka.Tsr) -> free
    neureka.devices.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    neureka.devices.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    neureka.devices.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    neureka.devices.Device execute(neureka.backend.api.ExecutionCall) -> execute
    java.lang.Object valueFor(neureka.Tsr) -> valueFor
    java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    java.util.Collection getTensors() -> getTensors
    java.lang.Object[] toArray(java.util.function.IntFunction) -> toArray
    neureka.backend.api.Operation optimizedOperationOf(neureka.calculus.Function,java.lang.String) -> optimizedOperationOf
    172:181:neureka.calculus.Function optimizedFunctionOf(neureka.calculus.Function,java.lang.String) -> optimizedFunctionOf
neureka.devices.Storage -> neureka.devices.Storage:
    neureka.devices.Storage store(neureka.Tsr) -> store
    neureka.devices.Storage restore(neureka.Tsr) -> restore
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(neureka.Tsr) -> contains
neureka.devices.file.FileDevice -> neureka.devices.file.FileDevice:
    org.slf4j.Logger _LOG -> a
    java.util.Map _DEVICES -> b
    java.util.Map _stored -> c
    java.lang.String _directory -> d
    java.util.List _loadable -> e
    java.util.List _loaded -> f
    boolean $assertionsDisabled -> g
    54:58:neureka.devices.file.FileDevice at(java.lang.String) -> at
    43:64:void <init>(java.lang.String) -> <init>
    71:95:void _updateFolderView() -> a
    97:97:neureka.Tsr load(java.lang.String) -> load
    100:111:neureka.Tsr load(java.lang.String,java.util.Map) -> load
    115:115:neureka.devices.file.FileHead fileHeadOf(neureka.Tsr) -> fileHeadOf
    120:122:void dispose() -> dispose
    126:134:neureka.devices.Device restore(neureka.Tsr) -> restore
    140:155:neureka.devices.Device store(neureka.Tsr) -> store
    160:160:neureka.devices.file.FileDevice store(neureka.Tsr,java.lang.String) -> store
    167:183:neureka.devices.file.FileDevice store(neureka.Tsr,java.lang.String,java.util.Map) -> store
    187:187:neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    191:191:boolean has(neureka.Tsr) -> has
    197:206:neureka.devices.Device free(neureka.Tsr) -> free
    211:211:neureka.devices.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    216:216:neureka.devices.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    221:221:neureka.devices.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    226:226:neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    231:231:neureka.devices.Device execute(neureka.backend.api.ExecutionCall) -> execute
    236:236:java.lang.Object valueFor(neureka.Tsr) -> valueFor
    241:241:java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    246:246:java.util.Collection getTensors() -> getTensors
    251:251:neureka.backend.api.Operation optimizedOperationOf(neureka.calculus.Function,java.lang.String) -> optimizedOperationOf
    256:264:boolean update(neureka.Component$OwnerChangeRequest) -> update
    269:269:java.lang.String toString() -> toString
    273:273:java.lang.String getDirectory() -> getDirectory
    277:277:java.util.List getLoadable() -> getLoadable
    281:281:java.util.List getLoaded() -> getLoaded
    37:37:neureka.devices.Storage restore(neureka.Tsr) -> restore
    37:37:neureka.devices.Storage store(neureka.Tsr) -> store
    90:94:void lambda$_updateFolderView$0(java.lang.String) -> a
    37:41:void <clinit>() -> <clinit>
neureka.devices.file.FileHead -> neureka.devices.file.FileHead:
    neureka.devices.file.heads.util.HeadFactory FACTORY -> FACTORY
    neureka.Tsr load() -> load
    java.lang.Object free() -> free
    int getValueSize() -> getValueSize
    int getDataSize() -> getDataSize
    int getTotalSize() -> getTotalSize
    java.lang.String getLocation() -> getLocation
    java.lang.String getFileName() -> getFileName
    neureka.dtype.DataType getDataType() -> getDataType
    int[] getShape() -> getShape
    java.lang.String extension() -> extension
    13:13:void <clinit>() -> <clinit>
neureka.devices.file.heads.AbstractFileHead -> neureka.devices.file.heads.AbstractFileHead:
    org.slf4j.Logger _LOG -> _LOG
    java.lang.String _fileName -> _fileName
    int _size -> _size
    23:46:void <init>(java.lang.String) -> <init>
    49:49:int size() -> size
    53:53:boolean isEmpty() -> isEmpty
    57:57:boolean contains(neureka.Tsr) -> contains
    java.lang.Object _loadData() -> _loadData
    65:72:java.io.File _loadFile() -> _loadFile
    77:89:java.io.FileInputStream _loadFileInputStream() -> _loadFileInputStream
    95:101:java.lang.Object free() -> free
    106:106:java.lang.String getLocation() -> getLocation
    111:112:java.lang.String getFileName() -> getFileName
    118:124:neureka.devices.Storage restore(neureka.Tsr) -> restore
neureka.devices.file.heads.CSVHead -> neureka.devices.file.heads.CSVHead:
    java.lang.String _tensorName -> a
    java.lang.String _delimiter -> b
    boolean _firstRowIsLabels -> c
    java.lang.String[] _colLabels -> d
    boolean _firstColIsIndex -> e
    java.lang.String[] _rowLabels -> f
    java.lang.Integer _numberOfRows -> g
    java.lang.Integer _numberOfColumns -> h
    java.lang.Integer _numberOfBytes -> i
    java.lang.ref.WeakReference _rawData -> j
    boolean $assertionsDisabled -> k
    37:85:void <init>(neureka.Tsr,java.lang.String) -> <init>
    37:101:void <init>(java.lang.String,java.util.Map) -> <init>
    104:176:java.lang.String[] _lazyLoad() -> a
    180:183:void _parseTensorNameFromFileName() -> b
    187:187:neureka.devices.Storage store(neureka.Tsr) -> store
    192:192:java.lang.Object _loadData() -> _loadData
    197:227:neureka.Tsr load() -> load
    231:232:java.lang.String getTensorName() -> getTensorName
    238:240:int getValueSize() -> getValueSize
    245:247:int getDataSize() -> getDataSize
    252:252:int getTotalSize() -> getTotalSize
    257:257:neureka.dtype.DataType getDataType() -> getDataType
    262:262:int[] getShape() -> getShape
    267:267:java.lang.String extension() -> extension
    271:271:java.lang.String getDelimiter() -> getDelimiter
    275:275:boolean isFirstRowIsLabels() -> isFirstRowIsLabels
    279:279:java.lang.String[] getColLabels() -> getColLabels
    283:283:boolean isFirstColIsIndex() -> isFirstColIsIndex
    287:287:java.lang.String[] getRowLabels() -> getRowLabels
    291:291:java.lang.Integer getNumberOfRows() -> getNumberOfRows
    295:295:java.lang.Integer getNumberOfColumns() -> getNumberOfColumns
    24:28:void <clinit>() -> <clinit>
neureka.devices.file.heads.IDXHead -> neureka.devices.file.heads.IDXHead:
    neureka.dtype.DataType _dataType -> a
    int _dataOffset -> b
    int _valueSize -> c
    int[] _shape -> d
    java.util.Map TYPE_MAP -> e
    java.util.Map CODE_MAP -> f
    boolean $assertionsDisabled -> g
    59:66:void <init>(java.lang.String) -> <init>
    1078:1101:void _loadHead():78:101 -> <init>
    1078:1101:void <init>(java.lang.String):61 -> <init>
    69:74:void <init>(neureka.Tsr,java.lang.String) -> <init>
    107:152:neureka.devices.file.heads.IDXHead store(neureka.Tsr) -> store
    157:170:java.lang.Object _loadData() -> _loadData
    176:180:neureka.Tsr load() -> load
    185:188:int getDataSize() -> getDataSize
    193:193:int getTotalSize() -> getTotalSize
    198:198:java.lang.String extension() -> extension
    203:203:neureka.dtype.DataType getDataType() -> getDataType
    207:207:int getValueSize() -> getValueSize
    211:211:int[] getShape() -> getShape
    26:26:neureka.devices.Storage store(neureka.Tsr) -> store
    26:51:void <clinit>() -> <clinit>
neureka.devices.file.heads.JPEGHead -> neureka.devices.file.heads.JPEGHead:
    int _width -> a
    int _height -> b
    boolean $assertionsDisabled -> c
    38:44:void <init>(java.lang.String) -> <init>
    1059:1089:void _loadHead():59:89 -> <init>
    1059:1089:void <init>(java.lang.String):40 -> <init>
    47:54:void <init>(neureka.Tsr,java.lang.String) -> <init>
    93:95:neureka.Tsr load() -> load
    101:121:java.lang.Object _loadData() -> _loadData
    127:127:int getValueSize() -> getValueSize
    132:132:int getDataSize() -> getDataSize
    137:137:int getTotalSize() -> getTotalSize
    142:142:neureka.dtype.DataType getDataType() -> getDataType
    147:147:int[] getShape() -> getShape
    152:152:java.lang.String extension() -> extension
    158:174:neureka.devices.Storage store(neureka.Tsr) -> store
    113:114:void lambda$_loadData$0(short[],neureka.dtype.custom.UI8,byte[],int,int) -> a
    26:30:void <clinit>() -> <clinit>
neureka.devices.file.heads.util.HeadFactory -> neureka.devices.file.heads.util.HeadFactory:
    java.util.Map _LOADERS -> a
    java.util.Map _SAVERS -> b
    28:41:void <init>() -> <init>
    44:44:boolean hasLoader(java.lang.String) -> hasLoader
    48:48:boolean hasSaver(java.lang.String) -> hasSaver
    52:52:neureka.devices.file.heads.util.HeadFactory$Loader getLoader(java.lang.String) -> getLoader
    56:56:neureka.devices.file.heads.util.HeadFactory$Saver getSaver(java.lang.String) -> getSaver
    40:40:neureka.devices.file.FileHead lambda$new$7(java.lang.String,neureka.Tsr,java.util.Map) -> a
    39:39:neureka.devices.file.FileHead lambda$new$6(java.lang.String,neureka.Tsr,java.util.Map) -> b
    38:38:neureka.devices.file.FileHead lambda$new$5(java.lang.String,neureka.Tsr,java.util.Map) -> c
    37:37:neureka.devices.file.FileHead lambda$new$4(java.lang.String,neureka.Tsr,java.util.Map) -> d
    35:35:neureka.devices.file.FileHead lambda$new$3(java.lang.String,java.util.Map) -> a
    34:34:neureka.devices.file.FileHead lambda$new$2(java.lang.String,java.util.Map) -> b
    33:33:neureka.devices.file.FileHead lambda$new$1(java.lang.String,java.util.Map) -> c
    32:32:neureka.devices.file.FileHead lambda$new$0(java.lang.String,java.util.Map) -> d
neureka.devices.file.heads.util.HeadFactory$Loader -> neureka.devices.file.heads.util.HeadFactory$Loader:
    neureka.devices.file.FileHead load(java.lang.String,java.util.Map) -> load
neureka.devices.file.heads.util.HeadFactory$Saver -> neureka.devices.file.heads.util.HeadFactory$Saver:
    neureka.devices.file.FileHead save(java.lang.String,neureka.Tsr,java.util.Map) -> save
neureka.devices.file.heads.util.NumberReader -> neureka.devices.file.heads.util.NumberReader:
    java.io.FileInputStream _fileInputStream -> a
    int _bytesRead -> b
    java.util.Map _byteMap -> c
    boolean $assertionsDisabled -> d
    13:23:void <init>(java.io.FileInputStream) -> <init>
    26:26:java.io.FileInputStream getStream() -> getStream
    30:32:java.lang.Object read(neureka.dtype.NumericType) -> read
    39:39:int bytesRead() -> bytesRead
    10:10:void <clinit>() -> <clinit>
neureka.devices.host.HostCPU -> neureka.devices.host.HostCPU:
    org.slf4j.Logger _LOG -> a
    neureka.devices.host.HostCPU _INSTANCE -> b
    neureka.devices.host.HostCPU$NativeExecutor _executor -> c
    java.util.Set _tensors -> d
    33:38:void <init>() -> <init>
    41:41:neureka.devices.host.HostCPU instance() -> instance
    45:45:neureka.devices.host.HostCPU$NativeExecutor getExecutor() -> getExecutor
    51:74:void _execute(neureka.Tsr[],int,neureka.backend.api.Operation) -> _execute
    78:79:void dispose() -> dispose
    83:83:java.lang.Object valueFor(neureka.Tsr) -> valueFor
    88:88:java.lang.Number valueFor(neureka.Tsr,int) -> valueFor
    93:93:neureka.devices.Device restore(neureka.Tsr) -> restore
    98:99:neureka.devices.Device store(neureka.Tsr) -> store
    104:106:neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    111:111:boolean has(neureka.Tsr) -> has
    116:117:neureka.devices.Device free(neureka.Tsr) -> free
    122:122:neureka.devices.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    127:127:neureka.devices.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    132:132:neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    137:137:java.util.Collection getTensors() -> getTensors
    141:141:neureka.backend.api.Operation optimizedOperationOf(neureka.calculus.Function,java.lang.String) -> optimizedOperationOf
    145:145:boolean update(neureka.Component$OwnerChangeRequest) -> update
    25:25:neureka.devices.Storage store(neureka.Tsr) -> store
    25:25:java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    25:25:neureka.devices.Storage restore(neureka.Tsr) -> restore
    27:30:void <clinit>() -> <clinit>
neureka.devices.host.HostCPU$NativeExecutor -> neureka.devices.host.HostCPU$NativeExecutor:
    java.util.concurrent.ThreadPoolExecutor _pool -> a
    153:157:void <init>(neureka.devices.host.HostCPU) -> <init>
    161:161:java.util.concurrent.ThreadPoolExecutor getPool() -> getPool
    168:192:void threaded(int,neureka.devices.host.HostCPU$Range) -> threaded
    178:180:void lambda$threaded$0(neureka.Neureka,neureka.devices.host.HostCPU$Range,int,int) -> a
neureka.devices.host.HostCPU$Range -> neureka.devices.host.HostCPU$Range:
    void execute(int,int) -> execute
neureka.devices.opencl.CLContext -> neureka.devices.opencl.CLContext:
    java.util.List _platforms -> a
    30:36:void <init>() -> <init>
    41:41:java.util.List getPlatforms() -> getPlatforms
    53:56:boolean update(neureka.Component$OwnerChangeRequest) -> update
    1065:1074:java.util.List _findLoadAndCompileForAllPlatforms():65:74 -> update
    1065:1074:boolean update(neureka.Component$OwnerChangeRequest):54 -> update
neureka.devices.opencl.KernelCaller -> neureka.devices.opencl.KernelCaller:
    org.jocl.cl_command_queue _queue -> a
    org.jocl.cl_kernel _kernel -> b
    java.util.List _inputs -> c
    int _argId -> d
    boolean $assertionsDisabled -> e
    24:35:void <init>(org.jocl.cl_kernel,org.jocl.cl_command_queue) -> <init>
    44:49:neureka.devices.opencl.KernelCaller pass(neureka.Tsr) -> pass
    59:62:neureka.devices.opencl.KernelCaller passRaw(neureka.Tsr) -> passRaw
    71:73:neureka.devices.opencl.KernelCaller pass(int) -> pass
    82:84:neureka.devices.opencl.KernelCaller pass(float) -> pass
    93:108:void call(int) -> call
    112:128:void call(long[],long[]) -> call
    132:138:void _releaseEvents(neureka.Tsr[]) -> a
    142:149:org.jocl.cl_event[] _getWaitList(neureka.Tsr[]) -> b
    18:18:void <clinit>() -> <clinit>
neureka.devices.opencl.OpenCLDevice -> neureka.devices.opencl.OpenCLDevice:
    org.slf4j.Logger _LOG -> a
    java.util.Map _adhocKernels -> b
    neureka.devices.opencl.OpenCLDevice$cl_ad_hoc[] _adhocKernelRingBuffer -> c
    int _ringIndex -> d
    java.util.Set _tensors -> e
    org.jocl.cl_device_id _deviceId -> f
    neureka.devices.opencl.OpenCLPlatform _platform -> g
    org.jocl.cl_command_queue _queue -> h
    84:85:neureka.devices.opencl.OpenCLDevice newInstanceOf(neureka.devices.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> newInstanceOf
    89:89:java.lang.String toString() -> toString
    93:93:org.jocl.cl_device_id getDeviceId() -> getDeviceId
    97:97:neureka.devices.opencl.OpenCLPlatform getPlatform() -> getPlatform
    178:231:void <init>(neureka.devices.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> <init>
    234:234:boolean hasAdHocKernel(java.lang.String) -> hasAdHocKernel
    238:240:neureka.devices.opencl.KernelCaller getAdHocKernel(java.lang.String) -> getAdHocKernel
    259:317:neureka.devices.opencl.OpenCLDevice compileAdHocKernel(java.lang.String,java.lang.String) -> compileAdHocKernel
    329:332:java.util.Collection getTensors() -> getTensors
    337:337:neureka.backend.api.Operation optimizedOperationOf(neureka.calculus.Function,java.lang.String) -> optimizedOperationOf
    345:347:void dispose() -> dispose
    361:373:neureka.devices.Device restore(neureka.Tsr) -> restore
    378:379:neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    1383:1386:neureka.devices.Device _store(neureka.Tsr,neureka.Tsr,java.lang.Runnable):383:386 -> store
    1383:1386:neureka.devices.Device store(neureka.Tsr,neureka.Tsr):378 -> store
    391:472:void _add(neureka.Tsr,neureka.devices.opencl.OpenCLDevice$cl_tsr,java.lang.Runnable) -> a
    484:484:boolean has(neureka.Tsr) -> has
    491:526:void _store(neureka.Tsr,neureka.devices.opencl.OpenCLDevice$cl_tsr,int) -> a
    531:536:neureka.devices.Device free(neureka.Tsr) -> free
    543:560:neureka.devices.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    566:584:neureka.devices.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    590:595:neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    600:607:boolean update(neureka.Component$OwnerChangeRequest) -> update
    1611:1615:void _updateInternal(neureka.Tsr,java.lang.Runnable):611:615 -> update
    1611:1615:boolean update(neureka.Component$OwnerChangeRequest):603 -> update
    618:619:double[] value64f(neureka.Tsr) -> value64f
    624:638:double[] _value64f(neureka.devices.opencl.OpenCLDevice$cl_tsr,int,int) -> a
    643:644:float[] value32f(neureka.Tsr) -> value32f
    648:663:float[] _value32f(neureka.devices.opencl.OpenCLDevice$cl_tsr,int,int) -> b
    668:668:java.lang.Object valueFor(neureka.Tsr) -> valueFor
    673:673:java.lang.Number valueFor(neureka.Tsr,int) -> valueFor
    677:678:double value64f(neureka.Tsr,int) -> value64f
    682:683:float value32f(neureka.Tsr,int) -> value32f
    688:690:neureka.devices.opencl.KernelCaller getKernel(neureka.backend.api.ExecutionCall) -> getKernel
    696:705:void _execute(neureka.Tsr[],int,neureka.backend.api.Operation) -> _execute
    739:739:java.lang.String name() -> name
    743:743:java.lang.String vendor() -> vendor
    747:747:java.lang.String version() -> version
    751:760:java.lang.String type() -> type
    764:764:int maxComputeUnits() -> maxComputeUnits
    768:768:long maxWorkItemSimensions() -> maxWorkItemSimensions
    772:772:long[] maxWorkItemSizes() -> maxWorkItemSizes
    776:776:long maxWorkGroupSize() -> maxWorkGroupSize
    780:780:long maxClockFrequenzy() -> maxClockFrequenzy
    784:784:int maxAddressBits() -> maxAddressBits
    788:788:long maxMemAllocSize() -> maxMemAllocSize
    792:792:long globalMemSize() -> globalMemSize
    796:796:int errorCorrectionSupport() -> errorCorrectionSupport
    800:800:int localMemType() -> localMemType
    804:804:long localMemSize() -> localMemSize
    808:808:long maxConstantBufferSize() -> maxConstantBufferSize
    812:812:long maxConstantBufferSizeKB() -> maxConstantBufferSizeKB
    826:826:int imageSupport() -> imageSupport
    830:830:int maxReadImageArgs() -> maxReadImageArgs
    834:834:int maxWriteImageArgs() -> maxWriteImageArgs
    838:838:long singleFPConfig() -> singleFPConfig
    842:842:long image2DMaxWidth() -> image2DMaxWidth
    846:846:long image2DMaxHeight() -> image2DMaxHeight
    850:850:long image3DMaxWidth() -> image3DMaxWidth
    854:854:long image3DMaxHeight() -> image3DMaxHeight
    858:858:long image3DMaxDepth() -> image3DMaxDepth
    862:862:int prefVecWidthChar() -> prefVecWidthChar
    866:866:int prefVecWidthShort() -> prefVecWidthShort
    870:870:int prefVecWidthInt() -> prefVecWidthInt
    874:874:int prefVecWidthLong() -> prefVecWidthLong
    878:878:int prefVecWidthFloat() -> prefVecWidthFloat
    882:882:int prefVecWidthDouble() -> prefVecWidthDouble
    78:78:java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    78:78:neureka.devices.Storage restore(neureka.Tsr) -> restore
    437:437:void lambda$_add$6(org.jocl.cl_mem) -> a
    406:408:void lambda$_add$5(org.jocl.cl_event,org.jocl.cl_mem) -> a
    378:378:void lambda$store$4(neureka.Tsr) -> a
    331:331:void lambda$getTensors$3(java.util.Collection,java.util.Collection) -> a
    331:331:void lambda$getTensors$2(java.util.Collection,neureka.Tsr) -> a
    314:316:void lambda$compileAdHocKernel$1(org.jocl.cl_kernel,org.jocl.cl_program) -> a
    221:221:void lambda$new$0() -> a
    80:80:void <clinit>() -> <clinit>
neureka.devices.opencl.OpenCLDevice$DeviceQuery -> neureka.devices.opencl.OpenCLDevice$DeviceQuery:
    885:885:void <init>() -> <init>
    895:895:int getInt(org.jocl.cl_device_id,int) -> getInt
    907:909:int[] getInts(org.jocl.cl_device_id,int,int) -> getInts
    920:920:long getLong(org.jocl.cl_device_id,int) -> getLong
    932:934:long[] getLongs(org.jocl.cl_device_id,int,int) -> getLongs
    946:954:java.lang.String getString(org.jocl.cl_device_id,int) -> getString
    966:974:java.lang.String getString(org.jocl.cl_platform_id,int) -> getString
    985:985:long getSize(org.jocl.cl_device_id,int) -> getSize
    999:1017:long[] getSizes(org.jocl.cl_device_id,int,int) -> getSizes
neureka.devices.opencl.OpenCLDevice$cl_ad_hoc -> neureka.devices.opencl.OpenCLDevice$a:
    java.lang.String source -> a
    org.jocl.cl_kernel kernel -> b
    165:165:void <init>() -> <init>
    165:165:void <init>(byte) -> <init>
neureka.devices.opencl.OpenCLDevice$cl_tsr -> neureka.devices.opencl.OpenCLDevice$cl_tsr:
    int fp -> a
    neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config config -> b
    neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_value value -> c
    114:145:void <init>() -> <init>
    151:152:boolean update(neureka.Component$OwnerChangeRequest) -> update
neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config -> neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config:
    org.jocl.cl_mem data -> data
    139:139:void <init>() -> <init>
neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_value -> neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_value:
    int size -> size
    org.jocl.cl_mem data -> data
    org.jocl.cl_event event -> event
    125:127:void <init>() -> <init>
neureka.devices.opencl.OpenCLPlatform -> neureka.devices.opencl.OpenCLPlatform:
    org.slf4j.Logger _LOG -> a
    org.jocl.cl_platform_id _pid -> b
    org.jocl.cl_context _context -> c
    java.util.Map _id_device -> d
    java.util.Map _kernels -> e
    24:56:void <init>(org.jocl.cl_platform_id) -> <init>
    59:63:void recompile() -> recompile
    68:164:void _compile(org.jocl.cl_device_id[]) -> a
    167:169:java.util.List getDevices() -> getDevices
    176:176:boolean has(org.jocl.cl_device_id) -> has
    179:179:neureka.devices.opencl.OpenCLDevice get(org.jocl.cl_device_id) -> get
    183:184:void put(org.jocl.cl_device_id,neureka.devices.opencl.OpenCLDevice) -> put
    187:187:java.util.Map getKernels() -> getKernels
    191:191:org.jocl.cl_platform_id getPid() -> getPid
    195:195:org.jocl.cl_context getContext() -> getContext
    168:168:void lambda$getDevices$1(java.util.List,org.jocl.cl_device_id,neureka.devices.opencl.OpenCLDevice) -> a
    128:130:void lambda$_compile$0(java.util.ArrayList,java.util.ArrayList,java.lang.String,java.lang.String) -> a
    18:18:void <clinit>() -> <clinit>
neureka.devices.opencl.utility.CLFunctionCompiler -> neureka.devices.opencl.utility.CLFunctionCompiler:
    neureka.devices.opencl.OpenCLDevice _device -> a
    neureka.calculus.Function _functionToBeOptimized -> b
    java.lang.String _functionName -> c
    int[] _argPointer -> d
    32:42:void <init>(neureka.devices.opencl.OpenCLDevice,neureka.calculus.Function,java.lang.String) -> <init>
    46:95:neureka.backend.api.Operation optimize() -> optimize
    105:201:void _adHocKernelFor(neureka.backend.api.ExecutionCall) -> a
    1225:1237:java.lang.String _readAndGetIndexMapper():225:237 -> a
    1225:1237:void _adHocKernelFor(neureka.backend.api.ExecutionCall):174 -> a
    204:215:java.lang.String _clTypeOf(neureka.Tsr) -> a
    205:207:java.lang.String lambda$_clTypeOf$21(java.lang.Class) -> a
    190:190:java.lang.String lambda$_adHocKernelFor$20(java.util.List,int,int) -> a
    182:182:java.lang.String lambda$_adHocKernelFor$19(java.util.List,int) -> a
    166:168:java.lang.String lambda$_adHocKernelFor$18(java.lang.String,java.lang.String) -> a
    154:154:java.lang.String lambda$_adHocKernelFor$17(java.util.List,int) -> b
    147:149:java.util.List lambda$_adHocKernelFor$16(int[]) -> a
    144:144:int[] lambda$_adHocKernelFor$15(neureka.Tsr) -> b
    120:128:java.lang.String lambda$_adHocKernelFor$14(neureka.Tsr) -> c
    106:106:neureka.Tsr lambda$_adHocKernelFor$13(neureka.backend.api.ExecutionCall,int) -> a
    84:92:neureka.backend.api.ExecutionCall lambda$optimize$12(neureka.backend.api.ExecutionCall) -> b
    81:81:neureka.Tsr lambda$optimize$11(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    80:80:neureka.Tsr lambda$optimize$10(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    75:77:neureka.autograd.ADAgent lambda$optimize$9(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    77:77:neureka.Tsr lambda$optimize$8(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    76:76:neureka.Tsr lambda$optimize$7(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    71:71:boolean lambda$optimize$6(neureka.backend.api.ExecutionCall) -> c
    70:70:boolean lambda$optimize$5(neureka.backend.api.ExecutionCall) -> d
    69:69:float lambda$optimize$4(neureka.backend.api.ExecutionCall) -> e
    59:63:java.lang.String lambda$optimize$3(java.lang.String[]) -> a
    47:47:boolean lambda$optimize$2(neureka.calculus.Function) -> a
    39:39:int lambda$new$1(neureka.calculus.Function) -> b
    38:38:boolean lambda$new$0(neureka.calculus.Function) -> c
neureka.devices.opencl.utility.DeviceQuery -> neureka.devices.opencl.utility.DeviceQuery:
    20:20:void <init>() -> <init>
    29:188:java.lang.String query() -> query
    1276:1284:java.lang.String getString(org.jocl.cl_platform_id,int):276:284 -> query
    1276:1284:java.lang.String query():44 -> query
    200:200:int getInt(org.jocl.cl_device_id,int) -> a
    213:215:int[] getInts(org.jocl.cl_device_id,int,int) -> a
    227:227:long getLong(org.jocl.cl_device_id,int) -> b
    240:242:long[] getLongs(org.jocl.cl_device_id,int,int) -> b
    255:263:java.lang.String getString(org.jocl.cl_device_id,int) -> c
    296:296:long getSize(org.jocl.cl_device_id,int) -> d
    311:330:long[] getSizes(org.jocl.cl_device_id,int,int) -> c
neureka.devices.opencl.utility.DispatchUtility -> neureka.devices.opencl.utility.DispatchUtility:
    boolean $assertionsDisabled -> a
    7:7:void <init>() -> <init>
    12:18:void _revert(int[]) -> a
    21:23:int _productOf(int[]) -> b
    28:154:int[] parseTile(int,int[]) -> parseTile
    1184:1205:int[] _primeFactors(int):184:205 -> parseTile
    1184:1205:int[] parseTile(int,int[]):35 -> parseTile
    2164:2167:int _productOfNewDimension(int[],int,int,int):164:167 -> parseTile
    2164:2167:int[] parseTile(int,int[]):114 -> parseTile
    2176:2179:int _inversionProductOfNewDimension(int[],int[],int,int):176:179 -> parseTile
    2176:2179:int[] parseTile(int,int[]):139 -> parseTile
    219:229:int[] findBestParams(int,int,int,int,int) -> findBestParams
    235:242:int[] bestMatMulMatch(int,int,int,int) -> bestMatMulMatch
    205:205:int lambda$_primeFactors$0(java.lang.Integer) -> a
    7:7:void <clinit>() -> <clinit>
neureka.devices.opencl.utility.WeakTensorReference -> neureka.devices.opencl.utility.WeakTensorReference:
    int _hash -> a
    24:26:void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    30:30:int hashCode() -> hashCode
    35:35:boolean equals(java.lang.Object) -> equals
neureka.dtype.AbstractNumericType -> neureka.dtype.AbstractNumericType:
    java.util.Map _NUMERIC_TYPE_RELATIONS -> a
    21:21:void <init>() -> <init>
    45:45:java.lang.Class getNumericTypeTarget() -> getNumericTypeTarget
    51:55:void writeDataTo(java.io.DataOutput,java.util.Iterator) -> writeDataTo
    31:41:void <clinit>() -> <clinit>
neureka.dtype.DataType -> neureka.dtype.DataType:
    java.util.Map _instances -> a
    org.slf4j.Logger _log -> b
    java.lang.Class _typeClass -> c
    71:83:java.lang.Class _numericTypeRepresentationOf(java.lang.Class) -> a
    88:95:neureka.dtype.DataType of(java.lang.Class) -> of
    100:105:void forType(java.lang.Class,java.util.function.Consumer) -> forType
    111:116:void <init>(java.lang.Class) -> <init>
    123:138:java.lang.Object getTypeClassInstance() -> getTypeClassInstance
    142:142:boolean typeClassImplements(java.lang.Class) -> typeClassImplements
    149:162:java.lang.Object virtualize(java.lang.Object) -> virtualize
    167:197:java.lang.Object actualize(java.lang.Object,int) -> actualize
    202:215:java.lang.Object allocate(int) -> allocate
    220:220:org.slf4j.Logger getLog() -> getLog
    224:234:boolean equals(java.lang.Object) -> equals
    238:244:int hashCode() -> hashCode
    248:248:java.lang.String toString() -> toString
    252:252:java.lang.Class getTypeClass() -> getTypeClass
    256:259:java.lang.Class getJVMTypeClass() -> getJVMTypeClass
    61:61:void <clinit>() -> <clinit>
neureka.dtype.NumericType -> neureka.dtype.NumericType:
    boolean signed() -> signed
    int numberOfBytes() -> numberOfBytes
    java.lang.Class targetType() -> targetType
    java.lang.Class targetArrayType() -> targetArrayType
    java.lang.Class holderType() -> holderType
    java.lang.Class holderArrayType() -> holderArrayType
    java.lang.Class getNumericTypeTarget() -> getNumericTypeTarget
    java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    java.lang.Object toTarget(java.lang.Object) -> toTarget
    byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    void writeDataTo(java.io.DataOutput,java.util.Iterator) -> writeDataTo
    java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
neureka.dtype.custom.F32 -> neureka.dtype.custom.F32:
    14:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:49:java.lang.Float foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    54:54:java.lang.Float toTarget(java.lang.Float) -> toTarget
    59:60:byte[] targetToForeignHolderBytes(java.lang.Float) -> targetToForeignHolderBytes
    70:70:float[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    75:77:float[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    83:83:float[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    88:88:float[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    94:107:java.lang.Float convertToHolder(java.lang.Object) -> convertToHolder
    112:112:float[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    117:117:java.lang.Float convertToTarget(java.lang.Object) -> convertToTarget
    122:122:float[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.F64 -> neureka.dtype.custom.F64:
    15:16:void <init>() -> <init>
    20:20:boolean signed() -> signed
    25:25:int numberOfBytes() -> numberOfBytes
    30:30:java.lang.Class targetType() -> targetType
    35:35:java.lang.Class targetArrayType() -> targetArrayType
    40:40:java.lang.Class holderType() -> holderType
    45:45:java.lang.Class holderArrayType() -> holderArrayType
    50:50:java.lang.Double foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    55:55:java.lang.Double toTarget(java.lang.Double) -> toTarget
    60:61:byte[] targetToForeignHolderBytes(java.lang.Double) -> targetToForeignHolderBytes
    75:75:double[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    80:82:double[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    87:87:double[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    92:94:double[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    99:112:java.lang.Double convertToHolder(java.lang.Object) -> convertToHolder
    117:117:double[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    122:122:java.lang.Double convertToTarget(java.lang.Object) -> convertToTarget
    127:127:double[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    131:137:double[] _readFrom(java.io.DataInput,int) -> a
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I16 -> neureka.dtype.custom.I16:
    java.nio.ByteBuffer buffer -> a
    13:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:51:java.lang.Short foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    56:56:java.lang.Short toTarget(java.lang.Short) -> toTarget
    61:62:byte[] targetToForeignHolderBytes(java.lang.Short) -> targetToForeignHolderBytes
    67:67:short[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    72:72:short[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    77:77:short[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    82:82:short[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    87:100:java.lang.Short convertToHolder(java.lang.Object) -> convertToHolder
    105:105:short[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    110:110:java.lang.Short convertToTarget(java.lang.Object) -> convertToTarget
    115:115:short[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    119:125:short[] _readData(java.io.DataInput,int) -> a
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I32 -> neureka.dtype.custom.I32:
    15:16:void <init>() -> <init>
    20:20:boolean signed() -> signed
    25:25:int numberOfBytes() -> numberOfBytes
    30:30:java.lang.Class targetType() -> targetType
    35:35:java.lang.Class targetArrayType() -> targetArrayType
    40:40:java.lang.Class holderType() -> holderType
    45:45:java.lang.Class holderArrayType() -> holderArrayType
    50:50:java.lang.Integer foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    56:56:java.lang.Integer toTarget(java.lang.Integer) -> toTarget
    61:65:byte[] targetToForeignHolderBytes(java.lang.Integer) -> targetToForeignHolderBytes
    71:71:int[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    76:76:int[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    81:81:int[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    86:86:int[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    91:104:java.lang.Integer convertToHolder(java.lang.Object) -> convertToHolder
    109:109:int[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    114:114:java.lang.Integer convertToTarget(java.lang.Object) -> convertToTarget
    119:119:int[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    123:129:int[] _readData(java.io.DataInput,int) -> a
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I64 -> neureka.dtype.custom.I64:
    java.nio.ByteBuffer buffer -> a
    13:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:51:java.lang.Long foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    57:57:java.lang.Long toTarget(java.lang.Long) -> toTarget
    62:63:byte[] targetToForeignHolderBytes(java.lang.Long) -> targetToForeignHolderBytes
    68:68:long[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    73:73:long[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    78:78:long[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    83:83:long[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    88:101:java.lang.Long convertToHolder(java.lang.Object) -> convertToHolder
    106:106:long[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    111:111:java.lang.Long convertToTarget(java.lang.Object) -> convertToTarget
    116:116:long[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I8 -> neureka.dtype.custom.I8:
    18:19:void <init>() -> <init>
    23:23:boolean signed() -> signed
    28:28:int numberOfBytes() -> numberOfBytes
    33:33:java.lang.Class targetType() -> targetType
    38:38:java.lang.Class targetArrayType() -> targetArrayType
    43:43:java.lang.Class holderType() -> holderType
    48:48:java.lang.Class holderArrayType() -> holderArrayType
    53:53:java.lang.Byte foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    58:58:java.lang.Byte toTarget(java.lang.Byte) -> toTarget
    63:63:byte[] targetToForeignHolderBytes(java.lang.Byte) -> targetToForeignHolderBytes
    68:70:byte[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    75:75:byte[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    80:82:byte[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    87:87:byte[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    92:105:java.lang.Byte convertToHolder(java.lang.Object) -> convertToHolder
    110:110:byte[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    115:115:java.lang.Byte convertToTarget(java.lang.Object) -> convertToTarget
    120:120:byte[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    15:15:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    15:15:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    15:15:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    15:15:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    15:15:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    15:15:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    15:15:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    15:15:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    15:15:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    15:15:java.lang.Object toTarget(java.lang.Object) -> toTarget
    15:15:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI16 -> neureka.dtype.custom.UI16:
    15:16:void <init>() -> <init>
    20:20:boolean signed() -> signed
    25:25:int numberOfBytes() -> numberOfBytes
    30:30:java.lang.Class targetType() -> targetType
    35:35:java.lang.Class targetArrayType() -> targetArrayType
    40:40:java.lang.Class holderType() -> holderType
    45:45:java.lang.Class holderArrayType() -> holderArrayType
    50:51:java.lang.Integer foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    59:59:java.lang.Integer toTarget(java.lang.Short) -> toTarget
    64:66:byte[] targetToForeignHolderBytes(java.lang.Integer) -> targetToForeignHolderBytes
    71:77:int[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    82:82:int[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    87:87:short[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    92:92:short[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    97:97:java.lang.Short convertToHolder(java.lang.Object) -> convertToHolder
    102:102:short[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    107:107:java.lang.Integer convertToTarget(java.lang.Object) -> convertToTarget
    112:112:int[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI32 -> neureka.dtype.custom.UI32:
    11:11:void <init>() -> <init>
    16:16:boolean signed() -> signed
    21:21:int numberOfBytes() -> numberOfBytes
    26:26:java.lang.Class targetType() -> targetType
    31:31:java.lang.Class targetArrayType() -> targetArrayType
    36:36:java.lang.Class holderType() -> holderType
    41:41:java.lang.Class holderArrayType() -> holderArrayType
    46:47:java.lang.Long foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    55:55:java.lang.Long toTarget(java.lang.Integer) -> toTarget
    60:63:byte[] targetToForeignHolderBytes(java.lang.Long) -> targetToForeignHolderBytes
    68:68:long[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    73:73:long[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    78:78:int[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    83:83:int[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    88:88:java.lang.Integer convertToHolder(java.lang.Object) -> convertToHolder
    93:93:int[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    98:98:java.lang.Long convertToTarget(java.lang.Object) -> convertToTarget
    103:103:long[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI64 -> neureka.dtype.custom.UI64:
    14:14:void <init>() -> <init>
    18:18:boolean signed() -> signed
    23:23:int numberOfBytes() -> numberOfBytes
    28:28:java.lang.Class targetType() -> targetType
    33:33:java.lang.Class targetArrayType() -> targetArrayType
    38:38:java.lang.Class holderType() -> holderType
    43:43:java.lang.Class holderArrayType() -> holderArrayType
    49:52:java.math.BigInteger foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    57:57:java.math.BigInteger toTarget(java.lang.Long) -> toTarget
    62:69:byte[] targetToForeignHolderBytes(java.math.BigInteger) -> targetToForeignHolderBytes
    74:74:java.math.BigInteger[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    79:79:java.math.BigInteger[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    84:84:long[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    89:89:long[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    94:94:java.lang.Long convertToHolder(java.lang.Object) -> convertToHolder
    99:99:long[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    104:104:java.math.BigInteger convertToTarget(java.lang.Object) -> convertToTarget
    109:109:java.math.BigInteger[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI8 -> neureka.dtype.custom.UI8:
    14:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:49:java.lang.Short foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    55:55:java.lang.Short toTarget(java.lang.Byte) -> toTarget
    61:61:byte[] targetToForeignHolderBytes(java.lang.Short) -> targetToForeignHolderBytes
    66:72:short[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    77:77:short[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    82:88:byte[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    93:93:byte[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    98:98:java.lang.Byte convertToHolder(java.lang.Object) -> convertToHolder
    103:103:byte[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    108:121:java.lang.Short convertToTarget(java.lang.Object) -> convertToTarget
    126:126:short[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    10:10:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    10:10:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    10:10:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    10:10:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    10:10:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    10:10:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    10:10:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    10:10:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    10:10:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    10:10:java.lang.Object toTarget(java.lang.Object) -> toTarget
    10:10:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.framing.NDFrame -> neureka.framing.NDFrame:
    java.util.List _hiddenKeys -> a
    java.util.Map _mapping -> b
    java.lang.String _tensorName -> c
    35:60:void <init>(java.util.List,java.lang.String) -> <init>
    35:66:void <init>(int,java.lang.String) -> <init>
    35:87:void <init>(java.util.Map,neureka.Tsr,java.lang.String) -> <init>
    90:90:int[] get(java.util.List) -> get
    94:103:int[] get(java.lang.Object[]) -> get
    118:164:neureka.framing.states.AxisFrame atAxis(java.lang.Object) -> atAxis
    168:180:java.util.Map _initializeIdxmap(java.lang.Object,java.lang.Object,int) -> a
    191:203:java.lang.String _paddedCentered(java.lang.String,int) -> a
    210:270:java.lang.String toString() -> toString
    276:278:boolean update(neureka.Component$OwnerChangeRequest) -> update
    282:282:java.util.Map getMapping() -> getMapping
    286:286:java.lang.String getTensorName() -> getTensorName
    240:256:void lambda$toString$14(java.lang.Object[],int[],java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    244:245:void lambda$toString$13(int[],java.lang.Object[],java.lang.Object,java.lang.Integer) -> a
    223:229:void lambda$toString$12(java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    218:218:java.lang.Boolean lambda$toString$11(int,int,java.lang.Integer) -> a
    157:161:java.util.List lambda$atAxis$10(java.lang.Object,java.lang.Integer) -> a
    159:159:void lambda$atAxis$9(java.lang.Integer,java.util.List,java.lang.Object,java.lang.Integer) -> a
    147:152:java.util.List lambda$atAxis$8(java.lang.Object) -> a
    150:150:void lambda$atAxis$7(java.util.List,java.lang.Object,java.lang.Integer) -> a
    138:138:neureka.utility.functional.With lambda$atAxis$6(java.lang.Object,java.lang.Object) -> a
    139:142:neureka.framing.NDFrame lambda$atAxis$5(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    130:130:neureka.framing.states.AxisFrame$Set lambda$atAxis$4(java.lang.Object,java.lang.Object) -> b
    132:134:neureka.framing.NDFrame lambda$atAxis$3(java.lang.Object,java.lang.Object,int) -> b
    120:120:neureka.framing.states.Get lambda$atAxis$2(java.lang.Object,java.lang.Object) -> c
    122:126:java.lang.Integer lambda$atAxis$1(java.lang.Object,java.lang.Object) -> d
    73:86:void lambda$new$0(int[],neureka.Tsr,java.lang.Object,java.util.List) -> a
neureka.framing.Relation -> neureka.framing.Relation:
    neureka.Tsr _parent -> a
    java.lang.ref.WeakReference[] _children -> b
    int[][] _shapeRelations -> c
    59:59:void <init>() -> <init>
    99:123:boolean update(neureka.Component$OwnerChangeRequest) -> update
    129:130:neureka.framing.Relation addParent(neureka.Tsr) -> addParent
    136:149:neureka.framing.Relation addChild(neureka.Tsr) -> addChild
    172:178:neureka.framing.Relation addReshapeRelationFor(neureka.Tsr,int[]) -> addReshapeRelationFor
    201:207:int[] getReshapeRelationFor(neureka.Tsr) -> getReshapeRelationFor
    212:222:neureka.framing.Relation foreachChild(java.util.function.Consumer) -> foreachChild
    234:237:neureka.Tsr findRootTensor() -> findRootTensor
    242:242:boolean hasParent() -> hasParent
    247:247:boolean hasChildren() -> hasChildren
    252:252:int childCount() -> childCount
    257:257:neureka.framing.Relation remove(neureka.Tsr) -> remove
    261:261:java.lang.String toString() -> toString
    265:265:neureka.Tsr getParent() -> getParent
neureka.framing.states.At -> neureka.framing.states.At:
    java.lang.Object at(java.lang.Object) -> at
neureka.framing.states.AxisFrame -> neureka.framing.states.AxisFrame:
    neureka.framing.states.At _keyBasedGetter -> a
    neureka.framing.states.At _keyBasedSetter -> b
    neureka.utility.functional.Replace _replace -> c
    java.util.function.Supplier _allAliasGetter -> d
    java.util.function.Function _allAliasGetterForIndex -> e
    38:44:void <init>(neureka.framing.states.At,neureka.framing.states.At,neureka.utility.functional.Replace,java.util.function.Supplier,java.util.function.Function) -> <init>
    47:47:neureka.framing.states.AxisFrame$Builder builder() -> builder
    51:51:java.lang.Object getIndexAtAlias(java.lang.Object) -> getIndexAtAlias
    55:55:neureka.framing.states.AxisFrame$Set atIndexAlias(java.lang.Object) -> atIndexAlias
    59:59:neureka.utility.functional.With replace(java.lang.Object) -> replace
    63:63:java.util.List getAllAliases() -> getAllAliases
    67:67:java.util.List getAllAliasesForIndex(int) -> getAllAliasesForIndex
    18:18:void <init>(neureka.framing.states.At,neureka.framing.states.At,neureka.utility.functional.Replace,java.util.function.Supplier,java.util.function.Function,byte) -> <init>
neureka.framing.states.AxisFrame$Builder -> neureka.framing.states.AxisFrame$Builder:
    neureka.framing.states.At keyBasedGetter -> a
    neureka.framing.states.At keyBasedSetter -> b
    neureka.utility.functional.Replace replacer -> c
    java.util.function.Supplier allAliasGetter -> d
    java.util.function.Function allAliasGetterForIndex -> e
    78:78:void <init>() -> <init>
    81:82:neureka.framing.states.AxisFrame$Builder getter(neureka.framing.states.At) -> getter
    86:87:neureka.framing.states.AxisFrame$Builder setter(neureka.framing.states.At) -> setter
    91:92:neureka.framing.states.AxisFrame$Builder replacer(neureka.utility.functional.Replace) -> replacer
    96:97:neureka.framing.states.AxisFrame$Builder allAliasGetter(java.util.function.Supplier) -> allAliasGetter
    101:102:neureka.framing.states.AxisFrame$Builder allAliasGetterFor(java.util.function.Function) -> allAliasGetterFor
    106:106:neureka.framing.states.AxisFrame build() -> build
neureka.framing.states.AxisFrame$Set -> neureka.framing.states.AxisFrame$Set:
    neureka.framing.NDFrame setIndex(int) -> setIndex
neureka.framing.states.Get -> neureka.framing.states.Get:
    java.lang.Object get() -> get
neureka.framing.states.Set -> neureka.framing.states.Set:
    neureka.framing.NDFrame set(int) -> set
neureka.ndim.AbstractComponentOwner -> neureka.ndim.AbstractComponentOwner:
    java.util.Map _CLASS_ORDER -> a
    neureka.Component[] _components -> b
    75:103:void <init>() -> <init>
    105:105:java.lang.Object _this() -> _this
    108:109:void _setComps(neureka.Component[]) -> a
    112:145:void _addOrRemoveComp(neureka.Component,boolean) -> a
    148:162:void _remove(neureka.Component) -> a
    165:184:void _add(neureka.Component) -> b
    198:208:void _transferFrom(neureka.ndim.AbstractComponentOwner) -> _transferFrom
    214:214:void _deleteComponents() -> _deleteComponents
    228:233:neureka.Component find(java.lang.Class) -> find
    246:249:java.lang.Object remove(java.lang.Class) -> remove
    260:260:boolean has(java.lang.Class) -> has
    275:284:java.lang.Object set(neureka.Component) -> set
    neureka.Component _setOrReject(neureka.Component) -> _setOrReject
    neureka.Component _removeOrReject(neureka.Component) -> _removeOrReject
    329:334:boolean forComponent(java.lang.Class,java.util.function.Consumer) -> forComponent
    75:75:void access$000(neureka.ndim.AbstractComponentOwner,neureka.Component) -> a
    75:75:void access$100(neureka.ndim.AbstractComponentOwner,neureka.Component) -> b
    89:98:void <clinit>() -> <clinit>
neureka.ndim.AbstractComponentOwner$1 -> neureka.ndim.AbstractComponentOwner$1:
    neureka.Component val$component -> a
    boolean[] val$changeExecuted -> b
    neureka.ndim.AbstractComponentOwner this$0 -> c
    116:116:void <init>(neureka.ndim.AbstractComponentOwner,neureka.Component,boolean[]) -> <init>
    117:117:java.lang.Object getOldOwner() -> getOldOwner
    118:118:java.lang.Object getNewOwner() -> getNewOwner
    120:122:boolean executeChange() -> executeChange
neureka.ndim.AbstractComponentOwner$2 -> neureka.ndim.AbstractComponentOwner$2:
    neureka.Component val$component -> a
    boolean[] val$changeExecuted -> b
    neureka.ndim.AbstractComponentOwner this$0 -> c
    132:132:void <init>(neureka.ndim.AbstractComponentOwner,neureka.Component,boolean[]) -> <init>
    133:133:java.lang.Object getOldOwner() -> getOldOwner
    134:134:java.lang.Object getNewOwner() -> getNewOwner
    136:138:boolean executeChange() -> executeChange
neureka.ndim.AbstractComponentOwner$3 -> neureka.ndim.AbstractComponentOwner$3:
    neureka.ndim.AbstractComponentOwner val$other -> a
    neureka.ndim.AbstractComponentOwner this$0 -> b
    201:201:void <init>(neureka.ndim.AbstractComponentOwner,neureka.ndim.AbstractComponentOwner) -> <init>
    202:202:java.lang.Object getOldOwner() -> getOldOwner
    203:203:java.lang.Object getNewOwner() -> getNewOwner
    204:204:boolean executeChange() -> executeChange
neureka.ndim.AbstractNDArray -> neureka.ndim.AbstractNDArray:
    org.slf4j.Logger _LOG -> _LOG
    neureka.ndim.config.NDConfiguration _NDConf -> a
    neureka.dtype.DataType _dataType -> b
    java.lang.Object _data -> c
    boolean $assertionsDisabled -> d
    67:76:void <init>() -> <init>
    boolean isDeleted() -> isDeleted
    85:85:void _guardGet(java.lang.String) -> _guardGet
    86:86:void _guardSet(java.lang.String) -> _guardSet
    87:87:void _guardMod(java.lang.String) -> _guardMod
    97:101:void _guard(java.lang.String) -> a
    106:106:neureka.ndim.config.NDConfiguration getNDConf() -> getNDConf
    115:115:neureka.dtype.DataType getDataType() -> getDataType
    124:124:java.lang.Object getData() -> getData
    131:131:java.lang.Class getValueClass() -> getValueClass
    146:153:java.lang.Object setDataType(neureka.dtype.DataType) -> setDataType
    158:174:void _setData(java.lang.Object) -> _setData
    178:200:void _initData(neureka.ndim.Initializer) -> _initData
    212:212:void _allocate(int) -> _allocate
    java.lang.Object setIsVirtual(boolean) -> setIsVirtual
    boolean isVirtual() -> isVirtual
    void _setIsVirtual(boolean) -> _setIsVirtual
    222:223:neureka.utility.NDAConstructor createConstructionAPI() -> createConstructionAPI
    244:244:void _virtualize() -> _virtualize
    256:256:void _actualize() -> _actualize
    260:269:java.lang.Object _convertedDataOfType(java.lang.Class) -> _convertedDataOfType
    276:277:void forEach(java.util.function.Consumer) -> forEach
    282:282:java.util.Spliterator spliterator() -> spliterator
    java.lang.Object getDataAt(int) -> getDataAt
    java.lang.Object setDataAt(int,java.lang.Object) -> setDataAt
    334:335:boolean is(java.lang.Class) -> is
    341:341:int indexOfIndex(int) -> indexOfIndex
    345:345:int[] IndicesOfIndex(int) -> IndicesOfIndex
    349:349:int indexOfIndices(int[]) -> indexOfIndices
    363:370:java.lang.Object setNDConf(neureka.ndim.config.NDConfiguration) -> setNDConf
    376:376:int rank() -> rank
    380:380:java.util.List shape() -> shape
    384:384:int shape(int) -> shape
    388:388:java.util.List indicesMap() -> indicesMap
    392:392:java.util.List translation() -> translation
    396:396:java.util.List spread() -> spread
    400:400:java.util.List offset() -> offset
    404:404:int size() -> size
    408:410:java.util.List _asList(int[]) -> _asList
    366:366:int lambda$setNDConf$1(int,int) -> a
    365:365:int lambda$setNDConf$0(int,int) -> b
    67:67:void <clinit>() -> <clinit>
neureka.ndim.AbstractNDArray$1 -> neureka.ndim.AbstractNDArray$1:
    neureka.ndim.AbstractNDArray val$nda -> a
    224:224:void <init>(neureka.ndim.AbstractNDArray,neureka.ndim.AbstractNDArray) -> <init>
    225:225:void setType(neureka.dtype.DataType) -> setType
    226:226:void setConf(neureka.ndim.config.NDConfiguration) -> setConf
    227:227:void setData(java.lang.Object) -> setData
    228:228:void allocate(int) -> allocate
    229:229:java.lang.Object getData() -> getData
    230:230:void setIsVirtual(boolean) -> setIsVirtual
neureka.ndim.AbstractNDArray$2 -> neureka.ndim.AbstractNDArray$2:
    283:283:void <init>(neureka.ndim.AbstractNDArray) -> <init>
    286:286:boolean tryAdvance(java.util.function.Consumer) -> tryAdvance
    291:291:java.util.Spliterator trySplit() -> trySplit
    296:296:long estimateSize() -> estimateSize
    301:301:int characteristics() -> characteristics
neureka.ndim.AbstractNDArray$Utility -> neureka.ndim.AbstractNDArray$Utility:
    421:421:void <init>() -> <init>
neureka.ndim.AbstractNDArray$Utility$Indexing -> neureka.ndim.AbstractNDArray$Utility$Indexing:
    437:437:void <init>() -> <init>
    441:451:void shpCheck(int[],neureka.Tsr) -> shpCheck
    455:476:int[][] makeFit(int[],int[]) -> makeFit
    481:483:int[] shpOfCon(int[],int[]) -> shpOfCon
    488:495:int[] shpOfBrc(int[],int[]) -> shpOfBrc
neureka.ndim.AbstractNDArray$Utility$Stringify -> neureka.ndim.AbstractNDArray$Utility$Stringify:
    423:423:void <init>() -> <init>
    427:430:java.lang.String strConf(int[]) -> strConf
neureka.ndim.Initializer -> neureka.ndim.Initializer:
    java.lang.Object init(int,int[]) -> init
neureka.ndim.config.AbstractNDC -> neureka.ndim.config.AbstractNDC:
    java.util.Map _CACHED_NDCS -> a
    java.util.Map _CACHED_INT_ARRAYS -> b
    boolean $assertionsDisabled -> c
    24:24:void <init>() -> <init>
    60:83:int[] _cacheArray(int[]) -> _cacheArray
    93:100:int[] asInlineArray() -> asInlineArray
    109:113:long keyCode() -> keyCode
    119:123:boolean equals(neureka.ndim.config.NDConfiguration) -> equals
    135:166:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    171:177:neureka.ndim.config.NDConfiguration _cached(neureka.ndim.config.NDConfiguration) -> _cached
    188:194:boolean _isSimpleConfiguration(int[],int[],int[],int[],int[]) -> a
    201:206:java.lang.String toString() -> toString
    212:225:neureka.ndim.config.NDConfiguration _simpleReshape(int[],neureka.ndim.config.NDConfiguration) -> _simpleReshape
    232:235:neureka.ndim.config.NDConfiguration newReshaped(int[]) -> newReshaped
    24:48:void <clinit>() -> <clinit>
neureka.ndim.config.NDConfiguration -> neureka.ndim.config.NDConfiguration:
    int rank() -> rank
    int[] shape() -> shape
    int shape(int) -> shape
    int[] indicesMap() -> indicesMap
    int indicesMap(int) -> indicesMap
    int[] translation() -> translation
    int translation(int) -> translation
    int[] spread() -> spread
    int spread(int) -> spread
    int[] offset() -> offset
    int offset(int) -> offset
    int indexOfIndex(int) -> indexOfIndex
    int[] indicesOfIndex(int) -> indicesOfIndex
    int indexOfIndices(int[]) -> indexOfIndices
    int[] asInlineArray() -> asInlineArray
    long keyCode() -> keyCode
    boolean equals(neureka.ndim.config.NDConfiguration) -> equals
    neureka.ndim.config.NDConfiguration newReshaped(int[]) -> newReshaped
    167:174:boolean isSimple() -> isSimple
    174:174:boolean lambda$isSimple$1(int) -> a
    170:170:boolean lambda$isSimple$0(int) -> b
neureka.ndim.config.NDConfiguration$Utility -> neureka.ndim.config.NDConfiguration$Utility:
    182:182:void <init>() -> <init>
    186:192:int[] rearrange(int[],int[],int[]) -> rearrange
    197:202:int[] rearrange(int[],int[]) -> rearrange
    207:213:int[] newTlnOf(int[]) -> newTlnOf
    218:220:void increment(int[],int[]) -> increment
    1225:1234:int _incrementAt(int,int[],int[]):225:234 -> increment
    1225:1234:void increment(int[],int[]):219 -> increment
    239:241:int szeOfShp(int[]) -> szeOfShp
neureka.ndim.config.types.D1C -> neureka.ndim.config.types.D1C:
    5:5:void <init>() -> <init>
    int indexOfIndices(int) -> indexOfIndices
neureka.ndim.config.types.D2C -> neureka.ndim.config.types.D2C:
    5:5:void <init>() -> <init>
    int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.D3C -> neureka.ndim.config.types.D3C:
    5:5:void <init>() -> <init>
    int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.complex.ComplexD1Configuration -> neureka.ndim.config.types.complex.ComplexD1Configuration:
    int _shape -> _shape
    int _translation -> a
    int _indicesMap -> b
    int _spread -> c
    int _offset -> d
    boolean $assertionsDisabled -> e
    37:37:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    46:55:void <init>(int,int,int,int,int) -> <init>
    59:59:int rank() -> rank
    64:64:int[] shape() -> shape
    69:69:int shape(int) -> shape
    74:74:int[] indicesMap() -> indicesMap
    79:79:int indicesMap(int) -> indicesMap
    84:84:int[] translation() -> translation
    89:89:int translation(int) -> translation
    94:94:int[] spread() -> spread
    99:99:int spread(int) -> spread
    104:104:int[] offset() -> offset
    109:109:int offset(int) -> offset
    115:115:int indexOfIndex(int) -> indexOfIndex
    120:120:int[] indicesOfIndex(int) -> indicesOfIndex
    124:124:int indexOfIndices(int[]) -> indexOfIndices
    130:130:int indexOfIndices(int) -> indexOfIndices
    6:6:void <clinit>() -> <clinit>
neureka.ndim.config.types.complex.ComplexD2Configuration -> neureka.ndim.config.types.complex.ComplexD2Configuration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _translation1 -> a
    int _translation2 -> b
    int _indicesMap1 -> c
    int _indicesMap2 -> d
    int _spread1 -> e
    int _spread2 -> f
    int _offset1 -> g
    int _offset2 -> h
    41:52:void <init>(int[],int[],int[],int[],int[]) -> <init>
    61:61:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    66:66:int rank() -> rank
    71:71:int[] shape() -> shape
    76:76:int shape(int) -> shape
    81:81:int[] indicesMap() -> indicesMap
    86:86:int indicesMap(int) -> indicesMap
    91:91:int[] translation() -> translation
    96:96:int translation(int) -> translation
    101:101:int[] spread() -> spread
    106:106:int spread(int) -> spread
    111:111:int[] offset() -> offset
    116:116:int offset(int) -> offset
    124:124:int indexOfIndex(int) -> indexOfIndex
    130:134:int[] indicesOfIndex(int) -> indicesOfIndex
    139:142:int indexOfIndices(int[]) -> indexOfIndices
    147:150:int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.complex.ComplexD3Configuration -> neureka.ndim.config.types.complex.ComplexD3Configuration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _shape3 -> _shape3
    int _translation1 -> a
    int _translation2 -> b
    int _translation3 -> c
    int _indicesMap1 -> d
    int _indicesMap2 -> e
    int _indicesMap3 -> f
    int _spread1 -> g
    int _spread2 -> h
    int _spread3 -> i
    int _offset1 -> j
    int _offset2 -> k
    int _offset3 -> l
    46:62:void <init>(int[],int[],int[],int[],int[]) -> <init>
    71:71:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    76:76:int rank() -> rank
    81:81:int[] shape() -> shape
    86:86:int shape(int) -> shape
    91:91:int[] indicesMap() -> indicesMap
    96:96:int indicesMap(int) -> indicesMap
    101:101:int[] translation() -> translation
    106:106:int translation(int) -> translation
    111:111:int[] spread() -> spread
    116:116:int spread(int) -> spread
    121:121:int[] offset() -> offset
    126:126:int offset(int) -> offset
    135:140:int indexOfIndex(int) -> indexOfIndex
    148:153:int[] indicesOfIndex(int) -> indicesOfIndex
    158:158:int indexOfIndices(int[]) -> indexOfIndices
    165:165:int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.complex.ComplexDefaultNDConfiguration -> neureka.ndim.config.types.complex.ComplexDefaultNDConfiguration:
    int[] _shape -> _shape
    int[] _translation -> a
    int[] _indicesMap -> b
    int[] _spread -> c
    int[] _offset -> d
    41:47:void <init>(int[],int[],int[],int[],int[]) -> <init>
    56:56:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    61:61:int rank() -> rank
    66:66:int[] shape() -> shape
    71:71:int shape(int) -> shape
    76:76:int[] indicesMap() -> indicesMap
    81:81:int indicesMap(int) -> indicesMap
    86:86:int[] translation() -> translation
    91:91:int translation(int) -> translation
    96:96:int[] spread() -> spread
    101:101:int spread(int) -> spread
    106:106:int[] offset() -> offset
    111:111:int offset(int) -> offset
    119:119:int indexOfIndex(int) -> indexOfIndex
    124:129:int[] indicesOfIndex(int) -> indicesOfIndex
    134:137:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.complex.ComplexScalarConfiguration -> neureka.ndim.config.types.complex.ComplexScalarConfiguration:
    int _shape -> _shape
    int _offset -> a
    25:25:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    31:34:void <init>(int,int) -> <init>
    38:38:int rank() -> rank
    43:43:int[] shape() -> shape
    48:48:int shape(int) -> shape
    53:53:int[] indicesMap() -> indicesMap
    58:58:int indicesMap(int) -> indicesMap
    63:63:int[] translation() -> translation
    68:68:int translation(int) -> translation
    73:73:int[] spread() -> spread
    78:78:int spread(int) -> spread
    83:83:int[] offset() -> offset
    88:88:int offset(int) -> offset
    94:94:int indexOfIndex(int) -> indexOfIndex
    99:99:int[] indicesOfIndex(int) -> indicesOfIndex
    104:104:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleD1Configuration -> neureka.ndim.config.types.simple.SimpleD1Configuration:
    int _shape -> _shape
    int _translation_and_indicesMap -> a
    23:23:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    29:32:void <init>(int,int) -> <init>
    36:36:int rank() -> rank
    41:41:int[] shape() -> shape
    46:46:int shape(int) -> shape
    51:51:int[] indicesMap() -> indicesMap
    56:56:int indicesMap(int) -> indicesMap
    61:61:int[] translation() -> translation
    66:66:int translation(int) -> translation
    71:71:int[] spread() -> spread
    76:76:int spread(int) -> spread
    81:81:int[] offset() -> offset
    86:86:int offset(int) -> offset
    92:92:int indexOfIndex(int) -> indexOfIndex
    97:97:int[] indicesOfIndex(int) -> indicesOfIndex
    102:102:int indexOfIndices(int[]) -> indexOfIndices
    107:107:int indexOfIndices(int) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleD2Configuration -> neureka.ndim.config.types.simple.SimpleD2Configuration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _translation1 -> a
    int _translation2 -> b
    23:28:void <init>(int[],int[]) -> <init>
    34:34:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    40:40:int rank() -> rank
    45:45:int[] shape() -> shape
    50:50:int shape(int) -> shape
    55:55:int[] indicesMap() -> indicesMap
    60:60:int indicesMap(int) -> indicesMap
    65:65:int[] translation() -> translation
    70:70:int translation(int) -> translation
    75:75:int[] spread() -> spread
    80:80:int spread(int) -> spread
    85:85:int[] offset() -> offset
    90:90:int offset(int) -> offset
    98:98:int indexOfIndex(int) -> indexOfIndex
    104:108:int[] indicesOfIndex(int) -> indicesOfIndex
    113:116:int indexOfIndices(int[]) -> indexOfIndices
    121:124:int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleD3Configuration -> neureka.ndim.config.types.simple.SimpleD3Configuration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _shape3 -> _shape3
    int _translation1 -> a
    int _translation2 -> b
    int _translation3 -> c
    24:31:void <init>(int[],int[]) -> <init>
    37:37:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    42:42:int rank() -> rank
    47:47:int[] shape() -> shape
    52:52:int shape(int) -> shape
    57:57:int[] indicesMap() -> indicesMap
    62:62:int indicesMap(int) -> indicesMap
    67:67:int[] translation() -> translation
    72:72:int translation(int) -> translation
    77:77:int[] spread() -> spread
    82:82:int spread(int) -> spread
    87:87:int[] offset() -> offset
    92:92:int offset(int) -> offset
    101:106:int indexOfIndex(int) -> indexOfIndex
    114:119:int[] indicesOfIndex(int) -> indicesOfIndex
    124:124:int indexOfIndices(int[]) -> indexOfIndices
    131:131:int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleDefaultNDConfiguration -> neureka.ndim.config.types.simple.SimpleDefaultNDConfiguration:
    int[] _shape -> _shape
    int[] _translation_and_indicesMap -> a
    23:26:void <init>(int[],int[]) -> <init>
    32:32:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    37:37:int rank() -> rank
    42:42:int[] shape() -> shape
    47:47:int shape(int) -> shape
    52:52:int[] indicesMap() -> indicesMap
    57:57:int indicesMap(int) -> indicesMap
    62:62:int[] translation() -> translation
    67:67:int translation(int) -> translation
    72:74:int[] spread() -> spread
    79:79:int spread(int) -> spread
    84:84:int[] offset() -> offset
    89:89:int offset(int) -> offset
    97:97:int indexOfIndex(int) -> indexOfIndex
    102:107:int[] indicesOfIndex(int) -> indicesOfIndex
    112:114:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleScalarConfiguration -> neureka.ndim.config.types.simple.SimpleScalarConfiguration:
    9:9:neureka.ndim.config.NDConfiguration construct() -> construct
    12:12:void <init>() -> <init>
    16:16:int rank() -> rank
    21:21:int[] shape() -> shape
    26:26:int shape(int) -> shape
    31:31:int[] indicesMap() -> indicesMap
    36:36:int indicesMap(int) -> indicesMap
    41:41:int[] translation() -> translation
    46:46:int translation(int) -> translation
    51:51:int[] spread() -> spread
    56:56:int spread(int) -> spread
    61:61:int[] offset() -> offset
    66:66:int offset(int) -> offset
    71:71:int indexOfIndex(int) -> indexOfIndex
    76:76:int[] indicesOfIndex(int) -> indicesOfIndex
    81:81:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.views.SimpleReshapeView -> neureka.ndim.config.types.views.SimpleReshapeView:
    neureka.ndim.config.NDConfiguration _toBeViewed -> a
    int[] _form -> b
    int[] _formTranslator -> c
    int[] _shape -> d
    int[] _translation -> e
    int[] _indicesMap -> f
    int[] _spread -> g
    int[] _offset -> h
    23:44:void <init>(int[],neureka.ndim.config.NDConfiguration) -> <init>
    48:48:int rank() -> rank
    53:53:int[] shape() -> shape
    58:58:int shape(int) -> shape
    63:63:int[] indicesMap() -> indicesMap
    68:68:int indicesMap(int) -> indicesMap
    73:73:int[] translation() -> translation
    78:78:int translation(int) -> translation
    83:83:int[] spread() -> spread
    88:88:int spread(int) -> spread
    93:93:int[] offset() -> offset
    98:98:int offset(int) -> offset
    103:103:int indexOfIndex(int) -> indexOfIndex
    108:113:int[] indicesOfIndex(int) -> indicesOfIndex
    118:119:int indexOfIndices(int[]) -> indexOfIndices
    1124:1127:int[] _rearrange(int[],int[],int[]):124:127 -> indexOfIndices
    1124:1127:int indexOfIndices(int[]):118 -> indexOfIndices
    35:35:int lambda$new$0(java.lang.Integer) -> a
neureka.ndim.config.types.virtual.VirtualNDConfiguration -> neureka.ndim.config.types.virtual.VirtualNDConfiguration:
    java.util.Map _Virtual_Cache -> a
    int[] _shape -> b
    16:18:void <init>(int[]) -> <init>
    23:30:neureka.ndim.config.NDConfiguration construct(int[]) -> construct
    35:35:int rank() -> rank
    40:40:int[] shape() -> shape
    45:45:int shape(int) -> shape
    50:50:int[] indicesMap() -> indicesMap
    55:55:int indicesMap(int) -> indicesMap
    60:60:int[] translation() -> translation
    65:65:int translation(int) -> translation
    70:70:int[] spread() -> spread
    75:75:int spread(int) -> spread
    80:80:int[] offset() -> offset
    85:85:int offset(int) -> offset
    90:90:int indexOfIndex(int) -> indexOfIndex
    95:95:int[] indicesOfIndex(int) -> indicesOfIndex
    100:100:int indexOfIndices(int[]) -> indexOfIndices
    12:12:void <clinit>() -> <clinit>
neureka.ndim.iterators.NDIterator -> neureka.ndim.iterators.NDIterator:
    63:76:neureka.ndim.iterators.NDIterator of(neureka.Tsr) -> of
    int shape(int) -> shape
    int[] shape() -> shape
    void increment() -> increment
    void decrement() -> decrement
    int i() -> i
    int get(int) -> get
    int[] get() -> get
    void set(int,int) -> set
    void set(int[]) -> set
    int rank() -> rank
    102:113:java.lang.String asString() -> asString
    111:111:void lambda$asString$1(java.util.StringJoiner,int) -> a
    106:106:void lambda$asString$0(java.util.StringJoiner,int) -> b
neureka.ndim.iterators.types.DefaultNDIterator -> neureka.ndim.iterators.types.DefaultNDIterator:
    int[] _indices -> a
    int[] _shape -> b
    neureka.ndim.config.NDConfiguration _conf -> c
    12:16:void <init>(neureka.ndim.config.NDConfiguration) -> <init>
    20:20:int shape(int) -> shape
    25:25:int[] shape() -> shape
    30:31:void increment() -> increment
    36:36:void decrement() -> decrement
    40:40:int i() -> i
    45:45:int get(int) -> get
    50:50:int[] get() -> get
    55:56:void set(int,int) -> set
    60:61:void set(int[]) -> set
    65:65:int rank() -> rank
neureka.ndim.iterators.types.VirtualNDIterator -> neureka.ndim.iterators.types.VirtualNDIterator:
    neureka.ndim.config.types.virtual.VirtualNDConfiguration _conf -> a
    10:12:void <init>(neureka.ndim.config.types.virtual.VirtualNDConfiguration) -> <init>
    16:16:int shape(int) -> shape
    21:21:int[] shape() -> shape
    27:27:void increment() -> increment
    32:32:void decrement() -> decrement
    36:36:int i() -> i
    41:41:int get(int) -> get
    46:46:int[] get() -> get
    52:52:void set(int,int) -> set
    57:57:void set(int[]) -> set
    61:61:int rank() -> rank
neureka.ndim.iterators.types.complex.ComplexD1CIterator -> neureka.ndim.iterators.types.complex.ComplexD1CIterator:
    int _d1 -> a
    11:12:void <init>(neureka.ndim.config.types.complex.ComplexD1Configuration) -> <init>
    16:17:void increment() -> increment
    21:22:void decrement() -> decrement
    27:27:int i() -> i
    32:32:int get(int) -> get
    37:37:int[] get() -> get
    42:43:void set(int,int) -> set
    47:48:void set(int[]) -> set
    52:52:int rank() -> rank
neureka.ndim.iterators.types.complex.main.ComplexD2CIterator -> neureka.ndim.iterators.types.complex.main.ComplexD2CIterator:
    int _d1 -> _d1
    int _d2 -> _d2
    8:13:void <init>(neureka.ndim.config.types.complex.ComplexD2Configuration) -> <init>
    18:23:void increment() -> increment
    27:31:void decrement() -> decrement
    35:35:int i() -> i
    40:40:int get(int) -> get
    45:45:int[] get() -> get
    50:52:void set(int,int) -> set
    56:58:void set(int[]) -> set
neureka.ndim.iterators.types.complex.main.ComplexD3CIterator -> neureka.ndim.iterators.types.complex.main.ComplexD3CIterator:
    int _d1 -> _d1
    int _d2 -> _d2
    int _d3 -> _d3
    8:14:void <init>(neureka.ndim.config.types.complex.ComplexD3Configuration) -> <init>
    19:28:void increment() -> increment
    32:38:void decrement() -> decrement
    42:42:int i() -> i
    47:47:int get(int) -> get
    52:52:int[] get() -> get
    57:60:void set(int,int) -> set
    64:67:void set(int[]) -> set
neureka.ndim.iterators.types.simple.SimpleD1CIterator -> neureka.ndim.iterators.types.simple.SimpleD1CIterator:
    int _d1 -> a
    12:13:void <init>(neureka.ndim.config.types.simple.SimpleD1Configuration) -> <init>
    18:19:void increment() -> increment
    23:24:void decrement() -> decrement
    29:29:int i() -> i
    34:34:int get(int) -> get
    39:39:int[] get() -> get
    44:45:void set(int,int) -> set
    49:50:void set(int[]) -> set
    54:54:int rank() -> rank
neureka.ndim.iterators.types.simple.main.SimpleD2CIterator -> neureka.ndim.iterators.types.simple.main.SimpleD2CIterator:
    int _d1 -> _d1
    int _d2 -> _d2
    8:13:void <init>(neureka.ndim.config.types.simple.SimpleD2Configuration) -> <init>
    17:22:void increment() -> increment
    26:30:void decrement() -> decrement
    34:34:int i() -> i
    39:39:int get(int) -> get
    44:44:int[] get() -> get
    49:51:void set(int,int) -> set
    55:57:void set(int[]) -> set
neureka.ndim.iterators.types.simple.main.SimpleD3CIterator -> neureka.ndim.iterators.types.simple.main.SimpleD3CIterator:
    int _d1 -> _d1
    int _d2 -> _d2
    int _d3 -> _d3
    8:14:void <init>(neureka.ndim.config.types.simple.SimpleD3Configuration) -> <init>
    19:28:void increment() -> increment
    32:38:void decrement() -> decrement
    42:42:int i() -> i
    47:47:int get(int) -> get
    52:52:int[] get() -> get
    57:60:void set(int,int) -> set
    64:67:void set(int[]) -> set
neureka.optimization.Optimizer -> neureka.optimization.Optimizer:
    void optimize(neureka.Tsr) -> optimize
neureka.optimization.implementations.ADAM -> neureka.optimization.implementations.ADAM:
    neureka.Tsr a -> a
    neureka.Tsr b1 -> b
    neureka.Tsr b2 -> c
    neureka.Tsr e -> d
    neureka.Tsr m -> e
    neureka.Tsr v -> f
    74:75:void optimize(neureka.Tsr) -> optimize
    1063:1070:void _optimize(neureka.Tsr):63:70 -> optimize
    1063:1070:void optimize(neureka.Tsr):74 -> optimize
    79:80:boolean update(neureka.Component$OwnerChangeRequest) -> update
neureka.optimization.implementations.SGD -> neureka.optimization.implementations.SGD:
    double _learningRate -> a
    neureka.calculus.Function _function -> b
    49:52:void <init>(double) -> <init>
    56:58:void optimize(neureka.Tsr) -> optimize
    61:61:double learningRate() -> learningRate
    66:67:boolean update(neureka.Component$OwnerChangeRequest) -> update
neureka.optimization.implementations.Template -> neureka.optimization.implementations.Template:
    5:5:void <init>() -> <init>
neureka.utility.CustomCleaner -> neureka.utility.CustomCleaner:
    java.lang.ref.ReferenceQueue _referenceQueue -> a
    int _registered -> b
    java.util.List list -> c
    14:20:void <init>() -> <init>
    37:42:void register(java.lang.Object,java.lang.Runnable) -> register
    46:59:void run() -> run
neureka.utility.CustomCleaner$ReferenceWithCleanup -> neureka.utility.CustomCleaner$a:
    java.lang.Runnable _action -> a
    27:29:void <init>(java.lang.Object,java.lang.Runnable,java.lang.ref.ReferenceQueue) -> <init>
    31:32:void cleanup() -> a
neureka.utility.DataConverter -> neureka.utility.DataConverter:
    org.slf4j.Logger _LOG -> a
    java.util.Map _converters -> b
    neureka.utility.DataConverter _instance -> c
    93:93:neureka.utility.DataConverter instance() -> instance
    102:161:void <init>() -> <init>
    177:191:void _set(java.lang.Class,java.lang.Class,neureka.utility.DataConverter$Conversion) -> a
    204:228:java.lang.Object convert(java.lang.Object,java.lang.Class) -> convert
    234:266:java.lang.Object convert(java.lang.Number[],java.lang.Class,int) -> convert
    237:237:java.lang.Number lambda$convert$7(java.lang.Number[],int) -> a
    237:237:int lambda$convert$6(int) -> a
    147:147:long[] lambda$new$5(java.util.List) -> a
    147:147:long lambda$new$4(java.lang.Object) -> a
    146:146:double[] lambda$new$3(java.util.List) -> b
    146:146:double lambda$new$2(java.lang.Object) -> b
    145:145:int[] lambda$new$1(java.util.List) -> c
    145:145:int lambda$new$0(java.lang.Object) -> c
    59:85:void <clinit>() -> <clinit>
neureka.utility.DataConverter$Conversion -> neureka.utility.DataConverter$a:
    java.lang.Object go(java.lang.Object) -> go
neureka.utility.DataConverter$Utility -> neureka.utility.DataConverter$Utility:
    275:275:void <init>() -> <init>
    278:282:float[] objFloatsToPrimFloats(java.lang.Float[]) -> objFloatsToPrimFloats
    286:290:double[] objDoublesToPrimDoubles(java.lang.Double[]) -> objDoublesToPrimDoubles
    294:298:int[] objIntsToPrimInts(java.lang.Integer[]) -> objIntsToPrimInts
    302:306:long[] objLongsToPrimLongs(java.lang.Long[]) -> objLongsToPrimLongs
    310:314:short[] objShortsToPrimShorts(java.lang.Short[]) -> objShortsToPrimShorts
    318:322:byte[] objBytesToPrimBytes(java.lang.Byte[]) -> objBytesToPrimBytes
    326:326:double[] newSeededDoubleArray(java.lang.String,int) -> newSeededDoubleArray
    330:330:double[] newSeededDoubleArray(long,int) -> newSeededDoubleArray
    334:334:double[] seededDoubleArray(double[],java.lang.String) -> seededDoubleArray
    338:341:double[] seededDoubleArray(double[],long) -> seededDoubleArray
    345:345:float[] newSeededFloatArray(java.lang.String,int) -> newSeededFloatArray
    349:349:float[] newSeededFloatArray(long,int) -> newSeededFloatArray
    353:353:float[] seededFloatArray(float[],java.lang.String) -> seededFloatArray
    357:360:float[] seededFloatArray(float[],long) -> seededFloatArray
    365:368:long _longStringHash(java.lang.String) -> a
    373:376:short[] byteToShort(byte[]) -> byteToShort
    380:383:java.math.BigInteger[] byteToBigInteger(byte[]) -> byteToBigInteger
    387:390:float[] doubleToFloat(double[]) -> doubleToFloat
    394:397:byte[] doubleToByte(double[]) -> doubleToByte
    401:404:short[] doubleToShort(double[]) -> doubleToShort
    408:411:long[] doubleToLong(double[]) -> doubleToLong
    415:418:double[] floatToDouble(float[]) -> floatToDouble
    422:425:byte[] floatToByte(float[]) -> floatToByte
    429:432:short[] floatToShort(float[]) -> floatToShort
    436:439:long[] floatToLong(float[]) -> floatToLong
    443:446:double[] shortToDouble(short[]) -> shortToDouble
    450:453:double[] byteToDouble(byte[]) -> byteToDouble
    457:460:float[] byteToFloat(byte[]) -> byteToFloat
    464:467:float[] shortToFloat(short[]) -> shortToFloat
    471:474:int[] byteToInt(byte[]) -> byteToInt
    478:481:int[] shortToInt(short[]) -> shortToInt
    485:488:byte[] shortToByte(short[]) -> shortToByte
    492:495:long[] byteToLong(byte[]) -> byteToLong
    499:502:long[] shortToLong(short[]) -> shortToLong
    506:509:java.math.BigInteger[] shortToBigInteger(short[]) -> shortToBigInteger
    513:516:float[] intToFloat(int[]) -> intToFloat
    520:523:int[] floatToInt(float[]) -> floatToInt
    527:530:java.math.BigInteger[] floatToBigInteger(float[]) -> floatToBigInteger
    534:537:int[] doubleToInt(double[]) -> doubleToInt
    541:544:java.math.BigInteger[] doubleToBigInteger(double[]) -> doubleToBigInteger
    548:551:double[] intToDouble(int[]) -> intToDouble
    555:558:long[] intToLong(int[]) -> intToLong
    562:565:short[] intToShort(int[]) -> intToShort
    569:572:byte[] intToByte(int[]) -> intToByte
    576:579:java.math.BigInteger[] intToBigInteger(int[]) -> intToBigInteger
    583:586:byte[] longToByte(long[]) -> longToByte
    590:593:short[] longToShort(long[]) -> longToShort
    597:600:int[] longToInt(long[]) -> longToInt
    604:607:float[] longToFloat(long[]) -> longToFloat
    612:615:double[] longToDouble(long[]) -> longToDouble
    620:623:java.math.BigInteger[] longToBigInteger(long[]) -> longToBigInteger
    630:637:double[] objectsToDoubles(java.lang.Object[],int) -> objectsToDoubles
    642:649:float[] objectsToFloats(java.lang.Object[],int) -> objectsToFloats
    654:661:short[] objectsToShorts(java.lang.Object[],int) -> objectsToShorts
    666:673:byte[] objectsToBytes(java.lang.Object[],int) -> objectsToBytes
    678:685:long[] objectsToLongs(java.lang.Object[],int) -> objectsToLongs
    690:697:int[] objectsToInts(java.lang.Object[],int) -> objectsToInts
neureka.utility.ListReader -> neureka.utility.ListReader:
    java.lang.Class _type -> a
    java.util.List _readers -> b
    int _size -> c
    21:48:void <init>(java.lang.Object,int,java.util.List,java.util.List,java.util.function.Function) -> <init>
    1053:1065:java.lang.Class _findType(java.util.List):53:65 -> <init>
    1053:1065:void <init>(java.lang.Object,int,java.util.List,java.util.List,java.util.function.Function):38 -> <init>
    1069:1077:int _findSize(java.util.List,int):69:77 -> <init>
    1069:1077:void <init>(java.lang.Object,int,java.util.List,java.util.List,java.util.function.Function):39 -> <init>
    50:50:java.lang.Class getType() -> getType
    77:77:java.lang.Integer lambda$_findSize$10(neureka.utility.ListReader) -> a
    74:74:boolean lambda$_findSize$9(int,java.lang.Integer) -> a
    71:71:boolean lambda$_findSize$8(int,java.lang.Integer) -> b
    69:69:java.util.stream.Stream lambda$_findSize$7(java.util.List) -> a
    69:69:java.lang.Integer lambda$_findSize$6(neureka.utility.ListReader) -> b
    61:61:boolean lambda$_findType$5(java.lang.Class,java.lang.Class) -> a
    55:55:boolean lambda$_findType$4(java.lang.Class,java.lang.Class) -> b
    53:53:java.util.stream.Stream lambda$_findType$3(java.util.List) -> b
    53:53:java.lang.Class lambda$_findType$2(neureka.utility.ListReader) -> c
    35:35:neureka.utility.ListReader lambda$new$1(int,java.util.List,java.util.List,java.util.function.Function,java.lang.Object) -> a
    28:28:boolean lambda$new$0(java.lang.Object) -> a
    1081:1084:boolean _isLeave(java.lang.Object):81:84 -> a
    1081:1084:boolean lambda$new$0(java.lang.Object):28 -> a
neureka.utility.Messages -> neureka.utility.Messages:
    java.lang.String ILLEGAL_OPERATION_STATE_ERROR -> ILLEGAL_OPERATION_STATE_ERROR
    java.lang.String OPERATION_LOADED_DEBUG -> OPERATION_LOADED_DEBUG
    java.lang.String CL_CONTEXT_NOT_CREATED_WARNING -> CL_CONTEXT_NOT_CREATED_WARNING
    14:14:void <init>() -> <init>
    14:14:java.lang.String access$000(java.lang.String,java.lang.Object[]) -> a
    1051:1051:java.lang.String _format(java.lang.String,java.lang.Object[]):51:51 -> a
    1051:1051:java.lang.String access$000(java.lang.String,java.lang.Object[]):14 -> a
    16:26:void <clinit>() -> <clinit>
neureka.utility.Messages$Device -> neureka.utility.Messages$Device:
    28:28:void <init>() -> <init>
    31:33:java.lang.String couldNotFindSuitableAlgorithmFor(java.lang.Class) -> couldNotFindSuitableAlgorithmFor
    41:44:java.lang.String couldNotFindSuitableImplementationFor(neureka.backend.api.Algorithm,java.lang.Class) -> couldNotFindSuitableImplementationFor
neureka.utility.NDAConstructor -> neureka.utility.NDAConstructor:
    org.slf4j.Logger _LOG -> a
    neureka.utility.NDAConstructor$API _API -> b
    32:32:void <init>(neureka.utility.NDAConstructor$API) -> <init>
    44:75:void configureFromNewShape(int[],boolean,boolean) -> configureFromNewShape
    79:111:void _tryConstructing(int[],neureka.dtype.DataType,java.lang.Object) -> _tryConstructing
    114:120:boolean _constructAllFromOne(int[],java.lang.Object) -> _constructAllFromOne
    1129:1131:void _constructAllF32(int[],float):129:131 -> _constructAllFromOne
    1129:1131:boolean _constructAllFromOne(int[],java.lang.Object):115 -> _constructAllFromOne
    1134:1136:void _constructAllI32(int[],int):134:136 -> _constructAllFromOne
    1134:1136:boolean _constructAllFromOne(int[],java.lang.Object):116 -> _constructAllFromOne
    1139:1141:void _constructAllI16(int[],short):139:141 -> _constructAllFromOne
    1139:1141:boolean _constructAllFromOne(int[],java.lang.Object):117 -> _constructAllFromOne
    1144:1146:void _constructAllI8(int[],byte):144:146 -> _constructAllFromOne
    1144:1146:boolean _constructAllFromOne(int[],java.lang.Object):118 -> _constructAllFromOne
    1149:1151:void _constructAllI64(int[],long):149:151 -> _constructAllFromOne
    1149:1151:boolean _constructAllFromOne(int[],java.lang.Object):119 -> _constructAllFromOne
    124:126:void _constructAllF64(int[],double) -> _constructAllF64
    154:157:void _constructAll(int[],java.lang.Class) -> a
    178:200:void construct(java.util.List) -> construct
    204:248:void constructForRange(int[],neureka.dtype.DataType,java.lang.Object[]) -> constructForRange
    1275:1282:void _constructForInts(int[],int[]):275:282 -> constructForRange
    1275:1282:void constructForRange(int[],neureka.dtype.DataType,java.lang.Object[]):228 -> constructForRange
    252:260:void constructForDoubles(int[],double[]) -> constructForDoubles
    264:271:void constructForFloats(int[],float[]) -> constructForFloats
    286:293:void _constructForShorts(int[],short[]) -> _constructForShorts
    297:304:void _constructForBytes(int[],byte[]) -> _constructForBytes
    308:315:void _constructForLongs(int[],long[]) -> _constructForLongs
    318:324:void construct(int[],java.lang.Object[]) -> construct
    1327:1336:void _fromRange(int[],java.lang.Object[]):327:336 -> construct
    1327:1336:void construct(int[],java.lang.Object[]):320 -> construct
    339:348:java.lang.Object optimizeArray(neureka.dtype.DataType,java.lang.Object,int) -> optimizeArray
    352:376:java.lang.Object optimizeObjectArray(neureka.dtype.DataType,java.lang.Object[],int) -> optimizeObjectArray
    356:356:long lambda$optimizeObjectArray$7(java.lang.Object[],int) -> a
    355:355:int lambda$optimizeObjectArray$6(java.lang.Object[],int) -> b
    354:354:double lambda$optimizeObjectArray$5(java.lang.Object[],int) -> c
    353:353:int lambda$optimizeObjectArray$4(java.lang.Object[],int) -> d
    353:353:int lambda$optimizeObjectArray$3(int) -> a
    181:181:boolean lambda$construct$2(int,java.util.List) -> a
    178:178:boolean lambda$construct$1(java.util.List) -> a
    178:178:boolean lambda$construct$0(java.lang.Object) -> a
    19:19:void <clinit>() -> <clinit>
neureka.utility.NDAConstructor$API -> neureka.utility.NDAConstructor$API:
    void setType(neureka.dtype.DataType) -> setType
    void setConf(neureka.ndim.config.NDConfiguration) -> setConf
    void setData(java.lang.Object) -> setData
    void allocate(int) -> allocate
    java.lang.Object getData() -> getData
    void setIsVirtual(boolean) -> setIsVirtual
neureka.utility.NeurekaCleaner -> neureka.utility.NeurekaCleaner:
    void register(java.lang.Object,java.lang.Runnable) -> register
neureka.utility.SettingsLoader -> neureka.utility.SettingsLoader:
    java.lang.String _settings_source -> a
    java.lang.String _setup_source -> b
    60:60:void <init>() -> <init>
    66:99:void loadProperties(neureka.Neureka) -> loadProperties
    151:162:java.lang.Object tryGroovyClosureOn(java.lang.Object,java.lang.Object) -> tryGroovyClosureOn
    167:186:void tryGroovyScriptsOn(neureka.Neureka,java.util.function.Consumer) -> tryGroovyScriptsOn
    94:94:void lambda$loadProperties$19(neureka.Neureka$Settings,java.lang.Boolean) -> a
    93:93:void lambda$loadProperties$18(neureka.Neureka$Settings,java.lang.Class) -> a
    92:92:void lambda$loadProperties$17(neureka.Neureka$Settings,java.lang.Boolean) -> b
    91:91:void lambda$loadProperties$16(neureka.Neureka$Settings,java.lang.Boolean) -> c
    90:90:void lambda$loadProperties$15(neureka.Neureka$Settings,java.lang.Boolean) -> d
    89:89:void lambda$loadProperties$14(neureka.Neureka$Settings,java.lang.Boolean) -> e
    88:88:void lambda$loadProperties$13(neureka.Neureka$Settings,java.lang.Boolean) -> f
    87:87:void lambda$loadProperties$12(neureka.Neureka$Settings,java.lang.Boolean) -> g
    86:86:void lambda$loadProperties$11(neureka.Neureka$Settings,java.lang.Integer) -> a
    85:85:void lambda$loadProperties$10(neureka.Neureka$Settings,java.lang.Boolean) -> h
    84:84:void lambda$loadProperties$9(neureka.Neureka$Settings,java.lang.Boolean) -> i
    83:83:void lambda$loadProperties$8(neureka.Neureka$Settings,java.lang.Boolean) -> j
    82:82:void lambda$loadProperties$7(neureka.Neureka$Settings,java.lang.Integer) -> b
    81:81:void lambda$loadProperties$6(neureka.Neureka$Settings,java.lang.Boolean) -> k
    80:80:void lambda$loadProperties$5(neureka.Neureka$Settings,java.lang.Boolean) -> l
    79:79:void lambda$loadProperties$4(neureka.Neureka$Settings,java.lang.Boolean) -> m
    78:78:void lambda$loadProperties$3(neureka.Neureka$Settings,java.lang.Boolean) -> n
    77:77:void lambda$loadProperties$2(neureka.Neureka$Settings,java.lang.Boolean) -> o
    76:76:void lambda$loadProperties$1(neureka.Neureka$Settings,java.lang.Boolean) -> p
    75:75:void lambda$loadProperties$0(neureka.Neureka$Settings,java.lang.Boolean) -> q
neureka.utility.SettingsLoader$TypeChecker -> neureka.utility.SettingsLoader$a:
    org.slf4j.Logger _LOG -> a
    java.util.Properties _properties -> b
    107:107:void <init>(java.util.Properties) -> <init>
    110:145:neureka.utility.SettingsLoader$TypeChecker checkAndAssign(java.lang.String,java.lang.Class,java.util.function.Consumer) -> a
    103:103:void <clinit>() -> <clinit>
neureka.utility.TsrAsString -> neureka.utility.TsrAsString:
    int _padding -> a
    int _shortage -> b
    boolean _hasGradient -> c
    boolean _isCompact -> d
    boolean _isFormatted -> e
    boolean _hasValue -> f
    boolean _hasShape -> g
    boolean _hasRecursiveGraph -> h
    boolean _hasDerivatives -> i
    boolean _isCellBound -> j
    int[] _shape -> k
    neureka.Tsr _tensor -> l
    java.lang.StringBuilder _asStr -> m
    boolean _legacy -> n
    java.util.Map _config -> o
    boolean $assertionsDisabled -> p
    61:102:void <init>(neureka.Tsr,java.util.Map) -> <init>
    61:110:void <init>(neureka.Tsr,java.lang.String) -> <init>
    61:118:void <init>(neureka.Tsr) -> <init>
    122:155:void _construct(neureka.Tsr,java.util.Map) -> a
    168:169:neureka.utility.TsrAsString _$(java.lang.String) -> a
    183:184:neureka.utility.TsrAsString _$(int) -> a
    199:220:neureka.utility.TsrAsString$ValStringifier _createValStringifierAndFormatter(java.lang.Object) -> a
    1230:1255:neureka.utility.TsrAsString$ValStringifier _createBasicStringifierFor(java.lang.Object,boolean):230:255 -> a
    1230:1255:neureka.utility.TsrAsString$ValStringifier _createValStringifierAndFormatter(java.lang.Object):199 -> a
    1262:1265:int _typeAdjustedPadding():262:265 -> a
    1262:1265:neureka.utility.TsrAsString$ValStringifier _createValStringifierAndFormatter(java.lang.Object):200 -> a
    270:270:java.lang.String toString() -> toString
    275:327:java.lang.String toString(java.lang.String) -> toString
    332:343:void _stringifyAllValues() -> a
    359:368:void _buildRow(int,int,int,int[],java.util.function.Function,java.lang.String) -> a
    384:448:void _recursiveFormatting(int[],int) -> a
    451:461:neureka.utility.TsrAsString _buildSingleLabel(neureka.framing.NDFrame,int,int[]) -> a
    470:477:void _strShape() -> b
    421:421:java.lang.String lambda$_recursiveFormatting$13(neureka.utility.TsrAsString$ValStringifier,int[]) -> a
    420:420:java.lang.String lambda$_recursiveFormatting$12(neureka.utility.TsrAsString$ValStringifier,int[]) -> b
    407:407:java.lang.String lambda$_recursiveFormatting$11(neureka.utility.TsrAsString$ValStringifier,int[]) -> c
    322:324:void lambda$toString$10(java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    304:315:void lambda$toString$9(java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    255:255:java.lang.String lambda$_createBasicStringifierFor$8(java.lang.Object,int) -> a
    251:253:java.lang.String lambda$_createBasicStringifierFor$7(boolean,int) -> a
    247:249:java.lang.String lambda$_createBasicStringifierFor$6(boolean,java.lang.Object,int) -> a
    243:245:java.lang.String lambda$_createBasicStringifierFor$5(boolean,java.lang.Object,int) -> b
    239:241:java.lang.String lambda$_createBasicStringifierFor$4(boolean,java.lang.Object,int) -> c
    235:237:java.lang.String lambda$_createBasicStringifierFor$3(boolean,java.lang.Object,int) -> d
    231:233:java.lang.String lambda$_createBasicStringifierFor$2(boolean,java.lang.Object,int) -> e
    213:216:java.lang.String lambda$_createValStringifierAndFormatter$1(neureka.utility.TsrAsString$ValStringifier,int,int) -> a
    203:207:java.lang.String lambda$_createValStringifierAndFormatter$0(neureka.utility.TsrAsString$ValStringifier,int,int) -> b
    59:59:void <clinit>() -> <clinit>
neureka.utility.TsrAsString$Should -> neureka.utility.TsrAsString$Should:
    neureka.utility.TsrAsString$Should BE_FORMATTED -> BE_FORMATTED
    neureka.utility.TsrAsString$Should HAVE_PADDING_OF -> HAVE_PADDING_OF
    neureka.utility.TsrAsString$Should BE_COMPACT -> BE_COMPACT
    neureka.utility.TsrAsString$Should HAVE_GRADIENT -> HAVE_GRADIENT
    neureka.utility.TsrAsString$Should BE_SHORTENED_BY -> BE_SHORTENED_BY
    neureka.utility.TsrAsString$Should HAVE_VALUE -> HAVE_VALUE
    neureka.utility.TsrAsString$Should HAVE_SHAPE -> HAVE_SHAPE
    neureka.utility.TsrAsString$Should HAVE_DERIVATIVES -> HAVE_DERIVATIVES
    neureka.utility.TsrAsString$Should HAVE_RECURSIVE_GRAPH -> HAVE_RECURSIVE_GRAPH
    neureka.utility.TsrAsString$Should BE_CELL_BOUND -> BE_CELL_BOUND
    neureka.utility.TsrAsString$Should[] $VALUES -> a
    79:79:neureka.utility.TsrAsString$Should[] values() -> values
    79:79:neureka.utility.TsrAsString$Should valueOf(java.lang.String) -> valueOf
    79:79:void <init>(java.lang.String,int) -> <init>
    79:89:void <clinit>() -> <clinit>
neureka.utility.TsrAsString$Util -> neureka.utility.TsrAsString$Util:
    484:484:void <init>() -> <init>
    488:488:java.lang.String indent(int) -> indent
    493:493:java.lang.String pad(int,java.lang.String) -> pad
    498:498:java.lang.String pad(java.lang.String,int) -> pad
    504:519:java.lang.String formatFP(double) -> formatFP
    525:538:java.util.Map configFromCode(java.lang.String) -> configFromCode
neureka.utility.TsrAsString$ValStringifier -> neureka.utility.TsrAsString$a:
    java.lang.String stringify(int) -> stringify
neureka.utility.fluent.TensorBuilder -> neureka.utility.fluent.TensorBuilder:
    neureka.dtype.DataType _dataType -> a
    int[] _shape -> b
    java.lang.Object _from -> c
    java.lang.Object _to -> d
    65:65:void <init>(java.lang.Class) -> <init>
    73:73:neureka.Tsr andFill(java.lang.Object[]) -> andFill
    83:83:neureka.Tsr andWhere(neureka.ndim.Initializer) -> andWhere
    86:86:neureka.utility.fluent.states.To iterativelyFilledFrom(java.lang.Object) -> iterativelyFilledFrom
    89:89:neureka.Tsr all(java.lang.Object) -> all
    92:92:neureka.utility.fluent.states.IterByOrIterFromOrAll withShape(int[]) -> withShape
    95:95:neureka.Tsr vector(java.lang.Object[]) -> vector
    98:98:neureka.Tsr scalar(java.lang.Object) -> scalar
    101:101:neureka.utility.fluent.states.Step to(java.lang.Object) -> to
    105:170:neureka.Tsr step(double) -> step
    174:176:int _size() -> a
    139:139:long lambda$step$5(java.util.List,int) -> a
    137:137:int lambda$step$4(int) -> a
    128:128:double lambda$step$3(java.util.List,int) -> b
    126:126:int lambda$step$2(int) -> b
    117:117:int lambda$step$1(java.util.List,int) -> c
    115:115:int lambda$step$0(int) -> c
neureka.utility.fluent.states.IterByOrIterFromOrAll -> neureka.utility.fluent.states.IterByOrIterFromOrAll:
    neureka.Tsr andFill(java.lang.Object[]) -> andFill
    neureka.Tsr andWhere(neureka.ndim.Initializer) -> andWhere
    neureka.utility.fluent.states.To iterativelyFilledFrom(java.lang.Object) -> iterativelyFilledFrom
    neureka.Tsr all(java.lang.Object) -> all
neureka.utility.fluent.states.Step -> neureka.utility.fluent.states.Step:
    neureka.Tsr step(double) -> step
neureka.utility.fluent.states.To -> neureka.utility.fluent.states.To:
    neureka.utility.fluent.states.Step to(java.lang.Object) -> to
neureka.utility.fluent.states.WithShapeOrScalarOrVector -> neureka.utility.fluent.states.WithShapeOrScalarOrVector:
    neureka.utility.fluent.states.IterByOrIterFromOrAll withShape(int[]) -> withShape
    neureka.Tsr vector(java.lang.Object[]) -> vector
    neureka.Tsr scalar(java.lang.Object) -> scalar
neureka.utility.functional.Replace -> neureka.utility.functional.Replace:
    neureka.utility.functional.With replace(java.lang.Object) -> replace
neureka.utility.functional.With -> neureka.utility.functional.With:
    java.lang.Object with(java.lang.Object) -> with
neureka.utility.slicing.AxisSliceBuilder -> neureka.utility.slicing.AxisSliceBuilder:
    neureka.utility.slicing.AxisSliceBuilder$Resolution _then -> a
    int _from -> b
    int _to -> c
    int _steps -> d
    20:25:void <init>(int,neureka.utility.slicing.AxisSliceBuilder$Resolution) -> <init>
    38:39:neureka.utility.slicing.states.To from(int) -> from
    53:54:neureka.utility.slicing.states.StepsOrAxisOrGet to(int) -> to
    68:69:neureka.utility.slicing.states.AxisOrGet step(int) -> step
    83:85:neureka.utility.slicing.states.AxisOrGet at(int) -> at
    94:94:neureka.utility.slicing.states.FromOrAt axis(int) -> axis
    99:99:neureka.Tsr get() -> get
    104:105:void resolve() -> resolve
neureka.utility.slicing.AxisSliceBuilder$Resolution -> neureka.utility.slicing.AxisSliceBuilder$a:
    neureka.utility.slicing.SliceBuilder resolve(int,int,int) -> resolve
neureka.utility.slicing.SliceBuilder -> neureka.utility.slicing.SliceBuilder:
    java.util.function.Supplier _create -> a
    neureka.utility.slicing.AxisSliceBuilder[] _axisSliceBuilders -> b
    39:72:void <init>(neureka.Tsr,neureka.utility.slicing.SliceBuilder$CreationCallback) -> <init>
    84:85:neureka.utility.slicing.states.FromOrAt axis(int) -> axis
    97:97:neureka.Tsr get() -> get
    67:70:neureka.Tsr lambda$new$1(neureka.utility.slicing.SliceBuilder$CreationCallback,int[],int[],int[]) -> a
    50:63:neureka.utility.slicing.SliceBuilder lambda$new$0(int[],int,int[],int[],int[],int,int,int) -> a
neureka.utility.slicing.SliceBuilder$CreationCallback -> neureka.utility.slicing.SliceBuilder$CreationCallback:
    neureka.Tsr sliceOf(int[],int[],int[]) -> sliceOf
neureka.utility.slicing.SmartSlicer -> neureka.utility.slicing.SmartSlicer:
    org.slf4j.Logger _LOG -> a
    18:18:void <init>() -> <init>
    30:124:neureka.Tsr slice(java.lang.Object[],neureka.Tsr,neureka.utility.slicing.SliceBuilder$CreationCallback) -> slice
    23:23:void <clinit>() -> <clinit>
neureka.utility.slicing.states.AxisOrGet -> neureka.utility.slicing.states.AxisOrGet:
    neureka.utility.slicing.states.FromOrAt axis(int) -> axis
    neureka.Tsr get() -> get
neureka.utility.slicing.states.FromOrAt -> neureka.utility.slicing.states.FromOrAt:
    neureka.utility.slicing.states.To from(int) -> from
    neureka.utility.slicing.states.AxisOrGet at(int) -> at
neureka.utility.slicing.states.StepsOrAxisOrGet -> neureka.utility.slicing.states.StepsOrAxisOrGet:
    neureka.utility.slicing.states.AxisOrGet step(int) -> step
neureka.utility.slicing.states.To -> neureka.utility.slicing.states.To:
    neureka.utility.slicing.states.StepsOrAxisOrGet to(int) -> to
