neureka.Component -> neureka.Component:
    void update(java.lang.Object,java.lang.Object) -> update
neureka.Neureka -> neureka.Neureka:
    java.lang.ThreadLocal _INSTANCES -> a
    java.lang.String _VERSION -> b
    boolean _OPENCL_AVAILABLE -> c
    neureka.Neureka$Settings _settings -> d
    neureka.Neureka$Utility _utility -> e
    70:73:void <init>() -> <init>
    76:84:neureka.Neureka instance() -> instance
    88:89:void setContext(neureka.Neureka) -> setContext
    92:94:neureka.Neureka instance(java.lang.Object) -> instance
    98:98:boolean canAccessOpenCL() -> canAccessOpenCL
    102:102:neureka.Neureka$Settings settings() -> settings
    106:107:neureka.Neureka$Settings settings(java.lang.Object) -> settings
    111:111:neureka.Neureka$Utility utility() -> utility
    115:115:java.lang.String version() -> version
    120:129:void reset() -> reset
    52:52:java.lang.String toString() -> toString
    53:53:boolean access$200(neureka.Neureka) -> a
    1132:1132:boolean _currentThreadIsAuthorized():132:132 -> a
    1132:1132:boolean access$200(neureka.Neureka):53 -> a
    63:65:void <clinit>() -> <clinit>
neureka.Neureka$Settings -> neureka.Neureka$Settings:
    neureka.Neureka$Settings$Debug _debug -> b
    neureka.Neureka$Settings$AutoGrad _autograd -> c
    neureka.Neureka$Settings$Indexing _indexing -> d
    neureka.Neureka$Settings$View _view -> e
    neureka.Neureka$Settings$NDim _ndim -> f
    neureka.Neureka$Settings$DType _dtype -> g
    boolean _isLocked -> h
    neureka.Neureka this$0 -> a
    146:155:void <init>(neureka.Neureka) -> <init>
    158:158:neureka.Neureka$Settings$Debug debug() -> debug
    162:163:neureka.Neureka$Settings$Debug debug(java.lang.Object) -> debug
    167:167:neureka.Neureka$Settings$AutoGrad autograd() -> autograd
    171:172:neureka.Neureka$Settings$AutoGrad autograd(java.lang.Object) -> autograd
    176:176:neureka.Neureka$Settings$Indexing indexing() -> indexing
    180:181:neureka.Neureka$Settings$Indexing indexing(java.lang.Object) -> indexing
    185:185:neureka.Neureka$Settings$View view() -> view
    189:190:neureka.Neureka$Settings$View view(java.lang.Object) -> view
    194:194:neureka.Neureka$Settings$NDim ndim() -> ndim
    198:199:neureka.Neureka$Settings$NDim ndim(java.lang.Object) -> ndim
    203:203:neureka.Neureka$Settings$DType dtype() -> dtype
    207:208:neureka.Neureka$Settings$DType dtype(java.lang.Object) -> dtype
    212:212:boolean isLocked() -> isLocked
    216:217:void setIsLocked(boolean) -> setIsLocked
    136:136:java.lang.String toString() -> toString
    137:137:void <init>(neureka.Neureka,byte) -> <init>
    137:137:boolean access$100(neureka.Neureka$Settings) -> a
neureka.Neureka$Settings$AutoGrad -> neureka.Neureka$Settings$AutoGrad:
    boolean _isPreventingInlineOperations -> a
    boolean _isRetainingPendingErrorForJITProp -> b
    boolean _isApplyingGradientWhenTensorIsUsed -> c
    boolean _isApplyingGradientWhenRequested -> d
    neureka.Neureka$Settings this$1 -> e
    253:288:void <init>(neureka.Neureka$Settings) -> <init>
    291:291:boolean isPreventingInlineOperations() -> isPreventingInlineOperations
    295:297:void setIsPreventingInlineOperations(boolean) -> setIsPreventingInlineOperations
    300:300:boolean isRetainingPendingErrorForJITProp() -> isRetainingPendingErrorForJITProp
    304:306:void setIsRetainingPendingErrorForJITProp(boolean) -> setIsRetainingPendingErrorForJITProp
    309:309:boolean isApplyingGradientWhenTensorIsUsed() -> isApplyingGradientWhenTensorIsUsed
    313:315:void setIsApplyingGradientWhenTensorIsUsed(boolean) -> setIsApplyingGradientWhenTensorIsUsed
    318:318:boolean isApplyingGradientWhenRequested() -> isApplyingGradientWhenRequested
    322:324:void setIsApplyingGradientWhenRequested(boolean) -> setIsApplyingGradientWhenRequested
    252:252:java.lang.String toString() -> toString
neureka.Neureka$Settings$DType -> neureka.Neureka$Settings$DType:
    java.lang.Class _defaultDataTypeClass -> a
    boolean _isAutoConvertingExternalDataToJVMTypes -> b
    neureka.Neureka$Settings this$1 -> c
    427:431:void <init>(neureka.Neureka$Settings) -> <init>
    434:434:java.lang.Class getDefaultDataTypeClass() -> getDefaultDataTypeClass
    438:440:void setDefaultDataTypeClass(java.lang.Class) -> setDefaultDataTypeClass
    443:443:boolean getIsAutoConvertingExternalDataToJVMTypes() -> getIsAutoConvertingExternalDataToJVMTypes
    447:449:void setIsAutoConvertingExternalDataToJVMTypes(boolean) -> setIsAutoConvertingExternalDataToJVMTypes
    426:426:java.lang.String toString() -> toString
neureka.Neureka$Settings$Debug -> neureka.Neureka$Settings$Debug:
    boolean _isKeepingDerivativeTargetPayloads -> a
    neureka.Neureka$Settings this$1 -> b
    221:238:void <init>(neureka.Neureka$Settings) -> <init>
    241:241:boolean isKeepingDerivativeTargetPayloads() -> isKeepingDerivativeTargetPayloads
    245:247:void setIsKeepingDerivativeTargetPayloads(boolean) -> setIsKeepingDerivativeTargetPayloads
    220:220:java.lang.String toString() -> toString
neureka.Neureka$Settings$Indexing -> neureka.Neureka$Settings$Indexing:
    boolean _isUsingLegacyIndexing -> a
    boolean _isUsingArrayBasedIndexing -> b
    neureka.Neureka$Settings this$1 -> c
    330:334:void <init>(neureka.Neureka$Settings) -> <init>
    348:348:boolean isUsingArrayBasedIndexing() -> isUsingArrayBasedIndexing
    352:354:void setIsUsingArrayBasedIndexing(boolean) -> setIsUsingArrayBasedIndexing
    329:329:java.lang.String toString() -> toString
neureka.Neureka$Settings$NDim -> neureka.Neureka$Settings$NDim:
    boolean _isOnlyUsingDefaultNDConfiguration -> a
    neureka.Neureka$Settings this$1 -> b
    405:412:void <init>(neureka.Neureka$Settings) -> <init>
    415:415:boolean isOnlyUsingDefaultNDConfiguration() -> isOnlyUsingDefaultNDConfiguration
    419:421:void setIsOnlyUsingDefaultNDConfiguration(boolean) -> setIsOnlyUsingDefaultNDConfiguration
    404:404:java.lang.String toString() -> toString
neureka.Neureka$Settings$View -> neureka.Neureka$Settings$View:
    boolean _isUsingLegacyView -> a
    java.util.Map _asString -> b
    neureka.Neureka$Settings this$1 -> c
    362:375:void <init>(neureka.Neureka$Settings) -> <init>
    381:381:boolean isUsingLegacyView() -> isUsingLegacyView
    385:387:void setIsUsingLegacyView(boolean) -> setIsUsingLegacyView
    390:390:java.util.Map getAsString() -> getAsString
    394:395:void setAsString(java.util.Map) -> setAsString
    398:399:void setAsString(java.lang.String) -> setAsString
    359:359:java.lang.String toString() -> toString
neureka.Neureka$Utility -> neureka.Neureka$Utility:
    455:455:void <init>() -> <init>
    466:479:java.lang.String readResource(java.lang.String) -> readResource
    484:498:boolean isPresent(java.lang.String) -> isPresent
neureka.Tsr -> neureka.Tsr:
    neureka.devices.Device _CPU -> a
    int _flags -> b
    int _version -> c
    boolean $assertionsDisabled -> d
    154:190:void <init>() -> <init>
    154:195:void <init>(java.lang.Object[]) -> <init>
    199:274:void _construct(java.lang.Object[]) -> a
    154:285:void <init>(java.util.List,java.lang.Object) -> <init>
    154:305:void <init>(java.util.List,java.lang.String) -> <init>
    154:316:void <init>(java.util.List,java.util.List) -> <init>
    154:327:void <init>(int[],java.util.List) -> <init>
    331:365:void _constructForRange(int[],neureka.dtype.DataType,java.lang.Object[]) -> a
    154:406:void <init>(java.util.List) -> <init>
    3417:3439:void _construct(java.util.List):417:439 -> <init>
    3417:3439:void <init>(java.util.List):371 -> <init>
    154:450:void <init>(double) -> <init>
    154:455:void <init>(float[]) -> <init>
    154:460:void <init>(int[],java.lang.String) -> <init>
    154:465:void <init>(int[]) -> <init>
    154:470:void <init>(int[],double) -> <init>
    154:475:void <init>(int[],double[]) -> <init>
    154:482:void <init>(int[],neureka.dtype.DataType) -> <init>
    154:489:void <init>(int[],java.lang.Class,java.lang.Object) -> <init>
    154:494:void <init>(java.util.List,java.lang.Class,java.util.List) -> <init>
    154:501:void <init>(int[],neureka.dtype.DataType,java.lang.Object) -> <init>
    154:508:void <init>(java.util.List,neureka.dtype.DataType,java.util.List) -> <init>
    514:516:void _construct(int[],java.lang.String) -> a
    520:523:void _construct(int[],boolean,boolean) -> a
    527:533:void _construct(int[],double) -> a
    537:544:void _constructForDoubles(int[],double[]) -> a
    548:555:void _constructForFloats(int[],float[]) -> a
    559:566:void _constructForInts(int[],int[]) -> a
    570:577:void _constructForShorts(int[],short[]) -> a
    580:594:void _construct(int[],java.lang.Object[]) -> a
    597:603:int[] _intArray(java.lang.Object[]) -> b
    608:615:double[] _doubleArray(java.lang.Object[]) -> c
    154:642:void <init>(java.util.List,neureka.dtype.DataType,neureka.ndim.AbstractNDArray$Initializer) -> <init>
    154:662:void <init>(int[],neureka.dtype.DataType,neureka.ndim.AbstractNDArray$Initializer) -> <init>
    672:675:void _constructFromInitializer(int[],neureka.dtype.DataType,neureka.ndim.AbstractNDArray$Initializer) -> a
    154:717:void <init>(java.lang.String,java.util.List) -> <init>
    154:739:void <init>(neureka.Tsr,java.lang.String) -> <init>
    154:759:void <init>(neureka.Tsr[],java.lang.String) -> <init>
    154:784:void <init>(neureka.Tsr[],java.lang.String,boolean) -> <init>
    808:810:void _construct(neureka.Tsr[],java.lang.String,boolean) -> a
    822:852:void _configureFromNewShape(int[],boolean,boolean) -> _configureFromNewShape
    4375:4380:int _dataLength():1375:1380 -> _configureFromNewShape
    4375:4380:void _configureFromNewShape(int[],boolean,boolean):830 -> _configureFromNewShape
    867:869:neureka.Tsr setRqsGradient(boolean) -> setRqsGradient
    873:873:boolean rqsGradient() -> rqsGradient
    877:881:void _setRqsGradient(boolean) -> _setRqsGradient
    890:931:neureka.Tsr setIsOutsourced(boolean) -> setIsOutsourced
    935:935:boolean isOutsourced() -> isOutsourced
    939:943:void _setIsOutsourced(boolean) -> _setIsOutsourced
    967:1002:neureka.Tsr setIsVirtual(boolean) -> setIsVirtual
    1018:1018:boolean isVirtual() -> isVirtual
    1028:1032:void _setIsVirtual(boolean) -> _setIsVirtual
    1057:1068:neureka.Tsr setGradientApplyRequested(boolean) -> setGradientApplyRequested
    1087:1087:boolean gradientApplyRequested() -> gradientApplyRequested
    1113:1151:neureka.Component _setOrReject(neureka.Component) -> _setOrReject
    1171:1194:neureka.Component _removeOrReject(neureka.Component) -> _removeOrReject
    1215:1215:void update(neureka.Tsr,neureka.Tsr) -> update
    1236:1236:boolean isEmpty() -> isEmpty
    1240:1240:boolean isUndefined() -> isUndefined
    1250:1251:boolean isSlice() -> isSlice
    1263:1264:int sliceCount() -> sliceCount
    1274:1275:boolean isSliceParent() -> isSliceParent
    1289:1289:boolean belongsToGraph() -> belongsToGraph
    1303:1303:boolean isLeave() -> isLeave
    1317:1317:boolean isBranch() -> isBranch
    1327:1327:boolean hasGradient() -> hasGradient
    1340:1340:neureka.Tsr getGradient() -> getGradient
    1347:1348:neureka.devices.Device getDevice() -> getDevice
    1355:1355:neureka.autograd.GraphNode getGraphNode() -> getGraphNode
    1363:1363:neureka.framing.IndexAlias index() -> index
    1399:1411:neureka.Tsr incrementVersionBecauseOf(neureka.backend.api.ExecutionCall) -> incrementVersionBecauseOf
    1427:1440:neureka.Tsr delete() -> delete
    1463:1473:neureka.Tsr _become(neureka.Tsr) -> _become
    1493:1494:java.util.Iterator iterator() -> iterator
    1538:1541:neureka.Tsr backward(neureka.Tsr) -> backward
    1561:1562:neureka.Tsr backward(double) -> backward
    1580:1581:neureka.Tsr backward() -> backward
    1596:1617:void applyGradient() -> applyGradient
    1628:1629:void detach() -> detach
    1657:1658:neureka.Tsr label(java.lang.String[][]) -> label
    1682:1683:neureka.Tsr label(java.lang.String,java.lang.String[][]) -> label
    1688:1701:void _label(java.lang.String,java.lang.String[][]) -> a
    1721:1723:neureka.Tsr label(java.util.List) -> label
    1745:1747:neureka.Tsr label(java.lang.String,java.util.List) -> label
    1768:1769:neureka.Tsr label(java.util.Map) -> label
    1774:1775:neureka.Tsr label(java.lang.String,java.util.Map) -> label
    1791:1791:neureka.Tsr plus(neureka.Tsr) -> plus
    1795:1795:neureka.Tsr plusAssign(neureka.Tsr) -> plusAssign
    1799:1799:neureka.Tsr plus(java.lang.Double) -> plus
    1803:1803:neureka.Tsr minus(neureka.Tsr) -> minus
    1807:1807:neureka.Tsr minusAssign(neureka.Tsr) -> minusAssign
    1811:1811:neureka.Tsr negative() -> negative
    1815:1815:neureka.Tsr multiply(neureka.Tsr) -> multiply
    1819:1819:neureka.Tsr timesAssign(neureka.Tsr) -> timesAssign
    1823:1823:neureka.Tsr multiply(java.lang.Double) -> multiply
    1827:1827:neureka.Tsr div(neureka.Tsr) -> div
    1831:1831:neureka.Tsr div(java.lang.Double) -> div
    1835:1835:neureka.Tsr divAssign(neureka.Tsr) -> divAssign
    1839:1839:neureka.Tsr mod(neureka.Tsr) -> mod
    1843:1843:neureka.Tsr modAssign(neureka.Tsr) -> modAssign
    1847:1847:neureka.Tsr power(neureka.Tsr) -> power
    1851:1851:neureka.Tsr power(java.lang.Double) -> power
    1855:1855:neureka.Tsr xor(neureka.Tsr) -> xor
    1859:1859:neureka.Tsr xor(java.lang.Double) -> xor
    1873:1876:neureka.Tsr T() -> T
    1888:1890:neureka.Tsr mean() -> mean
    1902:1911:neureka.Tsr dot(neureka.Tsr) -> dot
    1925:1925:neureka.Tsr dimtrim() -> dimtrim
    1938:1942:boolean isCase(neureka.Tsr) -> isCase
    1955:1955:boolean contains(neureka.Tsr) -> contains
    1979:1979:java.lang.Object getAt(int[]) -> getAt
    1990:1990:double getF64(int[]) -> getF64
    2003:2004:neureka.Tsr getAt(java.lang.Object[]) -> getAt
    2016:2016:neureka.Tsr getAt(int) -> getAt
    2027:2027:java.lang.Object getValueAt(int) -> getValueAt
    2041:2041:java.lang.Object getValueAt(int[]) -> getValueAt
    2056:2057:neureka.Tsr setAt(int,java.lang.Object) -> setAt
    2061:2061:neureka.Tsr getAt(double) -> getAt
    2065:2065:neureka.Tsr getAt(java.math.BigDecimal) -> getAt
    2070:2081:java.lang.Object getAt(java.util.Map) -> getAt
    2086:2093:neureka.Tsr shallowCopy() -> shallowCopy
    2105:2149:neureka.Tsr getAt(java.lang.Object) -> getAt
    2154:2227:neureka.Tsr _sliceOf(int[],int[],int[]) -> a
    2251:2331:int _configureSubsetFromRanges(java.lang.Object[],int[],int[],int[],int) -> a
    2352:2354:neureka.Tsr putAt(java.util.List,neureka.Tsr) -> putAt
    2368:2370:neureka.Tsr putAt(java.util.Map,neureka.Tsr) -> putAt
    2374:2379:void _putAtCheckFor(neureka.Tsr) -> a
    2383:2402:neureka.Tsr _putAt(neureka.Tsr,neureka.Tsr) -> a
    2497:2510:java.lang.Object getDataAt(int) -> getDataAt
    2522:2529:neureka.Tsr setDataAt(int,java.lang.Object) -> setDataAt
    2533:2542:neureka.Tsr setValue64(double[]) -> setValue64
    2546:2555:neureka.Tsr setValue32(float[]) -> setValue32
    2560:2579:neureka.Tsr setValue(java.lang.Object) -> setValue
    2583:2591:java.lang.Object getValue() -> getValue
    2596:2600:double[] gradient64() -> gradient64
    2605:2609:float[] gradient32() -> gradient32
    2614:2630:neureka.Tsr addToGradient(neureka.Tsr) -> addToGradient
    2653:2662:neureka.Tsr asType(java.lang.Class) -> asType
    2688:2699:neureka.Tsr toType(java.lang.Class) -> toType
    2703:2713:double value64(int) -> value64
    2718:2732:double[] value64() -> value64
    2736:2746:float value32(int) -> value32
    2751:2761:float[] value32() -> value32
    2769:2769:java.lang.String toString(java.lang.String) -> toString
    2773:2773:java.lang.String toString(java.util.Map,java.lang.String) -> toString
    2777:2777:java.lang.String toString(java.util.Map) -> toString
    2783:2783:java.lang.String _toString(java.lang.String,java.lang.String) -> _toString
    2789:2789:java.lang.String toString() -> toString
    2795:2824:void makeFit(neureka.Tsr[],boolean) -> makeFit
    175:175:int getVersion() -> getVersion
    135:135:java.lang.Object setDataAt(int,java.lang.Object) -> setDataAt
    135:135:void update(java.lang.Object,java.lang.Object) -> update
    2698:2698:void lambda$toType$32(java.lang.Class,neureka.Tsr) -> a
    2624:2629:void lambda$addToGradient$31(neureka.Tsr,neureka.devices.Device) -> a
    2618:2619:void lambda$addToGradient$30(neureka.Tsr,neureka.Tsr) -> b
    1939:1939:void lambda$isCase$29(neureka.Tsr,boolean[],neureka.framing.Relation) -> a
    1940:1941:void lambda$isCase$28(neureka.Tsr,boolean[],java.lang.Object) -> a
    1604:1615:void lambda$applyGradient$27(neureka.Tsr) -> b
    1604:1604:void lambda$applyGradient$26(neureka.optimization.Optimizer) -> a
    1538:1538:void lambda$backward$25(neureka.Tsr,neureka.autograd.GraphNode) -> a
    1434:1434:void lambda$delete$24(neureka.devices.Device) -> a
    1428:1433:void lambda$delete$23(neureka.autograd.GraphNode) -> a
    1128:1128:void lambda$_setOrReject$22(java.lang.Object) -> a
    1126:1126:void lambda$_setOrReject$21(java.lang.Object) -> b
    982:982:void lambda$setIsVirtual$20(neureka.Tsr) -> c
    898:926:void lambda$setIsOutsourced$19(neureka.devices.Device) -> b
    910:910:void lambda$setIsOutsourced$18(neureka.Tsr) -> d
    914:924:void lambda$setIsOutsourced$17(neureka.Tsr,neureka.devices.Device) -> b
    713:713:neureka.Tsr[] lambda$new$16(int) -> a
    713:713:neureka.Tsr lambda$new$15(java.lang.Object) -> c
    707:707:neureka.Tsr[] lambda$new$14(int) -> b
    705:705:boolean lambda$new$13(java.lang.Object) -> d
    641:641:int lambda$new$12(java.lang.Integer) -> a
    506:506:int lambda$new$11(java.lang.Integer) -> b
    493:493:int lambda$new$10(java.lang.Integer) -> c
    420:420:boolean lambda$_construct$9(int,java.util.List) -> a
    417:417:boolean lambda$_construct$8(java.util.List) -> a
    417:417:boolean lambda$_construct$7(java.lang.Object) -> e
    371:371:java.util.List lambda$new$6(java.lang.Object) -> f
    369:369:boolean lambda$new$5(java.lang.Object) -> g
    312:312:int lambda$new$4(java.lang.Integer) -> d
    300:300:neureka.Tsr[] lambda$new$3(int) -> c
    300:300:neureka.Tsr lambda$new$2(java.lang.Object) -> h
    289:289:boolean lambda$new$1(java.util.List,java.lang.Class) -> a
    289:289:boolean lambda$new$0(java.lang.Class,java.lang.Object) -> a
    136:136:org.slf4j.Logger access$000() -> a
    136:136:org.slf4j.Logger access$100() -> b
    135:141:void <clinit>() -> <clinit>
neureka.Tsr$1 -> neureka.Tsr$1:
    int _count -> a
    int _size -> b
    neureka.ndim.iterators.NDIterator val$_ndi -> c
    neureka.Tsr this$0 -> d
    1495:1497:void <init>(neureka.Tsr,neureka.ndim.iterators.NDIterator) -> <init>
    1501:1501:boolean hasNext() -> hasNext
    1506:1509:java.lang.Object next() -> next
neureka.Tsr$Create -> neureka.Tsr$Create:
    2834:2834:neureka.Tsr E(java.util.List) -> E
    2838:2838:neureka.Tsr E(int[]) -> E
    2842:2842:neureka.Tsr newRandom(int[]) -> newRandom
    2846:2847:neureka.Tsr newRandom(int[],long) -> newRandom
    2851:2860:neureka.Tsr newTsrLike(neureka.Tsr,double) -> newTsrLike
    2864:2873:neureka.Tsr newTsrLike(neureka.Tsr) -> newTsrLike
    2877:2879:neureka.Tsr _newEmptyLike(neureka.Tsr) -> a
    2830:2830:void <init>() -> <init>
    2834:2834:int lambda$E$0(java.lang.Integer) -> a
neureka.Tsr$IO -> neureka.Tsr$IO:
    2414:2416:double getFrom(neureka.Tsr,int) -> getFrom
    2420:2421:double getFrom(neureka.Tsr,int[]) -> getFrom
    2425:2427:void setInto(neureka.Tsr,int,double) -> setInto
    2430:2432:void setInto(neureka.Tsr,int[],double) -> setInto
    2435:2437:void addInto(neureka.Tsr,int,double) -> addInto
    2440:2442:void addInto(neureka.Tsr,int[],double) -> addInto
    2445:2447:neureka.Tsr addInto(neureka.Tsr,neureka.Tsr) -> addInto
    2451:2453:void subInto(neureka.Tsr,int,double) -> subInto
    2456:2458:void subInto(neureka.Tsr,int[],double) -> subInto
    2461:2472:void subInto(neureka.Tsr,neureka.Tsr) -> subInto
    2475:2477:void mulInto(neureka.Tsr,int,double) -> mulInto
    2480:2482:void mulInto(neureka.Tsr,int[],double) -> mulInto
    2410:2410:void <init>() -> <init>
neureka.autograd.ADAgent -> neureka.autograd.ADAgent:
    neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    neureka.Tsr derivative() -> derivative
    boolean hasForward() -> hasForward
    boolean hasBackward() -> hasBackward
    java.lang.String toString() -> toString
neureka.autograd.DefaultADAgent -> neureka.autograd.DefaultADAgent:
    neureka.autograd.DefaultADAgent$ADAction _forward -> a
    neureka.autograd.DefaultADAgent$ADAction _backward -> b
    java.util.Map _context -> c
    46:50:void <init>(neureka.Tsr) -> <init>
    46:52:void <init>() -> <init>
    55:56:neureka.autograd.DefaultADAgent withContext(java.util.Map) -> withContext
    61:61:neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    66:66:neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    71:71:neureka.Tsr derivative() -> derivative
    76:76:boolean hasForward() -> hasForward
    81:81:boolean hasBackward() -> hasBackward
    86:89:java.lang.String toString() -> toString
    44:44:neureka.autograd.DefaultADAgent setForward(neureka.autograd.DefaultADAgent$ADAction) -> setForward
    45:45:neureka.autograd.DefaultADAgent setBackward(neureka.autograd.DefaultADAgent$ADAction) -> setBackward
    88:88:java.lang.String lambda$toString$0(java.lang.String) -> a
neureka.autograd.DefaultADAgent$ADAction -> neureka.autograd.DefaultADAgent$ADAction:
    neureka.Tsr execute(neureka.autograd.GraphNode,neureka.Tsr) -> execute
neureka.autograd.GraphLock -> neureka.autograd.GraphLock:
    neureka.calculus.Function _owner -> a
    boolean _isLocked -> b
    28:38:void <init>(neureka.calculus.Function,neureka.Tsr[]) -> <init>
    45:46:void release() -> release
    53:53:java.lang.String toString() -> toString
    28:28:boolean isLocked() -> isLocked
neureka.autograd.GraphNode -> neureka.autograd.GraphNode:
    int _mode -> a
    boolean _allows_forward -> b
    boolean _allows_backward -> c
    boolean _reliesOnJustInTimeProp -> d
    neureka.autograd.PendingError _pendingError -> e
    boolean _isUsedAsDerivative -> f
    neureka.calculus.Function _function -> g
    neureka.autograd.GraphNode[] _parents -> h
    java.lang.ref.WeakReference _payload -> i
    int _payloadReferenceVersion -> j
    java.util.TreeMap _targets_derivatives -> k
    neureka.autograd.GraphLock _lock -> l
    java.util.List _children -> m
    long _nodeID -> n
    boolean $assertionsDisabled -> o
    92:92:boolean usesAD() -> usesAD
    101:101:boolean usesForwardAD() -> usesForwardAD
    110:110:boolean usesReverseAD() -> usesReverseAD
    174:176:neureka.autograd.PendingError getAndRemovePendingError() -> getAndRemovePendingError
    240:240:neureka.Tsr getPayload() -> getPayload
    244:261:void _setPayload(neureka.Tsr) -> a
    265:266:void update(neureka.Tsr,neureka.Tsr) -> update
    314:317:void _attachChild(neureka.autograd.GraphNode) -> a
    334:334:boolean isCacheable() -> isCacheable
    343:344:void obtainLocking(neureka.autograd.GraphLock) -> obtainLocking
    352:352:boolean isLeave() -> isLeave
    356:360:boolean isGraphLeave() -> isGraphLeave
    367:367:boolean isVirtual() -> isVirtual
    161:427:void <init>(neureka.calculus.Function,java.lang.Object,java.util.function.Supplier) -> <init>
    439:555:void _construct(neureka.Tsr,neureka.calculus.Function,neureka.backend.api.ExecutionCall,neureka.autograd.GraphLock) -> a
    570:591:int _modeOf(neureka.backend.api.ExecutionCall,neureka.calculus.Function) -> a
    602:618:void _migrateAndOrApplyError(neureka.Tsr,java.util.function.Consumer) -> a
    631:643:void backward(neureka.Tsr) -> backward
    661:682:void _backward(neureka.Tsr,java.util.Set,boolean) -> a
    694:702:void _carryPendingBackPropToGradients(java.util.Set) -> a
    718:720:void backwardJIT(neureka.Tsr) -> backwardJIT
    723:748:void _backwardJIT(neureka.Tsr,neureka.autograd.GraphNode) -> a
    760:764:void _deleteDerivativesRecursively() -> a
    772:781:int _numberOfReverseModeADChildren() -> b
    790:798:void put(neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> put
    807:808:java.util.List get(neureka.autograd.GraphNode) -> get
    819:820:boolean has(neureka.autograd.GraphNode) -> has
    830:830:int size() -> size
    837:841:void forEachDerivative(java.util.function.BiConsumer) -> forEachDerivative
    847:851:void forEachBackward(neureka.Tsr,java.util.function.BiConsumer) -> forEachBackward
    857:859:void forEachTarget(java.util.function.Consumer) -> forEachTarget
    865:873:void forEachTargetAgentPair(java.util.function.BiConsumer) -> forEachTargetAgentPair
    880:880:boolean hasDerivatives() -> hasDerivatives
    887:892:java.lang.String type() -> type
    897:897:java.lang.String toString() -> toString
    905:922:java.lang.String toString(java.lang.String) -> toString
    937:950:java.lang.String _toString(java.lang.String,boolean,java.lang.String) -> a
    83:83:int getMode() -> getMode
    161:161:boolean isReliesOnJustInTimeProp() -> isReliesOnJustInTimeProp
    182:182:neureka.autograd.PendingError getPendingError() -> getPendingError
    195:195:boolean isUsedAsDerivative() -> isUsedAsDerivative
    203:203:neureka.calculus.Function getFunction() -> getFunction
    213:213:neureka.autograd.GraphNode[] getParents() -> getParents
    277:277:int getPayloadReferenceVersion() -> getPayloadReferenceVersion
    298:298:neureka.autograd.GraphLock getLock() -> getLock
    307:307:java.util.List getChildren() -> getChildren
    324:324:long getNodeID() -> getNodeID
    69:69:void update(java.lang.Object,java.lang.Object) -> update
    869:869:void lambda$forEachTargetAgentPair$14(java.util.function.BiConsumer,neureka.autograd.GraphNode,java.util.List) -> a
    870:870:void lambda$forEachTargetAgentPair$13(java.util.function.BiConsumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    858:858:void lambda$forEachTarget$12(java.util.function.Consumer,neureka.autograd.GraphNode,java.util.List) -> a
    849:850:void lambda$forEachBackward$11(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,java.util.List) -> a
    839:839:void lambda$forEachDerivative$10(java.util.function.BiConsumer,neureka.autograd.GraphNode,java.util.List) -> b
    839:839:void lambda$forEachDerivative$9(java.util.function.BiConsumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> b
    790:790:int lambda$put$8(neureka.autograd.GraphNode,neureka.autograd.GraphNode) -> a
    745:745:void lambda$_backwardJIT$7(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> a
    725:730:void lambda$_backwardJIT$6(neureka.autograd.GraphNode,neureka.Tsr) -> a
    695:695:void lambda$_carryPendingBackPropToGradients$5(java.util.Set,neureka.autograd.GraphNode) -> a
    679:679:void lambda$_backward$4(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> a
    637:640:void lambda$backward$3(neureka.autograd.GraphNode) -> b
    634:634:void lambda$backward$2(java.util.Set,neureka.autograd.GraphNode) -> b
    509:528:void lambda$_construct$1(neureka.Tsr,neureka.backend.api.ExecutionCall,neureka.calculus.Function,int,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    249:259:void lambda$_setPayload$0() -> c
    69:69:void <clinit>() -> <clinit>
neureka.autograd.JITProp -> neureka.autograd.JITProp:
    java.util.Set _finished -> a
    java.util.Set _pending -> b
    16:20:void <init>(java.util.Set) -> <init>
    27:30:void addPending(java.util.Set) -> addPending
    37:46:void noteFinished(neureka.autograd.GraphNode) -> noteFinished
    49:49:int finishedCount() -> finishedCount
    53:53:int pendingCount() -> pendingCount
    66:76:void execute() -> execute
    82:82:boolean isDone() -> isDone
    90:92:java.lang.String toString() -> toString
    99:99:void update(neureka.Tsr,neureka.Tsr) -> update
    10:10:void update(java.lang.Object,java.lang.Object) -> update
    68:73:void lambda$execute$0(neureka.autograd.GraphNode) -> a
neureka.autograd.PendingError -> neureka.autograd.PendingError:
    int _toBeReceived -> a
    neureka.Tsr _accumulatedError -> b
    18:21:void <init>(neureka.Tsr,int) -> <init>
    24:28:void accumulate(neureka.Tsr) -> accumulate
    31:31:boolean isFullyAccumulated() -> isFullyAccumulated
    10:10:java.lang.String toString() -> toString
    13:13:int getToBeReceived() -> getToBeReceived
    15:15:neureka.Tsr getAccumulatedError() -> getAccumulatedError
neureka.backend.api.ExecutionCall -> neureka.backend.api.ExecutionCall:
    neureka.devices.Device _device -> a
    int _derivativeIndex -> b
    neureka.backend.api.operations.Operation _operation -> c
    neureka.Tsr[] _tensors -> d
    int _j -> e
    neureka.backend.api.algorithms.Algorithm _implementation -> f
    java.util.Map _context -> g
    215:215:neureka.backend.api.ExecutionCall$Validator validate() -> validate
    117:229:void <init>(neureka.devices.Device,neureka.Tsr[],int,neureka.backend.api.operations.Operation) -> <init>
    117:244:void <init>(neureka.devices.Device,neureka.Tsr[],int,int,neureka.backend.api.operations.Operation) -> <init>
    246:246:neureka.Tsr getTensor(int) -> getTensor
    250:252:neureka.backend.api.algorithms.Algorithm getImplementation() -> getImplementation
    256:256:boolean allowsForward() -> allowsForward
    260:260:boolean allowsBackward() -> allowsBackward
    265:269:neureka.autograd.ADAgent getADAgentFrom(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> getADAgentFrom
    273:274:void mutateArguments(neureka.backend.api.ExecutionCall$Mutator) -> mutateArguments
    277:277:neureka.backend.api.ExecutionCall withNew(neureka.Tsr[]) -> withNew
    281:281:neureka.backend.api.ExecutionCall withNew(neureka.devices.Device) -> withNew
    285:286:java.lang.Object getAt(java.lang.Class) -> getAt
    290:291:java.lang.Object getAt(java.lang.String) -> getAt
    295:297:neureka.backend.api.ExecutionCall putAt(java.lang.String,java.lang.Object) -> putAt
    301:303:void takeContext(java.util.Map) -> takeContext
    64:64:java.lang.String toString() -> toString
    76:76:neureka.devices.Device getDevice() -> getDevice
    91:91:int getDerivativeIndex() -> getDerivativeIndex
    98:98:neureka.backend.api.operations.Operation getOperation() -> getOperation
    108:108:neureka.Tsr[] getTensors() -> getTensors
    117:117:int getJ() -> getJ
    127:127:java.util.Map getContext() -> getContext
    65:65:neureka.Tsr[] access$000(neureka.backend.api.ExecutionCall) -> a
    65:65:neureka.devices.Device access$100(neureka.backend.api.ExecutionCall) -> b
    65:65:neureka.backend.api.operations.Operation access$200(neureka.backend.api.ExecutionCall) -> c
neureka.backend.api.ExecutionCall$DeviceCondition -> neureka.backend.api.ExecutionCall$DeviceCondition:
    boolean check(neureka.devices.Device) -> check
neureka.backend.api.ExecutionCall$Mutator -> neureka.backend.api.ExecutionCall$Mutator:
    neureka.Tsr[] mutate(neureka.Tsr[]) -> mutate
neureka.backend.api.ExecutionCall$OperationTypeCondition -> neureka.backend.api.ExecutionCall$OperationTypeCondition:
    boolean check(neureka.backend.api.operations.Operation) -> check
neureka.backend.api.ExecutionCall$TensorCompare -> neureka.backend.api.ExecutionCall$TensorCompare:
    boolean check(neureka.Tsr,neureka.Tsr) -> check
neureka.backend.api.ExecutionCall$TensorCondition -> neureka.backend.api.ExecutionCall$TensorCondition:
    boolean check(neureka.Tsr) -> check
neureka.backend.api.ExecutionCall$Validator -> neureka.backend.api.ExecutionCall$Validator:
    boolean _isValid -> a
    neureka.backend.api.ExecutionCall this$0 -> b
    138:140:void <init>(neureka.backend.api.ExecutionCall) -> <init>
    149:149:float estimation() -> estimation
    153:154:neureka.backend.api.ExecutionCall$Validator first(neureka.backend.api.ExecutionCall$TensorCondition) -> first
    159:162:neureka.backend.api.ExecutionCall$Validator any(neureka.backend.api.ExecutionCall$TensorCondition) -> any
    167:171:neureka.backend.api.ExecutionCall$Validator anyNotNull(neureka.backend.api.ExecutionCall$TensorCondition) -> anyNotNull
    176:179:neureka.backend.api.ExecutionCall$Validator all(neureka.backend.api.ExecutionCall$TensorCondition) -> all
    184:188:neureka.backend.api.ExecutionCall$Validator allNotNull(neureka.backend.api.ExecutionCall$TensorCondition) -> allNotNull
    193:200:neureka.backend.api.ExecutionCall$Validator all(neureka.backend.api.ExecutionCall$TensorCompare) -> all
    205:206:neureka.backend.api.ExecutionCall$Validator forDevice(neureka.backend.api.ExecutionCall$DeviceCondition) -> forDevice
    210:211:neureka.backend.api.ExecutionCall$Validator forOperation(neureka.backend.api.ExecutionCall$OperationTypeCondition) -> forOperation
    140:140:boolean isValid() -> isValid
neureka.backend.api.algorithms.AbstractBaseAlgorithm -> neureka.backend.api.algorithms.AbstractBaseAlgorithm:
    java.lang.String _name -> a
    java.util.Map _executions -> _executions
    20:22:void <init>(java.lang.String) -> <init>
    29:76:neureka.Tsr recursiveReductionOf(neureka.backend.api.ExecutionCall,java.util.function.Consumer) -> recursiveReductionOf
    84:88:java.lang.Object setImplementationFor(java.lang.Class,neureka.backend.api.implementations.ImplementationFor) -> setImplementationFor
    93:93:neureka.backend.api.implementations.ImplementationFor getImplementationFor(java.lang.Class) -> getImplementationFor
    18:18:java.lang.String getName() -> getName
    65:65:neureka.Tsr lambda$recursiveReductionOf$2(java.util.function.Consumer,neureka.backend.api.ExecutionCall) -> a
    52:52:void lambda$recursiveReductionOf$1(neureka.Tsr) -> a
    45:49:void lambda$recursiveReductionOf$0(neureka.devices.Device,neureka.Tsr) -> a
neureka.backend.api.algorithms.AbstractFunctionalAlgorithm -> neureka.backend.api.algorithms.AbstractFunctionalAlgorithm:
    neureka.backend.api.algorithms.Algorithm$SuitabilityChecker _suitabilityChecker -> a
    neureka.backend.api.algorithms.Algorithm$DeviceFinder _deviceFinder -> b
    neureka.backend.api.algorithms.Algorithm$ForwardADAnalyzer _forwardADAnalyzer -> c
    neureka.backend.api.algorithms.Algorithm$BackwardADAnalyzer _backwardADAnalyzer -> d
    neureka.backend.api.algorithms.Algorithm$ADAgentSupplier _ADAgentSupplier -> e
    neureka.backend.api.algorithms.Algorithm$InitialCallHook _callHook -> f
    neureka.backend.api.algorithms.Algorithm$RecursiveJunctionAgent _RJAgent -> g
    neureka.backend.api.algorithms.Algorithm$DrainInstantiation _drainInstantiation -> h
    44:45:void <init>(java.lang.String) -> <init>
    51:51:float isAlgorithmSuitableFor(neureka.backend.api.ExecutionCall) -> isAlgorithmSuitableFor
    58:58:neureka.devices.Device findDeviceFor(neureka.backend.api.ExecutionCall) -> findDeviceFor
    65:65:boolean canAlgorithmPerformForwardADFor(neureka.backend.api.ExecutionCall) -> canAlgorithmPerformForwardADFor
    72:72:boolean canAlgorithmPerformBackwardADFor(neureka.backend.api.ExecutionCall) -> canAlgorithmPerformBackwardADFor
    79:79:neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> supplyADAgentFor
    86:86:neureka.Tsr handleInsteadOfDevice(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> handleInsteadOfDevice
    93:93:neureka.Tsr handleRecursivelyAccordingToArity(neureka.backend.api.ExecutionCall,java.util.function.Function) -> handleRecursivelyAccordingToArity
    100:100:neureka.backend.api.ExecutionCall instantiateNewTensorsForExecutionIn(neureka.backend.api.ExecutionCall) -> instantiateNewTensorsForExecutionIn
    106:106:java.lang.Object build() -> build
    34:34:neureka.backend.api.algorithms.Algorithm$SuitabilityChecker getSuitabilityChecker() -> getSuitabilityChecker
    34:34:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setSuitabilityChecker(neureka.backend.api.algorithms.Algorithm$SuitabilityChecker) -> setSuitabilityChecker
    35:35:neureka.backend.api.algorithms.Algorithm$DeviceFinder getDeviceFinder() -> getDeviceFinder
    35:35:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setDeviceFinder(neureka.backend.api.algorithms.Algorithm$DeviceFinder) -> setDeviceFinder
    36:36:neureka.backend.api.algorithms.Algorithm$ForwardADAnalyzer getForwardADAnalyzer() -> getForwardADAnalyzer
    36:36:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setForwardADAnalyzer(neureka.backend.api.algorithms.Algorithm$ForwardADAnalyzer) -> setForwardADAnalyzer
    37:37:neureka.backend.api.algorithms.Algorithm$BackwardADAnalyzer getBackwardADAnalyzer() -> getBackwardADAnalyzer
    37:37:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setBackwardADAnalyzer(neureka.backend.api.algorithms.Algorithm$BackwardADAnalyzer) -> setBackwardADAnalyzer
    38:38:neureka.backend.api.algorithms.Algorithm$ADAgentSupplier getADAgentSupplier() -> getADAgentSupplier
    38:38:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setADAgentSupplier(neureka.backend.api.algorithms.Algorithm$ADAgentSupplier) -> setADAgentSupplier
    39:39:neureka.backend.api.algorithms.Algorithm$InitialCallHook getCallHook() -> getCallHook
    39:39:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setCallHook(neureka.backend.api.algorithms.Algorithm$InitialCallHook) -> setCallHook
    40:40:neureka.backend.api.algorithms.Algorithm$RecursiveJunctionAgent getRJAgent() -> getRJAgent
    40:40:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setRJAgent(neureka.backend.api.algorithms.Algorithm$RecursiveJunctionAgent) -> setRJAgent
    41:41:neureka.backend.api.algorithms.Algorithm$DrainInstantiation getDrainInstantiation() -> getDrainInstantiation
    41:41:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setDrainInstantiation(neureka.backend.api.algorithms.Algorithm$DrainInstantiation) -> setDrainInstantiation
neureka.backend.api.algorithms.Algorithm -> neureka.backend.api.algorithms.Algorithm:
    java.lang.String getName() -> getName
    float isAlgorithmSuitableFor(neureka.backend.api.ExecutionCall) -> isAlgorithmSuitableFor
    neureka.devices.Device findDeviceFor(neureka.backend.api.ExecutionCall) -> findDeviceFor
    boolean canAlgorithmPerformForwardADFor(neureka.backend.api.ExecutionCall) -> canAlgorithmPerformForwardADFor
    boolean canAlgorithmPerformBackwardADFor(neureka.backend.api.ExecutionCall) -> canAlgorithmPerformBackwardADFor
    neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> supplyADAgentFor
    neureka.Tsr handleInsteadOfDevice(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> handleInsteadOfDevice
    neureka.Tsr handleRecursivelyAccordingToArity(neureka.backend.api.ExecutionCall,java.util.function.Function) -> handleRecursivelyAccordingToArity
    neureka.backend.api.ExecutionCall instantiateNewTensorsForExecutionIn(neureka.backend.api.ExecutionCall) -> instantiateNewTensorsForExecutionIn
    neureka.Tsr recursiveReductionOf(neureka.backend.api.ExecutionCall,java.util.function.Consumer) -> recursiveReductionOf
    java.lang.Object setImplementationFor(java.lang.Class,neureka.backend.api.implementations.ImplementationFor) -> setImplementationFor
    neureka.backend.api.implementations.ImplementationFor getImplementationFor(java.lang.Class) -> getImplementationFor
neureka.backend.api.algorithms.Algorithm$ADAgentSupplier -> neureka.backend.api.algorithms.Algorithm$ADAgentSupplier:
    neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> getADAgentOf
neureka.backend.api.algorithms.Algorithm$BackwardADAnalyzer -> neureka.backend.api.algorithms.Algorithm$BackwardADAnalyzer:
    boolean allowsBackward(neureka.backend.api.ExecutionCall) -> allowsBackward
neureka.backend.api.algorithms.Algorithm$DeviceFinder -> neureka.backend.api.algorithms.Algorithm$DeviceFinder:
    neureka.devices.Device findFor(neureka.backend.api.ExecutionCall) -> findFor
neureka.backend.api.algorithms.Algorithm$DrainInstantiation -> neureka.backend.api.algorithms.Algorithm$DrainInstantiation:
    neureka.backend.api.ExecutionCall handle(neureka.backend.api.ExecutionCall) -> handle
neureka.backend.api.algorithms.Algorithm$ForwardADAnalyzer -> neureka.backend.api.algorithms.Algorithm$ForwardADAnalyzer:
    boolean allowsForward(neureka.backend.api.ExecutionCall) -> allowsForward
neureka.backend.api.algorithms.Algorithm$InitialCallHook -> neureka.backend.api.algorithms.Algorithm$InitialCallHook:
    neureka.Tsr handle(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> handle
neureka.backend.api.algorithms.Algorithm$RecursiveJunctionAgent -> neureka.backend.api.algorithms.Algorithm$RecursiveJunctionAgent:
    neureka.Tsr handle(neureka.backend.api.ExecutionCall,java.util.function.Function) -> handle
neureka.backend.api.algorithms.Algorithm$SuitabilityChecker -> neureka.backend.api.algorithms.Algorithm$SuitabilityChecker:
    float canHandle(neureka.backend.api.ExecutionCall) -> canHandle
neureka.backend.api.algorithms.GenericAlgorithm -> neureka.backend.api.algorithms.GenericAlgorithm:
    24:77:void <init>(java.lang.String,int,neureka.backend.api.operations.Operation) -> <init>
    81:86:float isAlgorithmSuitableFor(neureka.backend.api.ExecutionCall) -> isAlgorithmSuitableFor
    95:95:neureka.devices.Device findDeviceFor(neureka.backend.api.ExecutionCall) -> findDeviceFor
    100:100:boolean canAlgorithmPerformForwardADFor(neureka.backend.api.ExecutionCall) -> canAlgorithmPerformForwardADFor
    105:105:boolean canAlgorithmPerformBackwardADFor(neureka.backend.api.ExecutionCall) -> canAlgorithmPerformBackwardADFor
    111:121:neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> supplyADAgentFor
    126:126:neureka.Tsr handleInsteadOfDevice(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> handleInsteadOfDevice
    132:132:neureka.Tsr handleRecursivelyAccordingToArity(neureka.backend.api.ExecutionCall,java.util.function.Function) -> handleRecursivelyAccordingToArity
    138:152:neureka.backend.api.ExecutionCall instantiateNewTensorsForExecutionIn(neureka.backend.api.ExecutionCall) -> instantiateNewTensorsForExecutionIn
    121:121:neureka.Tsr lambda$supplyADAgentFor$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    120:120:neureka.Tsr lambda$supplyADAgentFor$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    116:116:neureka.Tsr lambda$supplyADAgentFor$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    115:115:neureka.Tsr lambda$supplyADAgentFor$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    29:73:void lambda$new$3(neureka.backend.api.operations.Operation,neureka.backend.api.ExecutionCall) -> a
    63:69:void lambda$new$2(java.lang.Object[],neureka.backend.api.ExecutionCall,groovy.lang.GroovyShell,java.lang.String,int,int) -> a
    43:49:void lambda$new$1(double[],neureka.backend.api.ExecutionCall,neureka.calculus.Function,int,int) -> a
    31:31:boolean lambda$new$0(neureka.Tsr) -> a
neureka.backend.api.implementations.AbstractImplementationFor -> neureka.backend.api.implementations.AbstractImplementationFor:
    neureka.backend.api.implementations.ImplementationFor _lambda -> a
    8:14:void <init>(neureka.backend.api.implementations.ImplementationFor,int) -> <init>
    20:21:void run(neureka.backend.api.ExecutionCall) -> run
neureka.backend.api.implementations.ImplementationFor -> neureka.backend.api.implementations.ImplementationFor:
    void run(neureka.backend.api.ExecutionCall) -> run
neureka.backend.api.operations.AbstractOperation -> neureka.backend.api.operations.AbstractOperation:
    org.slf4j.Logger _LOG -> a
    int _id -> _id
    java.lang.String _function -> _function
    java.lang.String _operator -> _operator
    int _arity -> _arity
    boolean _isIndexer -> _isIndexer
    boolean _isDifferentiable -> _isDifferentiable
    boolean _isInline -> _isInline
    boolean _isOperator -> _isOperator
    java.util.Map _algorithms -> b
    neureka.backend.api.algorithms.Algorithm _defaultAlgorithm -> c
    69:147:void <init>(neureka.backend.api.operations.OperationFactory) -> <init>
    153:153:neureka.backend.api.algorithms.Algorithm getAlgorithm(java.lang.Class) -> getAlgorithm
    158:158:boolean supportsAlgorithm(java.lang.Class) -> supportsAlgorithm
    163:164:neureka.backend.api.operations.Operation setAlgorithm(java.lang.Class,neureka.backend.api.algorithms.Algorithm) -> setAlgorithm
    171:192:neureka.backend.api.algorithms.Algorithm getAlgorithmFor(neureka.backend.api.ExecutionCall) -> getAlgorithmFor
    199:199:boolean supports(java.lang.Class) -> supports
    204:204:boolean isOperator() -> isOperator
    25:114:void <init>() -> <init>
    39:39:int getId() -> getId
    51:51:java.lang.String getFunction() -> getFunction
    63:63:java.lang.String getOperator() -> getOperator
    69:69:int getArity() -> getArity
    79:79:boolean isIndexer() -> isIndexer
    87:87:boolean isDifferentiable() -> isDifferentiable
    93:93:boolean isInline() -> isInline
    114:114:neureka.backend.api.algorithms.Algorithm getDefaultAlgorithm() -> getDefaultAlgorithm
    29:29:void <clinit>() -> <clinit>
neureka.backend.api.operations.Operation -> neureka.backend.api.operations.Operation:
    neureka.backend.api.algorithms.Algorithm getAlgorithmFor(neureka.backend.api.ExecutionCall) -> getAlgorithmFor
    java.lang.String getFunction() -> getFunction
    neureka.backend.api.algorithms.Algorithm getAlgorithm(java.lang.Class) -> getAlgorithm
    boolean supportsAlgorithm(java.lang.Class) -> supportsAlgorithm
    neureka.backend.api.operations.Operation setAlgorithm(java.lang.Class,neureka.backend.api.algorithms.Algorithm) -> setAlgorithm
    java.lang.String stringify(java.lang.String[]) -> stringify
    java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    int getId() -> getId
    java.lang.String getOperator() -> getOperator
    int getArity() -> getArity
    boolean isOperator() -> isOperator
    boolean isIndexer() -> isIndexer
    boolean isDifferentiable() -> isDifferentiable
    boolean isInline() -> isInline
    boolean supports(java.lang.Class) -> supports
    double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.api.operations.Operation$DefaultOperatorCreator -> neureka.backend.api.operations.Operation$DefaultOperatorCreator:
    java.lang.Object create(neureka.Tsr[],int) -> create
neureka.backend.api.operations.Operation$PrimaryNDIConsumer -> neureka.backend.api.operations.Operation$PrimaryNDIConsumer:
    double execute(neureka.ndim.iterators.NDIterator) -> execute
neureka.backend.api.operations.Operation$PrimaryNDXConsumer -> neureka.backend.api.operations.Operation$PrimaryNDXConsumer:
    double execute(int[]) -> execute
neureka.backend.api.operations.Operation$ScalarOperatorCreator -> neureka.backend.api.operations.Operation$ScalarOperatorCreator:
    java.lang.Object create(neureka.Tsr[],double,int) -> create
neureka.backend.api.operations.Operation$SecondaryNDIConsumer -> neureka.backend.api.operations.Operation$SecondaryNDIConsumer:
    double execute(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> execute
neureka.backend.api.operations.Operation$SecondaryNDXConsumer -> neureka.backend.api.operations.Operation$SecondaryNDXConsumer:
    double execute(int[],int[]) -> execute
neureka.backend.api.operations.Operation$TertiaryNDIConsumer -> neureka.backend.api.operations.Operation$TertiaryNDIConsumer:
    double execute(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> execute
neureka.backend.api.operations.Operation$TertiaryNDXConsumer -> neureka.backend.api.operations.Operation$TertiaryNDXConsumer:
    double execute(int[],int[],int[]) -> execute
neureka.backend.api.operations.Operation$Utility -> neureka.backend.api.operations.Operation$Utility:
    204:204:void <init>() -> <init>
    207:213:neureka.Tsr[] subset(neureka.Tsr[],int,int,int) -> subset
    217:219:neureka.Tsr[] without(neureka.Tsr[],int) -> without
    223:235:neureka.Tsr[] offsetted(neureka.Tsr[],int) -> offsetted
neureka.backend.api.operations.OperationContext -> neureka.backend.api.operations.OperationContext:
    org.slf4j.Logger log -> a
    java.lang.ThreadLocal _CONTEXTS -> b
    java.util.Map _lookup -> c
    java.util.List _instances -> d
    int _id -> e
    boolean $assertionsDisabled -> f
    55:55:neureka.backend.api.operations.OperationContext get() -> get
    67:68:void setInstance(neureka.backend.api.operations.OperationContext) -> setInstance
    86:90:void <init>() -> <init>
    94:95:void incrementID() -> incrementID
    107:107:neureka.backend.api.operations.Operation instance(int) -> instance
    120:120:neureka.backend.api.operations.Operation instance(java.lang.String) -> instance
    126:130:neureka.backend.api.operations.OperationContext clone() -> clone
    31:31:java.lang.String toString() -> toString
    73:73:java.util.Map lookup() -> lookup
    78:78:java.util.List instances() -> instances
    83:83:int id() -> id
    30:30:java.lang.Object clone() -> clone
    30:48:void <clinit>() -> <clinit>
neureka.backend.api.operations.OperationFactory -> neureka.backend.api.operations.OperationFactory:
    neureka.backend.api.operations.OperationFactory$Stringifier _stringifier -> a
    neureka.backend.api.operations.OperationFactory$Derivator _derivator -> b
    java.lang.String _function -> c
    java.lang.String _operator -> d
    java.lang.Integer _arity -> e
    java.lang.Boolean _isOperator -> f
    java.lang.Boolean _isIndexer -> g
    java.lang.Boolean _isDifferentiable -> h
    java.lang.Boolean _isInline -> i
    boolean _disposed -> j
    12:35:void <init>() -> <init>
    38:39:void dispose() -> dispose
    43:56:neureka.backend.api.operations.Operation build() -> build
    26:26:neureka.backend.api.operations.OperationFactory$Stringifier getStringifier() -> getStringifier
    26:26:neureka.backend.api.operations.OperationFactory setStringifier(neureka.backend.api.operations.OperationFactory$Stringifier) -> setStringifier
    27:27:neureka.backend.api.operations.OperationFactory$Derivator getDerivator() -> getDerivator
    27:27:neureka.backend.api.operations.OperationFactory setDerivator(neureka.backend.api.operations.OperationFactory$Derivator) -> setDerivator
    28:28:java.lang.String getFunction() -> getFunction
    28:28:neureka.backend.api.operations.OperationFactory setFunction(java.lang.String) -> setFunction
    29:29:java.lang.String getOperator() -> getOperator
    29:29:neureka.backend.api.operations.OperationFactory setOperator(java.lang.String) -> setOperator
    30:30:java.lang.Integer getArity() -> getArity
    30:30:neureka.backend.api.operations.OperationFactory setArity(java.lang.Integer) -> setArity
    31:31:java.lang.Boolean getIsOperator() -> getIsOperator
    31:31:neureka.backend.api.operations.OperationFactory setIsOperator(java.lang.Boolean) -> setIsOperator
    32:32:java.lang.Boolean getIsIndexer() -> getIsIndexer
    32:32:neureka.backend.api.operations.OperationFactory setIsIndexer(java.lang.Boolean) -> setIsIndexer
    33:33:java.lang.Boolean getIsDifferentiable() -> getIsDifferentiable
    33:33:neureka.backend.api.operations.OperationFactory setIsDifferentiable(java.lang.Boolean) -> setIsDifferentiable
    34:34:java.lang.Boolean getIsInline() -> getIsInline
    34:34:neureka.backend.api.operations.OperationFactory setIsInline(java.lang.Boolean) -> setIsInline
    12:12:neureka.backend.api.operations.OperationFactory$Stringifier access$000(neureka.backend.api.operations.OperationFactory) -> a
    12:12:neureka.backend.api.operations.OperationFactory$Derivator access$100(neureka.backend.api.operations.OperationFactory) -> b
neureka.backend.api.operations.OperationFactory$1 -> neureka.backend.api.operations.OperationFactory$1:
    neureka.backend.api.operations.OperationFactory this$0 -> a
    56:56:void <init>(neureka.backend.api.operations.OperationFactory,neureka.backend.api.operations.OperationFactory) -> <init>
    59:59:java.lang.String stringify(java.lang.String[]) -> stringify
    64:64:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    69:69:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.api.operations.OperationFactory$Derivator -> neureka.backend.api.operations.OperationFactory$a:
    java.lang.String asDerivative$574684d7() -> a
neureka.backend.api.operations.OperationFactory$Stringifier -> neureka.backend.api.operations.OperationFactory$b:
    java.lang.String stringify$4af589aa() -> a
neureka.backend.standard.algorithms.Activation -> neureka.backend.standard.algorithms.Activation:
    17:51:void <init>() -> <init>
    54:54:java.lang.String getKernelSource() -> getKernelSource
    63:76:void activate(neureka.Tsr,neureka.Tsr,int,int,neureka.backend.api.operations.Operation$TertiaryNDIConsumer) -> activate
    85:99:void activate(neureka.Tsr,int,int,neureka.backend.api.operations.Operation$TertiaryNDXConsumer) -> activate
    34:48:neureka.backend.api.ExecutionCall lambda$new$7(neureka.backend.api.ExecutionCall) -> a
    31:31:neureka.Tsr lambda$new$6(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    30:30:neureka.Tsr lambda$new$5(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    25:28:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> b
    27:27:boolean lambda$new$3(neureka.Tsr,neureka.Tsr) -> a
    23:23:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> c
    19:21:float lambda$new$1(neureka.backend.api.ExecutionCall) -> d
    20:20:boolean lambda$new$0(neureka.Tsr) -> a
neureka.backend.standard.algorithms.Broadcast -> neureka.backend.standard.algorithms.Broadcast:
    boolean $assertionsDisabled -> a
    17:89:void <init>() -> <init>
    92:92:java.lang.String getKernelSource() -> getKernelSource
    101:187:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.operations.Operation$TertiaryNDIConsumer) -> broadcast
    197:281:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.operations.Operation$TertiaryNDXConsumer) -> broadcast
    61:86:neureka.backend.api.ExecutionCall lambda$new$3(neureka.backend.api.ExecutionCall) -> a
    45:56:neureka.Tsr lambda$new$2(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    21:40:float lambda$new$1(neureka.backend.api.ExecutionCall) -> b
    23:23:boolean lambda$new$0(neureka.Tsr) -> a
    13:13:void <clinit>() -> <clinit>
neureka.backend.standard.algorithms.Convolution -> neureka.backend.standard.algorithms.Convolution:
    16:22:void <init>() -> <init>
    26:26:java.lang.String getKernelSource() -> getKernelSource
    35:174:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.operations.Operation$TertiaryNDIConsumer) -> convolve
    182:320:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.operations.Operation$TertiaryNDXConsumer) -> convolve
    18:20:float lambda$new$1(neureka.backend.api.ExecutionCall) -> a
    19:19:boolean lambda$new$0(neureka.Tsr) -> a
neureka.backend.standard.algorithms.GenericAlgorithm -> neureka.backend.standard.algorithms.GenericAlgorithm:
    8:9:void <init>(java.lang.String) -> <init>
neureka.backend.standard.algorithms.Operator -> neureka.backend.standard.algorithms.Operator:
    18:51:void <init>() -> <init>
    54:54:java.lang.String getKernelSource() -> getKernelSource
    64:85:void operate(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.operations.Operation$SecondaryNDIConsumer) -> operate
    95:110:void operate(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.api.operations.Operation$PrimaryNDXConsumer) -> operate
    34:48:neureka.backend.api.ExecutionCall lambda$new$7(neureka.backend.api.ExecutionCall) -> a
    31:31:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    30:30:boolean lambda$new$5(neureka.backend.api.ExecutionCall) -> b
    29:29:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> c
    21:26:float lambda$new$3(neureka.backend.api.ExecutionCall) -> d
    25:25:boolean lambda$new$2(neureka.Tsr) -> a
    24:24:boolean lambda$new$1(int,java.util.List,neureka.Tsr) -> a
    22:22:java.lang.Integer lambda$new$0(java.lang.Integer,java.lang.Integer) -> a
neureka.backend.standard.algorithms.Scalarization -> neureka.backend.standard.algorithms.Scalarization:
    boolean $assertionsDisabled -> a
    17:49:void <init>() -> <init>
    53:53:java.lang.String getKernelSource() -> getKernelSource
    63:75:void scalarize(neureka.Tsr,int,int,neureka.backend.api.operations.Operation$PrimaryNDIConsumer) -> scalarize
    83:94:void scalarize(neureka.Tsr,int,int,neureka.backend.api.operations.Operation$PrimaryNDXConsumer) -> scalarize
    32:46:neureka.backend.api.ExecutionCall lambda$new$3(neureka.backend.api.ExecutionCall) -> a
    19:28:float lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    22:22:boolean lambda$new$1(neureka.Tsr) -> a
    21:21:boolean lambda$new$0(neureka.Tsr) -> b
    13:13:void <clinit>() -> <clinit>
neureka.backend.standard.implementations.CLImplementation -> neureka.backend.standard.implementations.CLImplementation:
    java.util.function.Function _aliasSwapper -> a
    java.util.function.Function asAdvanced -> b
    java.lang.String _source -> c
    java.lang.String _name -> d
    23:53:void <init>(neureka.backend.api.implementations.ImplementationFor,int) -> <init>
    23:64:void <init>(neureka.backend.api.implementations.ImplementationFor,int,java.lang.String,java.lang.String) -> <init>
    23:98:void <init>(neureka.backend.api.implementations.ImplementationFor,int,java.lang.String,java.lang.String,java.lang.String,neureka.backend.api.operations.AbstractOperation) -> <init>
    1112:1140:java.util.Map _getParsedKernelsFromTemplate(java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.backend.api.operations.AbstractOperation):112:140 -> <init>
    1112:1140:void <init>(neureka.backend.api.implementations.ImplementationFor,int,java.lang.String,java.lang.String,java.lang.String,neureka.backend.api.operations.AbstractOperation):87 -> <init>
    45:45:java.lang.String getSource() -> getSource
    46:46:java.lang.String getName() -> getName
    118:128:void lambda$_getParsedKernelsFromTemplate$2(java.lang.String[],java.lang.String,java.util.Map,java.lang.String,java.lang.String,java.lang.String) -> a
    40:43:java.lang.String lambda$new$1(java.lang.String) -> a
    25:35:java.lang.String lambda$new$0(java.lang.String) -> b
neureka.backend.standard.implementations.CLImplementation$Parser -> neureka.backend.standard.implementations.CLImplementation$a:
    void apply(java.lang.String,java.lang.String,java.lang.String) -> apply
neureka.backend.standard.implementations.HostImplementation -> neureka.backend.standard.implementations.HostImplementation:
    20:21:void <init>(neureka.backend.api.implementations.ImplementationFor,int) -> <init>
neureka.backend.standard.operations.function.Absolute -> neureka.backend.standard.operations.function.Absolute:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _activationCreator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _activationXCreator -> b
    19:97:void <init>() -> <init>
    101:103:java.lang.String stringify(java.lang.String[]) -> stringify
    108:108:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    113:116:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    121:122:double calculate(double,boolean) -> calculate
    80:88:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    57:67:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    68:71:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    62:65:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    48:48:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    27:29:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    29:29:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    28:28:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:23:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    23:23:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    22:22:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Cosinus -> neureka.backend.standard.operations.function.Cosinus:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    19:99:void <init>() -> <init>
    103:105:java.lang.String stringify(java.lang.String[]) -> stringify
    110:110:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    115:118:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    123:124:double calculate(double,boolean) -> calculate
    81:89:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    58:68:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    69:72:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    63:66:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    48:48:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    27:29:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    29:29:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    28:28:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:23:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    23:23:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    22:22:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Gaussian -> neureka.backend.standard.operations.function.Gaussian:
    22:156:void <init>() -> <init>
    160:162:java.lang.String stringify(java.lang.String[]) -> stringify
    167:167:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    172:175:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    180:181:double calculate(double,boolean) -> calculate
    131:139:void lambda$new$15(neureka.backend.api.ExecutionCall) -> a
    108:118:void lambda$new$14(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    119:122:void lambda$new$13(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    113:116:void lambda$new$12(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    83:97:neureka.backend.api.ExecutionCall lambda$new$11(neureka.backend.api.ExecutionCall) -> b
    80:80:neureka.Tsr lambda$new$10(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    79:79:neureka.Tsr lambda$new$9(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    77:77:neureka.autograd.ADAgent lambda$new$8(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    67:72:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> c
    64:64:boolean lambda$new$6(neureka.backend.api.ExecutionCall) -> d
    51:55:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    56:57:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    53:53:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    36:40:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    41:42:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    38:38:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Identity -> neureka.backend.standard.operations.function.Identity:
    24:213:void <init>() -> <init>
    217:219:java.lang.String stringify(java.lang.String[]) -> stringify
    224:224:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    229:232:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    237:238:double calculate(double,boolean) -> calculate
    193:202:void lambda$new$27(neureka.backend.api.ExecutionCall) -> a
    174:186:void lambda$new$26(neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    179:182:void lambda$new$25(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> a
    149:163:neureka.backend.api.ExecutionCall lambda$new$24(neureka.backend.api.ExecutionCall) -> b
    146:146:neureka.Tsr lambda$new$23(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    145:145:neureka.Tsr lambda$new$22(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    143:143:neureka.autograd.ADAgent lambda$new$21(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    133:138:boolean lambda$new$20(neureka.backend.api.ExecutionCall) -> c
    130:130:boolean lambda$new$19(neureka.backend.api.ExecutionCall) -> d
    126:127:neureka.backend.api.operations.Operation$PrimaryNDIConsumer lambda$new$18(neureka.Tsr[],double,int) -> a
    127:127:double lambda$new$17(double,neureka.ndim.iterators.NDIterator) -> a
    126:126:double lambda$new$16(double,neureka.ndim.iterators.NDIterator) -> b
    104:114:void lambda$new$15(neureka.backend.api.ExecutionCall) -> e
    81:91:void lambda$new$14(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    92:95:void lambda$new$13(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    86:89:void lambda$new$12(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    68:70:neureka.backend.api.ExecutionCall lambda$new$11(neureka.backend.api.ExecutionCall) -> f
    65:65:neureka.Tsr lambda$new$10(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    64:64:neureka.Tsr lambda$new$9(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> b
    62:62:neureka.autograd.ADAgent lambda$new$8(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    53:58:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> g
    50:50:boolean lambda$new$6(neureka.backend.api.ExecutionCall) -> h
    44:46:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    46:46:double lambda$new$4(int[],int[],int[]) -> a
    45:45:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> a
    37:39:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    39:39:double lambda$new$1(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    38:38:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
neureka.backend.standard.operations.function.Quadratic -> neureka.backend.standard.operations.function.Quadratic:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorNDI -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorNDX -> b
    19:109:void <init>() -> <init>
    113:115:java.lang.String stringify(java.lang.String[]) -> stringify
    120:120:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    125:128:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    133:134:double calculate(double,boolean) -> calculate
    90:98:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    66:76:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    77:80:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    71:74:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    56:56:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    32:38:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    38:38:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    35:36:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:27:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    27:27:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    24:25:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.ReLU -> neureka.backend.standard.operations.function.ReLU:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    19:119:void <init>() -> <init>
    123:125:java.lang.String stringify(java.lang.String[]) -> stringify
    130:130:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    135:138:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    144:151:double calculate(double,boolean) -> calculate
    100:108:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    77:87:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    88:91:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    82:85:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    67:67:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    37:44:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    45:46:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    40:41:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:28:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    29:30:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    24:25:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Sigmoid -> neureka.backend.standard.operations.function.Sigmoid:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    19:105:void <init>() -> <init>
    109:111:java.lang.String stringify(java.lang.String[]) -> stringify
    116:116:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    121:124:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    129:132:double calculate(double,boolean) -> calculate
    84:92:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    61:71:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    72:75:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    66:69:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    50:50:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    28:30:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    30:30:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    29:29:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    21:23:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    23:23:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    22:22:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Sinus -> neureka.backend.standard.operations.function.Sinus:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    20:134:void <init>() -> <init>
    138:140:java.lang.String stringify(java.lang.String[]) -> stringify
    145:145:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    150:153:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    158:159:double calculate(double,boolean) -> calculate
    113:121:void lambda$new$15(neureka.backend.api.ExecutionCall) -> a
    90:100:void lambda$new$14(neureka.backend.api.ExecutionCall) -> b
    101:104:void lambda$new$13(neureka.backend.api.ExecutionCall,int,int) -> a
    95:98:void lambda$new$12(neureka.backend.api.ExecutionCall,int,int) -> b
    65:79:neureka.backend.api.ExecutionCall lambda$new$11(neureka.backend.api.ExecutionCall) -> c
    62:62:neureka.Tsr lambda$new$10(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    61:61:neureka.Tsr lambda$new$9(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    60:60:neureka.autograd.ADAgent lambda$new$8(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    51:56:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> d
    48:48:boolean lambda$new$6(neureka.backend.api.ExecutionCall) -> e
    29:31:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    31:31:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    30:30:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    22:24:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    24:24:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    23:23:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Softplus -> neureka.backend.standard.operations.function.Softplus:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    20:121:void <init>() -> <init>
    125:127:java.lang.String stringify(java.lang.String[]) -> stringify
    132:132:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    137:140:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    145:146:double calculate(double,boolean) -> calculate
    85:93:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    62:72:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    73:76:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    67:70:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    50:50:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    29:31:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    31:31:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    30:30:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    22:24:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    24:24:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    23:23:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.function.Tanh -> neureka.backend.standard.operations.function.Tanh:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    19:123:void <init>() -> <init>
    127:129:java.lang.String stringify(java.lang.String[]) -> stringify
    134:134:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    139:142:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    147:151:double calculate(double,boolean) -> calculate
    102:110:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    79:89:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    90:93:void lambda$new$8(neureka.backend.api.ExecutionCall,int,int) -> a
    84:87:void lambda$new$7(neureka.backend.api.ExecutionCall,int,int) -> b
    69:69:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    39:46:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$5(neureka.Tsr[],int) -> a
    47:48:double lambda$new$4(double[],neureka.Tsr[],int[],int[],int[]) -> a
    42:43:double lambda$new$3(double[],neureka.Tsr[],int[],int[],int[]) -> b
    22:29:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> b
    30:31:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    25:26:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.indexer.Product -> neureka.backend.standard.operations.indexer.Product:
    29:330:void <init>() -> <init>
    336:340:java.lang.String stringify(java.lang.String[]) -> stringify
    345:345:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    351:371:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    377:396:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    309:317:void lambda$new$40(neureka.backend.api.ExecutionCall) -> a
    285:295:void lambda$new$39(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    296:299:void lambda$new$38(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    290:293:void lambda$new$37(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    259:273:neureka.backend.api.ExecutionCall lambda$new$36(neureka.backend.api.ExecutionCall) -> b
    255:255:neureka.Tsr lambda$new$35(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    216:250:neureka.autograd.ADAgent lambda$new$34(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    250:250:neureka.Tsr lambda$new$33(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    249:249:neureka.Tsr lambda$new$32(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    243:243:neureka.Tsr lambda$new$31(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    242:242:neureka.Tsr lambda$new$30(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    230:230:neureka.Tsr lambda$new$29(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    229:229:neureka.Tsr lambda$new$28(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    221:221:neureka.Tsr lambda$new$27(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    220:220:neureka.Tsr lambda$new$26(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    212:212:boolean lambda$new$25(neureka.backend.api.ExecutionCall) -> c
    211:211:boolean lambda$new$24(neureka.backend.api.ExecutionCall) -> d
    205:207:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$23(neureka.Tsr[],int) -> a
    207:207:double lambda$new$22(double[],neureka.Tsr[],int[],int[],int[]) -> a
    206:206:double lambda$new$21(double[],neureka.Tsr[],int[],int[],int[]) -> b
    198:200:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$20(neureka.Tsr[],int) -> b
    200:200:double lambda$new$19(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    199:199:double lambda$new$18(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
    174:183:void lambda$new$17(neureka.backend.api.ExecutionCall) -> e
    145:158:void lambda$new$16(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> b
    159:165:void lambda$new$15(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> c
    150:156:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> d
    117:132:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    132:132:neureka.Tsr lambda$new$12(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    131:131:neureka.Tsr lambda$new$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    122:122:neureka.Tsr lambda$new$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    121:121:neureka.Tsr lambda$new$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    113:113:boolean lambda$new$8(neureka.backend.api.ExecutionCall) -> f
    112:112:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> g
    99:104:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$6(neureka.Tsr[],int) -> c
    105:106:double lambda$new$5(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    102:102:double lambda$new$4(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    84:89:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$3(neureka.Tsr[],int) -> d
    90:91:double lambda$new$2(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    87:87:double lambda$new$1(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    42:73:neureka.Tsr lambda$new$0(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
neureka.backend.standard.operations.indexer.Summation -> neureka.backend.standard.operations.indexer.Summation:
    28:309:void <init>() -> <init>
    313:317:java.lang.String stringify(java.lang.String[]) -> stringify
    322:322:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    327:338:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    343:361:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    288:299:void lambda$new$40(neureka.backend.api.ExecutionCall) -> a
    265:275:void lambda$new$39(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    276:279:void lambda$new$38(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    270:273:void lambda$new$37(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    240:254:neureka.backend.api.ExecutionCall lambda$new$36(neureka.backend.api.ExecutionCall) -> b
    236:236:neureka.Tsr lambda$new$35(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    197:231:neureka.autograd.ADAgent lambda$new$34(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    231:231:neureka.Tsr lambda$new$33(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    230:230:neureka.Tsr lambda$new$32(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    224:224:neureka.Tsr lambda$new$31(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    223:223:neureka.Tsr lambda$new$30(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    211:211:neureka.Tsr lambda$new$29(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    210:210:neureka.Tsr lambda$new$28(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    202:202:neureka.Tsr lambda$new$27(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    201:201:neureka.Tsr lambda$new$26(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    193:193:boolean lambda$new$25(neureka.backend.api.ExecutionCall) -> c
    192:192:boolean lambda$new$24(neureka.backend.api.ExecutionCall) -> d
    186:188:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$23(neureka.Tsr[],int) -> a
    188:188:double lambda$new$22(double[],neureka.Tsr[],int[],int[],int[]) -> a
    187:187:double lambda$new$21(double[],neureka.Tsr[],int[],int[],int[]) -> b
    179:181:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$20(neureka.Tsr[],int) -> b
    181:181:double lambda$new$19(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    180:180:double lambda$new$18(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
    154:163:void lambda$new$17(neureka.backend.api.ExecutionCall) -> e
    125:138:void lambda$new$16(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> b
    139:145:void lambda$new$15(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> c
    130:136:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> d
    96:111:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    111:111:neureka.Tsr lambda$new$12(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    110:110:neureka.Tsr lambda$new$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    101:101:neureka.Tsr lambda$new$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    100:100:neureka.Tsr lambda$new$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    92:92:boolean lambda$new$8(neureka.backend.api.ExecutionCall) -> f
    91:91:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> g
    84:87:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$6(neureka.Tsr[],int) -> c
    87:87:double lambda$new$5(int[],int[],int[]) -> a
    86:86:double lambda$new$4(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    75:78:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$3(neureka.Tsr[],int) -> d
    78:78:double lambda$new$2(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    77:77:double lambda$new$1(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    41:65:neureka.Tsr lambda$new$0(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
neureka.backend.standard.operations.linear.MatMul -> neureka.backend.standard.operations.linear.MatMul:
    27:244:void <init>() -> <init>
    249:256:java.lang.String stringify(java.lang.String[]) -> stringify
    261:261:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    266:266:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    210:219:void lambda$new$17(neureka.backend.api.ExecutionCall) -> a
    180:193:void lambda$new$16(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    194:198:void lambda$new$15(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    185:189:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    154:168:neureka.backend.api.ExecutionCall lambda$new$13(neureka.backend.api.ExecutionCall) -> b
    126:148:neureka.Tsr lambda$new$12(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    113:121:neureka.autograd.ADAgent lambda$new$11(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    121:121:neureka.Tsr lambda$new$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    120:120:neureka.Tsr lambda$new$9(neureka.autograd.GraphNode,neureka.Tsr) -> a
    99:106:boolean lambda$new$8(neureka.backend.api.ExecutionCall) -> c
    96:96:boolean lambda$new$7(neureka.backend.api.ExecutionCall) -> d
    82:87:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$6(neureka.Tsr[],int) -> a
    88:89:double lambda$new$5(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    85:85:double lambda$new$4(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    68:73:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$3(neureka.Tsr[],int) -> b
    74:75:double lambda$new$2(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    71:71:double lambda$new$1(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    40:62:neureka.Tsr lambda$new$0(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
neureka.backend.standard.operations.linear.XConv -> neureka.backend.standard.operations.linear.XConv:
    boolean $assertionsDisabled -> a
    26:315:void <init>() -> <init>
    320:327:java.lang.String stringify(java.lang.String[]) -> stringify
    332:332:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    337:337:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    225:234:void lambda$new$19(neureka.backend.api.ExecutionCall) -> a
    195:208:void lambda$new$18(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    209:213:void lambda$new$17(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    200:204:void lambda$new$16(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    169:183:neureka.backend.api.ExecutionCall lambda$new$15(neureka.backend.api.ExecutionCall) -> b
    141:163:neureka.Tsr lambda$new$14(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    120:136:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    136:136:neureka.Tsr lambda$new$12(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    135:135:neureka.Tsr lambda$new$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    107:114:boolean lambda$new$10(neureka.backend.api.ExecutionCall) -> c
    104:104:boolean lambda$new$9(neureka.backend.api.ExecutionCall) -> d
    91:96:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$8(neureka.Tsr[],int) -> a
    97:98:double lambda$new$7(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    94:94:double lambda$new$6(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    78:83:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$5(neureka.Tsr[],int) -> b
    84:85:double lambda$new$4(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    81:81:double lambda$new$3(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    39:72:neureka.Tsr lambda$new$2(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    70:70:neureka.Tsr[] lambda$new$1(neureka.Tsr[]) -> a
    67:67:neureka.Tsr[] lambda$new$0(neureka.Tsr[]) -> b
    21:21:void <clinit>() -> <clinit>
neureka.backend.standard.operations.linear.XConv$1 -> neureka.backend.standard.operations.linear.XConv$1:
    253:253:void <init>(neureka.backend.standard.operations.linear.XConv,neureka.backend.api.operations.OperationFactory) -> <init>
    256:263:java.lang.String stringify(java.lang.String[]) -> stringify
    268:268:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    273:273:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.linear.XConv$2 -> neureka.backend.standard.operations.linear.XConv$2:
    287:287:void <init>(neureka.backend.standard.operations.linear.XConv,neureka.backend.api.operations.OperationFactory) -> <init>
    290:297:java.lang.String stringify(java.lang.String[]) -> stringify
    302:302:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    307:307:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Addition -> neureka.backend.standard.operations.operator.Addition:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    neureka.backend.standard.algorithms.Broadcast _broadcast -> c
    87:543:void <init>() -> <init>
    549:556:java.lang.String stringify(java.lang.String[]) -> stringify
    561:567:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    572:585:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    591:603:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    564:564:neureka.calculus.Function lambda$asDerivative$57(int,neureka.calculus.Function) -> a
    563:563:boolean lambda$asDerivative$56(int,neureka.calculus.Function) -> b
    482:484:neureka.backend.api.ExecutionCall lambda$new$55(neureka.backend.api.ExecutionCall) -> a
    479:479:neureka.Tsr lambda$new$54(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    478:478:neureka.Tsr lambda$new$53(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    458:474:neureka.autograd.ADAgent lambda$new$52(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    474:474:neureka.Tsr lambda$new$51(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    473:473:neureka.Tsr lambda$new$50(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    463:463:neureka.Tsr lambda$new$49(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    462:462:neureka.Tsr lambda$new$48(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    447:452:boolean lambda$new$47(neureka.backend.api.ExecutionCall) -> b
    444:444:boolean lambda$new$46(neureka.backend.api.ExecutionCall) -> c
    331:340:void lambda$new$45(neureka.backend.api.ExecutionCall) -> d
    305:323:void lambda$new$44(neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    317:320:void lambda$new$43(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> a
    311:314:void lambda$new$42(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> b
    290:295:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$41(neureka.Tsr[],double,int) -> a
    295:295:double lambda$new$40(int[]) -> a
    294:294:double lambda$new$39(int[]) -> b
    292:292:double lambda$new$38(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    280:284:neureka.backend.api.operations.Operation$PrimaryNDIConsumer lambda$new$37(neureka.Tsr[],double,int) -> b
    284:284:double lambda$new$36(neureka.ndim.iterators.NDIterator) -> a
    283:283:double lambda$new$35(neureka.ndim.iterators.NDIterator) -> b
    281:281:double lambda$new$34(double[],double,neureka.ndim.iterators.NDIterator) -> a
    274:274:neureka.Tsr lambda$new$33(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> b
    272:272:neureka.autograd.ADAgent lambda$new$32(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    269:269:boolean lambda$new$31(neureka.backend.api.ExecutionCall) -> e
    268:268:boolean lambda$new$30(neureka.backend.api.ExecutionCall) -> f
    245:254:void lambda$new$29(neureka.backend.api.ExecutionCall) -> g
    222:232:void lambda$new$28(neureka.backend.api.ExecutionCall) -> h
    233:236:void lambda$new$27(neureka.backend.api.ExecutionCall,int,int) -> a
    227:230:void lambda$new$26(neureka.backend.api.ExecutionCall,int,int) -> b
    194:203:void lambda$new$25(neureka.backend.api.ExecutionCall) -> i
    164:177:void lambda$new$24(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    178:184:void lambda$new$23(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    169:175:void lambda$new$22(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    152:152:neureka.autograd.ADAgent lambda$new$21(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    141:146:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$20(neureka.Tsr[],int) -> a
    146:146:double lambda$new$19(int[]) -> c
    145:145:double lambda$new$18(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    133:136:neureka.backend.api.operations.Operation$SecondaryNDIConsumer lambda$new$17(neureka.Tsr[],int) -> b
    136:136:double lambda$new$16(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    135:135:double lambda$new$15(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    100:124:neureka.Tsr lambda$new$14(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    82:82:neureka.Tsr lambda$static$13(neureka.backend.api.ExecutionCall,java.util.function.Function) -> c
    63:78:neureka.autograd.ADAgent lambda$static$12(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> d
    78:78:neureka.Tsr lambda$static$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    77:77:neureka.Tsr lambda$static$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    68:68:neureka.Tsr lambda$static$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    67:67:neureka.Tsr lambda$static$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    53:58:boolean lambda$static$7(neureka.backend.api.ExecutionCall) -> j
    50:50:boolean lambda$static$6(neureka.backend.api.ExecutionCall) -> k
    40:45:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$static$5(neureka.Tsr[],int) -> c
    45:45:double lambda$static$4(int[],int[],int[]) -> a
    44:44:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    32:35:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> d
    35:35:double lambda$static$1(neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    34:34:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    30:83:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.Addition$1 -> neureka.backend.standard.operations.operator.Addition$1:
    362:362:void <init>(neureka.backend.standard.operations.operator.Addition,neureka.backend.api.operations.OperationFactory) -> <init>
    365:365:java.lang.String stringify(java.lang.String[]) -> stringify
    370:370:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    375:375:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Addition$2 -> neureka.backend.standard.operations.operator.Addition$2:
    389:389:void <init>(neureka.backend.standard.operations.operator.Addition,neureka.backend.api.operations.OperationFactory) -> <init>
    392:392:java.lang.String stringify(java.lang.String[]) -> stringify
    397:397:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    402:402:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Addition$3 -> neureka.backend.standard.operations.operator.Addition$3:
    418:418:void <init>(neureka.backend.standard.operations.operator.Addition,neureka.backend.api.operations.OperationFactory) -> <init>
    421:428:java.lang.String stringify(java.lang.String[]) -> stringify
    433:433:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    438:438:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Addition$4 -> neureka.backend.standard.operations.operator.Addition$4:
    499:499:void <init>(neureka.backend.standard.operations.operator.Addition,neureka.backend.api.operations.OperationFactory) -> <init>
    502:502:java.lang.String stringify(java.lang.String[]) -> stringify
    507:507:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    512:512:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Addition$5 -> neureka.backend.standard.operations.operator.Addition$5:
    525:525:void <init>(neureka.backend.standard.operations.operator.Addition,neureka.backend.api.operations.OperationFactory) -> <init>
    528:528:java.lang.String stringify(java.lang.String[]) -> stringify
    533:533:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    538:538:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Division -> neureka.backend.standard.operations.operator.Division:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    66:617:void <init>() -> <init>
    625:632:java.lang.String stringify(java.lang.String[]) -> stringify
    637:637:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    641:659:java.lang.String _asDerivative(neureka.calculus.Function[],int,int) -> a
    665:683:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    689:710:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    543:545:neureka.backend.api.ExecutionCall lambda$new$54(neureka.backend.api.ExecutionCall) -> a
    540:540:neureka.Tsr lambda$new$53(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    539:539:neureka.Tsr lambda$new$52(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    519:535:neureka.autograd.ADAgent lambda$new$51(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    535:535:neureka.Tsr lambda$new$50(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    534:534:neureka.Tsr lambda$new$49(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    524:524:neureka.Tsr lambda$new$48(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    523:523:neureka.Tsr lambda$new$47(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    509:514:boolean lambda$new$46(neureka.backend.api.ExecutionCall) -> b
    506:506:boolean lambda$new$45(neureka.backend.api.ExecutionCall) -> c
    392:401:void lambda$new$44(neureka.backend.api.ExecutionCall) -> d
    367:385:void lambda$new$43(neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    379:382:void lambda$new$42(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> a
    373:376:void lambda$new$41(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> b
    357:357:neureka.Tsr lambda$new$40(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> b
    355:355:neureka.autograd.ADAgent lambda$new$39(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    352:352:boolean lambda$new$38(neureka.backend.api.ExecutionCall) -> e
    351:351:boolean lambda$new$37(neureka.backend.api.ExecutionCall) -> f
    340:346:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$36(neureka.Tsr[],double,int) -> a
    346:346:double lambda$new$35(double,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    345:345:double lambda$new$34(double,int[]) -> a
    343:343:double lambda$new$33(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    329:334:neureka.backend.api.operations.Operation$PrimaryNDIConsumer lambda$new$32(neureka.Tsr[],double,int) -> b
    334:334:double lambda$new$31(double,double[],neureka.ndim.iterators.NDIterator) -> a
    333:333:double lambda$new$30(double,neureka.ndim.iterators.NDIterator) -> a
    331:331:double lambda$new$29(double[],double,neureka.ndim.iterators.NDIterator) -> a
    301:310:void lambda$new$28(neureka.backend.api.ExecutionCall) -> g
    278:288:void lambda$new$27(neureka.backend.api.ExecutionCall) -> h
    289:292:void lambda$new$26(neureka.backend.api.ExecutionCall,int,int) -> a
    283:286:void lambda$new$25(neureka.backend.api.ExecutionCall,int,int) -> b
    250:265:neureka.autograd.ADAgent lambda$new$24(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    265:265:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    264:264:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    255:255:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    254:254:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    246:246:boolean lambda$new$19(neureka.backend.api.ExecutionCall) -> i
    245:245:boolean lambda$new$18(neureka.backend.api.ExecutionCall) -> j
    217:226:void lambda$new$17(neureka.backend.api.ExecutionCall) -> k
    187:200:void lambda$new$16(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    201:207:void lambda$new$15(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    192:198:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    175:175:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> d
    157:162:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$12(neureka.Tsr[],int) -> a
    163:166:double lambda$new$11(int,double[],neureka.Tsr[],double[],int[]) -> a
    160:160:double lambda$new$10(double[],neureka.Tsr[],double[],int[]) -> a
    140:145:neureka.backend.api.operations.Operation$SecondaryNDIConsumer lambda$new$9(neureka.Tsr[],int) -> b
    146:149:double lambda$new$8(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    143:143:double lambda$new$7(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    79:131:neureka.Tsr lambda$new$6(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    47:54:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$static$5(neureka.Tsr[],int) -> c
    55:58:double lambda$static$4(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    52:52:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    30:35:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> d
    36:39:double lambda$static$1(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    33:33:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    28:45:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.Division$1 -> neureka.backend.standard.operations.operator.Division$1:
    427:427:void <init>(neureka.backend.standard.operations.operator.Division,neureka.backend.api.operations.OperationFactory) -> <init>
    430:430:java.lang.String stringify(java.lang.String[]) -> stringify
    435:435:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    440:440:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Division$2 -> neureka.backend.standard.operations.operator.Division$2:
    453:453:void <init>(neureka.backend.standard.operations.operator.Division,neureka.backend.api.operations.OperationFactory) -> <init>
    456:456:java.lang.String stringify(java.lang.String[]) -> stringify
    461:461:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    466:466:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Division$3 -> neureka.backend.standard.operations.operator.Division$3:
    481:481:void <init>(neureka.backend.standard.operations.operator.Division,neureka.backend.api.operations.OperationFactory) -> <init>
    484:491:java.lang.String stringify(java.lang.String[]) -> stringify
    496:496:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    501:501:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Division$4 -> neureka.backend.standard.operations.operator.Division$4:
    560:560:void <init>(neureka.backend.standard.operations.operator.Division,neureka.backend.api.operations.OperationFactory) -> <init>
    563:570:java.lang.String stringify(java.lang.String[]) -> stringify
    575:575:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    580:580:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Division$5 -> neureka.backend.standard.operations.operator.Division$5:
    593:593:void <init>(neureka.backend.standard.operations.operator.Division,neureka.backend.api.operations.OperationFactory) -> <init>
    596:603:java.lang.String stringify(java.lang.String[]) -> stringify
    608:608:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    613:613:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Modulo -> neureka.backend.standard.operations.operator.Modulo:
    28:489:void <init>() -> <init>
    495:502:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    509:516:java.lang.String stringify(java.lang.String[]) -> stringify
    521:521:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    526:535:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    410:419:void lambda$new$46(neureka.backend.api.ExecutionCall) -> a
    385:403:void lambda$new$45(neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    397:400:void lambda$new$44(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> a
    391:394:void lambda$new$43(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> b
    376:376:neureka.Tsr lambda$new$42(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    375:375:neureka.Tsr lambda$new$41(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    373:373:neureka.autograd.ADAgent lambda$new$40(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    363:368:boolean lambda$new$39(neureka.backend.api.ExecutionCall) -> b
    360:360:boolean lambda$new$38(neureka.backend.api.ExecutionCall) -> c
    349:355:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$37(neureka.Tsr[],double,int) -> a
    355:355:double lambda$new$36(double,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    354:354:double lambda$new$35(double,int[]) -> a
    352:352:double lambda$new$34(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    338:343:neureka.backend.api.operations.Operation$PrimaryNDIConsumer lambda$new$33(neureka.Tsr[],double,int) -> b
    343:343:double lambda$new$32(double,double[],neureka.ndim.iterators.NDIterator) -> a
    342:342:double lambda$new$31(double,neureka.ndim.iterators.NDIterator) -> a
    340:340:double lambda$new$30(double[],double,neureka.ndim.iterators.NDIterator) -> a
    310:319:void lambda$new$29(neureka.backend.api.ExecutionCall) -> d
    286:296:void lambda$new$28(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    297:300:void lambda$new$27(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    291:294:void lambda$new$26(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    277:277:neureka.Tsr lambda$new$25(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    258:273:neureka.autograd.ADAgent lambda$new$24(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    273:273:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    272:272:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    263:263:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    262:262:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    247:252:boolean lambda$new$19(neureka.backend.api.ExecutionCall) -> e
    244:244:boolean lambda$new$18(neureka.backend.api.ExecutionCall) -> f
    226:233:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$17(neureka.Tsr[],int) -> a
    234:237:double lambda$new$16(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    231:231:double lambda$new$15(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    206:211:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$14(neureka.Tsr[],int) -> b
    212:218:double lambda$new$13(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    209:209:double lambda$new$12(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    176:185:void lambda$new$11(neureka.backend.api.ExecutionCall) -> g
    147:160:void lambda$new$10(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> b
    161:167:void lambda$new$9(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> c
    152:158:void lambda$new$8(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> d
    136:136:neureka.autograd.ADAgent lambda$new$7(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    117:123:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$6(neureka.Tsr[],int) -> c
    124:127:double lambda$new$5(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    121:121:double lambda$new$4(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    102:106:neureka.backend.api.operations.Operation$SecondaryNDIConsumer lambda$new$3(neureka.Tsr[],int) -> d
    107:110:double lambda$new$2(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    104:104:double lambda$new$1(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    41:93:neureka.Tsr lambda$new$0(neureka.backend.api.ExecutionCall,java.util.function.Function) -> c
neureka.backend.standard.operations.operator.Modulo$1 -> neureka.backend.standard.operations.operator.Modulo$1:
    447:447:void <init>(neureka.backend.standard.operations.operator.Modulo,neureka.backend.api.operations.OperationFactory) -> <init>
    450:450:java.lang.String stringify(java.lang.String[]) -> stringify
    455:455:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    460:460:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Modulo$2 -> neureka.backend.standard.operations.operator.Modulo$2:
    473:473:void <init>(neureka.backend.standard.operations.operator.Modulo,neureka.backend.api.operations.OperationFactory) -> <init>
    476:476:java.lang.String stringify(java.lang.String[]) -> stringify
    481:481:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    486:486:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Multiplication -> neureka.backend.standard.operations.operator.Multiplication:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    63:661:void <init>() -> <init>
    667:674:java.lang.String stringify(java.lang.String[]) -> stringify
    679:691:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    696:715:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    721:739:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    682:687:java.lang.String lambda$asDerivative$82(int,neureka.calculus.Function[],neureka.calculus.Function) -> a
    685:685:boolean lambda$asDerivative$81(neureka.calculus.Function,neureka.calculus.Function) -> a
    680:680:boolean lambda$asDerivative$80(int,neureka.calculus.Function) -> a
    643:652:void lambda$new$79(neureka.backend.api.ExecutionCall) -> a
    620:630:void lambda$new$78(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    631:634:void lambda$new$77(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    625:628:void lambda$new$76(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    583:585:neureka.backend.api.ExecutionCall lambda$new$75(neureka.backend.api.ExecutionCall) -> b
    580:580:neureka.Tsr lambda$new$74(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    579:579:neureka.Tsr lambda$new$73(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    560:575:neureka.autograd.ADAgent lambda$new$72(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    575:575:neureka.Tsr lambda$new$71(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    574:574:neureka.Tsr lambda$new$70(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    565:565:neureka.Tsr lambda$new$69(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    564:564:neureka.Tsr lambda$new$68(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    549:554:boolean lambda$new$67(neureka.backend.api.ExecutionCall) -> c
    546:546:boolean lambda$new$66(neureka.backend.api.ExecutionCall) -> d
    526:535:void lambda$new$65(neureka.backend.api.ExecutionCall) -> e
    503:513:void lambda$new$64(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> b
    514:517:void lambda$new$63(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> c
    508:511:void lambda$new$62(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> d
    466:468:neureka.backend.api.ExecutionCall lambda$new$61(neureka.backend.api.ExecutionCall) -> f
    463:463:neureka.Tsr lambda$new$60(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    462:462:neureka.Tsr lambda$new$59(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> b
    439:456:neureka.autograd.ADAgent lambda$new$58(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    457:457:neureka.Tsr lambda$new$57(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    455:455:neureka.Tsr lambda$new$56(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    443:443:neureka.Tsr lambda$new$55(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    429:434:boolean lambda$new$54(neureka.backend.api.ExecutionCall) -> g
    426:426:boolean lambda$new$53(neureka.backend.api.ExecutionCall) -> h
    418:422:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$new$52(neureka.Tsr[],int) -> a
    422:422:double lambda$new$51(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    411:413:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$50(neureka.Tsr[],int) -> b
    413:413:double lambda$new$49(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    383:392:void lambda$new$48(neureka.backend.api.ExecutionCall) -> i
    358:376:void lambda$new$47(neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    370:373:void lambda$new$46(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> a
    364:367:void lambda$new$45(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> b
    348:348:neureka.Tsr lambda$new$44(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> c
    323:344:neureka.autograd.ADAgent lambda$new$43(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    344:344:neureka.Tsr lambda$new$42(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    343:343:neureka.Tsr lambda$new$41(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    336:336:neureka.Tsr lambda$new$40(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    327:327:neureka.Tsr lambda$new$39(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    319:319:boolean lambda$new$38(neureka.backend.api.ExecutionCall) -> j
    318:318:boolean lambda$new$37(neureka.backend.api.ExecutionCall) -> k
    308:313:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$36(neureka.Tsr[],double,int) -> a
    313:313:double lambda$new$35(double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    312:312:double lambda$new$34(double,int[]) -> a
    310:310:double lambda$new$33(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    298:302:neureka.backend.api.operations.Operation$PrimaryNDIConsumer lambda$new$32(neureka.Tsr[],double,int) -> b
    302:302:double lambda$new$31(double[],neureka.ndim.iterators.NDIterator) -> a
    301:301:double lambda$new$30(double,neureka.ndim.iterators.NDIterator) -> a
    299:299:double lambda$new$29(double[],double,neureka.ndim.iterators.NDIterator) -> a
    271:280:void lambda$new$28(neureka.backend.api.ExecutionCall) -> l
    248:258:void lambda$new$27(neureka.backend.api.ExecutionCall) -> m
    259:262:void lambda$new$26(neureka.backend.api.ExecutionCall,int,int) -> a
    253:256:void lambda$new$25(neureka.backend.api.ExecutionCall,int,int) -> b
    221:236:neureka.autograd.ADAgent lambda$new$24(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> d
    236:236:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    235:235:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> m
    226:226:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> n
    225:225:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> o
    217:217:boolean lambda$new$19(neureka.backend.api.ExecutionCall) -> n
    216:216:boolean lambda$new$18(neureka.backend.api.ExecutionCall) -> o
    192:201:void lambda$new$17(neureka.backend.api.ExecutionCall) -> p
    163:176:void lambda$new$16(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> c
    177:183:void lambda$new$15(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> e
    168:174:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> f
    152:152:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> e
    133:142:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$12(neureka.Tsr[],int) -> c
    143:144:double lambda$new$11(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    140:140:double lambda$new$10(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    116:123:neureka.backend.api.operations.Operation$SecondaryNDIConsumer lambda$new$9(neureka.Tsr[],int) -> d
    124:125:double lambda$new$8(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    121:121:double lambda$new$7(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    76:107:neureka.Tsr lambda$new$6(neureka.backend.api.ExecutionCall,java.util.function.Function) -> c
    47:54:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$static$5(neureka.Tsr[],int) -> e
    55:56:double lambda$static$4(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    52:52:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> b
    33:38:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> f
    39:40:double lambda$static$1(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    36:36:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
    31:45:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.Multiplication$1 -> neureka.backend.standard.operations.operator.Multiplication$1:
    482:482:void <init>(neureka.backend.standard.operations.operator.Multiplication,neureka.backend.api.operations.OperationFactory) -> <init>
    485:485:java.lang.String stringify(java.lang.String[]) -> stringify
    490:490:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    495:495:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Multiplication$2 -> neureka.backend.standard.operations.operator.Multiplication$2:
    599:599:void <init>(neureka.backend.standard.operations.operator.Multiplication,neureka.backend.api.operations.OperationFactory) -> <init>
    602:602:java.lang.String stringify(java.lang.String[]) -> stringify
    607:607:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    612:612:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Power -> neureka.backend.standard.operations.operator.Power:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    77:639:void <init>() -> <init>
    655:660:java.lang.String stringify(java.lang.String[]) -> stringify
    665:675:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    680:702:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    708:733:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    668:668:java.lang.String lambda$asDerivative$55(neureka.calculus.Function[],int) -> a
    575:577:neureka.backend.api.ExecutionCall lambda$new$54(neureka.backend.api.ExecutionCall) -> a
    572:572:neureka.Tsr lambda$new$53(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    571:571:neureka.Tsr lambda$new$52(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    551:567:neureka.autograd.ADAgent lambda$new$51(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    567:567:neureka.Tsr lambda$new$50(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    566:566:neureka.Tsr lambda$new$49(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    556:556:neureka.Tsr lambda$new$48(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    555:555:neureka.Tsr lambda$new$47(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    541:546:boolean lambda$new$46(neureka.backend.api.ExecutionCall) -> b
    538:538:boolean lambda$new$45(neureka.backend.api.ExecutionCall) -> c
    420:429:void lambda$new$44(neureka.backend.api.ExecutionCall) -> d
    395:413:void lambda$new$43(neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    407:410:void lambda$new$42(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> a
    401:404:void lambda$new$41(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> b
    385:385:neureka.Tsr lambda$new$40(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> b
    383:383:neureka.autograd.ADAgent lambda$new$39(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    380:380:boolean lambda$new$38(neureka.backend.api.ExecutionCall) -> e
    379:379:boolean lambda$new$37(neureka.backend.api.ExecutionCall) -> f
    369:374:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$36(neureka.Tsr[],double,int) -> a
    374:374:double lambda$new$35(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    373:373:double lambda$new$34(double,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    371:371:double lambda$new$33(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> b
    359:363:neureka.backend.api.operations.Operation$PrimaryNDIConsumer lambda$new$32(neureka.Tsr[],double,int) -> b
    363:363:double lambda$new$31(double[],double,neureka.ndim.iterators.NDIterator) -> a
    362:362:double lambda$new$30(double,double[],neureka.ndim.iterators.NDIterator) -> a
    360:360:double lambda$new$29(double[],double,neureka.ndim.iterators.NDIterator) -> b
    331:340:void lambda$new$28(neureka.backend.api.ExecutionCall) -> g
    308:318:void lambda$new$27(neureka.backend.api.ExecutionCall) -> h
    319:322:void lambda$new$26(neureka.backend.api.ExecutionCall,int,int) -> a
    313:316:void lambda$new$25(neureka.backend.api.ExecutionCall,int,int) -> b
    280:295:neureka.autograd.ADAgent lambda$new$24(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    295:295:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    294:294:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    285:285:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    284:284:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    276:276:boolean lambda$new$19(neureka.backend.api.ExecutionCall) -> i
    275:275:boolean lambda$new$18(neureka.backend.api.ExecutionCall) -> j
    246:257:void lambda$new$17(neureka.backend.api.ExecutionCall) -> k
    216:229:void lambda$new$16(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    230:236:void lambda$new$15(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    221:227:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    206:206:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> d
    135:197:neureka.Tsr lambda$new$12(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    116:123:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$11(neureka.Tsr[],int) -> a
    125:128:double lambda$new$10(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int,int[]) -> a
    121:121:double lambda$new$9(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    93:98:neureka.backend.api.operations.Operation$SecondaryNDIConsumer lambda$new$8(neureka.Tsr[],int) -> b
    100:109:double lambda$new$7(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    96:96:double lambda$new$6(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    56:63:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$static$5(neureka.Tsr[],int) -> c
    64:69:double lambda$static$4(int,double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    61:61:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    33:37:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> d
    38:48:double lambda$static$1(int,double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    35:35:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    31:54:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.Power$1 -> neureka.backend.standard.operations.operator.Power$1:
    458:458:void <init>(neureka.backend.standard.operations.operator.Power,neureka.backend.api.operations.OperationFactory) -> <init>
    461:461:java.lang.String stringify(java.lang.String[]) -> stringify
    466:466:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    471:471:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Power$2 -> neureka.backend.standard.operations.operator.Power$2:
    485:485:void <init>(neureka.backend.standard.operations.operator.Power,neureka.backend.api.operations.OperationFactory) -> <init>
    488:488:java.lang.String stringify(java.lang.String[]) -> stringify
    493:493:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    498:498:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Power$3 -> neureka.backend.standard.operations.operator.Power$3:
    513:513:void <init>(neureka.backend.standard.operations.operator.Power,neureka.backend.api.operations.OperationFactory) -> <init>
    516:523:java.lang.String stringify(java.lang.String[]) -> stringify
    528:528:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    533:533:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Power$4 -> neureka.backend.standard.operations.operator.Power$4:
    592:592:void <init>(neureka.backend.standard.operations.operator.Power,neureka.backend.api.operations.OperationFactory) -> <init>
    595:595:java.lang.String stringify(java.lang.String[]) -> stringify
    600:600:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    605:605:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Power$5 -> neureka.backend.standard.operations.operator.Power$5:
    619:619:void <init>(neureka.backend.standard.operations.operator.Power,neureka.backend.api.operations.OperationFactory) -> <init>
    622:622:java.lang.String stringify(java.lang.String[]) -> stringify
    627:627:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    632:632:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Subtraction -> neureka.backend.standard.operations.operator.Subtraction:
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creator -> a
    neureka.backend.api.operations.Operation$DefaultOperatorCreator _creatorX -> b
    60:497:void <init>() -> <init>
    503:510:java.lang.String stringify(java.lang.String[]) -> stringify
    515:520:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    525:542:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    548:564:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    518:518:neureka.calculus.Function lambda$asDerivative$46(int,neureka.calculus.Function) -> a
    517:517:boolean lambda$asDerivative$45(int,neureka.calculus.Function) -> b
    335:344:void lambda$new$44(neureka.backend.api.ExecutionCall) -> a
    312:322:void lambda$new$43(neureka.backend.api.ExecutionCall) -> b
    323:326:void lambda$new$42(neureka.backend.api.ExecutionCall,int,int) -> a
    317:320:void lambda$new$41(neureka.backend.api.ExecutionCall,int,int) -> b
    283:298:neureka.autograd.ADAgent lambda$new$40(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    298:298:neureka.Tsr lambda$new$39(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    297:297:neureka.Tsr lambda$new$38(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    288:288:neureka.Tsr lambda$new$37(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    287:287:neureka.Tsr lambda$new$36(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    279:279:boolean lambda$new$35(neureka.backend.api.ExecutionCall) -> c
    278:278:boolean lambda$new$34(neureka.backend.api.ExecutionCall) -> d
    251:260:void lambda$new$33(neureka.backend.api.ExecutionCall) -> e
    225:244:void lambda$new$32(neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    238:241:void lambda$new$31(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> a
    232:235:void lambda$new$30(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> b
    215:215:neureka.Tsr lambda$new$29(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    213:213:neureka.autograd.ADAgent lambda$new$28(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    210:210:boolean lambda$new$27(neureka.backend.api.ExecutionCall) -> f
    209:209:boolean lambda$new$26(neureka.backend.api.ExecutionCall) -> g
    202:205:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$25(neureka.Tsr[],double,int) -> a
    205:205:double lambda$new$24(int[]) -> a
    205:205:double lambda$new$23(int[]) -> b
    204:204:double lambda$new$22(double[],neureka.ndim.config.NDConfiguration,double,int[]) -> a
    195:197:neureka.backend.api.operations.Operation$PrimaryNDIConsumer lambda$new$21(neureka.Tsr[],double,int) -> b
    197:197:double lambda$new$20(neureka.ndim.iterators.NDIterator) -> a
    197:197:double lambda$new$19(neureka.ndim.iterators.NDIterator) -> b
    196:196:double lambda$new$18(double[],double,neureka.ndim.iterators.NDIterator) -> a
    167:176:void lambda$new$17(neureka.backend.api.ExecutionCall) -> h
    138:151:void lambda$new$16(neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.operations.Operation$DefaultOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    152:158:void lambda$new$15(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> a
    143:149:void lambda$new$14(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$DefaultOperatorCreator,int,int) -> b
    127:127:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> c
    115:121:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$12(neureka.Tsr[],int) -> a
    121:121:double lambda$new$11(int,int[]) -> a
    120:120:double lambda$new$10(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[]) -> a
    107:111:neureka.backend.api.operations.Operation$SecondaryNDIConsumer lambda$new$9(neureka.Tsr[],int) -> b
    111:111:double lambda$new$8(int,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    110:110:double lambda$new$7(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    74:98:neureka.Tsr lambda$new$6(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    44:51:neureka.backend.api.operations.Operation$TertiaryNDXConsumer lambda$static$5(neureka.Tsr[],int) -> c
    52:53:double lambda$static$4(int,int[],int[],int[]) -> a
    49:49:double lambda$static$3(double[],neureka.ndim.config.NDConfiguration,double[],neureka.ndim.config.NDConfiguration,int[],int[],int[]) -> a
    30:35:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$static$2(neureka.Tsr[],int) -> d
    36:37:double lambda$static$1(int,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    33:33:double lambda$static$0(double[],double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    28:42:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.Subtraction$1 -> neureka.backend.standard.operations.operator.Subtraction$1:
    366:366:void <init>(neureka.backend.standard.operations.operator.Subtraction,neureka.backend.api.operations.OperationFactory) -> <init>
    369:369:java.lang.String stringify(java.lang.String[]) -> stringify
    374:374:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    379:379:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Subtraction$2 -> neureka.backend.standard.operations.operator.Subtraction$2:
    392:392:void <init>(neureka.backend.standard.operations.operator.Subtraction,neureka.backend.api.operations.OperationFactory) -> <init>
    395:395:java.lang.String stringify(java.lang.String[]) -> stringify
    400:400:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    405:405:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Subtraction$3 -> neureka.backend.standard.operations.operator.Subtraction$3:
    420:420:void <init>(neureka.backend.standard.operations.operator.Subtraction,neureka.backend.api.operations.OperationFactory) -> <init>
    423:430:java.lang.String stringify(java.lang.String[]) -> stringify
    435:435:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    440:440:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Subtraction$4 -> neureka.backend.standard.operations.operator.Subtraction$4:
    453:453:void <init>(neureka.backend.standard.operations.operator.Subtraction,neureka.backend.api.operations.OperationFactory) -> <init>
    456:456:java.lang.String stringify(java.lang.String[]) -> stringify
    461:461:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    466:466:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.operator.Subtraction$5 -> neureka.backend.standard.operations.operator.Subtraction$5:
    479:479:void <init>(neureka.backend.standard.operations.operator.Subtraction,neureka.backend.api.operations.OperationFactory) -> <init>
    482:482:java.lang.String stringify(java.lang.String[]) -> stringify
    487:487:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    492:492:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.other.CopyLeft -> neureka.backend.standard.operations.other.CopyLeft:
    21:182:void <init>() -> <init>
    187:192:java.lang.String stringify(java.lang.String[]) -> stringify
    197:197:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    202:202:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    172:177:void lambda$new$22(neureka.backend.api.ExecutionCall) -> a
    159:164:void lambda$new$21(neureka.backend.api.ExecutionCall) -> b
    143:146:neureka.backend.api.ExecutionCall lambda$new$20(neureka.backend.api.ExecutionCall) -> c
    139:139:neureka.Tsr lambda$new$19(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    138:138:neureka.Tsr lambda$new$18(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    136:136:neureka.autograd.ADAgent lambda$new$17(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    133:133:boolean lambda$new$16(neureka.backend.api.ExecutionCall) -> d
    132:132:boolean lambda$new$15(neureka.backend.api.ExecutionCall) -> e
    112:121:void lambda$new$14(neureka.backend.api.ExecutionCall) -> f
    87:105:void lambda$new$13(neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    99:102:void lambda$new$12(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> a
    93:96:void lambda$new$11(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,double,int,int) -> b
    75:77:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$10(neureka.Tsr[],double,int) -> a
    76:76:double lambda$new$9(double[],neureka.Tsr[],double,int[]) -> a
    68:70:neureka.backend.api.operations.Operation$PrimaryNDIConsumer lambda$new$8(neureka.Tsr[],double,int) -> b
    69:69:double lambda$new$7(double[],double,neureka.ndim.iterators.NDIterator) -> a
    52:57:neureka.backend.api.ExecutionCall lambda$new$6(neureka.backend.api.ExecutionCall) -> g
    48:48:neureka.Tsr lambda$new$5(neureka.backend.api.ExecutionCall,java.util.function.Function) -> b
    47:47:neureka.Tsr lambda$new$4(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> b
    45:45:neureka.autograd.ADAgent lambda$new$3(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    42:42:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> h
    41:41:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> i
    36:38:float lambda$new$0(neureka.backend.api.ExecutionCall) -> j
neureka.backend.standard.operations.other.CopyRight -> neureka.backend.standard.operations.other.CopyRight:
    22:98:void <init>() -> <init>
    102:109:java.lang.String stringify(java.lang.String[]) -> stringify
    114:114:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    119:119:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    82:93:void lambda$new$10(neureka.backend.api.ExecutionCall) -> a
    64:75:void lambda$new$9(neureka.backend.api.ExecutionCall) -> b
    52:54:neureka.backend.api.ExecutionCall lambda$new$8(neureka.backend.api.ExecutionCall) -> c
    49:49:neureka.Tsr lambda$new$7(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    48:48:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    46:46:neureka.autograd.ADAgent lambda$new$5(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    43:43:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> d
    42:42:boolean lambda$new$3(neureka.backend.api.ExecutionCall) -> e
    35:37:neureka.backend.api.operations.Operation$TertiaryNDIConsumer lambda$new$2(neureka.Tsr[],int) -> a
    37:37:double lambda$new$1(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> a
    36:36:double lambda$new$0(double[],neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator,neureka.ndim.iterators.NDIterator) -> b
neureka.backend.standard.operations.other.DimFit -> neureka.backend.standard.operations.other.DimFit:
    boolean $assertionsDisabled -> a
    20:120:void <init>() -> <init>
    125:129:java.lang.String stringify(java.lang.String[]) -> stringify
    134:134:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    139:139:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    113:113:neureka.backend.api.ExecutionCall lambda$new$6(neureka.backend.api.ExecutionCall) -> a
    112:112:neureka.Tsr lambda$new$5(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    55:97:neureka.Tsr lambda$new$4(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    41:47:neureka.autograd.ADAgent lambda$new$3(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    34:34:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    33:33:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    32:32:float lambda$new$0(neureka.backend.api.ExecutionCall) -> d
    15:15:void <clinit>() -> <clinit>
neureka.backend.standard.operations.other.DimTrim -> neureka.backend.standard.operations.other.DimTrim:
    boolean $assertionsDisabled -> a
    22:77:void <init>() -> <init>
    80:119:neureka.Tsr pad(neureka.Tsr,int[],boolean) -> pad
    124:153:neureka.Tsr trim(neureka.Tsr,int[],boolean) -> trim
    159:163:java.lang.String stringify(java.lang.String[]) -> stringify
    168:168:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    173:173:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    148:148:int lambda$trim$18(java.lang.Integer) -> a
    147:147:int lambda$trim$17(java.lang.Integer) -> b
    146:146:int lambda$trim$16(java.lang.Integer) -> c
    145:145:int lambda$trim$15(java.lang.Integer) -> d
    144:144:int lambda$trim$14(java.lang.Integer) -> e
    116:116:int lambda$pad$13(java.lang.Integer) -> f
    115:115:int lambda$pad$12(java.lang.Integer) -> g
    114:114:int lambda$pad$11(java.lang.Integer) -> h
    113:113:int lambda$pad$10(java.lang.Integer) -> i
    112:112:int lambda$pad$9(java.lang.Integer) -> j
    69:69:neureka.backend.api.ExecutionCall lambda$new$8(neureka.backend.api.ExecutionCall) -> a
    68:68:neureka.Tsr lambda$new$7(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    54:64:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    40:48:neureka.autograd.ADAgent lambda$new$5(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    48:48:neureka.Tsr lambda$new$4(int,int,neureka.autograd.GraphNode,neureka.Tsr) -> a
    47:47:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    36:36:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    35:35:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    34:34:float lambda$new$0(neureka.backend.api.ExecutionCall) -> d
    17:17:void <clinit>() -> <clinit>
neureka.backend.standard.operations.other.Randomization -> neureka.backend.standard.operations.other.Randomization:
    24:122:void <init>() -> <init>
    126:130:java.lang.String stringify(java.lang.String[]) -> stringify
    135:135:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    140:140:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    92:106:void lambda$new$12(neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.operations.Operation$ScalarOperatorCreator,neureka.backend.api.ExecutionCall) -> a
    107:113:void lambda$new$11(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,int,int) -> a
    97:103:void lambda$new$10(neureka.backend.api.ExecutionCall,neureka.backend.api.operations.Operation$ScalarOperatorCreator,int,int) -> b
    80:82:neureka.backend.api.ExecutionCall lambda$new$9(neureka.backend.api.ExecutionCall) -> a
    77:77:neureka.Tsr lambda$new$8(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    76:76:neureka.Tsr lambda$new$7(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    74:74:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    62:69:boolean lambda$new$5(neureka.backend.api.ExecutionCall) -> b
    59:59:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> c
    49:49:neureka.backend.api.operations.Operation$PrimaryNDXConsumer lambda$new$3(neureka.Tsr[],double,int) -> a
    50:54:double lambda$new$2(double,int[]) -> a
    37:37:neureka.backend.api.operations.Operation$PrimaryNDIConsumer lambda$new$1(neureka.Tsr[],double,int) -> b
    38:43:double lambda$new$0(double,neureka.ndim.iterators.NDIterator) -> a
neureka.backend.standard.operations.other.Reshape -> neureka.backend.standard.operations.other.Reshape:
    24:74:void <init>() -> <init>
    79:88:neureka.Tsr reshaped(neureka.Tsr,int[],boolean) -> reshaped
    93:107:int[] invert(int[]) -> invert
    112:140:java.lang.String stringify(java.lang.String[]) -> stringify
    145:145:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    151:151:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    116:118:java.lang.Boolean lambda$stringify$9(java.lang.String) -> a
    66:66:neureka.backend.api.ExecutionCall lambda$new$8(neureka.backend.api.ExecutionCall) -> a
    65:65:neureka.Tsr lambda$new$7(neureka.backend.api.ExecutionCall,java.util.function.Function) -> a
    53:62:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    43:48:neureka.autograd.ADAgent lambda$new$5(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    48:48:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    47:47:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    38:38:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    37:37:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    36:36:float lambda$new$0(neureka.backend.api.ExecutionCall) -> d
neureka.calculus.AbstractBaseFunction -> neureka.calculus.AbstractBaseFunction:
    46:46:void <init>() -> <init>
    51:51:double call(double) -> call
    56:56:neureka.Tsr call(neureka.Tsr) -> call
    63:63:neureka.Tsr call(java.util.List) -> call
    68:68:neureka.Tsr invoke(java.util.List) -> invoke
    75:75:double invoke(double) -> invoke
    80:80:double invoke(double[],int) -> invoke
    85:85:double invoke(double[]) -> invoke
    92:92:neureka.Tsr invoke(neureka.Tsr) -> invoke
    97:97:neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    102:102:neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    109:109:neureka.Tsr derive(java.util.List,int,int) -> derive
    114:114:neureka.Tsr derive(java.util.List,int) -> derive
neureka.calculus.Cache -> neureka.calculus.Cache:
    neureka.calculus.Cache _cache -> a
    org.slf4j.Logger _log -> b
    java.util.Map FUNCTIONS -> c
    java.util.Map PROCESSING -> d
    41:60:void <init>() -> <init>
    49:51:neureka.calculus.Cache instance() -> instance
    57:57:java.util.Map FUNCTIONS() -> FUNCTIONS
    64:66:void free(neureka.autograd.GraphLock) -> free
    74:105:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier,int,int) -> preprocess
    110:118:neureka.Tsr _get(neureka.Tsr[],int,int) -> a
    123:139:void _put(neureka.Tsr,neureka.autograd.GraphNode,int,int) -> a
    143:149:long _keyOf(neureka.Tsr[],int,int) -> b
    153:153:int _keyed(int) -> a
    134:134:int lambda$_put$2(java.lang.Long,java.lang.Long) -> a
    93:93:java.lang.Object lambda$preprocess$1(neureka.Tsr) -> a
    60:60:int lambda$new$0(neureka.autograd.GraphLock,neureka.autograd.GraphLock) -> a
    40:40:void <clinit>() -> <clinit>
neureka.calculus.Function -> neureka.calculus.Function:
    neureka.calculus.Cache CACHE -> CACHE
    neureka.calculus.Function DIMTRIM -> DIMTRIM
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    114:114:neureka.calculus.Function create(java.lang.String) -> create
    118:118:neureka.calculus.Function create(java.lang.String,boolean) -> create
    neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    boolean isDoingAD() -> isDoingAD
    boolean isFlat() -> isFlat
    neureka.backend.api.operations.Operation getOperation() -> getOperation
    boolean dependsOn(int) -> dependsOn
    neureka.calculus.Function getDerivative(int) -> getDerivative
    double call(double) -> call
    double invoke(double) -> invoke
    double call(double[],int) -> call
    double invoke(double[],int) -> invoke
    double call(double[]) -> call
    double invoke(double[]) -> invoke
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    neureka.Tsr call(neureka.Tsr) -> call
    neureka.Tsr invoke(neureka.Tsr) -> invoke
    neureka.Tsr call(java.util.List) -> call
    neureka.Tsr invoke(java.util.List) -> invoke
    neureka.Tsr call(neureka.Tsr[],int) -> call
    neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    neureka.Tsr call(neureka.Tsr[]) -> call
    neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    neureka.Tsr derive(neureka.Tsr[],int) -> derive
    neureka.Tsr derive(java.util.List,int,int) -> derive
    neureka.Tsr derive(java.util.List,int) -> derive
    java.lang.String toString() -> toString
    64:83:void <clinit>() -> <clinit>
neureka.calculus.Function$Detached -> neureka.calculus.Function$Detached:
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function ADD -> ADD
    neureka.calculus.Function ADD_ASSIGN -> ADD_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    91:91:void <init>() -> <init>
    93:110:void <clinit>() -> <clinit>
neureka.calculus.Function$Setup -> neureka.calculus.Function$Setup:
    125:125:void <init>() -> <init>
    129:129:neureka.Tsr commit(neureka.Tsr[],java.lang.String,boolean) -> commit
    134:134:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],java.lang.String,boolean) -> commit
    139:139:neureka.Tsr commit(neureka.Tsr[],neureka.calculus.Function) -> commit
    144:144:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function) -> commit
    149:172:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier) -> commit
    154:154:java.lang.Object lambda$commit$0(neureka.Tsr) -> a
neureka.calculus.assembly.FunctionBuilder -> neureka.calculus.assembly.FunctionBuilder:
    boolean $assertionsDisabled -> a
    14:14:void <init>() -> <init>
    23:39:neureka.calculus.Function build(neureka.backend.api.operations.Operation,int,boolean) -> build
    50:66:neureka.calculus.Function build(java.lang.String,boolean) -> build
    76:286:neureka.calculus.Function _build(java.lang.String,boolean) -> a
    296:303:java.util.List _rebindPairwise(java.util.List,int) -> a
    14:14:void <clinit>() -> <clinit>
neureka.calculus.assembly.FunctionParser -> neureka.calculus.assembly.FunctionParser:
    boolean $assertionsDisabled -> a
    15:15:void <init>() -> <init>
    19:23:int numberOfOperationsWithin(java.util.List) -> numberOfOperationsWithin
    28:36:java.lang.String parsedOperation(java.lang.String,int) -> parsedOperation
    41:74:java.lang.String findComponentIn(java.lang.String,int) -> findComponentIn
    79:102:java.util.List findParametersIn(java.lang.String,int) -> findParametersIn
    107:108:boolean isAnyOperation(java.lang.String) -> isAnyOperation
    113:120:java.lang.String groupBy(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> groupBy
    124:124:boolean isForbiddenChar(char) -> a
    130:165:java.lang.String cleanedHeadAndTail(java.lang.String) -> cleanedHeadAndTail
    170:223:java.lang.String unpackAndCorrect(java.lang.String) -> unpackAndCorrect
    228:238:java.lang.String assumptionBasedOn(java.lang.String) -> assumptionBasedOn
    243:275:double similarity(java.lang.String,java.lang.String) -> similarity
    15:15:void <clinit>() -> <clinit>
neureka.calculus.implementations.FunctionConstant -> neureka.calculus.implementations.FunctionConstant:
    double _value -> a
    8:8:void <init>() -> <init>
    12:12:double value() -> value
    19:19:boolean isFlat() -> isFlat
    24:24:boolean isDoingAD() -> isDoingAD
    29:29:neureka.backend.api.operations.AbstractOperation getOperation() -> getOperation
    34:34:boolean dependsOn(int) -> dependsOn
    39:39:neureka.calculus.Function getDerivative(int) -> getDerivative
    45:58:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    65:65:double call(double[],int) -> call
    70:70:double call(double[]) -> call
    75:75:double derive(double[],int) -> derive
    80:80:double derive(double[],int,int) -> derive
    87:87:neureka.Tsr call(neureka.Tsr[],int) -> call
    92:92:neureka.Tsr call(neureka.Tsr[]) -> call
    97:97:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    102:102:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    109:109:java.lang.String toString() -> toString
    8:8:neureka.backend.api.operations.Operation getOperation() -> getOperation
neureka.calculus.implementations.FunctionInput -> neureka.calculus.implementations.FunctionInput:
    int _index -> a
    10:10:void <init>() -> <init>
    17:17:boolean providesGradient() -> providesGradient
    24:24:boolean isFlat() -> isFlat
    29:29:boolean isDoingAD() -> isDoingAD
    34:34:neureka.backend.api.operations.AbstractOperation getOperation() -> getOperation
    39:39:boolean dependsOn(int) -> dependsOn
    44:44:neureka.calculus.Function getDerivative(int) -> getDerivative
    52:72:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    77:87:neureka.Tsr _extract(neureka.Tsr) -> a
    94:94:double call(double[],int) -> call
    99:99:double call(double[]) -> call
    104:104:double derive(double[],int) -> derive
    109:109:double derive(double[],int,int) -> derive
    116:116:neureka.Tsr call(neureka.Tsr[],int) -> call
    121:121:neureka.Tsr call(neureka.Tsr[]) -> call
    126:126:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    131:133:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    140:140:java.lang.String toString() -> toString
    144:144:int index() -> index
    10:10:neureka.backend.api.operations.Operation getOperation() -> getOperation
neureka.calculus.implementations.FunctionNode -> neureka.calculus.implementations.FunctionNode:
    neureka.backend.api.operations.Operation _operation -> a
    boolean _isFlat -> b
    boolean _isDoingAD -> c
    neureka.calculus.Function[] _src -> d
    46:66:void <init>(neureka.backend.api.operations.Operation,java.util.List,boolean) -> <init>
    72:72:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    80:84:java.lang.String toString() -> toString
    90:91:boolean dependsOn(int) -> dependsOn
    96:96:neureka.calculus.Function getDerivative(int) -> getDerivative
    111:134:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int) -> _tensor_activation
    1335:1339:neureka.devices.Device _deviceFor(neureka.Tsr[]):335:339 -> _tensor_activation
    1335:1339:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):112 -> _tensor_activation
    140:144:neureka.Tsr __flat_execution(neureka.backend.api.ExecutionCall) -> a
    149:178:neureka.Tsr __deep_activation(neureka.backend.api.ExecutionCall) -> b
    212:300:neureka.Tsr _deep_derivative(neureka.backend.api.ExecutionCall) -> c
    305:330:neureka.Tsr[] srcActivation(neureka.Tsr[],int,int,int) -> srcActivation
    344:356:boolean _shareGuestDevice(neureka.Tsr[]) -> a
    363:363:neureka.Tsr call(neureka.Tsr[],int) -> call
    368:368:neureka.Tsr call(neureka.Tsr[]) -> call
    373:373:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    378:378:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    385:385:double call(double[],int) -> call
    390:390:double call(double[]) -> call
    395:395:double derive(double[],int,int) -> derive
    400:400:double derive(double[],int) -> derive
    28:28:neureka.backend.api.operations.Operation getOperation() -> getOperation
    30:30:boolean isFlat() -> isFlat
    32:32:boolean isDoingAD() -> isDoingAD
    378:378:neureka.Tsr lambda$derive$7(neureka.Tsr[],int) -> a
    373:373:neureka.Tsr lambda$derive$6(neureka.Tsr[],int,int) -> a
    368:368:neureka.Tsr lambda$call$5(neureka.Tsr[]) -> b
    363:363:neureka.Tsr lambda$call$4(neureka.Tsr[],int) -> b
    215:279:neureka.Tsr lambda$_deep_derivative$3(neureka.backend.api.ExecutionCall) -> d
    2193:2207:int ___indexOfFoundDerivative(neureka.Tsr[]):193:207 -> d
    2193:2207:neureka.Tsr lambda$_deep_derivative$3(neureka.backend.api.ExecutionCall):243 -> d
    168:168:java.lang.String lambda$__deep_activation$2(int) -> a
    129:129:java.lang.Object lambda$_tensor_activation$1(neureka.backend.api.ExecutionCall) -> e
    82:82:java.lang.String lambda$toString$0(neureka.calculus.Function) -> a
neureka.calculus.implementations.FunctionVariable -> neureka.calculus.implementations.FunctionVariable:
    boolean _providesGradient -> a
    9:11:void <init>() -> <init>
    14:14:boolean providesGradient() -> providesGradient
    19:19:boolean isFlat() -> isFlat
    24:24:boolean isDoingAD() -> isDoingAD
    29:29:neureka.backend.api.operations.AbstractOperation getOperation() -> getOperation
    34:34:boolean dependsOn(int) -> dependsOn
    39:39:neureka.calculus.Function getDerivative(int) -> getDerivative
    46:47:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    54:54:double call(double[],int) -> call
    59:61:double call(double[]) -> call
    66:66:double derive(double[],int) -> derive
    71:72:double derive(double[],int,int) -> derive
    78:78:neureka.Tsr call(neureka.Tsr[],int) -> call
    83:85:neureka.Tsr call(neureka.Tsr[]) -> call
    90:90:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    95:95:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    102:102:java.lang.String toString() -> toString
    9:9:neureka.backend.api.operations.Operation getOperation() -> getOperation
neureka.devices.AbstractBaseDevice -> neureka.devices.AbstractBaseDevice:
    48:48:void <init>() -> <init>
    53:55:int size() -> size
    60:60:boolean isEmpty() -> isEmpty
    65:65:boolean contains(neureka.Tsr) -> contains
    71:71:java.util.Iterator iterator() -> iterator
    76:76:java.lang.Object[] toArray(java.util.function.IntFunction) -> toArray
    81:81:java.util.Spliterator spliterator() -> spliterator
neureka.devices.AbstractDevice -> neureka.devices.AbstractDevice:
    neureka.utility.NeurekaCleaner _CLEANER -> a
    org.slf4j.Logger _log -> _log
    66:68:void <init>() -> <init>
    void _execute(neureka.Tsr[],int,neureka.backend.api.operations.Operation) -> _execute
    86:87:void update(neureka.Tsr,neureka.Tsr) -> update
    91:92:neureka.devices.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    96:97:void _cleaning(java.lang.Object,java.lang.Runnable) -> _cleaning
    102:114:neureka.devices.Device execute(neureka.backend.api.ExecutionCall) -> execute
    60:60:void update(java.lang.Object,java.lang.Object) -> update
    112:112:void lambda$execute$0(neureka.backend.api.ExecutionCall) -> a
    62:62:void <clinit>() -> <clinit>
neureka.devices.Device -> neureka.devices.Device:
    76:107:neureka.devices.Device find(java.lang.String) -> find
    void dispose() -> dispose
    neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    boolean has(neureka.Tsr) -> has
    neureka.devices.Device free(neureka.Tsr) -> free
    neureka.devices.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    neureka.devices.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    neureka.devices.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    neureka.devices.Device execute(neureka.backend.api.ExecutionCall) -> execute
    java.lang.Object valueFor(neureka.Tsr) -> valueFor
    java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    java.util.Collection getTensors() -> getTensors
    java.lang.Object[] toArray(java.util.function.IntFunction) -> toArray
neureka.devices.Storage -> neureka.devices.Storage:
    neureka.devices.Storage store(neureka.Tsr) -> store
    neureka.devices.Storage restore(neureka.Tsr) -> restore
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(neureka.Tsr) -> contains
neureka.devices.file.FileDevice -> neureka.devices.file.FileDevice:
    java.util.Map _DEVICES -> a
    java.util.Map _stored -> b
    java.lang.String _directory -> c
    java.util.List _loadable -> d
    java.util.List _loaded -> e
    boolean $assertionsDisabled -> f
    54:58:neureka.devices.file.FileDevice instance(java.lang.String) -> instance
    44:77:void <init>(java.lang.String) -> <init>
    80:80:neureka.Tsr load(java.lang.String) -> load
    84:94:neureka.Tsr load(java.lang.String,java.util.Map) -> load
    98:98:neureka.devices.file.FileHead fileHeadOf(neureka.Tsr) -> fileHeadOf
    103:105:void dispose() -> dispose
    109:117:neureka.devices.Device restore(neureka.Tsr) -> restore
    123:138:neureka.devices.Device store(neureka.Tsr) -> store
    143:143:neureka.devices.file.FileDevice store(neureka.Tsr,java.lang.String) -> store
    148:161:neureka.devices.file.FileDevice store(neureka.Tsr,java.lang.String,java.util.Map) -> store
    166:166:neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    171:171:boolean has(neureka.Tsr) -> has
    177:186:neureka.devices.Device free(neureka.Tsr) -> free
    191:191:neureka.devices.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    196:196:neureka.devices.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    201:201:neureka.devices.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    206:206:neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    211:211:neureka.devices.Device execute(neureka.backend.api.ExecutionCall) -> execute
    216:216:java.lang.Object valueFor(neureka.Tsr) -> valueFor
    221:221:java.lang.Number valueFor(neureka.Tsr,int) -> valueFor
    226:226:java.util.Collection getTensors() -> getTensors
    231:236:void update(neureka.Tsr,neureka.Tsr) -> update
    39:39:java.lang.String toString() -> toString
    46:46:java.lang.String getDirectory() -> getDirectory
    48:48:java.util.List getLoadable() -> getLoadable
    50:50:java.util.List getLoaded() -> getLoaded
    38:38:java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    38:38:void update(java.lang.Object,java.lang.Object) -> update
    38:38:neureka.devices.Storage restore(neureka.Tsr) -> restore
    38:38:neureka.devices.Storage store(neureka.Tsr) -> store
    38:42:void <clinit>() -> <clinit>
neureka.devices.file.FileHead -> neureka.devices.file.FileHead:
    neureka.devices.file.heads.util.HeadFactory FACTORY -> FACTORY
    neureka.Tsr load() -> load
    java.lang.Object free() -> free
    int getValueSize() -> getValueSize
    int getDataSize() -> getDataSize
    int getTotalSize() -> getTotalSize
    java.lang.String getLocation() -> getLocation
    java.lang.String getFileName() -> getFileName
    neureka.dtype.DataType getDataType() -> getDataType
    int[] getShape() -> getShape
    java.lang.String extension() -> extension
    14:14:void <clinit>() -> <clinit>
neureka.devices.file.heads.AbstractFileHead -> neureka.devices.file.heads.AbstractFileHead:
    org.slf4j.Logger _LOG -> _LOG
    java.lang.String _fileName -> _fileName
    int _size -> _size
    19:42:void <init>(java.lang.String) -> <init>
    45:45:int size() -> size
    49:49:boolean isEmpty() -> isEmpty
    53:53:boolean contains(neureka.Tsr) -> contains
    java.lang.Object _loadData() -> _loadData
    61:68:java.io.File _loadFile() -> _loadFile
    73:85:java.io.FileInputStream _loadFileInputStream() -> _loadFileInputStream
    91:97:java.lang.Object free() -> free
    102:102:java.lang.String getLocation() -> getLocation
    107:108:java.lang.String getFileName() -> getFileName
    114:120:neureka.devices.Storage restore(neureka.Tsr) -> restore
neureka.devices.file.heads.CSVHead -> neureka.devices.file.heads.CSVHead:
    java.lang.String _tensorName -> a
    java.lang.String _delimiter -> b
    boolean _firstRowIsLabels -> c
    java.lang.String[] _colLabels -> d
    boolean _firstColIsIndex -> e
    java.lang.String[] _rowLabels -> f
    java.lang.Integer _numberOfRows -> g
    java.lang.Integer _numberOfColumns -> h
    java.lang.Integer _numberOfBytes -> i
    java.lang.ref.WeakReference _rawData -> j
    boolean $assertionsDisabled -> k
    33:81:void <init>(neureka.Tsr,java.lang.String) -> <init>
    33:97:void <init>(java.lang.String,java.util.Map) -> <init>
    100:172:java.lang.String[] _lazyLoad() -> a
    176:179:void _parseTensorNameFromFileName() -> b
    183:183:neureka.devices.Storage store(neureka.Tsr) -> store
    188:188:java.lang.Object _loadData() -> _loadData
    193:223:neureka.Tsr load() -> load
    227:228:java.lang.String getTensorName() -> getTensorName
    234:236:int getValueSize() -> getValueSize
    241:243:int getDataSize() -> getDataSize
    248:248:int getTotalSize() -> getTotalSize
    253:253:neureka.dtype.DataType getDataType() -> getDataType
    258:258:int[] getShape() -> getShape
    263:263:java.lang.String extension() -> extension
    27:27:java.lang.String getDelimiter() -> getDelimiter
    28:28:boolean isFirstRowIsLabels() -> isFirstRowIsLabels
    29:29:java.lang.String[] getColLabels() -> getColLabels
    30:30:boolean isFirstColIsIndex() -> isFirstColIsIndex
    31:31:java.lang.String[] getRowLabels() -> getRowLabels
    33:33:java.lang.Integer getNumberOfRows() -> getNumberOfRows
    34:34:java.lang.Integer getNumberOfColumns() -> getNumberOfColumns
    19:24:void <clinit>() -> <clinit>
neureka.devices.file.heads.IDXHead -> neureka.devices.file.heads.IDXHead:
    neureka.dtype.DataType _dataType -> a
    int _dataOffset -> b
    int _valueSize -> c
    int[] _shape -> d
    java.util.Map TYPE_MAP -> e
    java.util.Map CODE_MAP -> f
    boolean $assertionsDisabled -> g
    58:65:void <init>(java.lang.String) -> <init>
    1077:1100:void _loadHead():77:100 -> <init>
    1077:1100:void <init>(java.lang.String):60 -> <init>
    68:73:void <init>(neureka.Tsr,java.lang.String) -> <init>
    106:151:neureka.devices.file.heads.IDXHead store(neureka.Tsr) -> store
    156:169:java.lang.Object _loadData() -> _loadData
    175:179:neureka.Tsr load() -> load
    184:187:int getDataSize() -> getDataSize
    192:192:int getTotalSize() -> getTotalSize
    197:197:java.lang.String extension() -> extension
    27:27:neureka.dtype.DataType getDataType() -> getDataType
    30:30:int getValueSize() -> getValueSize
    32:32:int[] getShape() -> getShape
    21:21:neureka.devices.Storage store(neureka.Tsr) -> store
    21:50:void <clinit>() -> <clinit>
neureka.devices.file.heads.JPEGHead -> neureka.devices.file.heads.JPEGHead:
    int _width -> a
    int _height -> b
    boolean $assertionsDisabled -> c
    31:37:void <init>(java.lang.String) -> <init>
    1052:1082:void _loadHead():52:82 -> <init>
    1052:1082:void <init>(java.lang.String):33 -> <init>
    40:47:void <init>(neureka.Tsr,java.lang.String) -> <init>
    86:88:neureka.Tsr load() -> load
    94:114:java.lang.Object _loadData() -> _loadData
    120:120:int getValueSize() -> getValueSize
    125:125:int getDataSize() -> getDataSize
    130:130:int getTotalSize() -> getTotalSize
    135:135:neureka.dtype.DataType getDataType() -> getDataType
    140:140:int[] getShape() -> getShape
    145:145:java.lang.String extension() -> extension
    151:167:neureka.devices.Storage store(neureka.Tsr) -> store
    106:107:void lambda$_loadData$0(short[],neureka.dtype.custom.UI8,byte[],int,int) -> a
    19:23:void <clinit>() -> <clinit>
neureka.devices.file.heads.util.HeadFactory -> neureka.devices.file.heads.util.HeadFactory:
    java.util.Map _LOADERS -> a
    java.util.Map _SAVERS -> b
    28:41:void <init>() -> <init>
    44:44:boolean hasLoader(java.lang.String) -> hasLoader
    48:48:boolean hasSaver(java.lang.String) -> hasSaver
    52:52:neureka.devices.file.heads.util.HeadFactory$Loader getLoader(java.lang.String) -> getLoader
    56:56:neureka.devices.file.heads.util.HeadFactory$Saver getSaver(java.lang.String) -> getSaver
    40:40:neureka.devices.file.FileHead lambda$new$7(java.lang.String,neureka.Tsr,java.util.Map) -> a
    39:39:neureka.devices.file.FileHead lambda$new$6(java.lang.String,neureka.Tsr,java.util.Map) -> b
    38:38:neureka.devices.file.FileHead lambda$new$5(java.lang.String,neureka.Tsr,java.util.Map) -> c
    37:37:neureka.devices.file.FileHead lambda$new$4(java.lang.String,neureka.Tsr,java.util.Map) -> d
    35:35:neureka.devices.file.FileHead lambda$new$3(java.lang.String,java.util.Map) -> a
    34:34:neureka.devices.file.FileHead lambda$new$2(java.lang.String,java.util.Map) -> b
    33:33:neureka.devices.file.FileHead lambda$new$1(java.lang.String,java.util.Map) -> c
    32:32:neureka.devices.file.FileHead lambda$new$0(java.lang.String,java.util.Map) -> d
neureka.devices.file.heads.util.HeadFactory$Loader -> neureka.devices.file.heads.util.HeadFactory$Loader:
    neureka.devices.file.FileHead load(java.lang.String,java.util.Map) -> load
neureka.devices.file.heads.util.HeadFactory$Saver -> neureka.devices.file.heads.util.HeadFactory$Saver:
    neureka.devices.file.FileHead save(java.lang.String,neureka.Tsr,java.util.Map) -> save
neureka.devices.file.heads.util.NumberReader -> neureka.devices.file.heads.util.NumberReader:
    java.io.FileInputStream _fileInputStream -> a
    int _bytesRead -> b
    java.util.Map _byteMap -> c
    boolean $assertionsDisabled -> d
    13:23:void <init>(java.io.FileInputStream) -> <init>
    26:26:java.io.FileInputStream getStream() -> getStream
    30:32:java.lang.Object read(neureka.dtype.NumericType) -> read
    39:39:int bytesRead() -> bytesRead
    10:10:void <clinit>() -> <clinit>
neureka.devices.host.HostCPU -> neureka.devices.host.HostCPU:
    neureka.devices.host.HostCPU _INSTANCE -> a
    neureka.devices.host.HostCPU$NativeExecutor _executor -> b
    java.util.Set _tensors -> c
    20:25:void <init>() -> <init>
    28:28:neureka.devices.host.HostCPU instance() -> instance
    32:32:neureka.devices.host.HostCPU$NativeExecutor getExecutor() -> getExecutor
    38:46:void _execute(neureka.Tsr[],int,neureka.backend.api.operations.Operation) -> _execute
    50:51:void dispose() -> dispose
    55:55:java.lang.Object valueFor(neureka.Tsr) -> valueFor
    60:60:java.lang.Number valueFor(neureka.Tsr,int) -> valueFor
    65:65:neureka.devices.Device restore(neureka.Tsr) -> restore
    70:71:neureka.devices.Device store(neureka.Tsr) -> store
    76:78:neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    83:83:boolean has(neureka.Tsr) -> has
    88:89:neureka.devices.Device free(neureka.Tsr) -> free
    94:94:neureka.devices.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    99:99:neureka.devices.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    104:104:neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    109:109:java.util.Collection getTensors() -> getTensors
    13:13:java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    13:13:neureka.devices.Storage restore(neureka.Tsr) -> restore
    13:13:neureka.devices.Storage store(neureka.Tsr) -> store
    17:17:void <clinit>() -> <clinit>
neureka.devices.host.HostCPU$NativeExecutor -> neureka.devices.host.HostCPU$NativeExecutor:
    java.util.concurrent.ThreadPoolExecutor _pool -> a
    116:120:void <init>(neureka.devices.host.HostCPU) -> <init>
    124:124:java.util.concurrent.ThreadPoolExecutor getPool() -> getPool
    131:155:void threaded(int,neureka.devices.host.HostCPU$Range) -> threaded
    141:143:void lambda$threaded$0(neureka.Neureka,neureka.devices.host.HostCPU$Range,int,int) -> a
neureka.devices.host.HostCPU$Range -> neureka.devices.host.HostCPU$Range:
    void execute(int,int) -> execute
neureka.devices.opencl.KernelCaller -> neureka.devices.opencl.KernelCaller:
    org.jocl.cl_command_queue _queue -> a
    org.jocl.cl_kernel _kernel -> b
    java.util.List _inputs -> c
    int _argId -> d
    boolean $assertionsDisabled -> e
    24:35:void <init>(org.jocl.cl_kernel,org.jocl.cl_command_queue) -> <init>
    44:49:neureka.devices.opencl.KernelCaller pass(neureka.Tsr) -> pass
    59:62:neureka.devices.opencl.KernelCaller passRaw(neureka.Tsr) -> passRaw
    71:73:neureka.devices.opencl.KernelCaller pass(int) -> pass
    82:84:neureka.devices.opencl.KernelCaller pass(float) -> pass
    93:108:void call(int) -> call
    112:128:void call(long[],long[]) -> call
    132:138:void _releaseEvents(neureka.Tsr[]) -> a
    142:149:org.jocl.cl_event[] _getWaitList(neureka.Tsr[]) -> b
    18:18:void <clinit>() -> <clinit>
neureka.devices.opencl.OpenCLDevice -> neureka.devices.opencl.OpenCLDevice:
    java.util.Map _adhocKernels -> a
    neureka.devices.opencl.OpenCLDevice$cl_ad_hoc[] _adhocKernelRingBuffer -> b
    int _ringIndex -> c
    java.util.Set _tensors -> d
    org.jocl.cl_device_id _deviceId -> e
    neureka.devices.opencl.OpenCLPlatform _platform -> f
    org.jocl.cl_command_queue _queue -> g
    83:84:neureka.devices.opencl.OpenCLDevice newInstanceOf(neureka.devices.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> newInstanceOf
    163:218:void <init>(neureka.devices.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> <init>
    221:221:boolean hasAdHocKernel(java.lang.String) -> hasAdHocKernel
    225:227:neureka.devices.opencl.KernelCaller getAdHocKernel(java.lang.String) -> getAdHocKernel
    246:304:neureka.devices.opencl.OpenCLDevice compileAdHocKernel(java.lang.String,java.lang.String) -> compileAdHocKernel
    316:319:java.util.Collection getTensors() -> getTensors
    327:329:void dispose() -> dispose
    343:355:neureka.devices.Device restore(neureka.Tsr) -> restore
    360:364:neureka.devices.Device store(neureka.Tsr) -> store
    369:373:neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    378:455:void _add(neureka.Tsr,neureka.devices.opencl.OpenCLDevice$cl_tsr) -> a
    468:468:boolean has(neureka.Tsr) -> has
    476:511:void _store(neureka.Tsr,neureka.devices.opencl.OpenCLDevice$cl_tsr,int) -> a
    516:521:neureka.devices.Device free(neureka.Tsr) -> free
    528:545:neureka.devices.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    551:569:neureka.devices.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    575:580:neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    584:585:double[] value64f(neureka.Tsr) -> value64f
    590:604:double[] _value64f(neureka.devices.opencl.OpenCLDevice$cl_tsr,int,int) -> a
    609:610:float[] value32f(neureka.Tsr) -> value32f
    614:629:float[] _value32f(neureka.devices.opencl.OpenCLDevice$cl_tsr,int,int) -> b
    634:634:java.lang.Object valueFor(neureka.Tsr) -> valueFor
    639:639:java.lang.Number valueFor(neureka.Tsr,int) -> valueFor
    643:644:double value64f(neureka.Tsr,int) -> value64f
    648:649:float value32f(neureka.Tsr,int) -> value32f
    653:655:neureka.devices.opencl.KernelCaller getKernel(neureka.backend.api.ExecutionCall) -> getKernel
    661:670:void _execute(neureka.Tsr[],int,neureka.backend.api.operations.Operation) -> _execute
    704:704:java.lang.String name() -> name
    708:708:java.lang.String vendor() -> vendor
    712:712:java.lang.String version() -> version
    716:725:java.lang.String type() -> type
    729:729:int maxComputeUnits() -> maxComputeUnits
    733:733:long maxWorkItemSimensions() -> maxWorkItemSimensions
    737:737:long[] maxWorkItemSizes() -> maxWorkItemSizes
    741:741:long maxWorkGroupSize() -> maxWorkGroupSize
    745:745:long maxClockFrequenzy() -> maxClockFrequenzy
    749:749:int maxAddressBits() -> maxAddressBits
    753:753:long maxMemAllocSize() -> maxMemAllocSize
    757:757:long globalMemSize() -> globalMemSize
    761:761:int errorCorrectionSupport() -> errorCorrectionSupport
    765:765:int localMemType() -> localMemType
    769:769:long localMemSize() -> localMemSize
    773:773:long maxConstantBufferSize() -> maxConstantBufferSize
    777:777:long maxConstantBufferSizeKB() -> maxConstantBufferSizeKB
    791:791:int imageSupport() -> imageSupport
    795:795:int maxReadImageArgs() -> maxReadImageArgs
    799:799:int maxWriteImageArgs() -> maxWriteImageArgs
    803:803:long singleFPConfig() -> singleFPConfig
    807:807:long image2DMaxWidth() -> image2DMaxWidth
    811:811:long image2DMaxHeight() -> image2DMaxHeight
    815:815:long image3DMaxWidth() -> image3DMaxWidth
    819:819:long image3DMaxHeight() -> image3DMaxHeight
    823:823:long image3DMaxDepth() -> image3DMaxDepth
    827:827:int prefVecWidthChar() -> prefVecWidthChar
    831:831:int prefVecWidthShort() -> prefVecWidthShort
    835:835:int prefVecWidthInt() -> prefVecWidthInt
    839:839:int prefVecWidthLong() -> prefVecWidthLong
    843:843:int prefVecWidthFloat() -> prefVecWidthFloat
    847:847:int prefVecWidthDouble() -> prefVecWidthDouble
    78:78:java.lang.String toString() -> toString
    169:169:org.jocl.cl_device_id getDeviceId() -> getDeviceId
    179:179:neureka.devices.opencl.OpenCLPlatform getPlatform() -> getPlatform
    77:77:java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    77:77:neureka.devices.Storage restore(neureka.Tsr) -> restore
    77:77:neureka.devices.Storage store(neureka.Tsr) -> store
    420:420:void lambda$_add$5(org.jocl.cl_mem) -> a
    389:391:void lambda$_add$4(org.jocl.cl_event,org.jocl.cl_mem) -> a
    318:318:void lambda$getTensors$3(java.util.Collection,java.util.Collection) -> a
    318:318:void lambda$getTensors$2(java.util.Collection,neureka.Tsr) -> a
    301:303:void lambda$compileAdHocKernel$1(org.jocl.cl_kernel,org.jocl.cl_program) -> a
    208:208:void lambda$new$0() -> a
neureka.devices.opencl.OpenCLDevice$DeviceQuery -> neureka.devices.opencl.OpenCLDevice$DeviceQuery:
    850:850:void <init>() -> <init>
    860:860:int getInt(org.jocl.cl_device_id,int) -> getInt
    872:874:int[] getInts(org.jocl.cl_device_id,int,int) -> getInts
    885:885:long getLong(org.jocl.cl_device_id,int) -> getLong
    897:899:long[] getLongs(org.jocl.cl_device_id,int,int) -> getLongs
    911:919:java.lang.String getString(org.jocl.cl_device_id,int) -> getString
    931:939:java.lang.String getString(org.jocl.cl_platform_id,int) -> getString
    950:950:long getSize(org.jocl.cl_device_id,int) -> getSize
    964:982:long[] getSizes(org.jocl.cl_device_id,int,int) -> getSizes
neureka.devices.opencl.OpenCLDevice$cl_ad_hoc -> neureka.devices.opencl.OpenCLDevice$a:
    java.lang.String source -> a
    org.jocl.cl_kernel kernel -> b
    150:150:void <init>() -> <init>
    150:150:void <init>(byte) -> <init>
neureka.devices.opencl.OpenCLDevice$cl_tsr -> neureka.devices.opencl.OpenCLDevice$cl_tsr:
    int fp -> a
    neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config config -> b
    neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_value value -> c
    101:132:void <init>() -> <init>
    101:101:void update(java.lang.Object,java.lang.Object) -> update
neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config -> neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config:
    org.jocl.cl_mem data -> data
    126:126:void <init>() -> <init>
neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_value -> neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_value:
    int size -> size
    org.jocl.cl_mem data -> data
    org.jocl.cl_event event -> event
    112:114:void <init>() -> <init>
neureka.devices.opencl.OpenCLPlatform -> neureka.devices.opencl.OpenCLPlatform:
    org.jocl.cl_platform_id _pid -> a
    org.jocl.cl_context _context -> b
    boolean _isDoingLegacyIndexing -> c
    java.util.Map _id_device -> d
    java.util.Map _kernels -> e
    24:60:void <init>(org.jocl.cl_platform_id) -> <init>
    63:67:void recompile() -> recompile
    72:165:void _compile(org.jocl.cl_device_id[]) -> a
    168:170:java.util.List getDevices() -> getDevices
    174:174:boolean has(org.jocl.cl_device_id) -> has
    178:178:neureka.devices.opencl.OpenCLDevice get(org.jocl.cl_device_id) -> get
    182:183:void put(org.jocl.cl_device_id,neureka.devices.opencl.OpenCLDevice) -> put
    186:186:java.util.Map getKernels() -> getKernels
    191:191:java.util.List PLATFORMS() -> PLATFORMS
    20:20:org.jocl.cl_platform_id getPid() -> getPid
    22:22:org.jocl.cl_context getContext() -> getContext
    24:24:boolean isDoingLegacyIndexing() -> isDoingLegacyIndexing
    169:169:void lambda$getDevices$1(java.util.List,org.jocl.cl_device_id,neureka.devices.opencl.OpenCLDevice) -> a
    132:134:void lambda$_compile$0(java.util.ArrayList,java.util.ArrayList,java.lang.String,java.lang.String) -> a
    18:18:void <init>(org.jocl.cl_platform_id,byte) -> <init>
neureka.devices.opencl.OpenCLPlatform$Setup -> neureka.devices.opencl.OpenCLPlatform$a:
    java.util.List PLATFORMS -> a
    196:196:void <clinit>() -> <clinit>
    1201:1210:java.util.List findAllPlatforms():201:210 -> <clinit>
    1201:1210:void <clinit>():196 -> <clinit>
neureka.devices.opencl.utility.DeviceQuery -> neureka.devices.opencl.utility.DeviceQuery:
    14:14:void <init>() -> <init>
    23:182:java.lang.String query() -> query
    1270:1278:java.lang.String getString(org.jocl.cl_platform_id,int):270:278 -> query
    1270:1278:java.lang.String query():38 -> query
    194:194:int getInt(org.jocl.cl_device_id,int) -> a
    207:209:int[] getInts(org.jocl.cl_device_id,int,int) -> a
    221:221:long getLong(org.jocl.cl_device_id,int) -> b
    234:236:long[] getLongs(org.jocl.cl_device_id,int,int) -> b
    249:257:java.lang.String getString(org.jocl.cl_device_id,int) -> c
    290:290:long getSize(org.jocl.cl_device_id,int) -> d
    305:324:long[] getSizes(org.jocl.cl_device_id,int,int) -> c
neureka.devices.opencl.utility.DispatchUtility -> neureka.devices.opencl.utility.DispatchUtility:
    boolean $assertionsDisabled -> a
    8:8:void <init>() -> <init>
    13:137:int[] parseTile(int,int[]) -> parseTile
    151:155:int productOfNewDimension(int[],int,int,int) -> a
    164:168:int inversionProductOfNewDimension(int[],int[],int,int) -> a
    173:194:java.util.List primeFactors(int) -> primeFactors
    208:218:int[] findBestParams(int,int,int,int,int) -> findBestParams
    224:231:int[] bestMatMulMatch(int,int,int,int) -> bestMatMulMatch
    8:8:void <clinit>() -> <clinit>
neureka.devices.opencl.utility.WeakTensorReference -> neureka.devices.opencl.utility.WeakTensorReference:
    int _hash -> a
    24:26:void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    30:30:int hashCode() -> hashCode
    35:35:boolean equals(java.lang.Object) -> equals
neureka.dtype.AbstractNumericType -> neureka.dtype.AbstractNumericType:
    java.util.Map _NUMERIC_TYPE_RELATIONS -> a
    11:11:void <init>() -> <init>
    32:32:java.lang.Class getNumericTypeTarget() -> getNumericTypeTarget
    38:42:void writeDataTo(java.io.DataOutput,java.util.Iterator) -> writeDataTo
    16:26:void <clinit>() -> <clinit>
neureka.dtype.AbstractNumericType$Conversion -> neureka.dtype.AbstractNumericType$Conversion:
    java.lang.Object go(java.lang.Object) -> go
neureka.dtype.DataType -> neureka.dtype.DataType:
    java.util.Map _instances -> a
    java.lang.Class _typeClass -> b
    58:70:java.lang.Class _trueType(java.lang.Class) -> a
    75:82:neureka.dtype.DataType of(java.lang.Class) -> of
    87:92:void forType(java.lang.Class,java.util.function.Consumer) -> forType
    96:98:void <init>(java.lang.Class) -> <init>
    102:116:java.lang.Object getTypeClassInstance() -> getTypeClassInstance
    120:120:boolean typeClassImplements(java.lang.Class) -> typeClassImplements
    127:141:java.lang.Object virtualize(java.lang.Object) -> virtualize
    146:173:java.lang.Object actualize(java.lang.Object,int) -> actualize
    178:189:java.lang.Object allocate(int) -> allocate
    52:52:boolean equals(java.lang.Object) -> equals
    52:52:int hashCode() -> hashCode
    51:51:java.lang.String toString() -> toString
    94:94:java.lang.Class getTypeClass() -> getTypeClass
    55:55:void <clinit>() -> <clinit>
neureka.dtype.NumericType -> neureka.dtype.NumericType:
    boolean signed() -> signed
    int numberOfBytes() -> numberOfBytes
    java.lang.Class targetType() -> targetType
    java.lang.Class targetArrayType() -> targetArrayType
    java.lang.Class holderType() -> holderType
    java.lang.Class holderArrayType() -> holderArrayType
    java.lang.Class getNumericTypeTarget() -> getNumericTypeTarget
    java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    java.lang.Object toTarget(java.lang.Object) -> toTarget
    byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    void writeDataTo(java.io.DataOutput,java.util.Iterator) -> writeDataTo
    java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
neureka.dtype.custom.F32 -> neureka.dtype.custom.F32:
    14:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:49:java.lang.Float foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    54:54:java.lang.Float toTarget(java.lang.Float) -> toTarget
    59:60:byte[] targetToForeignHolderBytes(java.lang.Float) -> targetToForeignHolderBytes
    70:70:float[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    75:77:float[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    83:83:float[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    88:88:float[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    94:107:java.lang.Float convertToHolder(java.lang.Object) -> convertToHolder
    112:112:float[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    117:117:java.lang.Float convertToTarget(java.lang.Object) -> convertToTarget
    122:122:float[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.F64 -> neureka.dtype.custom.F64:
    15:16:void <init>() -> <init>
    20:20:boolean signed() -> signed
    25:25:int numberOfBytes() -> numberOfBytes
    30:30:java.lang.Class targetType() -> targetType
    35:35:java.lang.Class targetArrayType() -> targetArrayType
    40:40:java.lang.Class holderType() -> holderType
    45:45:java.lang.Class holderArrayType() -> holderArrayType
    50:50:java.lang.Double foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    55:55:java.lang.Double toTarget(java.lang.Double) -> toTarget
    60:61:byte[] targetToForeignHolderBytes(java.lang.Double) -> targetToForeignHolderBytes
    75:75:double[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    80:82:double[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    87:87:double[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    92:94:double[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    99:112:java.lang.Double convertToHolder(java.lang.Object) -> convertToHolder
    117:117:double[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    122:122:java.lang.Double convertToTarget(java.lang.Object) -> convertToTarget
    127:127:double[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    131:137:double[] _readFrom(java.io.DataInput,int) -> a
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I16 -> neureka.dtype.custom.I16:
    java.nio.ByteBuffer buffer -> a
    13:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:51:java.lang.Short foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    56:56:java.lang.Short toTarget(java.lang.Short) -> toTarget
    61:62:byte[] targetToForeignHolderBytes(java.lang.Short) -> targetToForeignHolderBytes
    67:67:short[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    72:72:short[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    77:77:short[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    82:82:short[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    87:100:java.lang.Short convertToHolder(java.lang.Object) -> convertToHolder
    105:105:short[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    110:110:java.lang.Short convertToTarget(java.lang.Object) -> convertToTarget
    115:115:short[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    119:125:short[] _readData(java.io.DataInput,int) -> a
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I32 -> neureka.dtype.custom.I32:
    15:16:void <init>() -> <init>
    20:20:boolean signed() -> signed
    25:25:int numberOfBytes() -> numberOfBytes
    30:30:java.lang.Class targetType() -> targetType
    35:35:java.lang.Class targetArrayType() -> targetArrayType
    40:40:java.lang.Class holderType() -> holderType
    45:45:java.lang.Class holderArrayType() -> holderArrayType
    50:50:java.lang.Integer foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    56:56:java.lang.Integer toTarget(java.lang.Integer) -> toTarget
    61:65:byte[] targetToForeignHolderBytes(java.lang.Integer) -> targetToForeignHolderBytes
    71:71:int[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    76:76:int[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    81:81:int[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    86:86:int[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    91:104:java.lang.Integer convertToHolder(java.lang.Object) -> convertToHolder
    109:109:int[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    114:114:java.lang.Integer convertToTarget(java.lang.Object) -> convertToTarget
    119:119:int[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    123:129:int[] _readData(java.io.DataInput,int) -> a
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I64 -> neureka.dtype.custom.I64:
    java.nio.ByteBuffer buffer -> a
    13:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:51:java.lang.Long foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    57:57:java.lang.Long toTarget(java.lang.Long) -> toTarget
    62:63:byte[] targetToForeignHolderBytes(java.lang.Long) -> targetToForeignHolderBytes
    68:68:long[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    73:73:long[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    78:78:long[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    83:83:long[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    88:101:java.lang.Long convertToHolder(java.lang.Object) -> convertToHolder
    106:106:long[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    111:111:java.lang.Long convertToTarget(java.lang.Object) -> convertToTarget
    116:116:long[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I8 -> neureka.dtype.custom.I8:
    18:19:void <init>() -> <init>
    23:23:boolean signed() -> signed
    28:28:int numberOfBytes() -> numberOfBytes
    33:33:java.lang.Class targetType() -> targetType
    38:38:java.lang.Class targetArrayType() -> targetArrayType
    43:43:java.lang.Class holderType() -> holderType
    48:48:java.lang.Class holderArrayType() -> holderArrayType
    53:53:java.lang.Byte foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    58:58:java.lang.Byte toTarget(java.lang.Byte) -> toTarget
    63:63:byte[] targetToForeignHolderBytes(java.lang.Byte) -> targetToForeignHolderBytes
    68:70:byte[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    75:75:byte[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    80:82:byte[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    87:87:byte[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    92:105:java.lang.Byte convertToHolder(java.lang.Object) -> convertToHolder
    110:110:byte[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    115:115:java.lang.Byte convertToTarget(java.lang.Object) -> convertToTarget
    120:120:byte[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    15:15:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    15:15:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    15:15:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    15:15:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    15:15:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    15:15:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    15:15:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    15:15:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    15:15:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    15:15:java.lang.Object toTarget(java.lang.Object) -> toTarget
    15:15:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI16 -> neureka.dtype.custom.UI16:
    15:16:void <init>() -> <init>
    20:20:boolean signed() -> signed
    25:25:int numberOfBytes() -> numberOfBytes
    30:30:java.lang.Class targetType() -> targetType
    35:35:java.lang.Class targetArrayType() -> targetArrayType
    40:40:java.lang.Class holderType() -> holderType
    45:45:java.lang.Class holderArrayType() -> holderArrayType
    50:51:java.lang.Integer foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    59:59:java.lang.Integer toTarget(java.lang.Short) -> toTarget
    64:66:byte[] targetToForeignHolderBytes(java.lang.Integer) -> targetToForeignHolderBytes
    71:77:int[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    82:82:int[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    87:87:short[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    92:92:short[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    97:97:java.lang.Short convertToHolder(java.lang.Object) -> convertToHolder
    102:102:short[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    107:107:java.lang.Integer convertToTarget(java.lang.Object) -> convertToTarget
    112:112:int[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI32 -> neureka.dtype.custom.UI32:
    11:11:void <init>() -> <init>
    16:16:boolean signed() -> signed
    21:21:int numberOfBytes() -> numberOfBytes
    26:26:java.lang.Class targetType() -> targetType
    31:31:java.lang.Class targetArrayType() -> targetArrayType
    36:36:java.lang.Class holderType() -> holderType
    41:41:java.lang.Class holderArrayType() -> holderArrayType
    46:47:java.lang.Long foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    55:55:java.lang.Long toTarget(java.lang.Integer) -> toTarget
    60:63:byte[] targetToForeignHolderBytes(java.lang.Long) -> targetToForeignHolderBytes
    68:68:long[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    73:73:long[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    78:78:int[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    83:83:int[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    88:88:java.lang.Integer convertToHolder(java.lang.Object) -> convertToHolder
    93:93:int[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    98:98:java.lang.Long convertToTarget(java.lang.Object) -> convertToTarget
    103:103:long[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI64 -> neureka.dtype.custom.UI64:
    14:14:void <init>() -> <init>
    18:18:boolean signed() -> signed
    23:23:int numberOfBytes() -> numberOfBytes
    28:28:java.lang.Class targetType() -> targetType
    33:33:java.lang.Class targetArrayType() -> targetArrayType
    38:38:java.lang.Class holderType() -> holderType
    43:43:java.lang.Class holderArrayType() -> holderArrayType
    49:53:java.math.BigInteger foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    58:59:java.math.BigInteger toTarget(java.lang.Long) -> toTarget
    64:71:byte[] targetToForeignHolderBytes(java.math.BigInteger) -> targetToForeignHolderBytes
    76:76:java.math.BigInteger[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    81:81:java.math.BigInteger[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    86:86:long[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    91:91:long[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    96:96:java.lang.Long convertToHolder(java.lang.Object) -> convertToHolder
    101:101:long[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    106:106:java.math.BigInteger convertToTarget(java.lang.Object) -> convertToTarget
    111:111:java.math.BigInteger[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI8 -> neureka.dtype.custom.UI8:
    14:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:49:java.lang.Short foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    55:55:java.lang.Short toTarget(java.lang.Byte) -> toTarget
    61:61:byte[] targetToForeignHolderBytes(java.lang.Short) -> targetToForeignHolderBytes
    66:72:short[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    77:77:short[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    82:88:byte[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    93:93:byte[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    98:98:java.lang.Byte convertToHolder(java.lang.Object) -> convertToHolder
    103:103:byte[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    108:121:java.lang.Short convertToTarget(java.lang.Object) -> convertToTarget
    126:126:short[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    10:10:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    10:10:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    10:10:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    10:10:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    10:10:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    10:10:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    10:10:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    10:10:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    10:10:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    10:10:java.lang.Object toTarget(java.lang.Object) -> toTarget
    10:10:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.framing.IndexAlias -> neureka.framing.IndexAlias:
    java.util.List _hiddenKeys -> a
    java.util.Map _mapping -> b
    java.lang.String _tensorName -> c
    13:31:void <init>(java.util.List,java.lang.String) -> <init>
    13:37:void <init>(int,java.lang.String) -> <init>
    13:58:void <init>(java.util.Map,neureka.Tsr,java.lang.String) -> <init>
    61:61:int[] get(java.util.List) -> get
    65:74:int[] get(java.lang.Object[]) -> get
    79:81:int get(java.lang.Object,java.lang.Object) -> get
    86:91:void replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    94:100:void _initializeIdxmap(java.lang.Object,int,java.lang.Object,int) -> a
    104:107:void set(java.lang.Object,java.lang.Object,int) -> set
    111:116:java.util.List keysOf(java.lang.Object) -> keysOf
    120:124:java.util.List keysOf(java.lang.Object,int) -> keysOf
    128:139:java.lang.String _fixed(java.lang.String,int) -> a
    146:212:java.lang.String toString() -> toString
    219:219:void update(neureka.Tsr,neureka.Tsr) -> update
    15:15:java.util.Map getMapping() -> getMapping
    17:17:java.lang.String getTensorName() -> getTensorName
    10:10:void update(java.lang.Object,java.lang.Object) -> update
    181:198:void lambda$toString$6(java.lang.Object[],int[],java.lang.StringBuilder,int[],java.lang.Object,java.lang.Object) -> a
    185:186:void lambda$toString$5(int[],java.lang.Object[],java.lang.Object,java.lang.Integer) -> a
    161:169:void lambda$toString$4(int[],int[],java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    154:154:java.lang.Boolean lambda$toString$3(int,int,java.lang.Integer) -> a
    122:122:void lambda$keysOf$2(int,java.util.List,java.lang.Object,java.lang.Integer) -> a
    114:114:void lambda$keysOf$1(java.util.List,java.lang.Object,java.lang.Integer) -> a
    44:57:void lambda$new$0(int[],neureka.Tsr,java.lang.Object,java.util.List) -> a
neureka.framing.Relation -> neureka.framing.Relation:
    neureka.Tsr _parent -> a
    java.lang.ref.WeakReference[] _children -> b
    int[][] _shapeRelations -> c
    64:64:void <init>() -> <init>
    105:122:void update(neureka.Tsr,neureka.Tsr) -> update
    127:128:neureka.framing.Relation addParent(neureka.Tsr) -> addParent
    134:147:neureka.framing.Relation addChild(neureka.Tsr) -> addChild
    170:176:neureka.framing.Relation addReshapeRelationFor(neureka.Tsr,int[]) -> addReshapeRelationFor
    199:205:int[] getReshapeRelationFor(neureka.Tsr) -> getReshapeRelationFor
    210:220:neureka.framing.Relation foreachChild(java.util.function.Consumer) -> foreachChild
    225:228:neureka.Tsr findRootTensor() -> findRootTensor
    233:233:boolean hasParent() -> hasParent
    238:238:boolean hasChildren() -> hasChildren
    243:243:int childCount() -> childCount
    249:249:neureka.framing.Relation remove(neureka.Tsr) -> remove
    63:63:java.lang.String toString() -> toString
    76:76:neureka.Tsr getParent() -> getParent
    62:62:void update(java.lang.Object,java.lang.Object) -> update
neureka.ndim.AbstractComponentOwner -> neureka.ndim.AbstractComponentOwner:
    java.util.Map _CLASS_ORDER -> a
    neureka.Component[] _components -> _components
    63:92:void <init>() -> <init>
    95:96:void _setComps(neureka.Component[]) -> a
    99:134:void _addOrRemoveComp(neureka.Component,boolean) -> a
    155:160:void _transferFrom(neureka.ndim.AbstractComponentOwner) -> _transferFrom
    167:168:void _delComps() -> _delComps
    182:187:neureka.Component find(java.lang.Class) -> find
    200:203:java.lang.Object remove(java.lang.Class) -> remove
    214:214:boolean has(java.lang.Class) -> has
    229:238:java.lang.Object set(neureka.Component) -> set
    neureka.Component _setOrReject(neureka.Component) -> _setOrReject
    neureka.Component _removeOrReject(neureka.Component) -> _removeOrReject
    283:287:boolean forComponent(java.lang.Class,java.util.function.Consumer) -> forComponent
    78:87:void <clinit>() -> <clinit>
neureka.ndim.AbstractNDArray -> neureka.ndim.AbstractNDArray:
    org.slf4j.Logger _LOG -> _LOG
    neureka.ndim.config.NDConfiguration _NDConf -> a
    neureka.dtype.DataType _dataType -> b
    java.lang.Object _data -> c
    boolean $assertionsDisabled -> d
    66:79:void <init>() -> <init>
    86:88:java.lang.Class getValueClass() -> getValueClass
    103:109:java.lang.Object setDataType(neureka.dtype.DataType) -> setDataType
    114:129:void _setData(java.lang.Object) -> _setData
    133:152:void _initData(neureka.ndim.AbstractNDArray$Initializer) -> _initData
    166:167:void _allocate(int) -> _allocate
    180:181:void _virtualize() -> _virtualize
    195:196:void _actualize() -> _actualize
    200:209:java.lang.Object _convertedDataOfType(java.lang.Class) -> _convertedDataOfType
    216:217:void forEach(java.util.function.Consumer) -> forEach
    222:222:java.util.Spliterator spliterator() -> spliterator
    java.lang.Object getDataAt(int) -> getDataAt
    java.lang.Object setDataAt(int,java.lang.Object) -> setDataAt
    274:275:boolean is(java.lang.Class) -> is
    279:279:boolean is64() -> is64
    283:283:boolean is32() -> is32
    289:289:int indexOfIndex(int) -> indexOfIndex
    293:293:int[] IndicesOfIndex(int) -> IndicesOfIndex
    297:297:int indexOfIndices(int[]) -> indexOfIndices
    311:317:java.lang.Object setNDConf(neureka.ndim.config.NDConfiguration) -> setNDConf
    323:323:int rank() -> rank
    327:327:java.util.List shape() -> shape
    331:331:int shape(int) -> shape
    335:335:java.util.List indicesMap() -> indicesMap
    339:339:java.util.List translation() -> translation
    343:343:java.util.List spread() -> spread
    347:347:java.util.List offset() -> offset
    351:351:int size() -> size
    355:357:java.util.List _asList(int[]) -> _asList
    75:75:neureka.ndim.config.NDConfiguration getNDConf() -> getNDConf
    78:78:neureka.dtype.DataType getDataType() -> getDataType
    81:81:java.lang.Object getData() -> getData
    313:313:int lambda$setNDConf$1(int,int) -> a
    312:312:int lambda$setNDConf$0(int,int) -> b
    65:65:void <clinit>() -> <clinit>
neureka.ndim.AbstractNDArray$1 -> neureka.ndim.AbstractNDArray$1:
    223:223:void <init>(neureka.ndim.AbstractNDArray) -> <init>
    226:226:boolean tryAdvance(java.util.function.Consumer) -> tryAdvance
    231:231:java.util.Spliterator trySplit() -> trySplit
    236:236:long estimateSize() -> estimateSize
    241:241:int characteristics() -> characteristics
neureka.ndim.AbstractNDArray$Initializer -> neureka.ndim.AbstractNDArray$Initializer:
    java.lang.Object init(int,int[]) -> init
neureka.ndim.AbstractNDArray$Utility -> neureka.ndim.AbstractNDArray$Utility:
    368:368:void <init>() -> <init>
neureka.ndim.AbstractNDArray$Utility$Indexing -> neureka.ndim.AbstractNDArray$Utility$Indexing:
    384:384:void <init>() -> <init>
    388:398:int[] shpCheck(int[],neureka.Tsr) -> shpCheck
    403:424:int[][] makeFit(int[],int[]) -> makeFit
    429:431:int[] shpOfCon(int[],int[]) -> shpOfCon
    436:443:int[] shpOfBrc(int[],int[]) -> shpOfBrc
neureka.ndim.AbstractNDArray$Utility$Stringify -> neureka.ndim.AbstractNDArray$Utility$Stringify:
    370:370:void <init>() -> <init>
    374:377:java.lang.String strConf(int[]) -> strConf
neureka.ndim.config.AbstractNDC -> neureka.ndim.config.AbstractNDC:
    java.util.Map _CACHED_NDCS -> a
    java.util.Map _CACHED_INT_ARRAYS -> b
    boolean $assertionsDisabled -> c
    11:11:void <init>() -> <init>
    34:57:int[] _cacheArray(int[]) -> _cacheArray
    67:74:int[] asInlineArray() -> asInlineArray
    83:87:long keyCode() -> keyCode
    93:97:boolean equals(neureka.ndim.config.NDConfiguration) -> equals
    109:140:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    145:154:neureka.ndim.config.NDConfiguration _cached(neureka.ndim.config.NDConfiguration) -> _cached
    165:171:boolean _isSimpleConfiguration(int[],int[],int[],int[],int[]) -> a
    178:183:java.lang.String toString() -> toString
    188:201:neureka.ndim.config.NDConfiguration _simpleReshape(int[],neureka.ndim.config.NDConfiguration) -> _simpleReshape
    208:211:neureka.ndim.config.NDConfiguration newReshaped(int[]) -> newReshaped
    11:30:void <clinit>() -> <clinit>
neureka.ndim.config.NDConfiguration -> neureka.ndim.config.NDConfiguration:
    int rank() -> rank
    int[] shape() -> shape
    int shape(int) -> shape
    int[] indicesMap() -> indicesMap
    int indicesMap(int) -> indicesMap
    int[] translation() -> translation
    int translation(int) -> translation
    int[] spread() -> spread
    int spread(int) -> spread
    int[] offset() -> offset
    int offset(int) -> offset
    int indexOfIndex(int) -> indexOfIndex
    int[] indicesOfIndex(int) -> indicesOfIndex
    int indexOfIndices(int[]) -> indexOfIndices
    int[] asInlineArray() -> asInlineArray
    long keyCode() -> keyCode
    boolean equals(neureka.ndim.config.NDConfiguration) -> equals
    neureka.ndim.config.NDConfiguration newReshaped(int[]) -> newReshaped
neureka.ndim.config.NDConfiguration$Utility -> neureka.ndim.config.NDConfiguration$Utility:
    88:88:void <init>() -> <init>
    92:98:int[] rearrange(int[],int[],int[]) -> rearrange
    103:108:int[] rearrange(int[],int[]) -> rearrange
    113:119:int[] newTlnOf(int[]) -> newTlnOf
    124:126:void increment(int[],int[]) -> increment
    1131:1140:int _incrementAt(int,int[],int[]):131:140 -> increment
    1131:1140:void increment(int[],int[]):125 -> increment
    145:147:int szeOfShp(int[]) -> szeOfShp
neureka.ndim.config.types.D1C -> neureka.ndim.config.types.D1C:
    5:5:void <init>() -> <init>
    int indexOfIndices(int) -> indexOfIndices
neureka.ndim.config.types.D2C -> neureka.ndim.config.types.D2C:
    5:5:void <init>() -> <init>
    int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.D3C -> neureka.ndim.config.types.D3C:
    5:5:void <init>() -> <init>
    int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.complex.ComplexD1Configuration -> neureka.ndim.config.types.complex.ComplexD1Configuration:
    int _shape -> _shape
    int _translation -> a
    int _indicesMap -> b
    int _spread -> c
    int _offset -> d
    boolean $assertionsDisabled -> e
    37:37:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    46:55:void <init>(int,int,int,int,int) -> <init>
    59:59:int rank() -> rank
    64:64:int[] shape() -> shape
    69:69:int shape(int) -> shape
    74:74:int[] indicesMap() -> indicesMap
    79:79:int indicesMap(int) -> indicesMap
    84:84:int[] translation() -> translation
    89:89:int translation(int) -> translation
    94:94:int[] spread() -> spread
    99:99:int spread(int) -> spread
    104:104:int[] offset() -> offset
    109:109:int offset(int) -> offset
    115:115:int indexOfIndex(int) -> indexOfIndex
    120:120:int[] indicesOfIndex(int) -> indicesOfIndex
    124:124:int indexOfIndices(int[]) -> indexOfIndices
    130:130:int indexOfIndices(int) -> indexOfIndices
    6:6:void <clinit>() -> <clinit>
neureka.ndim.config.types.complex.ComplexD2Configuration -> neureka.ndim.config.types.complex.ComplexD2Configuration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _translation1 -> a
    int _translation2 -> b
    int _indicesMap1 -> c
    int _indicesMap2 -> d
    int _spread1 -> e
    int _spread2 -> f
    int _offset1 -> g
    int _offset2 -> h
    41:52:void <init>(int[],int[],int[],int[],int[]) -> <init>
    61:61:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    66:66:int rank() -> rank
    71:71:int[] shape() -> shape
    76:76:int shape(int) -> shape
    81:81:int[] indicesMap() -> indicesMap
    86:86:int indicesMap(int) -> indicesMap
    91:91:int[] translation() -> translation
    96:96:int translation(int) -> translation
    101:101:int[] spread() -> spread
    106:106:int spread(int) -> spread
    111:111:int[] offset() -> offset
    116:116:int offset(int) -> offset
    124:124:int indexOfIndex(int) -> indexOfIndex
    130:134:int[] indicesOfIndex(int) -> indicesOfIndex
    139:142:int indexOfIndices(int[]) -> indexOfIndices
    147:150:int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.complex.ComplexD3Configuration -> neureka.ndim.config.types.complex.ComplexD3Configuration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _shape3 -> _shape3
    int _translation1 -> a
    int _translation2 -> b
    int _translation3 -> c
    int _indicesMap1 -> d
    int _indicesMap2 -> e
    int _indicesMap3 -> f
    int _spread1 -> g
    int _spread2 -> h
    int _spread3 -> i
    int _offset1 -> j
    int _offset2 -> k
    int _offset3 -> l
    47:63:void <init>(int[],int[],int[],int[],int[]) -> <init>
    72:72:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    77:77:int rank() -> rank
    82:82:int[] shape() -> shape
    87:87:int shape(int) -> shape
    92:92:int[] indicesMap() -> indicesMap
    97:97:int indicesMap(int) -> indicesMap
    102:102:int[] translation() -> translation
    107:107:int translation(int) -> translation
    112:112:int[] spread() -> spread
    117:117:int spread(int) -> spread
    122:122:int[] offset() -> offset
    127:127:int offset(int) -> offset
    136:141:int indexOfIndex(int) -> indexOfIndex
    149:154:int[] indicesOfIndex(int) -> indicesOfIndex
    159:159:int indexOfIndices(int[]) -> indexOfIndices
    166:166:int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.complex.ComplexDefaultNDConfiguration -> neureka.ndim.config.types.complex.ComplexDefaultNDConfiguration:
    int[] _shape -> _shape
    int[] _translation -> a
    int[] _indicesMap -> b
    int[] _spread -> c
    int[] _offset -> d
    41:47:void <init>(int[],int[],int[],int[],int[]) -> <init>
    56:56:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    61:61:int rank() -> rank
    66:66:int[] shape() -> shape
    71:71:int shape(int) -> shape
    76:76:int[] indicesMap() -> indicesMap
    81:81:int indicesMap(int) -> indicesMap
    86:86:int[] translation() -> translation
    91:91:int translation(int) -> translation
    96:96:int[] spread() -> spread
    101:101:int spread(int) -> spread
    106:106:int[] offset() -> offset
    111:111:int offset(int) -> offset
    119:119:int indexOfIndex(int) -> indexOfIndex
    124:129:int[] indicesOfIndex(int) -> indicesOfIndex
    134:136:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.complex.ComplexScalarConfiguration -> neureka.ndim.config.types.complex.ComplexScalarConfiguration:
    int _shape -> _shape
    int _offset -> a
    25:25:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    31:34:void <init>(int,int) -> <init>
    38:38:int rank() -> rank
    43:43:int[] shape() -> shape
    48:48:int shape(int) -> shape
    53:53:int[] indicesMap() -> indicesMap
    58:58:int indicesMap(int) -> indicesMap
    63:63:int[] translation() -> translation
    68:68:int translation(int) -> translation
    73:73:int[] spread() -> spread
    78:78:int spread(int) -> spread
    83:83:int[] offset() -> offset
    88:88:int offset(int) -> offset
    94:94:int indexOfIndex(int) -> indexOfIndex
    99:99:int[] indicesOfIndex(int) -> indicesOfIndex
    104:104:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleD1Configuration -> neureka.ndim.config.types.simple.SimpleD1Configuration:
    int _shape -> _shape
    int _translation_and_indicesMap -> a
    23:23:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    29:32:void <init>(int,int) -> <init>
    36:36:int rank() -> rank
    41:41:int[] shape() -> shape
    46:46:int shape(int) -> shape
    51:51:int[] indicesMap() -> indicesMap
    56:56:int indicesMap(int) -> indicesMap
    61:61:int[] translation() -> translation
    66:66:int translation(int) -> translation
    71:71:int[] spread() -> spread
    76:76:int spread(int) -> spread
    81:81:int[] offset() -> offset
    86:86:int offset(int) -> offset
    92:92:int indexOfIndex(int) -> indexOfIndex
    97:97:int[] indicesOfIndex(int) -> indicesOfIndex
    102:102:int indexOfIndices(int[]) -> indexOfIndices
    107:107:int indexOfIndices(int) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleD2Configuration -> neureka.ndim.config.types.simple.SimpleD2Configuration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _translation1 -> a
    int _translation2 -> b
    25:30:void <init>(int[],int[]) -> <init>
    36:36:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    42:42:int rank() -> rank
    47:47:int[] shape() -> shape
    52:52:int shape(int) -> shape
    57:57:int[] indicesMap() -> indicesMap
    62:62:int indicesMap(int) -> indicesMap
    67:67:int[] translation() -> translation
    72:72:int translation(int) -> translation
    77:77:int[] spread() -> spread
    82:82:int spread(int) -> spread
    87:87:int[] offset() -> offset
    92:92:int offset(int) -> offset
    100:100:int indexOfIndex(int) -> indexOfIndex
    106:110:int[] indicesOfIndex(int) -> indicesOfIndex
    115:118:int indexOfIndices(int[]) -> indexOfIndices
    123:126:int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleD3Configuration -> neureka.ndim.config.types.simple.SimpleD3Configuration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _shape3 -> _shape3
    int _translation1 -> a
    int _translation2 -> b
    int _translation3 -> c
    26:33:void <init>(int[],int[]) -> <init>
    39:39:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    44:44:int rank() -> rank
    49:49:int[] shape() -> shape
    54:54:int shape(int) -> shape
    59:59:int[] indicesMap() -> indicesMap
    64:64:int indicesMap(int) -> indicesMap
    69:69:int[] translation() -> translation
    74:74:int translation(int) -> translation
    79:79:int[] spread() -> spread
    84:84:int spread(int) -> spread
    89:89:int[] offset() -> offset
    94:94:int offset(int) -> offset
    103:108:int indexOfIndex(int) -> indexOfIndex
    116:121:int[] indicesOfIndex(int) -> indicesOfIndex
    126:126:int indexOfIndices(int[]) -> indexOfIndices
    133:133:int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleDefaultNDConfiguration -> neureka.ndim.config.types.simple.SimpleDefaultNDConfiguration:
    int[] _shape -> _shape
    int[] _translation_and_indicesMap -> a
    23:26:void <init>(int[],int[]) -> <init>
    32:32:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    37:37:int rank() -> rank
    42:42:int[] shape() -> shape
    47:47:int shape(int) -> shape
    52:52:int[] indicesMap() -> indicesMap
    57:57:int indicesMap(int) -> indicesMap
    62:62:int[] translation() -> translation
    67:67:int translation(int) -> translation
    72:74:int[] spread() -> spread
    79:79:int spread(int) -> spread
    84:84:int[] offset() -> offset
    89:89:int offset(int) -> offset
    97:97:int indexOfIndex(int) -> indexOfIndex
    102:107:int[] indicesOfIndex(int) -> indicesOfIndex
    112:114:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleScalarConfiguration -> neureka.ndim.config.types.simple.SimpleScalarConfiguration:
    9:9:neureka.ndim.config.NDConfiguration construct() -> construct
    12:12:void <init>() -> <init>
    16:16:int rank() -> rank
    21:21:int[] shape() -> shape
    26:26:int shape(int) -> shape
    31:31:int[] indicesMap() -> indicesMap
    36:36:int indicesMap(int) -> indicesMap
    41:41:int[] translation() -> translation
    46:46:int translation(int) -> translation
    51:51:int[] spread() -> spread
    56:56:int spread(int) -> spread
    61:61:int[] offset() -> offset
    66:66:int offset(int) -> offset
    71:71:int indexOfIndex(int) -> indexOfIndex
    76:76:int[] indicesOfIndex(int) -> indicesOfIndex
    81:81:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.views.SimpleReshapeView -> neureka.ndim.config.types.views.SimpleReshapeView:
    neureka.ndim.config.NDConfiguration _toBeViewed -> a
    int[] _form -> b
    int[] _formTranslator -> c
    int[] _shape -> d
    int[] _translation -> e
    int[] _indicesMap -> f
    int[] _spread -> g
    int[] _offset -> h
    23:44:void <init>(int[],neureka.ndim.config.NDConfiguration) -> <init>
    48:48:int rank() -> rank
    53:53:int[] shape() -> shape
    58:58:int shape(int) -> shape
    63:63:int[] indicesMap() -> indicesMap
    68:68:int indicesMap(int) -> indicesMap
    73:73:int[] translation() -> translation
    78:78:int translation(int) -> translation
    83:83:int[] spread() -> spread
    88:88:int spread(int) -> spread
    93:93:int[] offset() -> offset
    98:98:int offset(int) -> offset
    103:103:int indexOfIndex(int) -> indexOfIndex
    108:113:int[] indicesOfIndex(int) -> indicesOfIndex
    118:119:int indexOfIndices(int[]) -> indexOfIndices
    1124:1127:int[] _rearrange(int[],int[],int[]):124:127 -> indexOfIndices
    1124:1127:int indexOfIndices(int[]):118 -> indexOfIndices
    35:35:int lambda$new$0(java.lang.Integer) -> a
neureka.ndim.config.types.virtual.VirtualNDConfiguration -> neureka.ndim.config.types.virtual.VirtualNDConfiguration:
    java.util.Map _Virtual_Cache -> a
    int[] _shape -> b
    16:18:void <init>(int[]) -> <init>
    23:30:neureka.ndim.config.NDConfiguration construct(int[]) -> construct
    35:35:int rank() -> rank
    40:40:int[] shape() -> shape
    45:45:int shape(int) -> shape
    50:50:int[] indicesMap() -> indicesMap
    55:55:int indicesMap(int) -> indicesMap
    60:60:int[] translation() -> translation
    65:65:int translation(int) -> translation
    70:70:int[] spread() -> spread
    75:75:int spread(int) -> spread
    80:80:int[] offset() -> offset
    85:85:int offset(int) -> offset
    90:90:int indexOfIndex(int) -> indexOfIndex
    95:95:int[] indicesOfIndex(int) -> indicesOfIndex
    100:100:int indexOfIndices(int[]) -> indexOfIndices
    12:12:void <clinit>() -> <clinit>
neureka.ndim.iterators.NDIterator -> neureka.ndim.iterators.NDIterator:
    63:76:neureka.ndim.iterators.NDIterator of(neureka.Tsr) -> of
    int shape(int) -> shape
    int[] shape() -> shape
    void increment() -> increment
    void decrement() -> decrement
    int i() -> i
    int get(int) -> get
    int[] get() -> get
    void set(int,int) -> set
    void set(int[]) -> set
    int rank() -> rank
    102:113:java.lang.String asString() -> asString
    111:111:void lambda$asString$1(java.util.StringJoiner,int) -> a
    106:106:void lambda$asString$0(java.util.StringJoiner,int) -> b
neureka.ndim.iterators.types.DefaultNDIterator -> neureka.ndim.iterators.types.DefaultNDIterator:
    int[] _indices -> a
    int[] _shape -> b
    neureka.ndim.config.NDConfiguration _conf -> c
    12:16:void <init>(neureka.ndim.config.NDConfiguration) -> <init>
    20:20:int shape(int) -> shape
    25:25:int[] shape() -> shape
    30:31:void increment() -> increment
    36:36:void decrement() -> decrement
    40:40:int i() -> i
    45:45:int get(int) -> get
    50:50:int[] get() -> get
    55:56:void set(int,int) -> set
    60:61:void set(int[]) -> set
    65:65:int rank() -> rank
neureka.ndim.iterators.types.VirtualNDIterator -> neureka.ndim.iterators.types.VirtualNDIterator:
    neureka.ndim.config.types.virtual.VirtualNDConfiguration _conf -> a
    10:12:void <init>(neureka.ndim.config.types.virtual.VirtualNDConfiguration) -> <init>
    16:16:int shape(int) -> shape
    21:21:int[] shape() -> shape
    27:27:void increment() -> increment
    32:32:void decrement() -> decrement
    36:36:int i() -> i
    41:41:int get(int) -> get
    46:46:int[] get() -> get
    52:52:void set(int,int) -> set
    57:57:void set(int[]) -> set
    61:61:int rank() -> rank
neureka.ndim.iterators.types.complex.ComplexD1CIterator -> neureka.ndim.iterators.types.complex.ComplexD1CIterator:
    int _d1 -> a
    11:12:void <init>(neureka.ndim.config.types.complex.ComplexD1Configuration) -> <init>
    16:17:void increment() -> increment
    21:22:void decrement() -> decrement
    27:27:int i() -> i
    32:32:int get(int) -> get
    37:37:int[] get() -> get
    42:43:void set(int,int) -> set
    47:48:void set(int[]) -> set
    52:52:int rank() -> rank
neureka.ndim.iterators.types.complex.main.ComplexD2CIterator -> neureka.ndim.iterators.types.complex.main.ComplexD2CIterator:
    int _d1 -> _d1
    int _d2 -> _d2
    8:13:void <init>(neureka.ndim.config.types.complex.ComplexD2Configuration) -> <init>
    18:23:void increment() -> increment
    27:31:void decrement() -> decrement
    35:35:int i() -> i
    40:40:int get(int) -> get
    45:45:int[] get() -> get
    50:52:void set(int,int) -> set
    56:58:void set(int[]) -> set
neureka.ndim.iterators.types.complex.main.ComplexD3CIterator -> neureka.ndim.iterators.types.complex.main.ComplexD3CIterator:
    int _d1 -> _d1
    int _d2 -> _d2
    int _d3 -> _d3
    8:14:void <init>(neureka.ndim.config.types.complex.ComplexD3Configuration) -> <init>
    19:28:void increment() -> increment
    32:38:void decrement() -> decrement
    42:42:int i() -> i
    47:47:int get(int) -> get
    52:52:int[] get() -> get
    57:60:void set(int,int) -> set
    64:67:void set(int[]) -> set
neureka.ndim.iterators.types.simple.SimpleD1CIterator -> neureka.ndim.iterators.types.simple.SimpleD1CIterator:
    int _d1 -> a
    12:13:void <init>(neureka.ndim.config.types.simple.SimpleD1Configuration) -> <init>
    18:19:void increment() -> increment
    23:24:void decrement() -> decrement
    29:29:int i() -> i
    34:34:int get(int) -> get
    39:39:int[] get() -> get
    44:45:void set(int,int) -> set
    49:50:void set(int[]) -> set
    54:54:int rank() -> rank
neureka.ndim.iterators.types.simple.main.SimpleD2CIterator -> neureka.ndim.iterators.types.simple.main.SimpleD2CIterator:
    int _d1 -> _d1
    int _d2 -> _d2
    8:13:void <init>(neureka.ndim.config.types.simple.SimpleD2Configuration) -> <init>
    17:22:void increment() -> increment
    26:30:void decrement() -> decrement
    34:34:int i() -> i
    39:39:int get(int) -> get
    44:44:int[] get() -> get
    49:51:void set(int,int) -> set
    55:57:void set(int[]) -> set
neureka.ndim.iterators.types.simple.main.SimpleD3CIterator -> neureka.ndim.iterators.types.simple.main.SimpleD3CIterator:
    int _d1 -> _d1
    int _d2 -> _d2
    int _d3 -> _d3
    8:14:void <init>(neureka.ndim.config.types.simple.SimpleD3Configuration) -> <init>
    19:28:void increment() -> increment
    32:38:void decrement() -> decrement
    42:42:int i() -> i
    47:47:int get(int) -> get
    52:52:int[] get() -> get
    57:60:void set(int,int) -> set
    64:67:void set(int[]) -> set
neureka.optimization.Optimizer -> neureka.optimization.Optimizer:
    void optimize(neureka.Tsr) -> optimize
neureka.optimization.implementations.ADAM -> neureka.optimization.implementations.ADAM:
    neureka.Tsr a -> a
    neureka.Tsr b1 -> b
    neureka.Tsr b2 -> c
    neureka.Tsr e -> d
    neureka.Tsr m -> e
    neureka.Tsr v -> f
    74:75:void optimize(neureka.Tsr) -> optimize
    1063:1070:void _optimize(neureka.Tsr):63:70 -> optimize
    1063:1070:void optimize(neureka.Tsr):74 -> optimize
    80:80:void update(neureka.Tsr,neureka.Tsr) -> update
    42:42:void update(java.lang.Object,java.lang.Object) -> update
neureka.optimization.implementations.SGD -> neureka.optimization.implementations.SGD:
    double _learningRate -> a
    neureka.calculus.Function _function -> b
    48:51:void <init>(double) -> <init>
    55:57:void optimize(neureka.Tsr) -> optimize
    60:60:double learningRate() -> learningRate
    66:66:void update(neureka.Tsr,neureka.Tsr) -> update
    42:42:void update(java.lang.Object,java.lang.Object) -> update
neureka.optimization.implementations.Template -> neureka.optimization.implementations.Template:
    5:5:void <init>() -> <init>
neureka.utility.CustomCleaner -> neureka.utility.CustomCleaner:
    java.lang.ref.ReferenceQueue _referenceQueue -> a
    int _registered -> b
    java.util.List list -> c
    8:14:void <init>() -> <init>
    31:36:void register(java.lang.Object,java.lang.Runnable) -> register
    40:53:void run() -> run
neureka.utility.CustomCleaner$ReferenceWithCleanup -> neureka.utility.CustomCleaner$a:
    java.lang.Runnable _action -> a
    20:23:void <init>(neureka.utility.CustomCleaner,java.lang.Object,java.lang.Runnable,java.lang.ref.ReferenceQueue) -> <init>
    25:26:void cleanup() -> a
neureka.utility.DataConverter -> neureka.utility.DataConverter:
    java.util.Map _converters -> a
    neureka.utility.DataConverter _instance -> b
    93:93:neureka.utility.DataConverter instance() -> instance
    102:151:void <init>() -> <init>
    167:180:void _set(java.lang.Class,java.lang.Class,neureka.utility.DataConverter$Conversion) -> a
    193:195:java.lang.Object convert(java.lang.Object,java.lang.Class) -> convert
    147:147:long[] lambda$new$5(java.util.List) -> a
    147:147:long lambda$new$4(java.lang.Object) -> a
    146:146:double[] lambda$new$3(java.util.List) -> b
    146:146:double lambda$new$2(java.lang.Object) -> b
    145:145:int[] lambda$new$1(java.util.List) -> c
    145:145:int lambda$new$0(java.lang.Object) -> c
    79:85:void <clinit>() -> <clinit>
neureka.utility.DataConverter$Conversion -> neureka.utility.DataConverter$a:
    java.lang.Object go(java.lang.Object) -> go
neureka.utility.DataConverter$Utility -> neureka.utility.DataConverter$Utility:
    204:204:void <init>() -> <init>
    208:208:double[] newSeededDoubleArray(java.lang.String,int) -> newSeededDoubleArray
    212:212:double[] newSeededDoubleArray(long,int) -> newSeededDoubleArray
    216:216:double[] seededDoubleArray(double[],java.lang.String) -> seededDoubleArray
    220:223:double[] seededDoubleArray(double[],long) -> seededDoubleArray
    227:227:float[] newSeededFloatArray(java.lang.String,int) -> newSeededFloatArray
    231:231:float[] newSeededFloatArray(long,int) -> newSeededFloatArray
    235:235:float[] seededFloatArray(float[],java.lang.String) -> seededFloatArray
    239:242:float[] seededFloatArray(float[],long) -> seededFloatArray
    247:250:long _longStringHash(java.lang.String) -> a
    255:258:short[] byteToShort(byte[]) -> byteToShort
    262:265:java.math.BigInteger[] byteToBigInteger(byte[]) -> byteToBigInteger
    269:272:float[] doubleToFloat(double[]) -> doubleToFloat
    276:279:byte[] doubleToByte(double[]) -> doubleToByte
    283:286:short[] doubleToShort(double[]) -> doubleToShort
    290:293:long[] doubleToLong(double[]) -> doubleToLong
    297:300:double[] floatToDouble(float[]) -> floatToDouble
    304:307:byte[] floatToByte(float[]) -> floatToByte
    311:314:short[] floatToShort(float[]) -> floatToShort
    318:321:long[] floatToLong(float[]) -> floatToLong
    325:328:double[] shortToDouble(short[]) -> shortToDouble
    332:335:double[] byteToDouble(byte[]) -> byteToDouble
    339:342:float[] byteToFloat(byte[]) -> byteToFloat
    346:349:float[] shortToFloat(short[]) -> shortToFloat
    353:356:int[] byteToInt(byte[]) -> byteToInt
    360:363:int[] shortToInt(short[]) -> shortToInt
    367:370:byte[] shortToByte(short[]) -> shortToByte
    374:377:long[] byteToLong(byte[]) -> byteToLong
    381:384:long[] shortToLong(short[]) -> shortToLong
    388:391:java.math.BigInteger[] shortToBigInteger(short[]) -> shortToBigInteger
    395:398:float[] intToFloat(int[]) -> intToFloat
    402:405:int[] floatToInt(float[]) -> floatToInt
    409:412:java.math.BigInteger[] floatToBigInteger(float[]) -> floatToBigInteger
    416:419:int[] doubleToInt(double[]) -> doubleToInt
    423:426:java.math.BigInteger[] doubleToBigInteger(double[]) -> doubleToBigInteger
    430:433:double[] intToDouble(int[]) -> intToDouble
    437:440:long[] intToLong(int[]) -> intToLong
    444:447:short[] intToShort(int[]) -> intToShort
    451:454:byte[] intToByte(int[]) -> intToByte
    458:461:java.math.BigInteger[] intToBigInteger(int[]) -> intToBigInteger
    465:468:byte[] longToByte(long[]) -> longToByte
    472:475:short[] longToShort(long[]) -> longToShort
    479:482:int[] longToInt(long[]) -> longToInt
    486:489:float[] longToFloat(long[]) -> longToFloat
    494:497:double[] longToDouble(long[]) -> longToDouble
    502:505:java.math.BigInteger[] longToBigInteger(long[]) -> longToBigInteger
    512:519:double[] objectsToDoubles(java.lang.Object[],int) -> objectsToDoubles
    524:531:float[] objectsToFloats(java.lang.Object[],int) -> objectsToFloats
    536:543:short[] objectsToShorts(java.lang.Object[],int) -> objectsToShorts
    548:555:int[] objectsToInts(java.lang.Object[],int) -> objectsToInts
neureka.utility.NeurekaCleaner -> neureka.utility.NeurekaCleaner:
    void register(java.lang.Object,java.lang.Runnable) -> register
neureka.utility.SettingsLoader -> neureka.utility.SettingsLoader:
    java.lang.String _settings_source -> a
    java.lang.String _setup_source -> b
    55:55:void <init>() -> <init>
    61:62:java.lang.Object tryGroovyClosureOn(java.lang.Object,java.lang.Object) -> tryGroovyClosureOn
    67:86:void tryGroovyScriptsOn(neureka.Neureka) -> tryGroovyScriptsOn
neureka.utility.TsrAsString -> neureka.utility.TsrAsString:
    int _padding -> a
    int _shortage -> b
    boolean _hasGradient -> c
    boolean _isCompact -> d
    boolean _isFormatted -> e
    boolean _hasValue -> f
    boolean _hasShape -> g
    boolean _hasRecursiveGraph -> h
    boolean _hasDerivatives -> i
    boolean _isCellBound -> j
    int[] _shape -> k
    neureka.Tsr _tensor -> l
    java.lang.StringBuilder _asStr -> m
    boolean _legacy -> n
    java.util.Map _config -> o
    boolean $assertionsDisabled -> p
    81:105:void <init>(neureka.Tsr,java.util.Map) -> <init>
    81:113:void <init>(neureka.Tsr,java.lang.String) -> <init>
    81:121:void <init>(neureka.Tsr) -> <init>
    125:158:void _construct(neureka.Tsr,java.util.Map) -> a
    171:172:neureka.utility.TsrAsString _$(java.lang.String) -> a
    186:187:neureka.utility.TsrAsString _$(int) -> a
    202:249:neureka.utility.TsrAsString$ValStringifier _createValStringifier(java.lang.Object) -> a
    254:254:java.lang.String toString() -> toString
    259:311:java.lang.String toString(java.lang.String) -> toString
    316:327:void _stringifyAllValues() -> a
    343:352:void _buildRow(int,int,int,int[],java.util.function.Function,java.lang.String) -> a
    368:432:void _recursiveFormatting(int[],int) -> a
    435:445:neureka.utility.TsrAsString _buildSingleLabel(neureka.framing.IndexAlias,int,int[]) -> a
    454:461:void _strShape() -> b
    81:81:int getPadding() -> getPadding
    82:82:int getShortage() -> getShortage
    83:83:boolean isHasGradient() -> isHasGradient
    84:84:boolean isCompact() -> isCompact
    85:85:boolean isFormatted() -> isFormatted
    86:86:boolean isHasValue() -> isHasValue
    87:87:boolean isHasShape() -> isHasShape
    88:88:boolean isHasRecursiveGraph() -> isHasRecursiveGraph
    89:89:boolean isHasDerivatives() -> isHasDerivatives
    90:90:boolean isCellBound() -> isCellBound
    405:405:java.lang.String lambda$_recursiveFormatting$12(neureka.utility.TsrAsString$ValStringifier,int[]) -> a
    404:404:java.lang.String lambda$_recursiveFormatting$11(neureka.utility.TsrAsString$ValStringifier,int[]) -> b
    391:391:java.lang.String lambda$_recursiveFormatting$10(neureka.utility.TsrAsString$ValStringifier,int[]) -> c
    306:308:void lambda$toString$9(java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    288:299:void lambda$toString$8(java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    242:245:java.lang.String lambda$_createValStringifier$7(neureka.utility.TsrAsString$ValStringifier,int,int) -> a
    232:236:java.lang.String lambda$_createValStringifier$6(neureka.utility.TsrAsString$ValStringifier,int,int) -> b
    228:228:java.lang.String lambda$_createValStringifier$5(java.lang.Object,int) -> a
    224:226:java.lang.String lambda$_createValStringifier$4(boolean,int) -> a
    220:222:java.lang.String lambda$_createValStringifier$3(boolean,java.lang.Object,int) -> a
    216:218:java.lang.String lambda$_createValStringifier$2(boolean,java.lang.Object,int) -> b
    212:214:java.lang.String lambda$_createValStringifier$1(boolean,java.lang.Object,int) -> c
    208:210:java.lang.String lambda$_createValStringifier$0(boolean,java.lang.Object,int) -> d
    61:61:void <clinit>() -> <clinit>
neureka.utility.TsrAsString$Should -> neureka.utility.TsrAsString$Should:
    neureka.utility.TsrAsString$Should BE_FORMATTED -> BE_FORMATTED
    neureka.utility.TsrAsString$Should HAVE_PADDING_OF -> HAVE_PADDING_OF
    neureka.utility.TsrAsString$Should BE_COMPACT -> BE_COMPACT
    neureka.utility.TsrAsString$Should HAVE_GRADIENT -> HAVE_GRADIENT
    neureka.utility.TsrAsString$Should BE_SHORTENED_BY -> BE_SHORTENED_BY
    neureka.utility.TsrAsString$Should HAVE_VALUE -> HAVE_VALUE
    neureka.utility.TsrAsString$Should HAVE_SHAPE -> HAVE_SHAPE
    neureka.utility.TsrAsString$Should HAVE_DERIVATIVES -> HAVE_DERIVATIVES
    neureka.utility.TsrAsString$Should HAVE_RECURSIVE_GRAPH -> HAVE_RECURSIVE_GRAPH
    neureka.utility.TsrAsString$Should BE_CELL_BOUND -> BE_CELL_BOUND
    neureka.utility.TsrAsString$Should[] $VALUES -> a
    64:64:neureka.utility.TsrAsString$Should[] values() -> values
    64:64:neureka.utility.TsrAsString$Should valueOf(java.lang.String) -> valueOf
    64:64:void <init>(java.lang.String,int) -> <init>
    64:74:void <clinit>() -> <clinit>
neureka.utility.TsrAsString$Util -> neureka.utility.TsrAsString$Util:
    468:468:void <init>() -> <init>
    472:472:java.lang.String indent(int) -> indent
    477:477:java.lang.String pad(int,java.lang.String) -> pad
    482:482:java.lang.String pad(java.lang.String,int) -> pad
    488:503:java.lang.String formatFP(double) -> formatFP
    509:522:java.util.Map configFromCode(java.lang.String) -> configFromCode
neureka.utility.TsrAsString$ValStringifier -> neureka.utility.TsrAsString$a:
    java.lang.String stringify(int) -> stringify
