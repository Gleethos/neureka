neureka.Neureka -> neureka.Neureka:
    java.lang.ThreadLocal _INSTANCES -> a
    org.slf4j.Logger _LOG -> b
    java.lang.String _VERSION -> c
    boolean _OPENCL_AVAILABLE -> d
    neureka.Neureka$Settings _settings -> e
    neureka.Neureka$Utility _utility -> f
    neureka.backend.api.BackendContext _backend -> g
    boolean $assertionsDisabled -> h
    104:130:neureka.backend.api.BackendContext backend() -> backend
    134:137:java.lang.String _illegalStateFor(java.lang.String) -> a
    141:144:void <init>() -> <init>
    155:163:neureka.Neureka get() -> get
    177:178:void set(neureka.Neureka) -> set
    187:189:neureka.Neureka configure(java.lang.Object) -> configure
    195:195:boolean canAccessOpenCL() -> canAccessOpenCL
    200:200:neureka.Neureka$Settings settings() -> settings
    206:207:neureka.Neureka$Settings settings(java.lang.Object) -> settings
    213:213:neureka.Neureka$Utility utility() -> utility
    218:218:java.lang.String version() -> version
    227:236:void reset() -> reset
    241:241:java.lang.String toString() -> toString
    248:248:neureka.backend.api.BackendContext getBackend() -> getBackend
    250:250:void setBackend(neureka.backend.api.BackendContext) -> setBackend
    69:69:boolean access$100(neureka.Neureka) -> a
    1238:1238:boolean _currentThreadIsNotAuthorized():238:238 -> a
    1238:1238:boolean access$100(neureka.Neureka):69 -> a
    69:69:org.slf4j.Logger access$200() -> a
    69:88:void <clinit>() -> <clinit>
neureka.Neureka$Settings -> neureka.Neureka$Settings:
    neureka.Neureka$Settings$Debug _debug -> b
    neureka.Neureka$Settings$AutoGrad _autograd -> c
    neureka.Neureka$Settings$View _view -> d
    neureka.Neureka$Settings$NDim _ndim -> e
    neureka.Neureka$Settings$DType _dtype -> f
    boolean _isLocked -> g
    neureka.Neureka this$0 -> a
    263:271:void <init>(neureka.Neureka) -> <init>
    284:284:neureka.Neureka$Settings$Debug debug() -> debug
    290:291:neureka.Neureka$Settings$Debug debug(java.lang.Object) -> debug
    294:294:neureka.Neureka$Settings$AutoGrad autograd() -> autograd
    300:301:neureka.Neureka$Settings$AutoGrad autograd(java.lang.Object) -> autograd
    304:304:neureka.Neureka$Settings$View view() -> view
    307:308:neureka.Neureka$Settings$View view(java.lang.Object) -> view
    311:311:neureka.Neureka$Settings$NDim ndim() -> ndim
    317:318:neureka.Neureka$Settings$NDim ndim(java.lang.Object) -> ndim
    321:321:neureka.Neureka$Settings$DType dtype() -> dtype
    327:328:neureka.Neureka$Settings$DType dtype(java.lang.Object) -> dtype
    336:336:boolean isLocked() -> isLocked
    344:344:void setIsLocked(boolean) -> setIsLocked
    347:353:java.lang.String toString() -> toString
    255:255:void <init>(neureka.Neureka,byte) -> <init>
    255:255:boolean access$300(neureka.Neureka$Settings) -> a
    1274:1281:boolean notModifiable():274:281 -> a
    1274:1281:boolean access$300(neureka.Neureka$Settings):255 -> a
    255:255:boolean access$400(neureka.Neureka$Settings) -> b
neureka.Neureka$Settings$AutoGrad -> neureka.Neureka$Settings$AutoGrad:
    boolean _isPreventingInlineOperations -> a
    boolean _isRetainingPendingErrorForJITProp -> b
    boolean _isApplyingGradientWhenTensorIsUsed -> c
    boolean _isApplyingGradientWhenRequested -> d
    neureka.Neureka$Settings this$1 -> e
    433:438:void <init>(neureka.Neureka$Settings) -> <init>
    445:445:boolean isPreventingInlineOperations() -> isPreventingInlineOperations
    453:455:void setIsPreventingInlineOperations(boolean) -> setIsPreventingInlineOperations
    467:467:boolean isRetainingPendingErrorForJITProp() -> isRetainingPendingErrorForJITProp
    480:482:void setIsRetainingPendingErrorForJITProp(boolean) -> setIsRetainingPendingErrorForJITProp
    489:489:boolean isApplyingGradientWhenTensorIsUsed() -> isApplyingGradientWhenTensorIsUsed
    499:501:void setIsApplyingGradientWhenTensorIsUsed(boolean) -> setIsApplyingGradientWhenTensorIsUsed
    525:525:boolean isApplyingGradientWhenRequested() -> isApplyingGradientWhenRequested
    536:538:void setIsApplyingGradientWhenRequested(boolean) -> setIsApplyingGradientWhenRequested
    541:545:java.lang.String toString() -> toString
neureka.Neureka$Settings$DType -> neureka.Neureka$Settings$DType:
    java.lang.Class _defaultDataTypeClass -> a
    boolean _isAutoConvertingExternalDataToJVMTypes -> b
    neureka.Neureka$Settings this$1 -> c
    608:612:void <init>(neureka.Neureka$Settings) -> <init>
    619:619:java.lang.Class getDefaultDataTypeClass() -> getDefaultDataTypeClass
    627:629:void setDefaultDataTypeClass(java.lang.Class) -> setDefaultDataTypeClass
    637:637:boolean getIsAutoConvertingExternalDataToJVMTypes() -> getIsAutoConvertingExternalDataToJVMTypes
    646:648:void setIsAutoConvertingExternalDataToJVMTypes(boolean) -> setIsAutoConvertingExternalDataToJVMTypes
    651:652:java.lang.String toString() -> toString
neureka.Neureka$Settings$Debug -> neureka.Neureka$Settings$Debug:
    boolean _isKeepingDerivativeTargetPayloads -> a
    boolean _isDeletingIntermediateTensors -> b
    neureka.Neureka$Settings this$1 -> c
    358:361:void <init>(neureka.Neureka$Settings) -> <init>
    378:378:boolean isKeepingDerivativeTargetPayloads() -> isKeepingDerivativeTargetPayloads
    396:398:void setIsKeepingDerivativeTargetPayloads(boolean) -> setIsKeepingDerivativeTargetPayloads
    409:409:boolean isDeletingIntermediateTensors() -> isDeletingIntermediateTensors
    421:423:void setIsDeletingIntermediateTensors(boolean) -> setIsDeletingIntermediateTensors
    426:427:java.lang.String toString() -> toString
neureka.Neureka$Settings$NDim -> neureka.Neureka$Settings$NDim:
    boolean _isOnlyUsingDefaultNDConfiguration -> a
    neureka.Neureka$Settings this$1 -> b
    584:591:void <init>(neureka.Neureka$Settings) -> <init>
    593:593:boolean isOnlyUsingDefaultNDConfiguration() -> isOnlyUsingDefaultNDConfiguration
    596:598:void setIsOnlyUsingDefaultNDConfiguration(boolean) -> setIsOnlyUsingDefaultNDConfiguration
    601:602:java.lang.String toString() -> toString
neureka.Neureka$Settings$View -> neureka.Neureka$Settings$View:
    neureka.view.TsrStringSettings _settings -> a
    557:559:void <init>(neureka.Neureka$Settings) -> <init>
    564:564:neureka.view.TsrStringSettings getTensorSettings() -> getTensorSettings
    574:574:void tensors(java.util.function.Consumer) -> tensors
    577:578:java.lang.String toString() -> toString
    558:558:java.lang.Boolean lambda$new$0(neureka.Neureka$Settings) -> a
neureka.Neureka$Utility -> neureka.Neureka$Utility:
    660:660:void <init>() -> <init>
    671:683:java.lang.String readResource(java.lang.String) -> readResource
    694:710:boolean isPresent(java.lang.String) -> isPresent
neureka.Tsr -> neureka.Tsr:
    neureka.devices.Device _CPU -> a
    byte _flags -> b
    int _version -> c
    boolean $assertionsDisabled -> d
    218:218:neureka.Tsr newInstance() -> newInstance
    168:229:void <init>() -> <init>
    238:238:neureka.Tsr of(java.lang.Object[]) -> of
    242:309:neureka.Tsr _of(java.lang.Object[]) -> a
    330:331:neureka.Tsr of(java.util.List,java.lang.Object) -> of
    345:347:neureka.Tsr of(java.util.List,java.lang.String) -> of
    360:364:neureka.Tsr of(java.util.List,java.util.List) -> of
    379:382:neureka.Tsr of(int[],java.util.List) -> of
    396:396:neureka.Tsr of(java.util.List) -> of
    410:433:neureka.Tsr of(java.lang.Class,java.util.List) -> of
    442:442:neureka.Tsr ofShape(java.util.List) -> ofShape
    451:452:neureka.Tsr ofShape(java.lang.Number[]) -> ofShape
    168:460:void <init>(java.util.List) -> <init>
    477:477:neureka.fluent.building.states.WithShapeOrScalarOrVectorOnDevice of(java.lang.Class) -> of
    488:488:neureka.fluent.building.states.WithShapeOrScalarOrVectorOnDevice ofDoubles() -> ofDoubles
    499:499:neureka.fluent.building.states.WithShapeOrScalarOrVectorOnDevice ofFloats() -> ofFloats
    510:510:neureka.fluent.building.states.WithShapeOrScalarOrVectorOnDevice ofInts() -> ofInts
    521:521:neureka.fluent.building.states.WithShapeOrScalarOrVectorOnDevice ofShorts() -> ofShorts
    532:532:neureka.fluent.building.states.WithShapeOrScalarOrVectorOnDevice ofBytes() -> ofBytes
    538:538:neureka.Tsr of(double) -> of
    168:540:void <init>(double) -> <init>
    548:548:neureka.Tsr of(float[]) -> of
    168:550:void <init>(float[]) -> <init>
    558:558:neureka.Tsr of(double[]) -> of
    168:560:void <init>(double[]) -> <init>
    568:568:neureka.Tsr of(byte[]) -> of
    168:570:void <init>(byte[]) -> <init>
    578:578:neureka.Tsr of(int[]) -> of
    168:580:void <init>(int[],int[]) -> <init>
    588:588:neureka.Tsr of(long[]) -> of
    168:590:void <init>(int[],long[]) -> <init>
    598:598:neureka.Tsr of(short[]) -> of
    168:600:void <init>(int[],short[]) -> <init>
    602:602:neureka.Tsr of(java.lang.Class,int[],java.lang.String) -> of
    610:610:neureka.Tsr of(boolean[]) -> of
    168:612:void <init>(int[],boolean[]) -> <init>
    168:620:void <init>(java.lang.Class,int[],java.lang.String) -> <init>
    622:622:neureka.Tsr ofShape(int[]) -> ofShape
    168:624:void <init>(int[]) -> <init>
    626:626:neureka.Tsr of(int[],double) -> of
    168:628:void <init>(int[],double) -> <init>
    630:630:neureka.Tsr of(int[],double[]) -> of
    168:632:void <init>(int[],double[]) -> <init>
    634:634:neureka.Tsr of(neureka.dtype.DataType,int[]) -> of
    168:641:void <init>(int[],neureka.dtype.DataType) -> <init>
    643:643:neureka.Tsr of(java.lang.Class,int[],java.lang.Object) -> of
    645:645:neureka.Tsr of(java.lang.Class,java.util.List,java.lang.Object) -> of
    648:650:neureka.Tsr of(java.lang.Class,java.util.List,java.util.List) -> of
    668:668:neureka.Tsr of(neureka.dtype.DataType,int[],java.lang.Object) -> of
    168:670:void <init>(int[],neureka.dtype.DataType,java.lang.Object) -> <init>
    673:676:neureka.Tsr of(neureka.dtype.DataType,java.util.List,java.util.List) -> of
    684:685:void _constructAndAllocate(int[],boolean) -> a
    688:694:int[] _intArray(java.lang.Object[]) -> b
    719:721:neureka.Tsr of(neureka.dtype.DataType,java.util.List,neureka.ndim.Filler) -> of
    742:742:neureka.Tsr of(neureka.dtype.DataType,int[],neureka.ndim.Filler) -> of
    168:756:void <init>(int[],neureka.dtype.DataType,neureka.ndim.Filler) -> <init>
    3766:3769:void _constructFromInitializer(int[],neureka.dtype.DataType,neureka.ndim.Filler):766:769 -> <init>
    3766:3769:void <init>(int[],neureka.dtype.DataType,neureka.ndim.Filler):755 -> <init>
    798:798:neureka.Tsr of(java.lang.String,java.lang.Number[]) -> of
    821:824:neureka.Tsr of(java.lang.String,java.util.List) -> of
    846:846:neureka.Tsr of(java.lang.String,neureka.Tsr) -> of
    867:867:neureka.Tsr of(java.lang.String,neureka.Tsr[]) -> of
    895:895:neureka.Tsr of(java.lang.String,boolean,neureka.Tsr[]) -> of
    921:923:neureka.Tsr setRqsGradient(boolean) -> setRqsGradient
    935:935:boolean rqsGradient() -> rqsGradient
    938:942:void _setRqsGradient(boolean) -> _setRqsGradient
    952:952:boolean isIntermediate() -> isIntermediate
    963:967:void _setIsIntermediate(boolean) -> _setIsIntermediate
    987:1029:neureka.Tsr setIsOutsourced(boolean) -> setIsOutsourced
    1038:1038:boolean isOutsourced() -> isOutsourced
    1041:1045:void _setIsOutsourced(boolean) -> _setIsOutsourced
    1071:1118:neureka.Tsr setIsVirtual(boolean) -> setIsVirtual
    1134:1134:boolean isVirtual() -> isVirtual
    1144:1148:void _setIsVirtual(boolean) -> _setIsVirtual
    1173:1185:neureka.Tsr setGradientApplyRequested(boolean) -> setGradientApplyRequested
    1203:1203:boolean gradientApplyRequested() -> gradientApplyRequested
    1220:1220:boolean isDeleted() -> isDeleted
    1277:1277:neureka.common.composition.Component _setOrReject(neureka.common.composition.Component) -> _setOrReject
    1297:1318:neureka.common.composition.Component _removeOrReject(neureka.common.composition.Component) -> _removeOrReject
    1334:1349:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    1359:1359:neureka.Tsr to(neureka.devices.Device) -> to
    1378:1378:boolean isEmpty() -> isEmpty
    1387:1387:boolean isUndefined() -> isUndefined
    1396:1397:boolean isSlice() -> isSlice
    1409:1410:int sliceCount() -> sliceCount
    1420:1421:boolean isSliceParent() -> isSliceParent
    1434:1434:boolean belongsToGraph() -> belongsToGraph
    1446:1446:boolean isLeave() -> isLeave
    1458:1458:boolean isBranch() -> isBranch
    1466:1466:boolean hasGradient() -> hasGradient
    1477:1477:neureka.Tsr getGradient() -> getGradient
    1483:1484:neureka.devices.Device getDevice() -> getDevice
    1490:1490:neureka.autograd.GraphNode getGraphNode() -> getGraphNode
    1495:1495:neureka.framing.NDFrame frame() -> frame
    1558:1564:void _assignIfActual(java.util.function.Supplier) -> a
    1626:1636:neureka.Tsr _become(neureka.Tsr) -> _become
    1656:1657:java.util.Iterator iterator() -> iterator
    1699:1708:neureka.Tsr backward(neureka.Tsr) -> backward
    1727:1728:neureka.Tsr backward(double) -> backward
    1746:1747:neureka.Tsr backward() -> backward
    1762:1784:void applyGradient() -> applyGradient
    1795:1795:neureka.Tsr detach() -> detach
    1823:1824:neureka.Tsr label(java.lang.String[][]) -> label
    1848:1849:neureka.Tsr label(java.lang.String,java.lang.String[][]) -> label
    1861:1877:void _label(java.lang.String,java.lang.String[][]) -> a
    1897:1900:neureka.Tsr label(java.util.List) -> label
    1922:1925:neureka.Tsr label(java.lang.String,java.util.List) -> label
    1946:1948:neureka.Tsr label(java.util.Map) -> label
    1953:1955:neureka.Tsr label(java.lang.String,java.util.Map) -> label
    1987:1988:neureka.Tsr plus(neureka.Tsr) -> plus
    1992:1993:neureka.Tsr plusAssign(neureka.Tsr) -> plusAssign
    2006:2006:neureka.Tsr plus(double) -> plus
    2025:2026:neureka.Tsr minus(neureka.Tsr) -> minus
    2030:2034:neureka.Tsr minus(java.lang.Object) -> minus
    2039:2040:neureka.Tsr minusAssign(neureka.Tsr) -> minusAssign
    2044:2048:neureka.Tsr minusAssign(java.lang.Object) -> minusAssign
    2056:2056:neureka.Tsr negative() -> negative
    2077:2078:neureka.Tsr multiply(neureka.Tsr) -> multiply
    2086:2090:neureka.Tsr multiply(java.lang.Object) -> multiply
    2112:2113:neureka.Tsr times(neureka.Tsr) -> times
    2121:2122:neureka.Tsr times(java.lang.Object) -> times
    2130:2131:neureka.Tsr timesAssign(neureka.Tsr) -> timesAssign
    2139:2140:neureka.Tsr timesAssign(java.lang.Object) -> timesAssign
    2148:2148:neureka.Tsr multiply(double) -> multiply
    2167:2168:neureka.Tsr div(neureka.Tsr) -> div
    2171:2171:neureka.Tsr div(double) -> div
    2174:2175:neureka.Tsr divAssign(neureka.Tsr) -> divAssign
    2195:2196:neureka.Tsr mod(neureka.Tsr) -> mod
    2199:2199:neureka.Tsr mod(int) -> mod
    2201:2201:neureka.Tsr rem(int) -> rem
    2204:2205:neureka.Tsr modAssign(neureka.Tsr) -> modAssign
    2225:2226:neureka.Tsr power(neureka.Tsr) -> power
    2230:2230:neureka.Tsr power(double) -> power
    2237:2238:neureka.Tsr xor(neureka.Tsr) -> xor
    2242:2242:neureka.Tsr xor(double) -> xor
    2258:2269:neureka.Tsr T() -> T
    2279:2279:neureka.Tsr getT() -> getT
    2291:2303:neureka.Tsr mean() -> mean
    2314:2329:neureka.Tsr convDot(neureka.Tsr) -> convDot
    2342:2345:neureka.Tsr dot(neureka.Tsr) -> dot
    2357:2364:neureka.Tsr matMul(neureka.Tsr) -> matMul
    2377:2377:neureka.Tsr dimtrim() -> dimtrim
    2389:2394:boolean isCase(neureka.Tsr) -> isCase
    2407:2408:boolean contains(neureka.Tsr) -> contains
    2433:2434:neureka.Tsr getAt(int[]) -> getAt
    2447:2448:neureka.Tsr getAt(java.lang.Object[]) -> getAt
    2471:2473:neureka.Tsr getAt(java.util.Map) -> getAt
    2487:2494:neureka.Tsr shallowCopy() -> shallowCopy
    2507:2542:neureka.Tsr getAt(java.lang.Object) -> getAt
    2557:2568:neureka.Tsr clone() -> clone
    2587:2587:neureka.fluent.slicing.SliceBuilder slice() -> slice
    2603:2688:neureka.Tsr _sliceOf(int[],int[],int[]) -> a
    2710:2712:neureka.Tsr putAt(java.util.List,neureka.Tsr) -> putAt
    2725:2735:neureka.Tsr putAt(int[],java.lang.Object) -> putAt
    2759:2761:neureka.Tsr putAt(java.util.Map,neureka.Tsr) -> putAt
    2765:2770:void _putAtCheckFor(neureka.Tsr) -> b
    2774:2793:neureka.Tsr _putAt(neureka.Tsr,neureka.Tsr) -> a
    2805:2820:java.lang.Object getDataAt(int) -> getDataAt
    2832:2834:neureka.Tsr setDataAt(int,java.lang.Object) -> setDataAt
    2847:2850:neureka.Tsr setValueAt(int,java.lang.Object) -> setValueAt
    2854:2863:void _setDataAt(int,java.lang.Object) -> a
    2907:2942:neureka.Tsr setValue(java.lang.Object) -> setValue
    3884:3893:void _setValue32(float[]):2884:2893 -> setValue
    3884:3893:neureka.Tsr setValue(java.lang.Object):2907 -> setValue
    4869:4878:void _setValue64(double[]):2869:2878 -> setValue
    4869:4878:neureka.Tsr setValue(java.lang.Object):2908 -> setValue
    2946:2954:java.lang.Object getValue() -> getValue
    2968:2977:neureka.Tsr mapTo(java.lang.Class,java.util.function.Function) -> mapTo
    3051:3078:java.awt.image.BufferedImage asImage(neureka.Tsr$ImageType) -> asImage
    3082:3106:void _checkRankForImageConversion(neureka.Tsr$ImageType,java.lang.Class,int[]) -> a
    3109:3112:void writeImgData(java.awt.image.DataBuffer,java.awt.image.BufferedImage) -> a
    3122:3145:neureka.Tsr addToGradient(neureka.Tsr) -> addToGradient
    3168:3178:neureka.Tsr asType(java.lang.Class) -> asType
    3204:3215:neureka.Tsr _toType(java.lang.Class) -> a
    3219:3226:java.lang.Object getValueAs(java.lang.Class) -> getValueAs
    5237:5251:double[] _value64():3237:3251 -> getValueAs
    5237:5251:java.lang.Object getValueAs(java.lang.Class):3219 -> getValueAs
    5255:5265:float[] _value32():3255:3265 -> getValueAs
    5255:5265:java.lang.Object getValueAs(java.lang.Class):3220 -> getValueAs
    3230:3233:java.lang.Object getDataAs(java.lang.Class) -> getDataAs
    3271:3271:java.lang.String toString(java.lang.String) -> toString
    3275:3278:java.lang.String toString(neureka.view.TsrStringSettings) -> toString
    3291:3294:java.lang.String toString(java.util.function.Consumer) -> toString
    3300:3303:java.lang.String _toString(java.lang.String) -> _toString
    3309:3312:java.lang.String toString() -> toString
    3319:3319:int getVersion() -> getVersion
    3330:3332:neureka.fluent.building.states.IterByOrIterFromOrAll like(neureka.Tsr) -> like
    3349:3352:neureka.Tsr ofRandom(java.lang.Class,int[]) -> ofRandom
    3364:3365:neureka.ndim.AbstractTensor$Unsafe getUnsafe() -> getUnsafe
    150:150:java.lang.Object setIsVirtual(boolean) -> setIsVirtual
    150:150:java.lang.Object clone() -> clone
    3214:3214:void lambda$_toType$44(java.lang.Class,neureka.Tsr) -> a
    3139:3144:void lambda$addToGradient$43(neureka.Tsr,neureka.devices.Device) -> a
    3127:3128:void lambda$addToGradient$42(neureka.Tsr,neureka.Tsr) -> b
    3129:3133:neureka.Tsr lambda$addToGradient$41(neureka.Tsr,neureka.Tsr) -> c
    3093:3093:java.lang.String lambda$_checkRankForImageConversion$40(java.lang.Integer) -> a
    2978:3038:neureka.Tsr lambda$mapTo$39(java.lang.Class,java.util.function.Function) -> a
    3032:3032:java.lang.Object lambda$mapTo$38(java.util.function.Function,byte[],java.lang.Integer) -> a
    3029:3029:java.lang.Object lambda$mapTo$37(java.util.function.Function,short[],java.lang.Integer) -> a
    3026:3026:java.lang.Object lambda$mapTo$36(java.util.function.Function,float[],java.lang.Integer) -> a
    3023:3023:java.lang.Object lambda$mapTo$35(java.util.function.Function,double[],java.lang.Integer) -> a
    3020:3020:java.lang.Object lambda$mapTo$34(java.util.function.Function,int[],java.lang.Integer) -> a
    3004:3004:java.lang.Number lambda$mapTo$33(java.util.function.Function,byte[],java.lang.Integer) -> b
    3001:3001:java.lang.Number lambda$mapTo$32(java.util.function.Function,short[],java.lang.Integer) -> b
    2998:2998:java.lang.Number lambda$mapTo$31(java.util.function.Function,float[],java.lang.Integer) -> b
    2995:2995:java.lang.Number lambda$mapTo$30(java.util.function.Function,double[],java.lang.Integer) -> b
    2992:2992:java.lang.Number lambda$mapTo$29(java.util.function.Function,int[],java.lang.Integer) -> b
    2733:2733:java.lang.Integer lambda$putAt$28(int) -> a
    2391:2391:void lambda$isCase$27(neureka.Tsr,boolean[],neureka.framing.Relation) -> a
    2392:2393:void lambda$isCase$26(neureka.Tsr,boolean[],java.lang.Object) -> a
    1770:1782:void lambda$applyGradient$25(neureka.Tsr) -> c
    1705:1705:void lambda$backward$24(neureka.Tsr,neureka.autograd.GraphNode) -> a
    1561:1561:neureka.Tsr lambda$_assignIfActual$23(neureka.Tsr) -> d
    1543:1543:neureka.Tsr lambda$_fromRMToCM$22() -> a
    1536:1536:neureka.Tsr lambda$_fromCMToRM$21(neureka.Tsr) -> e
    1247:1247:void lambda$_delete$20(neureka.Tsr) -> f
    1243:1243:void lambda$_delete$19(neureka.devices.Device) -> a
    1237:1242:void lambda$_delete$18(neureka.autograd.GraphNode) -> a
    1097:1099:void lambda$setIsVirtual$17(neureka.Tsr) -> g
    995:1023:void lambda$setIsOutsourced$16(neureka.devices.Device) -> b
    1007:1007:void lambda$setIsOutsourced$15(neureka.Tsr) -> h
    1011:1021:void lambda$setIsOutsourced$14(neureka.Tsr,neureka.devices.Device) -> b
    824:824:neureka.Tsr[] lambda$of$13(int) -> b
    824:824:neureka.Tsr lambda$of$12(java.lang.Object) -> a
    822:822:neureka.Tsr[] lambda$of$11(int) -> c
    821:821:boolean lambda$of$10(java.lang.Object) -> b
    721:721:int lambda$of$9(java.lang.Integer) -> b
    675:675:int lambda$of$8(java.lang.Integer) -> c
    650:650:int lambda$of$7(java.lang.Integer) -> d
    645:645:int lambda$of$6(java.lang.Integer) -> e
    459:459:java.util.List lambda$new$5(java.lang.Object) -> c
    431:431:java.lang.Object lambda$of$4(neureka.common.utility.DataConverter,java.lang.Class,java.lang.Object) -> a
    424:424:int lambda$of$3(java.lang.Integer) -> f
    421:421:java.lang.Object lambda$of$2(java.lang.Object) -> d
    413:415:boolean lambda$of$1(java.lang.Object) -> e
    415:415:boolean lambda$of$0(java.lang.Object) -> f
    150:150:java.lang.Object access$000(neureka.Tsr,neureka.ndim.config.NDConfiguration) -> a
    150:150:neureka.Tsr access$100(neureka.Tsr,java.lang.Class) -> a
    150:150:java.lang.Object access$200(neureka.Tsr,neureka.dtype.DataType) -> a
    150:150:void access$300(neureka.Tsr,neureka.ndim.config.NDConfiguration$Layout) -> a
    5513:5523:void _toLayout(neureka.ndim.config.NDConfiguration$Layout):1513:1523 -> a
    5513:5523:void access$300(neureka.Tsr,neureka.ndim.config.NDConfiguration$Layout):150 -> a
    5529:5537:void _fromCMToRM():1529:1537 -> a
    5529:5537:void _toLayout(neureka.ndim.config.NDConfiguration$Layout):1518 -> a
    5529:5537:void access$300(neureka.Tsr,neureka.ndim.config.NDConfiguration$Layout):150 -> a
    5543:5551:void _fromRMToCM():1543:1551 -> a
    5543:5551:void _toLayout(neureka.ndim.config.NDConfiguration$Layout):1520 -> a
    5543:5551:void access$300(neureka.Tsr,neureka.ndim.config.NDConfiguration$Layout):150 -> a
    5569:5571:neureka.ndim.config.NDConfiguration _createNewNDCFrom(neureka.ndim.config.NDConfiguration,int[],int[]):1569:1571 -> a
    5569:5571:void _fromRMToCM():1550 -> a
    5569:5571:void _toLayout(neureka.ndim.config.NDConfiguration$Layout):1520 -> a
    5569:5571:void access$300(neureka.Tsr,neureka.ndim.config.NDConfiguration$Layout):150 -> a
    5580:5587:void _checkLayoutConversion(neureka.ndim.config.NDConfiguration,neureka.ndim.config.NDConfiguration,neureka.ndim.config.NDConfiguration$Layout):1580:1587 -> a
    5580:5587:void _toLayout(neureka.ndim.config.NDConfiguration$Layout):1522 -> a
    5580:5587:void access$300(neureka.Tsr,neureka.ndim.config.NDConfiguration$Layout):150 -> a
    150:150:neureka.Tsr access$400(neureka.Tsr,neureka.backend.api.ExecutionCall) -> a
    5600:5612:neureka.Tsr _incrementVersionBecauseOf(neureka.backend.api.ExecutionCall):1600:1612 -> a
    5600:5612:neureka.Tsr access$400(neureka.Tsr,neureka.backend.api.ExecutionCall):150 -> a
    150:150:neureka.Tsr access$500(neureka.Tsr) -> a
    6235:6251:neureka.Tsr _delete():1235:1251 -> a
    6235:6251:neureka.Tsr access$500(neureka.Tsr):150 -> a
    150:155:void <clinit>() -> <clinit>
neureka.Tsr$1 -> neureka.Tsr$1:
    int _count -> a
    int _size -> b
    neureka.ndim.iterator.NDIterator val$_ndi -> c
    neureka.Tsr this$0 -> d
    1658:1660:void <init>(neureka.Tsr,neureka.ndim.iterator.NDIterator) -> <init>
    1663:1663:boolean hasNext() -> hasNext
    1667:1670:java.lang.Object next() -> next
neureka.Tsr$2 -> neureka.Tsr$2:
    neureka.Tsr this$0 -> a
    3365:3365:void <init>(neureka.Tsr) -> <init>
    3367:3367:neureka.Tsr setNDConf(neureka.ndim.config.NDConfiguration) -> setNDConf
    3369:3369:neureka.Tsr toType(java.lang.Class) -> toType
    3371:3371:neureka.Tsr setDataType(neureka.dtype.DataType) -> setDataType
    3373:3373:neureka.Tsr toLayout(neureka.ndim.config.NDConfiguration$Layout) -> toLayout
    3376:3377:neureka.Tsr incrementVersion(neureka.backend.api.ExecutionCall) -> incrementVersion
    3381:3382:neureka.Tsr setIsIntermediate(boolean) -> setIsIntermediate
    3386:3386:neureka.Tsr delete() -> delete
neureka.Tsr$ImageType -> neureka.Tsr$ImageType:
    neureka.Tsr$ImageType RGB_1INT -> RGB_1INT
    neureka.Tsr$ImageType ARGB_1INT -> ARGB_1INT
    neureka.Tsr$ImageType ARGB_PRE_1INT -> ARGB_PRE_1INT
    neureka.Tsr$ImageType BGR_1INT -> BGR_1INT
    neureka.Tsr$ImageType BGR_3BYTE -> BGR_3BYTE
    neureka.Tsr$ImageType ABGR_4BYTE -> ABGR_4BYTE
    neureka.Tsr$ImageType ABGR_PRE_4BYTE -> ABGR_PRE_4BYTE
    neureka.Tsr$ImageType RGB_565_USHORT -> RGB_565_USHORT
    neureka.Tsr$ImageType RGB_555_USHORT -> RGB_555_USHORT
    neureka.Tsr$ImageType GRAY_BYTE -> GRAY_BYTE
    neureka.Tsr$ImageType GRAY_USHORT -> GRAY_USHORT
    int bufferType -> bufferType
    neureka.Tsr$ImageType[] $VALUES -> a
    3392:3392:neureka.Tsr$ImageType[] values() -> values
    3392:3392:neureka.Tsr$ImageType valueOf(java.lang.String) -> valueOf
    3407:3409:void <init>(java.lang.String,int,int) -> <init>
    3392:3403:void <clinit>() -> <clinit>
neureka.autograd.ADAgent -> neureka.autograd.ADAgent:
    56:56:neureka.autograd.DefaultADAgent of(neureka.Tsr) -> of
    neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    neureka.Tsr derivative() -> derivative
    boolean hasForward() -> hasForward
    boolean hasBackward() -> hasBackward
    java.lang.String toString() -> toString
neureka.autograd.DefaultADAgent -> neureka.autograd.DefaultADAgent:
    neureka.autograd.DefaultADAgent$ADAction _forward -> a
    neureka.autograd.DefaultADAgent$ADAction _backward -> b
    37:37:neureka.autograd.DefaultADAgent ofDerivative(neureka.Tsr) -> ofDerivative
    43:53:void <init>(neureka.Tsr) -> <init>
    56:56:neureka.autograd.DefaultADAgent setForward(neureka.autograd.DefaultADAgent$ADAction) -> setForward
    58:58:neureka.autograd.DefaultADAgent setBackward(neureka.autograd.DefaultADAgent$ADAction) -> setBackward
    70:71:neureka.autograd.DefaultADAgent withArgs(java.util.List) -> withArgs
    83:84:neureka.autograd.DefaultADAgent withArgs(neureka.calculus.args.Arg[]) -> withArgs
    88:88:neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    91:91:neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    95:96:neureka.Tsr derivative() -> derivative
    100:100:boolean hasForward() -> hasForward
    103:103:boolean hasBackward() -> hasBackward
    119:122:java.lang.String toString() -> toString
    121:121:java.lang.String lambda$toString$2(neureka.calculus.args.Arg) -> a
    48:48:neureka.Tsr lambda$new$1(neureka.autograd.GraphNode,neureka.Tsr) -> a
    43:43:neureka.Tsr lambda$new$0(neureka.autograd.GraphNode,neureka.Tsr) -> b
neureka.autograd.DefaultADAgent$ADAction -> neureka.autograd.DefaultADAgent$ADAction:
    neureka.Tsr execute(neureka.autograd.GraphNode,neureka.Tsr) -> execute
neureka.autograd.GraphLock -> neureka.autograd.GraphLock:
    neureka.calculus.Function _owner -> a
    boolean _isLocked -> b
    22:28:void <init>(neureka.calculus.Function) -> <init>
    34:34:void release() -> release
    41:41:java.lang.String toString() -> toString
    48:48:boolean isLocked() -> isLocked
neureka.autograd.GraphNode -> neureka.autograd.GraphNode:
    org.slf4j.Logger _LOG -> a
    int _mode -> b
    boolean _allows_forward -> c
    boolean _reliesOnJustInTimeProp -> d
    neureka.autograd.PendingError _pendingError -> e
    boolean _isUsedAsDerivative -> f
    neureka.calculus.Function _function -> g
    neureka.autograd.GraphNode[] _parents -> h
    java.lang.ref.WeakReference _payload -> i
    int _payloadReferenceVersion -> j
    java.util.TreeMap _targetsToAgents -> k
    neureka.autograd.GraphLock _lock -> l
    java.util.List _children -> m
    long _nodeID -> n
    boolean $assertionsDisabled -> o
    132:270:void <init>(neureka.calculus.Function,java.lang.Object,java.util.function.Supplier) -> <init>
    287:323:neureka.autograd.GraphNodeAssemblyState _construct(neureka.autograd.GraphNode,neureka.Tsr,neureka.calculus.Function,neureka.backend.api.ExecutionCall,neureka.autograd.GraphLock) -> a
    328:397:void _construct2(neureka.Tsr,neureka.calculus.Function,neureka.backend.api.ExecutionCall) -> a
    408:424:void _migrateAndOrApplyError(neureka.Tsr,java.util.function.Consumer) -> a
    432:432:boolean usesAD() -> usesAD
    439:439:boolean usesForwardAD() -> usesForwardAD
    446:446:boolean usesReverseAD() -> usesReverseAD
    455:455:boolean isCacheable() -> isCacheable
    461:462:void obtainLocking(neureka.autograd.GraphLock) -> obtainLocking
    469:469:boolean isLeave() -> isLeave
    472:476:boolean isGraphLeave() -> isGraphLeave
    482:482:boolean isVirtual() -> isVirtual
    488:491:void _attachChild(neureka.autograd.GraphNode) -> a
    502:502:neureka.Tsr getPayload() -> getPayload
    509:526:void _setPayload(neureka.Tsr) -> a
    530:532:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    543:545:neureka.autograd.PendingError getAndRemovePendingError() -> getAndRemovePendingError
    558:574:void backward(neureka.Tsr) -> backward
    592:613:void _backward(neureka.Tsr,java.util.Set,boolean) -> a
    625:633:void _carryPendingBackPropToGradients(java.util.Set) -> a
    649:651:void backwardJIT(neureka.Tsr) -> backwardJIT
    654:679:void _backwardJIT(neureka.Tsr,neureka.autograd.GraphNode) -> a
    691:695:void _deleteDerivativesRecursively() -> a
    703:712:int _numberOfReverseModeADChildren() -> b
    721:730:void _put(neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    739:740:java.util.List get(neureka.autograd.GraphNode) -> get
    751:752:boolean has(neureka.autograd.GraphNode) -> has
    761:761:int size() -> size
    767:771:void forEachDerivative(java.util.function.BiConsumer) -> forEachDerivative
    778:784:void forEachBackward(neureka.Tsr,java.util.function.BiConsumer) -> forEachBackward
    790:792:void forEachTarget(java.util.function.Consumer) -> forEachTarget
    798:806:void forEachTargetAgentPair(java.util.function.BiConsumer) -> forEachTargetAgentPair
    812:812:boolean hasDerivatives() -> hasDerivatives
    842:842:int getMode() -> getMode
    858:858:boolean isReliesOnJustInTimeProp() -> isReliesOnJustInTimeProp
    860:860:neureka.autograd.PendingError getPendingError() -> getPendingError
    862:862:boolean isUsedAsDerivative() -> isUsedAsDerivative
    864:864:neureka.calculus.Function getFunction() -> getFunction
    866:866:neureka.autograd.GraphNode[] getParents() -> getParents
    868:868:int getPayloadReferenceVersion() -> getPayloadReferenceVersion
    870:870:neureka.autograd.GraphLock getLock() -> getLock
    872:872:java.util.List getChildren() -> getChildren
    877:877:long getNodeID() -> getNodeID
    883:888:java.lang.String type() -> type
    892:892:java.lang.String toString() -> toString
    899:941:java.lang.String toString(java.lang.String) -> toString
    971:984:java.lang.String _toString(java.lang.String,boolean,java.lang.String) -> a
    942:955:void lambda$toString$17(neureka.view.TsrStringSettings) -> a
    919:932:void lambda$toString$16(neureka.view.TsrStringSettings) -> b
    902:902:java.lang.String lambda$toString$15(neureka.Tsr) -> b
    802:802:void lambda$forEachTargetAgentPair$14(java.util.function.BiConsumer,neureka.autograd.GraphNode,java.util.List) -> a
    803:803:void lambda$forEachTargetAgentPair$13(java.util.function.BiConsumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    791:791:void lambda$forEachTarget$12(java.util.function.Consumer,neureka.autograd.GraphNode,java.util.List) -> a
    781:783:void lambda$forEachBackward$11(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,java.util.List) -> a
    769:769:void lambda$forEachDerivative$10(java.util.function.BiConsumer,neureka.autograd.GraphNode,java.util.List) -> b
    769:769:void lambda$forEachDerivative$9(java.util.function.BiConsumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> b
    721:721:int lambda$_put$8(neureka.autograd.GraphNode,neureka.autograd.GraphNode) -> a
    676:676:void lambda$_backwardJIT$7(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> a
    656:661:void lambda$_backwardJIT$6(neureka.autograd.GraphNode,neureka.Tsr) -> a
    626:626:void lambda$_carryPendingBackPropToGradients$5(java.util.Set,neureka.autograd.GraphNode) -> a
    610:610:void lambda$_backward$4(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> a
    564:571:void lambda$backward$3(neureka.autograd.GraphNode) -> b
    561:561:void lambda$backward$2(java.util.Set,neureka.autograd.GraphNode) -> b
    514:524:void lambda$_setPayload$1() -> c
    361:377:void lambda$_construct2$0(neureka.Tsr,neureka.backend.api.ExecutionCall,int,neureka.calculus.Function,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    74:76:void <clinit>() -> <clinit>
neureka.autograd.GraphNodeAssemblyState -> neureka.autograd.a:
    int _mode -> a
    boolean _allowsForward -> b
    boolean _allowsBackward -> c
    neureka.calculus.Function _function -> d
    neureka.autograd.GraphNode[] _parents -> e
    int _payloadReferenceVersion -> f
    neureka.autograd.GraphLock _lock -> g
    long _nodeID -> h
    13:29:void <init>() -> <init>
    32:32:int mode() -> a
    38:39:neureka.autograd.GraphNodeAssemblyState setMode(int) -> a
    56:78:void _modeOf(neureka.backend.api.ExecutionCall) -> a
    80:80:boolean isAllowsForward() -> b
    82:82:boolean isAllowsBackward() -> c
    84:84:neureka.calculus.Function function() -> d
    87:88:neureka.autograd.GraphNodeAssemblyState setFunction(neureka.calculus.Function) -> a
    91:91:neureka.autograd.GraphNode[] parents() -> e
    94:95:neureka.autograd.GraphNodeAssemblyState setParents(neureka.autograd.GraphNode[]) -> a
    98:98:int payloadReferenceVersion() -> f
    101:102:neureka.autograd.GraphNodeAssemblyState setPayloadReferenceVersion(int) -> b
    105:105:neureka.autograd.GraphLock lock() -> g
    108:109:neureka.autograd.GraphNodeAssemblyState setLock(neureka.autograd.GraphLock) -> a
    112:112:long nodeID() -> h
    115:116:neureka.autograd.GraphNodeAssemblyState setNodeID(long) -> a
neureka.autograd.JITProp -> neureka.autograd.JITProp:
    java.util.Set _finished -> a
    java.util.Set _pending -> b
    16:20:void <init>(java.util.Set) -> <init>
    27:30:void addPending(java.util.Set) -> addPending
    37:46:void noteFinished(neureka.autograd.GraphNode) -> noteFinished
    49:49:int finishedCount() -> finishedCount
    53:53:int pendingCount() -> pendingCount
    66:76:void execute() -> execute
    82:82:boolean isDone() -> isDone
    90:92:java.lang.String toString() -> toString
    98:99:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    68:73:void lambda$execute$0(neureka.autograd.GraphNode) -> a
neureka.autograd.PendingError -> neureka.autograd.PendingError:
    int _toBeReceived -> a
    neureka.Tsr _accumulatedError -> b
    13:16:void <init>(neureka.Tsr,int) -> <init>
    19:29:void accumulate(neureka.Tsr) -> accumulate
    32:32:boolean isFullyAccumulated() -> isFullyAccumulated
    36:36:java.lang.String toString() -> toString
    40:40:int getToBeReceived() -> getToBeReceived
    44:44:neureka.Tsr getAccumulatedError() -> getAccumulatedError
    21:26:java.lang.Object lambda$accumulate$0(neureka.Tsr[]) -> a
neureka.backend.api.Algorithm -> neureka.backend.api.Algorithm:
    70:70:neureka.backend.standard.algorithms.FunAlgorithm withName(java.lang.String) -> withName
    java.lang.String getName() -> getName
    neureka.backend.api.Algorithm setImplementationFor(java.lang.Class,neureka.backend.api.ImplementationFor) -> setImplementationFor
    neureka.backend.api.ImplementationFor getImplementationFor(java.lang.Class) -> getImplementationFor
    121:121:neureka.backend.api.ImplementationFor getImplementationFor(neureka.devices.Device) -> getImplementationFor
neureka.backend.api.BackendContext -> neureka.backend.api.BackendContext:
    org.slf4j.Logger log -> a
    neureka.backend.api.Extensions extensions -> b
    java.util.Map _lookup -> c
    java.util.List _operations -> d
    int _size -> e
    neureka.calculus.FunctionCache _functionCache -> f
    neureka.calculus.Functions _getAutogradFunction -> g
    neureka.calculus.Functions _getFunction -> h
    boolean $assertionsDisabled -> i
    80:80:neureka.backend.api.BackendContext$Runner runner() -> runner
    91:91:java.util.Map getOperationLookupMap() -> getOperationLookupMap
    102:102:java.util.List getOperations() -> getOperations
    107:107:int size() -> size
    112:112:neureka.calculus.FunctionCache getFunctionCache() -> getFunctionCache
    121:122:neureka.calculus.Functions getFunction() -> getFunction
    134:135:neureka.calculus.Functions getAutogradFunction() -> getAutogradFunction
    41:147:void <init>() -> <init>
    158:179:neureka.backend.api.BackendContext addOperation(neureka.backend.api.Operation) -> addOperation
    187:187:boolean hasOperation(neureka.backend.api.Operation) -> hasOperation
    195:195:boolean hasOperation(java.lang.String) -> hasOperation
    206:206:neureka.backend.api.Operation getOperation(int) -> getOperation
    216:216:neureka.backend.api.Operation getOperation(java.lang.String) -> getOperation
    227:231:neureka.backend.api.BackendContext clone() -> clone
    235:235:java.lang.String toString() -> toString
    246:246:boolean has(java.lang.Class) -> has
    254:254:neureka.backend.api.BackendExtension get(java.lang.Class) -> get
    261:261:java.util.List getExtensions() -> getExtensions
    272:273:neureka.backend.api.BackendContext set(neureka.backend.api.BackendExtension) -> set
    37:37:java.lang.Object clone() -> clone
    37:37:org.slf4j.Logger access$100() -> a
    37:39:void <clinit>() -> <clinit>
neureka.backend.api.BackendContext$Runner -> neureka.backend.api.BackendContext$Runner:
    neureka.backend.api.BackendContext originalContext -> a
    neureka.backend.api.BackendContext visitedContext -> b
    294:298:void <init>(neureka.backend.api.BackendContext,neureka.backend.api.BackendContext) -> <init>
    310:313:neureka.backend.api.BackendContext$Runner run(java.lang.Runnable) -> run
    330:333:java.lang.Object runAndGet(java.util.function.Supplier) -> runAndGet
    352:352:java.lang.Object call(java.util.function.Supplier) -> call
    371:371:java.lang.Object invoke(java.util.function.Supplier) -> invoke
    289:289:void <init>(neureka.backend.api.BackendContext,neureka.backend.api.BackendContext,byte) -> <init>
neureka.backend.api.BackendExtension -> neureka.backend.api.BackendExtension:
    neureka.backend.api.BackendExtension$DeviceOption find(java.lang.String) -> find
    void dispose() -> dispose
neureka.backend.api.BackendExtension$DeviceOption -> neureka.backend.api.BackendExtension$DeviceOption:
    neureka.devices.Device _device -> a
    double _confidence -> b
    42:45:void <init>(neureka.devices.Device,double) -> <init>
    50:50:neureka.devices.Device device() -> device
    55:55:double confidence() -> confidence
neureka.backend.api.Call -> neureka.backend.api.Call:
    neureka.Tsr[] _tensors -> _tensors
    java.lang.Object _device -> _device
    neureka.calculus.args.Args _arguments -> _arguments
    26:26:neureka.backend.api.Call$Builder to(neureka.devices.Device) -> to
    43:50:void <init>(neureka.Tsr[],java.lang.Object,java.util.List) -> <init>
    55:55:java.lang.Object getDevice() -> getDevice
    60:60:neureka.Tsr[] inputs() -> inputs
    65:65:int arity() -> arity
    72:72:neureka.Tsr input(int) -> input
    76:80:void rearrangeInputs(int[]) -> rearrangeInputs
    84:84:neureka.devices.Device getDeviceFor(java.lang.Class) -> getDeviceFor
    88:88:java.util.List allMetaArgs() -> allMetaArgs
    92:92:neureka.calculus.args.Arg get(java.lang.Class) -> get
    96:96:java.lang.Object getValOf(java.lang.Class) -> getValOf
    100:100:int getDerivativeIndex() -> getDerivativeIndex
    104:121:neureka.Tsr getTsrOfType(java.lang.Class,int) -> getTsrOfType
    124:124:neureka.backend.api.Call$Validator validate() -> validate
    88:88:neureka.calculus.args.Arg lambda$allMetaArgs$0(neureka.calculus.args.Arg) -> a
neureka.backend.api.Call$Builder -> neureka.backend.api.Call$Builder:
    neureka.devices.Device _device -> a
    neureka.Tsr[] _tensors -> b
    neureka.calculus.args.Args _arguments -> c
    130:132:void <init>(neureka.devices.Device) -> <init>
    136:137:neureka.backend.api.Call$Builder with(neureka.Tsr[]) -> with
    141:142:neureka.backend.api.Call$Builder andArgs(java.util.List) -> andArgs
    146:146:neureka.backend.api.Call$Builder andArgs(neureka.calculus.args.Arg[]) -> andArgs
    150:150:neureka.backend.api.Call get() -> get
    126:126:void <init>(neureka.devices.Device,byte) -> <init>
neureka.backend.api.Call$DeviceCondition -> neureka.backend.api.Call$DeviceCondition:
    boolean check(neureka.devices.Device) -> check
neureka.backend.api.Call$OperationCondition -> neureka.backend.api.Call$OperationCondition:
    boolean check(neureka.backend.api.Operation) -> check
neureka.backend.api.Call$TensorCompare -> neureka.backend.api.Call$TensorCompare:
    boolean check(neureka.Tsr,neureka.Tsr) -> check
neureka.backend.api.Call$TensorCondition -> neureka.backend.api.Call$TensorCondition:
    boolean check(neureka.Tsr) -> check
neureka.backend.api.Call$TensorsCondition -> neureka.backend.api.Call$TensorsCondition:
    boolean check(neureka.Tsr[]) -> check
neureka.backend.api.Call$Validator -> neureka.backend.api.Call$Validator:
    boolean _isValid -> a
    neureka.backend.api.Call this$0 -> b
    163:165:void <init>(neureka.backend.api.Call) -> <init>
    168:168:boolean isValid() -> isValid
    180:180:float basicSuitability() -> basicSuitability
    184:184:float suitabilityIfValid(float) -> suitabilityIfValid
    187:187:neureka.backend.api.Call$Validator$Estimator getEstimator() -> getEstimator
    190:191:neureka.backend.api.Call$Validator first(neureka.backend.api.Call$TensorCondition) -> first
    195:196:neureka.backend.api.Call$Validator last(neureka.backend.api.Call$TensorCondition) -> last
    200:201:neureka.backend.api.Call$Validator tensors(neureka.backend.api.Call$TensorsCondition) -> tensors
    206:207:neureka.backend.api.Call$Validator any(neureka.backend.api.Call$TensorCondition) -> any
    212:214:boolean _anyMatch(neureka.backend.api.Call$TensorCondition) -> a
    219:220:neureka.backend.api.Call$Validator anyNotNull(neureka.backend.api.Call$TensorCondition) -> anyNotNull
    1225:1228:boolean _anyNotNullMatch(neureka.backend.api.Call$TensorCondition):225:228 -> anyNotNull
    1225:1228:neureka.backend.api.Call$Validator anyNotNull(neureka.backend.api.Call$TensorCondition):219 -> anyNotNull
    233:234:neureka.backend.api.Call$Validator all(neureka.backend.api.Call$TensorCondition) -> all
    238:240:boolean _allMatch(neureka.backend.api.Call$TensorCondition) -> b
    245:246:neureka.backend.api.Call$Validator allNotNull(neureka.backend.api.Call$TensorCondition) -> allNotNull
    1251:1254:boolean _allNotNullMatch(neureka.backend.api.Call$TensorCondition):251:254 -> allNotNull
    1251:1254:neureka.backend.api.Call$Validator allNotNull(neureka.backend.api.Call$TensorCondition):245 -> allNotNull
    259:260:neureka.backend.api.Call$Validator all(neureka.backend.api.Call$TensorCompare) -> all
    264:270:boolean _allMatch(neureka.backend.api.Call$TensorCompare) -> a
    274:287:neureka.backend.api.Call$Validator allShare(java.util.function.Function) -> allShare
    163:163:boolean access$100(neureka.backend.api.Call$Validator,neureka.backend.api.Call$TensorCondition) -> a
    163:163:boolean access$200(neureka.backend.api.Call$Validator,neureka.backend.api.Call$TensorCondition) -> b
    163:163:boolean access$300(neureka.backend.api.Call$Validator,neureka.backend.api.Call$TensorCompare) -> a
neureka.backend.api.Call$Validator$Estimator -> neureka.backend.api.Call$Validator$Estimator:
    float _estimation -> a
    neureka.backend.api.Call$Validator this$1 -> b
    294:296:void <init>(neureka.backend.api.Call$Validator,boolean) -> <init>
    299:302:void _mod(float) -> a
    304:304:neureka.backend.api.Call$Validator$Estimator goodIfAll(neureka.backend.api.Call$TensorCondition) -> goodIfAll
    306:306:neureka.backend.api.Call$Validator$Estimator badIfAll(neureka.backend.api.Call$TensorCondition) -> badIfAll
    308:308:neureka.backend.api.Call$Validator$Estimator goodIfAnyNonNull(neureka.backend.api.Call$TensorCondition) -> goodIfAnyNonNull
    310:310:neureka.backend.api.Call$Validator$Estimator goodIfAny(neureka.backend.api.Call$TensorCondition) -> goodIfAny
    312:312:neureka.backend.api.Call$Validator$Estimator badIfAnyNonNull(neureka.backend.api.Call$TensorCondition) -> badIfAnyNonNull
    314:314:neureka.backend.api.Call$Validator$Estimator badIfAny(neureka.backend.api.Call$TensorCondition) -> badIfAny
    316:316:neureka.backend.api.Call$Validator$Estimator goodIfAll(neureka.backend.api.Call$TensorCompare) -> goodIfAll
    318:318:neureka.backend.api.Call$Validator$Estimator badIfAll(neureka.backend.api.Call$TensorCompare) -> badIfAll
    320:320:float getEstimation() -> getEstimation
    312:312:boolean lambda$badIfAnyNonNull$1(neureka.backend.api.Call$TensorCondition,neureka.Tsr) -> a
    308:308:boolean lambda$goodIfAnyNonNull$0(neureka.backend.api.Call$TensorCondition,neureka.Tsr) -> b
neureka.backend.api.ExecutionCall -> neureka.backend.api.ExecutionCall:
    org.slf4j.Logger _LOG -> a
    neureka.backend.api.Operation _operation -> b
    neureka.backend.api.Algorithm _algorithm -> c
    78:78:neureka.backend.api.ExecutionCall$Builder of(neureka.Tsr[]) -> of
    106:119:void <init>(neureka.devices.Device,neureka.backend.api.Operation,neureka.Tsr[],neureka.backend.api.Algorithm,java.util.List) -> <init>
    128:128:neureka.backend.api.Operation getOperation() -> getOperation
    137:138:neureka.backend.api.ExecutionCall withInputs(neureka.Tsr[]) -> withInputs
    149:151:neureka.backend.api.ExecutionCall withArgs(neureka.calculus.args.Arg[]) -> withArgs
    165:175:neureka.backend.api.Algorithm getAlgorithm() -> getAlgorithm
    185:188:boolean allowsForward() -> allowsForward
    198:201:boolean allowsBackward() -> allowsBackward
    205:205:neureka.autograd.ADAgent getADAgentFrom(neureka.calculus.Function,boolean) -> getADAgentFrom
    215:215:void setInput(int,neureka.Tsr) -> setInput
    221:230:java.lang.String toString() -> toString
    230:230:java.lang.String lambda$toString$0(neureka.calculus.args.Arg) -> a
    66:66:void <init>(neureka.devices.Device,neureka.backend.api.Operation,neureka.Tsr[],neureka.backend.api.Algorithm,java.util.List,byte) -> <init>
    68:68:void <clinit>() -> <clinit>
neureka.backend.api.ExecutionCall$Builder -> neureka.backend.api.ExecutionCall$Builder:
    neureka.Tsr[] _tensors -> a
    java.util.List _arguments -> b
    neureka.backend.api.Operation _operation -> c
    neureka.backend.api.Algorithm _algorithm -> d
    240:244:void <init>(neureka.Tsr[]) -> <init>
    247:247:neureka.backend.api.ExecutionCall on(neureka.devices.Device) -> on
    251:252:neureka.backend.api.ExecutionCall$Builder running(neureka.backend.api.Operation) -> running
    256:257:neureka.backend.api.ExecutionCall$Builder algorithm(neureka.backend.api.Algorithm) -> algorithm
    261:262:neureka.backend.api.ExecutionCall$Builder andArgs(java.util.List) -> andArgs
    266:266:neureka.backend.api.ExecutionCall$Builder andArgs(neureka.calculus.args.Arg[]) -> andArgs
    237:237:void <init>(neureka.Tsr[],byte) -> <init>
neureka.backend.api.Extensions -> neureka.backend.api.Extensions:
    9:9:void <init>() -> <init>
    13:13:neureka.common.composition.Component _setOrReject(neureka.common.composition.Component) -> _setOrReject
    18:18:neureka.common.composition.Component _removeOrReject(neureka.common.composition.Component) -> _removeOrReject
neureka.backend.api.ImplementationFor -> neureka.backend.api.ImplementationFor:
    void run(neureka.backend.api.ExecutionCall) -> run
    72:73:neureka.Tsr runAndGetFirstTensor(neureka.backend.api.ExecutionCall) -> runAndGetFirstTensor
neureka.backend.api.Operation -> neureka.backend.api.Operation:
    64:64:neureka.backend.api.operations.OperationBuilder builder() -> builder
    neureka.backend.api.Algorithm[] getAllAlgorithms() -> getAllAlgorithms
    neureka.backend.api.Algorithm getAlgorithmFor(neureka.backend.api.ExecutionCall) -> getAlgorithmFor
    neureka.backend.api.Operation setAlgorithm(java.lang.Class,neureka.backend.api.Algorithm) -> setAlgorithm
    96:96:neureka.backend.api.Operation setAlgorithm(neureka.backend.api.Algorithm) -> setAlgorithm
    neureka.backend.api.Algorithm getAlgorithm(java.lang.Class) -> getAlgorithm
    boolean supportsAlgorithm(java.lang.Class) -> supportsAlgorithm
    java.lang.String getIdentifier() -> getIdentifier
    java.lang.String stringify(java.lang.String[]) -> stringify
    java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    java.lang.String getOperator() -> getOperator
    int getArity() -> getArity
    boolean isOperator() -> isOperator
    boolean isIndexer() -> isIndexer
    boolean isDifferentiable() -> isDifferentiable
    boolean isInline() -> isInline
    boolean supports(java.lang.Class) -> supports
    double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.api.Operation$Utility -> neureka.backend.api.Operation$Utility:
    231:231:void <init>() -> <init>
    234:240:neureka.Tsr[] subset(neureka.Tsr[],int,int,int) -> subset
    244:246:neureka.Tsr[] without(neureka.Tsr[],int) -> without
    250:262:neureka.Tsr[] offsetted(neureka.Tsr[],int) -> offsetted
neureka.backend.api.algorithms.AbstractBaseAlgorithm -> neureka.backend.api.algorithms.AbstractBaseAlgorithm:
    org.slf4j.Logger _LOG -> a
    java.lang.String _name -> b
    java.util.Map _implementations -> _implementations
    22:34:void <init>(java.lang.String) -> <init>
    44:44:java.lang.String getName() -> getName
    50:59:neureka.backend.api.Algorithm setImplementationFor(java.lang.Class,neureka.backend.api.ImplementationFor) -> setImplementationFor
    65:71:neureka.backend.api.ImplementationFor getImplementationFor(java.lang.Class) -> getImplementationFor
    76:79:java.lang.String toString() -> toString
neureka.backend.api.algorithms.AbstractFunctionalAlgorithm -> neureka.backend.api.algorithms.AbstractFunctionalAlgorithm:
    org.slf4j.Logger _LOG -> a
    neureka.backend.api.algorithms.fun.SuitabilityPredicate _isSuitableFor -> b
    neureka.backend.api.algorithms.fun.ForwardADPredicate _canPerformForwardADFor -> c
    neureka.backend.api.algorithms.fun.BackwardADPredicate _canPerformBackwardADFor -> d
    neureka.backend.api.algorithms.fun.ADAgentSupplier _supplyADAgentFor -> e
    neureka.backend.api.algorithms.fun.ExecutionDispatcher _handleInsteadOfDevice -> f
    neureka.backend.api.algorithms.fun.ExecutionPreparation _instantiateNewTensorsForExecutionIn -> g
    boolean _isFullyBuilt -> h
    57:60:void <init>(java.lang.String) -> <init>
    70:71:float isSuitableFor(neureka.backend.api.ExecutionCall) -> isSuitableFor
    81:82:boolean canPerformForwardADFor(neureka.backend.api.ExecutionCall) -> canPerformForwardADFor
    92:93:boolean canPerformBackwardADFor(neureka.backend.api.ExecutionCall) -> canPerformBackwardADFor
    108:109:neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> supplyADAgentFor
    134:154:neureka.Tsr dispatch(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> dispatch
    165:178:neureka.backend.api.ExecutionCall prepare(neureka.backend.api.ExecutionCall) -> prepare
    186:200:neureka.backend.api.Algorithm buildFunAlgorithm() -> buildFunAlgorithm
    208:214:void _checkReadiness() -> a
    227:237:java.lang.Object _checked(java.lang.Object,java.lang.Object,java.lang.Class) -> a
    252:253:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setIsSuitableFor(neureka.backend.api.algorithms.fun.SuitabilityPredicate) -> setIsSuitableFor
    267:268:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setCanPerformForwardADFor(neureka.backend.api.algorithms.fun.ForwardADPredicate) -> setCanPerformForwardADFor
    281:282:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setCanPerformBackwardADFor(neureka.backend.api.algorithms.fun.BackwardADPredicate) -> setCanPerformBackwardADFor
    295:296:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setSupplyADAgentFor(neureka.backend.api.algorithms.fun.ADAgentSupplier) -> setSupplyADAgentFor
    322:323:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setExecutionDispatcher(neureka.backend.api.algorithms.fun.ExecutionDispatcher) -> setExecutionDispatcher
    344:345:neureka.backend.api.algorithms.AbstractFunctionalAlgorithm setCallPreparation(neureka.backend.api.algorithms.fun.ExecutionPreparation) -> setCallPreparation
    174:174:void lambda$prepare$3(neureka.Tsr) -> a
    171:172:boolean lambda$prepare$2(neureka.Tsr[],neureka.Tsr) -> a
    172:172:boolean lambda$prepare$1(neureka.Tsr,neureka.Tsr) -> a
    136:136:neureka.Tsr lambda$dispatch$0(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    42:42:void <clinit>() -> <clinit>
neureka.backend.api.algorithms.FallbackAlgorithm -> neureka.backend.api.algorithms.FallbackAlgorithm:
    org.slf4j.Logger _LOG -> a
    33:96:void <init>(java.lang.String,int,neureka.backend.api.Operation) -> <init>
    100:108:float isSuitableFor(neureka.backend.api.ExecutionCall) -> isSuitableFor
    112:112:boolean canPerformForwardADFor(neureka.backend.api.ExecutionCall) -> canPerformForwardADFor
    115:115:boolean canPerformBackwardADFor(neureka.backend.api.ExecutionCall) -> canPerformBackwardADFor
    120:131:neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> supplyADAgentFor
    137:137:neureka.Tsr dispatch(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> dispatch
    143:158:neureka.backend.api.ExecutionCall prepare(neureka.backend.api.ExecutionCall) -> prepare
    194:195:void setAt(neureka.Tsr,int,java.lang.Object) -> a
    198:206:java.lang.Object _tryExecute(java.lang.reflect.Method,java.lang.Object[],int) -> a
    212:237:java.lang.reflect.Method _findMethod(java.lang.String,java.lang.Class) -> a
    182:189:void lambda$_tryExecute$10(neureka.backend.api.ExecutionCall,java.lang.reflect.Method,int,int) -> a
    131:131:neureka.Tsr lambda$supplyADAgentFor$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    130:130:neureka.Tsr lambda$supplyADAgentFor$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    127:127:neureka.Tsr lambda$supplyADAgentFor$7(neureka.calculus.Function,neureka.backend.api.ExecutionCall) -> a
    125:125:neureka.Tsr lambda$supplyADAgentFor$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    124:124:neureka.Tsr lambda$supplyADAgentFor$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    40:93:void lambda$new$4(neureka.backend.api.Operation,neureka.backend.api.ExecutionCall) -> a
    1162:1191:void _tryExecute(neureka.backend.api.ExecutionCall,java.lang.Class):162:191 -> a
    1162:1191:void lambda$new$4(neureka.backend.api.Operation,neureka.backend.api.ExecutionCall):92 -> a
    81:88:void lambda$new$3(neureka.backend.api.ExecutionCall,int,int) -> a
    65:71:void lambda$new$2(double[],neureka.backend.api.ExecutionCall,neureka.calculus.Function,int,int) -> a
    54:54:java.lang.Class lambda$new$1(neureka.Tsr) -> a
    50:50:boolean lambda$new$0(neureka.Tsr) -> b
    29:29:void <clinit>() -> <clinit>
neureka.backend.api.algorithms.fun.ADAgentSupplier -> neureka.backend.api.algorithms.fun.ADAgentSupplier:
    neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> supplyADAgentFor
neureka.backend.api.algorithms.fun.BackwardADPredicate -> neureka.backend.api.algorithms.fun.BackwardADPredicate:
    boolean canPerformBackwardADFor(neureka.backend.api.ExecutionCall) -> canPerformBackwardADFor
neureka.backend.api.algorithms.fun.ExecutionDispatcher -> neureka.backend.api.algorithms.fun.ExecutionDispatcher:
    neureka.Tsr dispatch(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> dispatch
neureka.backend.api.algorithms.fun.ExecutionPreparation -> neureka.backend.api.algorithms.fun.ExecutionPreparation:
    neureka.backend.api.ExecutionCall prepare(neureka.backend.api.ExecutionCall) -> prepare
neureka.backend.api.algorithms.fun.ForwardADPredicate -> neureka.backend.api.algorithms.fun.ForwardADPredicate:
    boolean canPerformForwardADFor(neureka.backend.api.ExecutionCall) -> canPerformForwardADFor
neureka.backend.api.algorithms.fun.SuitabilityPredicate -> neureka.backend.api.algorithms.fun.SuitabilityPredicate:
    float PERFECT -> PERFECT
    float EXCELLENT -> EXCELLENT
    float VERY_GOOD -> VERY_GOOD
    float GOOD -> GOOD
    float OKAY -> OKAY
    float NOT_GOOD -> NOT_GOOD
    float BAD -> BAD
    float TERRIBLE -> TERRIBLE
    float UNSUITABLE -> UNSUITABLE
    float isSuitableFor(neureka.backend.api.ExecutionCall) -> isSuitableFor
neureka.backend.api.implementations.AbstractImplementationFor -> neureka.backend.api.implementations.AbstractImplementationFor:
    neureka.backend.api.ImplementationFor _lambda -> a
    9:15:void <init>(neureka.backend.api.ImplementationFor,int) -> <init>
    21:22:void run(neureka.backend.api.ExecutionCall) -> run
neureka.backend.api.operations.AbstractOperation -> neureka.backend.api.operations.AbstractOperation:
    org.slf4j.Logger _LOG -> a
    java.lang.String _function -> _function
    java.lang.String _operator -> _operator
    int _arity -> _arity
    boolean _isIndexer -> _isIndexer
    boolean _isDifferentiable -> _isDifferentiable
    boolean _isInline -> _isInline
    boolean _isOperator -> _isOperator
    java.util.Map _algorithms -> b
    neureka.backend.api.Algorithm _defaultAlgorithm -> c
    82:112:void <init>(neureka.backend.api.operations.OperationBuilder) -> <init>
    118:118:neureka.backend.api.Algorithm[] getAllAlgorithms() -> getAllAlgorithms
    135:144:neureka.backend.api.Algorithm getAlgorithm(java.lang.Class) -> getAlgorithm
    157:157:boolean supportsAlgorithm(java.lang.Class) -> supportsAlgorithm
    173:179:neureka.backend.api.Operation setAlgorithm(java.lang.Class,neureka.backend.api.Algorithm) -> setAlgorithm
    186:211:neureka.backend.api.Algorithm getAlgorithmFor(neureka.backend.api.ExecutionCall) -> getAlgorithmFor
    218:218:boolean supports(java.lang.Class) -> supports
    223:223:boolean isOperator() -> isOperator
    228:228:java.lang.String getIdentifier() -> getIdentifier
    233:233:java.lang.String getOperator() -> getOperator
    238:238:int getArity() -> getArity
    243:243:boolean isIndexer() -> isIndexer
    248:248:boolean isDifferentiable() -> isDifferentiable
    253:253:boolean isInline() -> isInline
    257:257:neureka.backend.api.Algorithm getDefaultAlgorithm() -> getDefaultAlgorithm
    262:264:java.lang.String toString() -> toString
    140:140:neureka.backend.api.Algorithm lambda$getAlgorithm$1(java.util.Map$Entry) -> a
    139:139:boolean lambda$getAlgorithm$0(java.lang.Class,java.util.Map$Entry) -> a
    26:26:void <clinit>() -> <clinit>
neureka.backend.api.operations.OperationBuilder -> neureka.backend.api.operations.OperationBuilder:
    neureka.backend.api.operations.OperationBuilder$Stringifier _stringifier -> a
    neureka.backend.api.operations.OperationBuilder$Derivator _derivator -> b
    java.lang.String _function -> c
    java.lang.String _operator -> d
    java.lang.Integer _arity -> e
    java.lang.Boolean _isOperator -> f
    java.lang.Boolean _isIndexer -> g
    java.lang.Boolean _isDifferentiable -> h
    java.lang.Boolean _isInline -> i
    boolean _disposed -> j
    17:55:void <init>() -> <init>
    67:67:neureka.backend.api.operations.OperationBuilder$Stringifier getStringifier() -> getStringifier
    69:69:neureka.backend.api.operations.OperationBuilder$Derivator getDerivator() -> getDerivator
    71:71:java.lang.String getFunction() -> getFunction
    73:73:java.lang.String getOperator() -> getOperator
    75:75:java.lang.Integer getArity() -> getArity
    77:77:java.lang.Boolean getIsOperator() -> getIsOperator
    79:79:java.lang.Boolean getIsIndexer() -> getIsIndexer
    81:81:java.lang.Boolean getIsDifferentiable() -> getIsDifferentiable
    83:83:java.lang.Boolean getIsInline() -> getIsInline
    86:87:neureka.backend.api.operations.OperationBuilder setStringifier(neureka.backend.api.operations.OperationBuilder$Stringifier) -> setStringifier
    91:92:neureka.backend.api.operations.OperationBuilder setDerivator(neureka.backend.api.operations.OperationBuilder$Derivator) -> setDerivator
    96:97:neureka.backend.api.operations.OperationBuilder setFunction(java.lang.String) -> setFunction
    101:102:neureka.backend.api.operations.OperationBuilder setOperator(java.lang.String) -> setOperator
    106:107:neureka.backend.api.operations.OperationBuilder setArity(java.lang.Integer) -> setArity
    111:112:neureka.backend.api.operations.OperationBuilder setIsOperator(java.lang.Boolean) -> setIsOperator
    116:117:neureka.backend.api.operations.OperationBuilder setIsIndexer(java.lang.Boolean) -> setIsIndexer
    121:122:neureka.backend.api.operations.OperationBuilder setIsDifferentiable(java.lang.Boolean) -> setIsDifferentiable
    126:127:neureka.backend.api.operations.OperationBuilder setIsInline(java.lang.Boolean) -> setIsInline
    130:130:void dispose() -> dispose
    146:151:neureka.backend.api.Operation build() -> build
    1133:1141:java.util.List _listOfMissingProperties():133:141 -> build
    1133:1141:neureka.backend.api.Operation build():147 -> build
    17:17:neureka.backend.api.operations.OperationBuilder$Stringifier access$000(neureka.backend.api.operations.OperationBuilder) -> a
    17:17:neureka.backend.api.operations.OperationBuilder$Derivator access$100(neureka.backend.api.operations.OperationBuilder) -> b
neureka.backend.api.operations.OperationBuilder$1 -> neureka.backend.api.operations.OperationBuilder$1:
    neureka.backend.api.operations.OperationBuilder this$0 -> a
    151:151:void <init>(neureka.backend.api.operations.OperationBuilder,neureka.backend.api.operations.OperationBuilder) -> <init>
    154:154:java.lang.String stringify(java.lang.String[]) -> stringify
    159:159:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    164:164:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    169:169:java.lang.String toString() -> toString
neureka.backend.api.operations.OperationBuilder$Derivator -> neureka.backend.api.operations.OperationBuilder$Derivator:
    java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
neureka.backend.api.operations.OperationBuilder$Stringifier -> neureka.backend.api.operations.OperationBuilder$Stringifier:
    java.lang.String stringify(java.lang.String[]) -> stringify
neureka.backend.standard.algorithms.Activation -> neureka.backend.standard.algorithms.Activation:
    boolean $assertionsDisabled -> a
    25:58:void <init>() -> <init>
    61:61:java.lang.String getKernelSource() -> getKernelSource
    65:65:neureka.backend.standard.algorithms.internal.WithForward implementationForGPU(java.lang.String) -> implementationForGPU
    94:94:neureka.backend.standard.algorithms.Functions$Builder implementationForCPU() -> implementationForCPU
    206:218:void lambda$_newWorkloadFor$16(neureka.Tsr,neureka.Tsr,int[],neureka.backend.standard.algorithms.internal.Fun$I32ToI32,int[],int,int) -> a
    202:203:void lambda$_newWorkloadFor$15(int[],neureka.backend.standard.algorithms.internal.Fun$I32ToI32,int[],int,int) -> a
    180:192:void lambda$_newWorkloadFor$14(neureka.Tsr,neureka.Tsr,float[],neureka.backend.standard.algorithms.internal.Fun$F32ToF32,float[],int,int) -> a
    176:177:void lambda$_newWorkloadFor$13(float[],neureka.backend.standard.algorithms.internal.Fun$F32ToF32,float[],int,int) -> a
    153:165:void lambda$_newWorkloadFor$12(neureka.Tsr,neureka.Tsr,double[],neureka.backend.standard.algorithms.internal.Fun$F64ToF64,double[],int,int) -> a
    149:150:void lambda$_newWorkloadFor$11(double[],neureka.backend.standard.algorithms.internal.Fun$F64ToF64,double[],int,int) -> a
    130:142:void lambda$_newWorkloadFor$10(neureka.Tsr,neureka.Tsr,double[],neureka.backend.standard.algorithms.internal.Fun$F64ToF64,int[],int,int) -> a
    97:101:void lambda$implementationForCPU$9(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions) -> a
    1110:1227:neureka.devices.host.CPU$RangeWorkload _newWorkloadFor(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):110:227 -> a
    1110:1227:void lambda$implementationForCPU$9(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):101 -> a
    67:67:neureka.backend.standard.algorithms.internal.AndBackward lambda$implementationForGPU$8(java.lang.String,java.lang.String) -> a
    68:90:neureka.backend.standard.implementations.CLImplementation lambda$implementationForGPU$7(java.lang.String,java.lang.String,java.lang.String) -> a
    77:88:void lambda$implementationForGPU$6(neureka.backend.api.ExecutionCall) -> a
    41:55:neureka.backend.api.ExecutionCall lambda$new$5(neureka.backend.api.ExecutionCall) -> b
    33:36:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> c
    35:35:boolean lambda$new$3(neureka.Tsr,neureka.Tsr) -> a
    31:31:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> d
    27:29:float lambda$new$1(neureka.backend.api.ExecutionCall) -> e
    28:28:boolean lambda$new$0(neureka.Tsr) -> a
    22:22:void <clinit>() -> <clinit>
neureka.backend.standard.algorithms.Broadcast -> neureka.backend.standard.algorithms.Broadcast:
    boolean $assertionsDisabled -> a
    25:108:void <init>(neureka.calculus.internal.RecursiveExecutor) -> <init>
    111:111:neureka.backend.standard.algorithms.internal.WithForward implementationForGPU(java.lang.String) -> implementationForGPU
    137:137:neureka.backend.standard.algorithms.Functions$Builder implementationForCPU() -> implementationForCPU
    168:168:void lambda$_newWorkloadFor$11(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,int,int) -> a
    1284:1376:void _broadcastF32(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32):284:376 -> a
    1284:1376:void lambda$_newWorkloadFor$11(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,int,int):168 -> a
    164:164:void lambda$_newWorkloadFor$10(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,int,int) -> a
    2183:2275:void _broadcastF64(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64):183:275 -> a
    2183:2275:void lambda$_newWorkloadFor$10(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,int,int):164 -> a
    140:144:void lambda$implementationForCPU$9(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions) -> a
    3153:3174:neureka.devices.host.CPU$RangeWorkload _newWorkloadFor(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):153:174 -> a
    3153:3174:void lambda$implementationForCPU$9(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):144 -> a
    113:113:neureka.backend.standard.algorithms.internal.AndBackward lambda$implementationForGPU$8(java.lang.String,java.lang.String) -> a
    114:133:neureka.backend.standard.implementations.CLImplementation lambda$implementationForGPU$7(java.lang.String,java.lang.String,java.lang.String) -> a
    122:131:void lambda$implementationForGPU$6(neureka.backend.api.ExecutionCall) -> a
    80:105:neureka.backend.api.ExecutionCall lambda$new$5(neureka.backend.api.ExecutionCall) -> b
    65:75:neureka.Tsr lambda$new$4(neureka.calculus.internal.RecursiveExecutor,neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    73:73:neureka.Tsr lambda$new$3(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> a
    56:61:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> c
    29:52:float lambda$new$1(neureka.backend.api.ExecutionCall) -> d
    31:31:boolean lambda$new$0(neureka.Tsr) -> a
    21:21:void <clinit>() -> <clinit>
neureka.backend.standard.algorithms.Convolution -> neureka.backend.standard.algorithms.Convolution:
    16:23:void <init>() -> <init>
    27:27:java.lang.String getKernelSource() -> getKernelSource
    32:32:neureka.backend.standard.algorithms.Functions$Builder implementationForCPU() -> implementationForCPU
    70:70:void lambda$_newWorkloadFor$6(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,int,int) -> a
    1324:1406:void _deConvolve32(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32):324:406 -> a
    1324:1406:void lambda$_newWorkloadFor$6(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,int,int):70 -> a
    68:68:void lambda$_newWorkloadFor$5(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,int,int) -> b
    2252:2316:void _convolve32(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32):252:316 -> b
    2252:2316:void lambda$_newWorkloadFor$5(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,int,int):68 -> b
    63:63:void lambda$_newWorkloadFor$4(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,int,int) -> a
    3159:3242:void _deConvolve64(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64):159:242 -> a
    3159:3242:void lambda$_newWorkloadFor$4(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,int,int):63 -> a
    61:61:void lambda$_newWorkloadFor$3(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,int,int) -> b
    4086:4151:void _convolve64(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64):86:151 -> b
    4086:4151:void lambda$_newWorkloadFor$3(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,int,int):61 -> b
    35:39:void lambda$implementationForCPU$2(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions) -> a
    5049:5076:neureka.devices.host.CPU$RangeWorkload _newWorkloadFor(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):49:76 -> a
    5049:5076:void lambda$implementationForCPU$2(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):39 -> a
    19:21:float lambda$new$1(neureka.backend.api.ExecutionCall) -> a
    20:20:boolean lambda$new$0(neureka.Tsr) -> a
neureka.backend.standard.algorithms.FunAlgorithm -> neureka.backend.standard.algorithms.FunAlgorithm:
    7:7:void <init>(java.lang.String) -> <init>
neureka.backend.standard.algorithms.Functions -> neureka.backend.standard.algorithms.Functions:
    java.util.List _functions -> a
    21:21:neureka.backend.standard.algorithms.Functions$Builder implementation(int,neureka.backend.standard.algorithms.internal.FunImplementation) -> implementation
    16:26:void <init>(java.util.List) -> <init>
    29:33:neureka.backend.standard.algorithms.internal.FunArray get(java.lang.Class) -> get
    14:14:void <init>(java.util.List,byte) -> <init>
neureka.backend.standard.algorithms.Functions$Builder -> neureka.backend.standard.algorithms.Functions$Builder:
    java.util.List _functions -> a
    neureka.backend.standard.algorithms.internal.FunImplementation _implementation -> b
    int _arity -> c
    38:47:void <init>(int,neureka.backend.standard.algorithms.internal.FunImplementation) -> <init>
    50:51:neureka.backend.standard.algorithms.Functions$Builder with(neureka.backend.standard.algorithms.internal.FunArray) -> with
    55:55:neureka.backend.api.ImplementationFor get() -> get
    56:56:void lambda$get$0(neureka.backend.api.ExecutionCall) -> a
    36:36:void <init>(int,neureka.backend.standard.algorithms.internal.FunImplementation,byte) -> <init>
neureka.backend.standard.algorithms.Operator -> neureka.backend.standard.algorithms.Operator:
    boolean $assertionsDisabled -> a
    24:58:void <init>(neureka.calculus.internal.RecursiveExecutor) -> <init>
    61:61:neureka.backend.standard.algorithms.internal.WithForward implementationForGPU(java.lang.String) -> implementationForGPU
    89:89:neureka.backend.standard.algorithms.Functions$Builder implementationForCPU() -> implementationForCPU
    250:265:void lambda$_newWorkloadI32$20(neureka.Tsr,neureka.Tsr,neureka.Tsr,int[],neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32,int[],int[],int,int) -> a
    246:247:void lambda$_newWorkloadI32$19(int[],neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32,int[],int[],int,int) -> a
    242:242:void lambda$_newWorkloadI32$18(int[],neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32,int[],int[],int,int) -> b
    204:219:void lambda$_newWorkloadF32$17(neureka.Tsr,neureka.Tsr,neureka.Tsr,float[],neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,float[],float[],int,int) -> a
    200:201:void lambda$_newWorkloadF32$16(float[],neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,float[],float[],int,int) -> a
    196:196:void lambda$_newWorkloadF32$15(float[],neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,float[],float[],int,int) -> b
    158:173:void lambda$_newWorkloadF64$14(neureka.Tsr,neureka.Tsr,neureka.Tsr,double[],neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,double[],double[],int,int) -> a
    154:155:void lambda$_newWorkloadF64$13(double[],neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,double[],double[],int,int) -> a
    150:150:void lambda$_newWorkloadF64$12(double[],neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,double[],double[],int,int) -> b
    92:96:void lambda$implementationForCPU$11(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions) -> a
    1107:1128:neureka.devices.host.CPU$RangeWorkload _newWorkloadFor(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):107:128 -> a
    1107:1128:void lambda$implementationForCPU$11(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):96 -> a
    1137:1157:neureka.devices.host.CPU$RangeWorkload _newWorkloadF64(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64):137:157 -> a
    1137:1157:neureka.devices.host.CPU$RangeWorkload _newWorkloadFor(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):117 -> a
    1137:1157:void lambda$implementationForCPU$11(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):96 -> a
    1182:1203:neureka.devices.host.CPU$RangeWorkload _newWorkloadF32(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32):182:203 -> a
    1182:1203:neureka.devices.host.CPU$RangeWorkload _newWorkloadFor(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):120 -> a
    1182:1203:void lambda$implementationForCPU$11(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):96 -> a
    1229:1249:neureka.devices.host.CPU$RangeWorkload _newWorkloadI32(neureka.Tsr,neureka.Tsr,neureka.Tsr,neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32):229:249 -> a
    1229:1249:neureka.devices.host.CPU$RangeWorkload _newWorkloadFor(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):123 -> a
    1229:1249:void lambda$implementationForCPU$11(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):96 -> a
    63:63:neureka.backend.standard.algorithms.internal.AndBackward lambda$implementationForGPU$10(java.lang.String,java.lang.String) -> a
    64:85:neureka.backend.standard.implementations.CLImplementation lambda$implementationForGPU$9(java.lang.String,java.lang.String,java.lang.String) -> a
    73:83:void lambda$implementationForGPU$8(neureka.backend.api.ExecutionCall) -> a
    40:55:neureka.backend.api.ExecutionCall lambda$new$7(neureka.backend.api.ExecutionCall) -> b
    37:37:neureka.Tsr lambda$new$6(neureka.calculus.internal.RecursiveExecutor,neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    36:36:boolean lambda$new$5(neureka.backend.api.ExecutionCall) -> c
    35:35:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> d
    27:32:float lambda$new$3(neureka.backend.api.ExecutionCall) -> e
    31:31:boolean lambda$new$2(neureka.Tsr) -> a
    30:30:boolean lambda$new$1(int,java.util.List,neureka.Tsr) -> a
    28:28:java.lang.Integer lambda$new$0(java.lang.Integer,java.lang.Integer) -> a
    21:21:void <clinit>() -> <clinit>
neureka.backend.standard.algorithms.Operator$FunTriple -> neureka.backend.standard.algorithms.Operator$FunTriple:
    neureka.backend.standard.algorithms.internal.Fun _a -> a
    neureka.backend.standard.algorithms.internal.Fun _d1 -> b
    neureka.backend.standard.algorithms.internal.Fun _d2 -> c
    274:276:void <init>(neureka.backend.standard.algorithms.internal.Fun,neureka.backend.standard.algorithms.internal.Fun,neureka.backend.standard.algorithms.internal.Fun) -> <init>
    280:280:neureka.backend.standard.algorithms.internal.Fun get(int) -> get
    285:285:java.lang.Class getType() -> getType
neureka.backend.standard.algorithms.Scalarization -> neureka.backend.standard.algorithms.Scalarization:
    boolean $assertionsDisabled -> a
    18:54:void <init>() -> <init>
    58:58:java.lang.String getKernelSource() -> getKernelSource
    63:63:neureka.backend.standard.algorithms.Functions$Builder implementationForCPU() -> implementationForCPU
    159:173:void lambda$_workloadFor$10(neureka.Tsr,neureka.Tsr,java.lang.Object[],neureka.backend.standard.algorithms.internal.Fun$ObjObjToObj,java.lang.Object[],java.lang.Object,int,int) -> a
    137:151:void lambda$_workloadFor$9(neureka.Tsr,neureka.Tsr,int[],neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32,int[],int,int,int) -> a
    115:129:void lambda$_workloadFor$8(neureka.Tsr,neureka.Tsr,float[],neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,float[],float,int,int) -> a
    93:107:void lambda$_workloadFor$7(neureka.Tsr,neureka.Tsr,double[],neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,double[],double,int,int) -> a
    66:70:void lambda$implementationForCPU$6(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions) -> a
    1079:1179:neureka.devices.host.CPU$RangeWorkload _workloadFor(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):79:179 -> a
    1079:1179:void lambda$implementationForCPU$6(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions):70 -> a
    38:51:neureka.backend.api.ExecutionCall lambda$new$5(neureka.backend.api.ExecutionCall) -> a
    22:34:float lambda$new$4(neureka.backend.api.ExecutionCall) -> b
    26:32:boolean lambda$new$3(neureka.Tsr[]) -> a
    23:23:boolean lambda$new$2(neureka.Tsr) -> a
    20:20:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    19:19:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> d
    15:15:void <clinit>() -> <clinit>
neureka.backend.standard.algorithms.internal.AndBackward -> neureka.backend.standard.algorithms.internal.AndBackward:
    neureka.backend.standard.implementations.CLImplementation and(java.lang.Object) -> and
neureka.backend.standard.algorithms.internal.Fun -> neureka.backend.standard.algorithms.internal.Fun:
neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32 -> neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32:
    float invoke(float,float) -> invoke
    87:87:neureka.backend.standard.algorithms.internal.FunArray triple(neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32,neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32) -> triple
    91:91:neureka.backend.standard.algorithms.internal.FunArray of(neureka.backend.standard.algorithms.internal.Fun$F32F32ToF32) -> of
neureka.backend.standard.algorithms.internal.Fun$F32ToF32 -> neureka.backend.standard.algorithms.internal.Fun$F32ToF32:
    float invoke(float) -> invoke
    22:22:neureka.backend.standard.algorithms.internal.FunArray pair(neureka.backend.standard.algorithms.internal.Fun$F32ToF32,neureka.backend.standard.algorithms.internal.Fun$F32ToF32) -> pair
neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64 -> neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64:
    double invoke(double,double) -> invoke
    70:70:neureka.backend.standard.algorithms.internal.FunArray triple(neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64,neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64) -> triple
    74:74:neureka.backend.standard.algorithms.internal.FunArray of(neureka.backend.standard.algorithms.internal.Fun$F64F64ToF64) -> of
neureka.backend.standard.algorithms.internal.Fun$F64ToF64 -> neureka.backend.standard.algorithms.internal.Fun$F64ToF64:
    double invoke(double) -> invoke
    13:13:neureka.backend.standard.algorithms.internal.FunPair pair(neureka.backend.standard.algorithms.internal.Fun$F64ToF64,neureka.backend.standard.algorithms.internal.Fun$F64ToF64) -> pair
neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32 -> neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32:
    int invoke(int,int) -> invoke
    104:104:neureka.backend.standard.algorithms.internal.FunArray triple(neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32,neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32,neureka.backend.standard.algorithms.internal.Fun$I32I32ToI32) -> triple
neureka.backend.standard.algorithms.internal.Fun$I32ToI32 -> neureka.backend.standard.algorithms.internal.Fun$I32ToI32:
    int invoke(int) -> invoke
    31:31:neureka.backend.standard.algorithms.internal.FunArray pair(neureka.backend.standard.algorithms.internal.Fun$I32ToI32,neureka.backend.standard.algorithms.internal.Fun$I32ToI32) -> pair
neureka.backend.standard.algorithms.internal.Fun$ObjObjToObj -> neureka.backend.standard.algorithms.internal.Fun$ObjObjToObj:
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> invoke
    53:53:neureka.backend.standard.algorithms.internal.FunArray triple(neureka.backend.standard.algorithms.internal.Fun$ObjObjToObj,neureka.backend.standard.algorithms.internal.Fun$ObjObjToObj,neureka.backend.standard.algorithms.internal.Fun$ObjObjToObj) -> triple
    57:57:neureka.backend.standard.algorithms.internal.FunArray of(neureka.backend.standard.algorithms.internal.Fun$ObjObjToObj) -> of
neureka.backend.standard.algorithms.internal.Fun$ObjToObj -> neureka.backend.standard.algorithms.internal.Fun$ObjToObj:
    java.lang.Object invoke(java.lang.Object) -> invoke
    40:40:neureka.backend.standard.algorithms.internal.FunArray pair(neureka.backend.standard.algorithms.internal.Fun$ObjToObj,neureka.backend.standard.algorithms.internal.Fun$ObjToObj) -> pair
neureka.backend.standard.algorithms.internal.FunArray -> neureka.backend.standard.algorithms.internal.FunArray:
    neureka.backend.standard.algorithms.internal.Fun get(int) -> get
    java.lang.Class getType() -> getType
neureka.backend.standard.algorithms.internal.FunImplementation -> neureka.backend.standard.algorithms.internal.FunImplementation:
    void get(neureka.backend.api.ExecutionCall,neureka.backend.standard.algorithms.Functions) -> get
neureka.backend.standard.algorithms.internal.FunPair -> neureka.backend.standard.algorithms.internal.FunPair:
    java.lang.Class _type -> a
    neureka.backend.standard.algorithms.internal.Fun _a -> b
    neureka.backend.standard.algorithms.internal.Fun _d -> c
    9:13:void <init>(neureka.backend.standard.algorithms.internal.Fun,neureka.backend.standard.algorithms.internal.Fun) -> <init>
    16:16:neureka.backend.standard.algorithms.internal.Fun get(int) -> get
    19:19:java.lang.Class getType() -> getType
neureka.backend.standard.algorithms.internal.WithForward -> neureka.backend.standard.algorithms.internal.WithForward:
    neureka.backend.standard.algorithms.internal.AndBackward with(java.lang.Object) -> with
neureka.backend.standard.implementations.AdHocClImplementation -> neureka.backend.standard.implementations.AdHocClImplementation:
    neureka.devices.opencl.KernelSource _kernelProvider -> a
    14:16:void <init>(neureka.backend.api.ImplementationFor,int,neureka.devices.opencl.KernelSource) -> <init>
    20:20:neureka.devices.opencl.KernelCode getKernelFor(neureka.backend.api.ExecutionCall) -> getKernelFor
neureka.backend.standard.implementations.CLImplementation -> neureka.backend.standard.implementations.CLImplementation:
    23:24:void <init>(neureka.backend.api.ImplementationFor,int) -> <init>
    27:27:neureka.backend.standard.implementations.CLImplementation$SourceBuilder fromSource() -> fromSource
    31:31:neureka.backend.standard.implementations.CLImplementation$Compiler compiler() -> compiler
    35:35:neureka.backend.standard.implementations.CLImplementation$AdHocCompiler adHoc(neureka.devices.opencl.KernelSource) -> adHoc
neureka.backend.standard.implementations.CLImplementation$AdHocCompiler -> neureka.backend.standard.implementations.CLImplementation$AdHocCompiler:
    neureka.devices.opencl.KernelSource _source -> a
    int _arity -> b
    91:91:void <init>(neureka.devices.opencl.KernelSource) -> <init>
    93:93:neureka.backend.standard.implementations.CLImplementation$AdHocCompiler arity(int) -> arity
    96:96:neureka.backend.standard.implementations.CLImplementation caller(neureka.backend.api.ImplementationFor) -> caller
neureka.backend.standard.implementations.CLImplementation$Compiler -> neureka.backend.standard.implementations.CLImplementation$Compiler:
    neureka.backend.api.ImplementationFor lambda -> a
    int arity -> b
    java.lang.String kernelSource -> c
    java.lang.String activationSource -> d
    java.lang.String differentiationSource -> e
    java.lang.String type -> f
    70:70:void <init>() -> <init>
    72:72:neureka.backend.standard.implementations.CLImplementation$Compiler execution(neureka.backend.api.ImplementationFor) -> execution
    73:73:neureka.backend.standard.implementations.CLImplementation$Compiler arity(int) -> arity
    74:74:neureka.backend.standard.implementations.CLImplementation$Compiler kernelSource(java.lang.String) -> kernelSource
    75:75:neureka.backend.standard.implementations.CLImplementation$Compiler activationSource(java.lang.String) -> activationSource
    76:76:neureka.backend.standard.implementations.CLImplementation$Compiler differentiationSource(java.lang.String) -> differentiationSource
    77:77:neureka.backend.standard.implementations.CLImplementation$Compiler kernelPostfix(java.lang.String) -> kernelPostfix
    79:82:neureka.backend.standard.implementations.CLImplementation build() -> build
    62:62:void <init>(byte) -> <init>
neureka.backend.standard.implementations.CLImplementation$SourceBuilder -> neureka.backend.standard.implementations.CLImplementation$SourceBuilder:
    neureka.backend.api.ImplementationFor lambda -> a
    int arity -> b
    java.lang.String kernelName -> c
    java.lang.String kernelSource -> d
    49:49:void <init>() -> <init>
    55:55:neureka.backend.standard.implementations.CLImplementation$SourceBuilder lambda(neureka.backend.api.ImplementationFor) -> lambda
    56:56:neureka.backend.standard.implementations.CLImplementation$SourceBuilder arity(int) -> arity
    57:57:neureka.backend.standard.implementations.CLImplementation$SourceBuilder kernelName(java.lang.String) -> kernelName
    58:58:neureka.backend.standard.implementations.CLImplementation$SourceBuilder kernelSource(java.lang.String) -> kernelSource
    59:59:neureka.backend.standard.implementations.CLImplementation build() -> build
    42:42:void <init>(byte) -> <init>
neureka.backend.standard.implementations.CPUImplementation -> neureka.backend.standard.implementations.CPUImplementation:
    18:18:neureka.backend.standard.implementations.CPUImplementation$AndImplementation withArity(int) -> withArity
    20:20:void <init>(neureka.backend.api.ImplementationFor,int) -> <init>
    18:18:neureka.backend.standard.implementations.CPUImplementation lambda$withArity$0(int,neureka.backend.api.ImplementationFor) -> a
neureka.backend.standard.implementations.CPUImplementation$AndImplementation -> neureka.backend.standard.implementations.CPUImplementation$AndImplementation:
    neureka.backend.standard.implementations.CPUImplementation andImplementation(neureka.backend.api.ImplementationFor) -> andImplementation
neureka.backend.standard.implementations.ParsedCLImplementation -> neureka.backend.standard.implementations.ParsedCLImplementation:
    java.util.function.Function _aliasSwapper -> a
    java.util.function.Function asAdvanced -> b
    neureka.devices.opencl.KernelCode _kernel -> c
    13:65:void <init>(neureka.backend.api.ImplementationFor,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> <init>
    1076:1104:java.util.Map _getParsedKernelsFromTemplate(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String):76:104 -> <init>
    1076:1104:void <init>(neureka.backend.api.ImplementationFor,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String):53 -> <init>
    109:109:neureka.devices.opencl.KernelCode getKernelFor(neureka.backend.api.ExecutionCall) -> getKernelFor
    82:92:void lambda$_getParsedKernelsFromTemplate$2(java.lang.String[],java.lang.String,java.util.Map,java.lang.String,java.lang.String,java.lang.String) -> a
    30:33:java.lang.String lambda$new$1(java.lang.String) -> a
    15:25:java.lang.String lambda$new$0(java.lang.String) -> b
neureka.backend.standard.implementations.ParsedCLImplementation$Parser -> neureka.backend.standard.implementations.ParsedCLImplementation$a:
    void apply(java.lang.String,java.lang.String,java.lang.String) -> apply
neureka.backend.standard.implementations.SimpleCLImplementation -> neureka.backend.standard.implementations.SimpleCLImplementation:
    neureka.devices.opencl.KernelCode _kernel -> a
    18:20:void <init>(neureka.backend.api.ImplementationFor,int,java.lang.String,java.lang.String) -> <init>
    24:24:neureka.devices.opencl.KernelCode getKernelFor(neureka.backend.api.ExecutionCall) -> getKernelFor
neureka.backend.standard.memory.MemUtil -> neureka.backend.standard.memory.MemUtil:
    23:23:void <init>() -> <init>
    42:52:void autoDelete(neureka.Tsr[]) -> autoDelete
    69:74:java.lang.Object keep(neureka.Tsr[],java.util.function.Supplier) -> keep
    93:98:java.lang.Object keep(neureka.Tsr,neureka.Tsr,java.util.function.Supplier) -> keep
    97:97:void lambda$keep$3(neureka.Tsr) -> a
    94:94:void lambda$keep$2(neureka.Tsr) -> b
    73:73:void lambda$keep$1(neureka.Tsr) -> c
    70:70:void lambda$keep$0(neureka.Tsr) -> d
neureka.backend.standard.memory.MemValidator -> neureka.backend.standard.memory.MemValidator:
    neureka.Tsr _result -> a
    boolean _wronglyIntermediate -> b
    boolean _wronglyNonIntermediate -> c
    31:31:neureka.backend.standard.memory.MemValidator forInputs(neureka.Tsr[],java.util.function.Supplier) -> forInputs
    34:94:void <init>(neureka.Tsr[],java.util.function.Supplier) -> <init>
    100:100:boolean isWronglyIntermediate() -> isWronglyIntermediate
    107:107:boolean isWronglyNonIntermediate() -> isWronglyNonIntermediate
    114:114:neureka.Tsr getResult() -> getResult
    72:72:boolean lambda$new$6(neureka.Tsr[],neureka.Tsr,int) -> a
    68:68:boolean lambda$new$5(neureka.Tsr[],neureka.Tsr,int) -> b
    60:60:boolean lambda$new$4(neureka.Tsr,neureka.Tsr) -> a
    59:59:boolean lambda$new$3(neureka.Tsr,neureka.Tsr) -> b
    42:42:java.lang.Boolean[] lambda$new$2(int) -> a
    42:42:java.lang.Boolean lambda$new$1(neureka.Tsr) -> a
    41:41:java.lang.Boolean[] lambda$new$0(int) -> b
neureka.backend.standard.operations.ConvUtil -> neureka.backend.standard.operations.ConvUtil:
    neureka.backend.standard.algorithms.Convolution conv -> a
    boolean $assertionsDisabled -> b
    16:16:void <init>() -> <init>
    25:133:neureka.backend.standard.algorithms.Convolution createDeconvolutionFor(java.lang.String) -> createDeconvolutionFor
    137:139:neureka.backend.standard.algorithms.Convolution getConv() -> getConv
    144:147:int[] _shpOfCon(int[],int[]) -> a
    117:130:neureka.backend.api.ExecutionCall lambda$createDeconvolutionFor$5(neureka.backend.api.ExecutionCall) -> a
    74:112:neureka.Tsr lambda$createDeconvolutionFor$4(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    42:62:neureka.autograd.ADAgent lambda$createDeconvolutionFor$3(java.lang.String,neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    64:67:neureka.Tsr lambda$createDeconvolutionFor$2(neureka.calculus.Function,neureka.Tsr,int[],neureka.autograd.GraphNode,neureka.Tsr) -> a
    29:36:boolean lambda$createDeconvolutionFor$1(neureka.backend.api.ExecutionCall) -> b
    26:26:boolean lambda$createDeconvolutionFor$0(neureka.backend.api.ExecutionCall) -> c
    16:22:void <clinit>() -> <clinit>
neureka.backend.standard.operations.JunctionUtil -> neureka.backend.standard.operations.JunctionUtil:
    org.slf4j.Logger _LOG -> a
    19:19:void <init>() -> <init>
    28:66:neureka.Tsr forConvolution(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> forConvolution
    74:110:neureka.Tsr forMultiplications(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> forMultiplications
    119:181:neureka.Tsr forDivisionsOrModuli(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> forDivisionsOrModuli
    189:189:neureka.Tsr forAdditions(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> forAdditions
    197:197:neureka.Tsr forSubtractions(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> forSubtractions
    206:239:neureka.Tsr _forAdditionsOrSubtractions(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor,boolean) -> a
    246:257:neureka.Tsr newTsrLike(neureka.Tsr,double) -> newTsrLike
    21:21:void <clinit>() -> <clinit>
neureka.backend.standard.operations.function.Absolute -> neureka.backend.standard.operations.function.Absolute:
    16:54:void <init>() -> <init>
    58:60:java.lang.String stringify(java.lang.String[]) -> stringify
    65:65:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    70:73:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    78:79:double calculate(double,boolean) -> calculate
    43:43:int lambda$new$5(int) -> a
    42:42:int lambda$new$4(int) -> b
    39:39:float lambda$new$3(float) -> a
    38:38:float lambda$new$2(float) -> b
    35:35:double lambda$new$1(double) -> a
    34:34:double lambda$new$0(double) -> b
neureka.backend.standard.operations.function.Cosinus -> neureka.backend.standard.operations.function.Cosinus:
    16:54:void <init>() -> <init>
    58:60:java.lang.String stringify(java.lang.String[]) -> stringify
    65:65:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    70:73:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    78:79:double calculate(double,boolean) -> calculate
    43:43:int lambda$new$5(int) -> a
    42:42:int lambda$new$4(int) -> b
    39:39:float lambda$new$3(float) -> a
    38:38:float lambda$new$2(float) -> b
    35:35:double lambda$new$1(double) -> a
    34:34:double lambda$new$0(double) -> b
neureka.backend.standard.operations.function.Gaussian -> neureka.backend.standard.operations.function.Gaussian:
    18:82:void <init>() -> <init>
    86:88:java.lang.String stringify(java.lang.String[]) -> stringify
    93:93:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    98:101:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    106:107:double calculate(double,boolean) -> calculate
    60:60:int lambda$new$7(int) -> a
    59:59:int lambda$new$6(int) -> b
    56:56:float lambda$new$5(float) -> a
    55:55:float lambda$new$4(float) -> b
    52:52:double lambda$new$3(double) -> a
    51:51:double lambda$new$2(double) -> b
    33:38:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> a
    30:30:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> b
neureka.backend.standard.operations.function.Identity -> neureka.backend.standard.operations.function.Identity:
    24:173:void <init>() -> <init>
    177:179:java.lang.String stringify(java.lang.String[]) -> stringify
    184:184:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    189:192:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    197:198:double calculate(double,boolean) -> calculate
    157:167:void lambda$new$22(neureka.backend.api.ExecutionCall) -> a
    143:143:int lambda$new$21(int,int) -> a
    142:142:int lambda$new$20(int,int) -> b
    141:141:int lambda$new$19(int,int) -> c
    138:138:float lambda$new$18(float,float) -> a
    137:137:float lambda$new$17(float,float) -> b
    136:136:float lambda$new$16(float,float) -> c
    133:133:double lambda$new$15(double,double) -> a
    132:132:double lambda$new$14(double,double) -> b
    131:131:double lambda$new$13(double,double) -> c
    107:120:neureka.backend.api.ExecutionCall lambda$new$12(neureka.backend.api.ExecutionCall) -> b
    95:100:boolean lambda$new$11(neureka.backend.api.ExecutionCall) -> c
    92:92:boolean lambda$new$10(neureka.backend.api.ExecutionCall) -> d
    78:78:java.lang.Object lambda$new$9(java.lang.Object) -> a
    75:75:int lambda$new$8(int) -> a
    74:74:int lambda$new$7(int) -> b
    71:71:float lambda$new$6(float) -> a
    70:70:float lambda$new$5(float) -> b
    67:67:double lambda$new$4(double) -> a
    66:66:double lambda$new$3(double) -> b
    51:55:neureka.backend.api.ExecutionCall lambda$new$2(neureka.backend.api.ExecutionCall) -> e
    39:44:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> f
    36:36:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> g
neureka.backend.standard.operations.function.Logarithm -> neureka.backend.standard.operations.function.Logarithm:
    16:58:void <init>() -> <init>
    62:64:java.lang.String stringify(java.lang.String[]) -> stringify
    69:70:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    75:78:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    83:84:double calculate(double,boolean) -> calculate
    46:46:int lambda$new$5(int) -> a
    45:45:int lambda$new$4(int) -> b
    42:42:float lambda$new$3(float) -> a
    41:41:float lambda$new$2(float) -> b
    38:38:double lambda$new$1(double) -> a
    37:37:double lambda$new$0(double) -> b
neureka.backend.standard.operations.function.Quadratic -> neureka.backend.standard.operations.function.Quadratic:
    15:56:void <init>() -> <init>
    60:62:java.lang.String stringify(java.lang.String[]) -> stringify
    67:67:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    72:75:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    80:81:double calculate(double,boolean) -> calculate
    45:45:int lambda$new$5(int) -> a
    44:44:int lambda$new$4(int) -> b
    41:41:float lambda$new$3(float) -> a
    40:40:float lambda$new$2(float) -> b
    37:37:double lambda$new$1(double) -> a
    36:36:double lambda$new$0(double) -> b
neureka.backend.standard.operations.function.ReLU -> neureka.backend.standard.operations.function.ReLU:
    16:57:void <init>() -> <init>
    61:63:java.lang.String stringify(java.lang.String[]) -> stringify
    68:68:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    73:76:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    82:89:double calculate(double,boolean) -> calculate
    46:46:int lambda$new$5(int) -> a
    45:45:int lambda$new$4(int) -> b
    42:42:float lambda$new$3(float) -> a
    41:41:float lambda$new$2(float) -> b
    38:38:double lambda$new$1(double) -> a
    37:37:double lambda$new$0(double) -> b
neureka.backend.standard.operations.function.Sigmoid -> neureka.backend.standard.operations.function.Sigmoid:
    16:58:void <init>() -> <init>
    62:64:java.lang.String stringify(java.lang.String[]) -> stringify
    69:69:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    74:77:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    82:85:double calculate(double,boolean) -> calculate
    47:47:int lambda$new$5(int) -> a
    46:46:int lambda$new$4(int) -> b
    43:43:float lambda$new$3(float) -> a
    42:42:float lambda$new$2(float) -> b
    39:39:double lambda$new$1(double) -> a
    38:38:double lambda$new$0(double) -> b
neureka.backend.standard.operations.function.Sinus -> neureka.backend.standard.operations.function.Sinus:
    20:95:void <init>() -> <init>
    99:101:java.lang.String stringify(java.lang.String[]) -> stringify
    106:106:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    111:114:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    119:120:double calculate(double,boolean) -> calculate
    84:84:int lambda$new$9(int) -> a
    83:83:int lambda$new$8(int) -> b
    80:80:float lambda$new$7(float) -> a
    79:79:float lambda$new$6(float) -> b
    76:76:double lambda$new$5(double) -> a
    75:75:double lambda$new$4(double) -> b
    51:64:neureka.backend.api.ExecutionCall lambda$new$3(neureka.backend.api.ExecutionCall) -> a
    46:46:neureka.autograd.ADAgent lambda$new$2(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    36:41:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> b
    33:33:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> c
neureka.backend.standard.operations.function.Softplus -> neureka.backend.standard.operations.function.Softplus:
    17:80:void <init>() -> <init>
    84:86:java.lang.String stringify(java.lang.String[]) -> stringify
    91:91:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    96:99:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    104:105:double calculate(double,boolean) -> calculate
    49:49:int lambda$new$5(int) -> a
    48:48:int lambda$new$4(int) -> b
    45:45:float lambda$new$3(float) -> a
    44:44:float lambda$new$2(float) -> b
    41:41:double lambda$new$1(double) -> a
    40:40:double lambda$new$0(double) -> b
neureka.backend.standard.operations.function.Tanh -> neureka.backend.standard.operations.function.Tanh:
    16:58:void <init>() -> <init>
    62:64:java.lang.String stringify(java.lang.String[]) -> stringify
    69:69:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    74:77:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    82:86:double calculate(double,boolean) -> calculate
    46:46:int lambda$new$5(int) -> a
    45:45:int lambda$new$4(int) -> b
    42:42:float lambda$new$3(float) -> a
    41:41:float lambda$new$2(float) -> b
    38:38:double lambda$new$1(double) -> a
    37:37:double lambda$new$0(double) -> b
neureka.backend.standard.operations.indexer.Product -> neureka.backend.standard.operations.indexer.Product:
    36:214:void <init>() -> <init>
    220:224:java.lang.String stringify(java.lang.String[]) -> stringify
    229:229:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    235:255:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    261:280:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    197:205:void lambda$new$32(neureka.backend.api.ExecutionCall) -> a
    183:183:int lambda$new$31(int) -> a
    182:182:int lambda$new$30(int) -> b
    179:179:float lambda$new$29(float) -> a
    178:178:float lambda$new$28(float) -> b
    175:175:double lambda$new$27(double) -> a
    174:174:double lambda$new$26(double) -> b
    149:162:neureka.backend.api.ExecutionCall lambda$new$25(neureka.backend.api.ExecutionCall) -> b
    146:146:neureka.Tsr lambda$new$24(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    108:141:neureka.autograd.ADAgent lambda$new$23(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    141:141:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    140:140:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    134:134:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    133:133:neureka.Tsr lambda$new$19(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    121:121:neureka.Tsr lambda$new$18(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    120:120:neureka.Tsr lambda$new$17(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    113:113:neureka.Tsr lambda$new$16(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    112:112:neureka.Tsr lambda$new$15(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    104:104:boolean lambda$new$14(neureka.backend.api.ExecutionCall) -> c
    103:103:boolean lambda$new$13(neureka.backend.api.ExecutionCall) -> d
    87:87:float lambda$new$12(float,float) -> a
    86:86:float lambda$new$11(float,float) -> b
    85:85:float lambda$new$10(float,float) -> c
    82:82:double lambda$new$9(double,double) -> a
    81:81:double lambda$new$8(double,double) -> b
    80:80:double lambda$new$7(double,double) -> c
    57:71:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    71:71:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    70:70:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    62:62:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    61:61:neureka.Tsr lambda$new$2(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    53:53:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> e
    52:52:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> f
neureka.backend.standard.operations.indexer.Summation -> neureka.backend.standard.operations.indexer.Summation:
    36:214:void <init>() -> <init>
    218:222:java.lang.String stringify(java.lang.String[]) -> stringify
    227:227:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    232:234:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    239:250:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    256:263:double _calculate(double[],neureka.calculus.Function[]) -> a
    197:208:void lambda$new$32(neureka.backend.api.ExecutionCall) -> a
    183:183:int lambda$new$31(int) -> a
    183:183:int lambda$new$30(int) -> b
    182:182:float lambda$new$29(float) -> a
    182:182:float lambda$new$28(float) -> b
    181:181:double lambda$new$27(double) -> a
    181:181:double lambda$new$26(double) -> b
    158:171:neureka.backend.api.ExecutionCall lambda$new$25(neureka.backend.api.ExecutionCall) -> b
    155:155:neureka.Tsr lambda$new$24(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    112:150:neureka.autograd.ADAgent lambda$new$23(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    150:150:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    149:149:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    139:142:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    137:137:neureka.Tsr lambda$new$19(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    125:125:neureka.Tsr lambda$new$18(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    124:124:neureka.Tsr lambda$new$17(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    117:117:neureka.Tsr lambda$new$16(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    116:116:neureka.Tsr lambda$new$15(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    108:108:boolean lambda$new$14(neureka.backend.api.ExecutionCall) -> c
    107:107:boolean lambda$new$13(neureka.backend.api.ExecutionCall) -> d
    90:90:float lambda$new$12(float,float) -> a
    89:89:float lambda$new$11(float,float) -> b
    88:88:float lambda$new$10(float,float) -> c
    85:85:double lambda$new$9(double,double) -> a
    84:84:double lambda$new$8(double,double) -> b
    83:83:double lambda$new$7(double,double) -> c
    56:70:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> b
    70:70:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    69:69:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    61:61:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    60:60:neureka.Tsr lambda$new$2(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    52:52:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> e
    51:51:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> f
neureka.backend.standard.operations.linear.CPUMatMul -> neureka.backend.standard.operations.linear.CPUMatMul:
    14:14:void <init>() -> <init>
    28:31:void execute(boolean,double[],double[],double[],int,int,int) -> execute
    36:39:void execute(boolean,float[],float[],float[],int,int,int) -> execute
    44:92:void run(neureka.backend.api.ExecutionCall) -> run
    44:44:neureka.ndim.config.NDConfiguration$Layout lambda$run$0(neureka.Tsr) -> a
neureka.backend.standard.operations.linear.MatMul -> neureka.backend.standard.operations.linear.MatMul:
    org.slf4j.Logger _LOG -> a
    neureka.backend.standard.algorithms.FunAlgorithm simpleMatMulAlgorithm -> b
    32:148:void <init>() -> <init>
    152:170:neureka.backend.api.ExecutionCall _prepare(neureka.backend.api.ExecutionCall) -> a
    1180:1195:void _autoClone(neureka.backend.api.ExecutionCall):180:195 -> a
    1180:1195:neureka.backend.api.ExecutionCall _prepare(neureka.backend.api.ExecutionCall):169 -> a
    1202:1202:boolean _isSimpleRowMajorMatrix(neureka.Tsr):202:202 -> a
    1202:1202:void _autoClone(neureka.backend.api.ExecutionCall):182 -> a
    1202:1202:neureka.backend.api.ExecutionCall _prepare(neureka.backend.api.ExecutionCall):169 -> a
    2198:2198:boolean _isSimpleColumnMajorMatrix(neureka.Tsr):198:198 -> a
    2198:2198:void _autoClone(neureka.backend.api.ExecutionCall):184 -> a
    2198:2198:neureka.backend.api.ExecutionCall _prepare(neureka.backend.api.ExecutionCall):169 -> a
    207:213:java.lang.String stringify(java.lang.String[]) -> stringify
    218:218:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    223:223:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    124:142:void lambda$new$10(neureka.backend.api.ExecutionCall) -> b
    126:126:boolean lambda$new$9(neureka.Tsr) -> a
    76:84:neureka.Tsr lambda$new$8(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    59:66:neureka.autograd.ADAgent lambda$new$7(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    67:70:neureka.Tsr lambda$new$6(int,neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    55:55:boolean lambda$new$5(neureka.backend.api.ExecutionCall) -> c
    54:54:boolean lambda$new$4(neureka.backend.api.ExecutionCall) -> d
    47:52:float lambda$new$3(neureka.backend.api.ExecutionCall) -> e
    51:51:boolean lambda$new$2(neureka.Tsr) -> b
    50:50:boolean lambda$new$1(neureka.Tsr) -> c
    48:48:boolean lambda$new$0(neureka.Tsr) -> d
    27:27:void <clinit>() -> <clinit>
neureka.backend.standard.operations.linear.XConv -> neureka.backend.standard.operations.linear.XConv:
    18:75:void <init>() -> <init>
    80:87:java.lang.String stringify(java.lang.String[]) -> stringify
    92:92:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    97:97:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    59:69:void lambda$new$6(neureka.backend.api.ExecutionCall) -> a
    45:45:float lambda$new$5(float,float) -> a
    44:44:float lambda$new$4(float,float) -> b
    43:43:float lambda$new$3(float,float) -> c
    40:40:double lambda$new$2(double,double) -> a
    39:39:double lambda$new$1(double,double) -> b
    38:38:double lambda$new$0(double,double) -> c
neureka.backend.standard.operations.linear.XConvLeft -> neureka.backend.standard.operations.linear.XConvLeft:
    12:23:void <init>() -> <init>
    27:34:java.lang.String stringify(java.lang.String[]) -> stringify
    39:39:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    44:44:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.linear.XConvRight -> neureka.backend.standard.operations.linear.XConvRight:
    12:23:void <init>() -> <init>
    27:34:java.lang.String stringify(java.lang.String[]) -> stringify
    39:39:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    44:44:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
neureka.backend.standard.operations.linear.internal.M32 -> neureka.backend.standard.operations.linear.internal.M32:
    float[] _data -> a
    int _rowCount -> b
    int _colCount -> c
    15:19:void <init>(int,int,float[]) -> <init>
    23:32:neureka.backend.standard.operations.linear.internal.M32 multiply(boolean,neureka.backend.standard.operations.linear.internal.M32,float[]) -> multiply
    35:35:int getRowDim() -> getRowDim
    37:37:int getColDim() -> getColDim
    40:40:float[] getData() -> getData
    45:51:java.lang.String toString() -> toString
    52:59:void lambda$toString$0(neureka.view.TsrStringSettings) -> a
neureka.backend.standard.operations.linear.internal.M64 -> neureka.backend.standard.operations.linear.internal.M64:
    double[] _data -> a
    int _rowCount -> b
    int _colCount -> c
    15:19:void <init>(int,int,double[]) -> <init>
    23:32:neureka.backend.standard.operations.linear.internal.M64 multiply(boolean,neureka.backend.standard.operations.linear.internal.M64,double[]) -> multiply
    35:35:int getRowDim() -> getRowDim
    37:37:int getColDim() -> getColDim
    40:40:double[] getData() -> getData
    45:51:java.lang.String toString() -> toString
    52:59:void lambda$toString$0(neureka.view.TsrStringSettings) -> a
neureka.backend.standard.operations.linear.internal.blas.AXPY -> neureka.backend.standard.operations.linear.internal.blas.AXPY:
    9:9:void <init>() -> <init>
    20:23:void invoke(double[],int,double,double[],int,int,int) -> invoke
    34:37:void invoke(float[],int,float,float[],int,int,int) -> invoke
neureka.backend.standard.operations.linear.internal.blas.COPY -> neureka.backend.standard.operations.linear.internal.blas.COPY:
    9:9:void <init>() -> <init>
    13:16:java.lang.Object[] copyOf(java.lang.Object[]) -> copyOf
neureka.backend.standard.operations.linear.internal.blas.DOT -> neureka.backend.standard.operations.linear.internal.blas.DOT:
    9:9:void <init>() -> <init>
    12:12:double invoke(double[],int,double[],int,int,int) -> invoke
    1021:1049:double unrolled04(double[],int,double[],int,int,int):21:49 -> invoke
    1021:1049:double invoke(double[],int,double[],int,int,int):12 -> invoke
    16:16:float invoke(float[],int,float[],int,int,int) -> invoke
    1054:1082:float unrolled04(float[],int,float[],int,int,int):54:82 -> invoke
    1054:1082:float invoke(float[],int,float[],int,int,int):16 -> invoke
neureka.backend.standard.operations.linear.internal.blas.MatMul -> neureka.backend.standard.operations.linear.internal.blas.MatMul:
    11:11:void <init>() -> <init>
    36:57:neureka.backend.standard.operations.linear.internal.blas.MatMul$VectorOperationF32 operationForF32(boolean,long,long) -> operationForF32
    64:101:neureka.backend.standard.operations.linear.internal.blas.MatMul$VectorOperationF64 operationForF64(boolean,long,long) -> operationForF64
    111:123:void full_F64_Mx1_CM(double[],double[],int,double[]) -> a
    131:144:void full_F64_Mx1_RM(double[],double[],int,double[]) -> b
    152:164:void full_F32_Mx1_CM(float[],float[],int,float[]) -> a
    172:185:void full_F32_Mx1_RM(float[],float[],int,float[]) -> b
    195:210:void partial_F64_MxN_CM(double[],int,int,double[],int,double[]) -> a
    220:234:void partial_F64_MxN_RM(double[],int,int,double[],int,double[]) -> b
    244:258:void partial_F32_MxN_CM(float[],int,int,float[],int,float[]) -> a
    268:282:void partial_F32_MxN_RM(float[],int,int,float[],int,float[]) -> b
    286:293:void threaded_F64_MxN_CM(double[],double[],int,double[]) -> c
    296:303:void threaded_F32_MxN_CM(float[],float[],int,float[]) -> c
    306:313:void threaded_F32_MxN_RM(float[],float[],int,float[]) -> d
    316:323:void threaded_F64_MxN_RM(double[],double[],int,double[]) -> d
    332:374:void full_F64_0xN_CM(double[],double[],int,double[]) -> e
    382:390:void full_F64_1x1_CM(double[],double[],int,double[]) -> f
    398:400:void full_F64_1xN_CM(double[],double[],int,double[]) -> g
    408:420:void full_F64_1xN_RM(double[],double[],int,double[]) -> h
    428:431:void full_F32_1xN_CM(float[],float[],int,float[]) -> e
    440:452:void full_F32_1xN_RM(float[],float[],int,float[]) -> f
    461:488:void full_F64_2x2_CM(double[],double[],int,double[]) -> i
    496:542:void full_F64_3x3_CM(double[],double[],int,double[]) -> j
    550:621:void full_F64_4x4_CM(double[],double[],int,double[]) -> k
    629:731:void full_F64_5x5_CM(double[],double[],int,double[]) -> l
    740:770:void full_F64_6xN_CM(double[],double[],int,double[]) -> m
    779:812:void full_F64_7xN_CM(double[],double[],int,double[]) -> n
    821:857:void full_F64_8xN_CM(double[],double[],int,double[]) -> o
    866:905:void full_F64_9xN_CM(double[],double[],int,double[]) -> p
    913:914:void full_F64_MxN_CM(double[],double[],int,double[]) -> q
    922:923:void full_F64_MxN_RM(double[],double[],int,double[]) -> r
    931:932:void full_F32_MxN_CM(float[],float[],int,float[]) -> g
    940:941:void full_F32_MxN_RM(float[],float[],int,float[]) -> h
    321:321:void lambda$threaded_F64_MxN_RM$3(double[],double[],int,double[],int,int) -> a
    311:311:void lambda$threaded_F32_MxN_RM$2(float[],float[],int,float[],int,int) -> a
    301:301:void lambda$threaded_F32_MxN_CM$1(float[],float[],int,float[],int,int) -> b
    291:291:void lambda$threaded_F64_MxN_CM$0(double[],double[],int,double[],int,int) -> b
neureka.backend.standard.operations.linear.internal.blas.MatMul$VectorOperationF32 -> neureka.backend.standard.operations.linear.internal.blas.MatMul$VectorOperationF32:
    void invoke(float[],float[],int,float[]) -> invoke
neureka.backend.standard.operations.linear.internal.blas.MatMul$VectorOperationF64 -> neureka.backend.standard.operations.linear.internal.blas.MatMul$VectorOperationF64:
    void invoke(double[],double[],int,double[]) -> invoke
neureka.backend.standard.operations.linear.internal.opencl.GEMM -> neureka.backend.standard.operations.linear.internal.opencl.GEMM:
    boolean $assertionsDisabled -> a
    11:11:void <init>() -> <init>
    16:101:void run(neureka.backend.api.ExecutionCall) -> run
    45:53:java.lang.String lambda$run$0(int,int,int,int,int,int,java.lang.String) -> a
    11:11:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.Addition -> neureka.backend.standard.operations.operator.Addition:
    neureka.backend.standard.algorithms.Broadcast _broadcast -> a
    boolean $assertionsDisabled -> b
    28:218:void <init>() -> <init>
    223:230:java.lang.String stringify(java.lang.String[]) -> stringify
    235:240:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    245:258:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    264:276:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    237:237:neureka.calculus.Function lambda$asDerivative$32(int,neureka.calculus.Function) -> a
    236:236:boolean lambda$asDerivative$31(int,neureka.calculus.Function) -> b
    196:213:void lambda$new$30(neureka.backend.api.ExecutionCall) -> a
    157:182:void lambda$new$29(neureka.backend.api.ExecutionCall) -> b
    177:177:int lambda$new$28(int,int) -> a
    176:176:int lambda$new$27(int,int) -> b
    175:175:int lambda$new$26(int,int) -> c
    172:172:float lambda$new$25(float,float) -> a
    171:171:float lambda$new$24(float,float) -> b
    170:170:float lambda$new$23(float,float) -> c
    167:167:double lambda$new$22(double,double) -> a
    166:166:double lambda$new$21(double,double) -> b
    165:165:double lambda$new$20(double,double) -> c
    147:147:neureka.Tsr lambda$new$19(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    130:130:float lambda$new$18(float,float) -> d
    129:129:float lambda$new$17(float,float) -> e
    128:128:float lambda$new$16(float,float) -> f
    125:125:double lambda$new$15(double,double) -> d
    124:124:double lambda$new$14(double,double) -> e
    123:123:double lambda$new$13(double,double) -> f
    102:102:int lambda$new$12(int,int) -> d
    101:101:int lambda$new$11(int,int) -> e
    100:100:int lambda$new$10(int,int) -> f
    97:97:float lambda$new$9(float,float) -> g
    96:96:float lambda$new$8(float,float) -> h
    95:95:float lambda$new$7(float,float) -> i
    92:92:double lambda$new$6(double,double) -> g
    91:91:double lambda$new$5(double,double) -> h
    90:90:double lambda$new$4(double,double) -> i
    34:44:neureka.autograd.ADAgent lambda$new$3(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    46:56:neureka.Tsr lambda$new$2(neureka.devices.Device,neureka.Tsr,neureka.Tsr,int,neureka.autograd.GraphNode,neureka.Tsr) -> a
    30:30:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    29:29:neureka.Tsr lambda$new$0(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> a
    26:26:void <clinit>() -> <clinit>
neureka.backend.standard.operations.operator.Division -> neureka.backend.standard.operations.operator.Division:
    29:216:void <init>() -> <init>
    221:228:java.lang.String stringify(java.lang.String[]) -> stringify
    233:233:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    237:258:java.lang.String _asDerivative(neureka.calculus.Function[],int,int) -> a
    264:282:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    288:309:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    202:211:void lambda$new$35(neureka.backend.api.ExecutionCall) -> a
    181:181:int lambda$new$34(int,int) -> a
    180:180:int lambda$new$33(int,int) -> b
    179:179:int lambda$new$32(int,int) -> c
    176:176:float lambda$new$31(float,float) -> a
    175:175:float lambda$new$30(float,float) -> b
    174:174:float lambda$new$29(float,float) -> c
    171:171:double lambda$new$28(double,double) -> a
    170:170:double lambda$new$27(double,double) -> b
    169:169:double lambda$new$26(double,double) -> c
    160:160:neureka.Tsr lambda$new$25(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    158:158:boolean lambda$new$24(neureka.backend.api.ExecutionCall) -> b
    157:157:boolean lambda$new$23(neureka.backend.api.ExecutionCall) -> c
    156:156:float lambda$new$22(neureka.backend.api.ExecutionCall) -> d
    134:134:float lambda$new$21(float,float) -> d
    133:133:float lambda$new$20(float,float) -> e
    132:132:float lambda$new$19(float,float) -> f
    129:129:double lambda$new$18(double,double) -> d
    128:128:double lambda$new$17(double,double) -> e
    127:127:double lambda$new$16(double,double) -> f
    101:115:neureka.autograd.ADAgent lambda$new$15(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    115:115:neureka.Tsr lambda$new$14(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    114:114:neureka.Tsr lambda$new$13(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    106:106:neureka.Tsr lambda$new$12(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    105:105:neureka.Tsr lambda$new$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    91:96:boolean lambda$new$10(neureka.backend.api.ExecutionCall) -> e
    89:89:boolean lambda$new$9(neureka.backend.api.ExecutionCall) -> f
    66:66:int lambda$new$8(int,int) -> d
    65:65:int lambda$new$7(int,int) -> e
    64:64:int lambda$new$6(int,int) -> f
    61:61:float lambda$new$5(float,float) -> g
    60:60:float lambda$new$4(float,float) -> h
    59:59:float lambda$new$3(float,float) -> i
    56:56:double lambda$new$2(double,double) -> g
    55:55:double lambda$new$1(double,double) -> h
    54:54:double lambda$new$0(double,double) -> i
neureka.backend.standard.operations.operator.Modulo -> neureka.backend.standard.operations.operator.Modulo:
    28:229:void <init>() -> <init>
    235:243:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    250:257:java.lang.String stringify(java.lang.String[]) -> stringify
    262:262:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    267:277:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    213:223:void lambda$new$35(neureka.backend.api.ExecutionCall) -> a
    192:192:int lambda$new$34(int,int) -> a
    191:191:int lambda$new$33(int,int) -> b
    190:190:int lambda$new$32(int,int) -> c
    187:187:float lambda$new$31(float,float) -> a
    186:186:float lambda$new$30(float,float) -> b
    185:185:float lambda$new$29(float,float) -> c
    182:182:double lambda$new$28(double,double) -> a
    181:181:double lambda$new$27(double,double) -> b
    180:180:double lambda$new$26(double,double) -> c
    162:167:boolean lambda$new$25(neureka.backend.api.ExecutionCall) -> b
    159:159:boolean lambda$new$24(neureka.backend.api.ExecutionCall) -> c
    158:158:float lambda$new$23(neureka.backend.api.ExecutionCall) -> d
    136:136:float lambda$new$22(float,float) -> d
    135:135:float lambda$new$21(float,float) -> e
    134:134:float lambda$new$20(float,float) -> f
    131:131:double lambda$new$19(double,double) -> d
    130:130:double lambda$new$18(double,double) -> e
    129:129:double lambda$new$17(double,double) -> f
    103:117:neureka.autograd.ADAgent lambda$new$16(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    117:117:neureka.Tsr lambda$new$15(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    116:116:neureka.Tsr lambda$new$14(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    108:108:neureka.Tsr lambda$new$13(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    107:107:neureka.Tsr lambda$new$12(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    92:97:boolean lambda$new$11(neureka.backend.api.ExecutionCall) -> e
    89:89:boolean lambda$new$10(neureka.backend.api.ExecutionCall) -> f
    88:88:neureka.Tsr lambda$new$9(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> a
    65:65:int lambda$new$8(int,int) -> d
    64:64:int lambda$new$7(int,int) -> e
    63:63:int lambda$new$6(int,int) -> f
    60:60:float lambda$new$5(float,float) -> g
    59:59:float lambda$new$4(float,float) -> h
    58:58:float lambda$new$3(float,float) -> i
    55:55:double lambda$new$2(double,double) -> g
    54:54:double lambda$new$1(double,double) -> h
    53:53:double lambda$new$0(double,double) -> i
neureka.backend.standard.operations.operator.Multiplication -> neureka.backend.standard.operations.operator.Multiplication:
    33:217:void <init>() -> <init>
    223:230:java.lang.String stringify(java.lang.String[]) -> stringify
    235:247:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    252:271:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    277:295:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    238:243:java.lang.String lambda$asDerivative$39(int,neureka.calculus.Function[],neureka.calculus.Function) -> a
    241:241:boolean lambda$asDerivative$38(neureka.calculus.Function,neureka.calculus.Function) -> a
    236:236:boolean lambda$asDerivative$37(int,neureka.calculus.Function) -> a
    195:211:void lambda$new$36(neureka.backend.api.ExecutionCall) -> a
    158:181:void lambda$new$35(neureka.backend.api.ExecutionCall) -> b
    177:177:int lambda$new$34(int,int) -> a
    176:176:int lambda$new$33(int,int) -> b
    175:175:int lambda$new$32(int,int) -> c
    172:172:float lambda$new$31(float,float) -> a
    171:171:float lambda$new$30(float,float) -> b
    170:170:float lambda$new$29(float,float) -> c
    167:167:double lambda$new$28(double,double) -> a
    166:166:double lambda$new$27(double,double) -> b
    165:165:double lambda$new$26(double,double) -> c
    147:147:neureka.Tsr lambda$new$25(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    145:145:boolean lambda$new$24(neureka.backend.api.ExecutionCall) -> c
    144:144:boolean lambda$new$23(neureka.backend.api.ExecutionCall) -> d
    125:125:float lambda$new$22(float,float) -> d
    124:124:float lambda$new$21(float,float) -> e
    123:123:float lambda$new$20(float,float) -> f
    120:120:double lambda$new$19(double,double) -> d
    119:119:double lambda$new$18(double,double) -> e
    118:118:double lambda$new$17(double,double) -> f
    91:105:neureka.autograd.ADAgent lambda$new$16(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    105:105:neureka.Tsr lambda$new$15(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    104:104:neureka.Tsr lambda$new$14(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    102:102:neureka.Tsr lambda$new$13(neureka.calculus.Function,neureka.backend.api.ExecutionCall,int) -> a
    96:96:neureka.Tsr lambda$new$12(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    95:95:neureka.Tsr lambda$new$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    87:87:boolean lambda$new$10(neureka.backend.api.ExecutionCall) -> e
    86:86:boolean lambda$new$9(neureka.backend.api.ExecutionCall) -> f
    69:69:int lambda$new$8(int,int) -> d
    68:68:int lambda$new$7(int,int) -> e
    67:67:int lambda$new$6(int,int) -> f
    64:64:float lambda$new$5(float,float) -> g
    63:63:float lambda$new$4(float,float) -> h
    62:62:float lambda$new$3(float,float) -> i
    59:59:double lambda$new$2(double,double) -> g
    58:58:double lambda$new$1(double,double) -> h
    57:57:double lambda$new$0(double,double) -> i
neureka.backend.standard.operations.operator.Power -> neureka.backend.standard.operations.operator.Power:
    32:285:void <init>() -> <init>
    294:299:java.lang.String stringify(java.lang.String[]) -> stringify
    304:333:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    338:364:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    370:395:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    307:307:java.lang.String lambda$asDerivative$37(neureka.calculus.Function[],int) -> a
    268:278:void lambda$new$36(neureka.backend.api.ExecutionCall) -> a
    247:247:float lambda$new$35(float,float) -> a
    246:246:float lambda$new$34(float,float) -> b
    245:245:float lambda$new$33(float,float) -> c
    242:242:float lambda$new$32(float,float) -> d
    241:241:float lambda$new$31(float,float) -> e
    240:240:float lambda$new$30(float,float) -> f
    237:237:double lambda$new$29(double,double) -> a
    236:236:double lambda$new$28(double,double) -> b
    235:235:double lambda$new$27(double,double) -> c
    226:226:neureka.Tsr lambda$new$26(neureka.calculus.internal.RecursiveExecutor,neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    224:224:boolean lambda$new$25(neureka.backend.api.ExecutionCall) -> b
    223:223:boolean lambda$new$24(neureka.backend.api.ExecutionCall) -> c
    222:222:float lambda$new$23(neureka.backend.api.ExecutionCall) -> d
    199:199:float lambda$new$22(float,float) -> g
    198:198:float lambda$new$21(float,float) -> h
    196:196:float lambda$new$20(float,float) -> i
    193:193:double lambda$new$19(double,double) -> d
    192:192:double lambda$new$18(double,double) -> e
    190:190:double lambda$new$17(double,double) -> f
    164:178:neureka.autograd.ADAgent lambda$new$16(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    178:178:neureka.Tsr lambda$new$15(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    177:177:neureka.Tsr lambda$new$14(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    169:169:neureka.Tsr lambda$new$13(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    168:168:neureka.Tsr lambda$new$12(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    160:160:boolean lambda$new$11(neureka.backend.api.ExecutionCall) -> e
    159:159:boolean lambda$new$10(neureka.backend.api.ExecutionCall) -> f
    137:137:int lambda$new$9(int,int) -> a
    136:136:int lambda$new$8(int,int) -> b
    135:135:int lambda$new$7(int,int) -> c
    132:132:float lambda$new$6(float,float) -> j
    131:131:float lambda$new$5(float,float) -> k
    130:130:float lambda$new$4(float,float) -> l
    127:127:double lambda$new$3(double,double) -> g
    126:126:double lambda$new$2(double,double) -> h
    125:125:double lambda$new$1(double,double) -> i
    48:113:neureka.Tsr lambda$new$0(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> a
neureka.backend.standard.operations.operator.Subtraction -> neureka.backend.standard.operations.operator.Subtraction:
    boolean $assertionsDisabled -> a
    30:210:void <init>() -> <init>
    216:223:java.lang.String stringify(java.lang.String[]) -> stringify
    228:233:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    238:254:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    260:275:double calculate(double[],int,neureka.calculus.Function[]) -> calculate
    231:231:neureka.calculus.Function lambda$asDerivative$31(int,neureka.calculus.Function) -> a
    230:230:boolean lambda$asDerivative$30(int,neureka.calculus.Function) -> b
    199:199:float lambda$new$29(float,float) -> a
    198:198:float lambda$new$28(float,float) -> b
    196:196:float lambda$new$27(float,float) -> c
    193:193:double lambda$new$26(double,double) -> a
    192:192:double lambda$new$25(double,double) -> b
    190:190:double lambda$new$24(double,double) -> c
    153:163:neureka.autograd.ADAgent lambda$new$23(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    165:175:neureka.Tsr lambda$new$22(neureka.devices.Device,neureka.Tsr,neureka.Tsr,int,neureka.autograd.GraphNode,neureka.Tsr) -> a
    149:149:boolean lambda$new$21(neureka.backend.api.ExecutionCall) -> a
    129:139:void lambda$new$20(neureka.backend.api.ExecutionCall) -> b
    109:109:int lambda$new$19(int,int) -> a
    108:108:int lambda$new$18(int,int) -> b
    107:107:int lambda$new$17(int,int) -> c
    104:104:float lambda$new$16(float,float) -> d
    103:103:float lambda$new$15(float,float) -> e
    102:102:float lambda$new$14(float,float) -> f
    99:99:double lambda$new$13(double,double) -> d
    98:98:double lambda$new$12(double,double) -> e
    97:97:double lambda$new$11(double,double) -> f
    88:88:neureka.Tsr lambda$new$10(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    86:86:float lambda$new$9(neureka.backend.api.ExecutionCall) -> c
    64:64:int lambda$new$8(int,int) -> d
    63:63:int lambda$new$7(int,int) -> e
    62:62:int lambda$new$6(int,int) -> f
    59:59:float lambda$new$5(float,float) -> g
    58:58:float lambda$new$4(float,float) -> h
    57:57:float lambda$new$3(float,float) -> i
    54:54:double lambda$new$2(double,double) -> g
    53:53:double lambda$new$1(double,double) -> h
    52:52:double lambda$new$0(double,double) -> i
    26:26:void <clinit>() -> <clinit>
neureka.backend.standard.operations.other.AssignLeft -> neureka.backend.standard.operations.other.AssignLeft:
    23:146:void <init>() -> <init>
    151:156:java.lang.String stringify(java.lang.String[]) -> stringify
    161:161:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    166:166:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    131:136:void lambda$new$14(neureka.backend.api.ExecutionCall) -> a
    112:117:neureka.backend.api.ExecutionCall lambda$new$13(neureka.backend.api.ExecutionCall) -> b
    107:107:boolean lambda$new$12(neureka.backend.api.ExecutionCall) -> c
    106:106:boolean lambda$new$11(neureka.backend.api.ExecutionCall) -> d
    102:104:float lambda$new$10(neureka.backend.api.ExecutionCall) -> e
    103:103:boolean lambda$new$9(neureka.Tsr) -> a
    84:94:void lambda$new$8(neureka.backend.api.ExecutionCall) -> f
    70:70:java.lang.Object lambda$new$7(java.lang.Object,java.lang.Object) -> a
    69:69:float lambda$new$6(float,float) -> a
    68:68:float lambda$new$5(float,float) -> b
    67:67:double lambda$new$4(double,double) -> a
    50:57:neureka.backend.api.ExecutionCall lambda$new$3(neureka.backend.api.ExecutionCall) -> g
    44:44:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> h
    43:43:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> i
    37:40:float lambda$new$0(neureka.backend.api.ExecutionCall) -> j
neureka.backend.standard.operations.other.DimFit -> neureka.backend.standard.operations.other.DimFit:
    boolean $assertionsDisabled -> a
    22:112:void <init>() -> <init>
    117:121:java.lang.String stringify(java.lang.String[]) -> stringify
    126:126:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    131:131:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    105:105:neureka.backend.api.ExecutionCall lambda$new$5(neureka.backend.api.ExecutionCall) -> a
    55:92:neureka.Tsr lambda$new$4(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    41:47:neureka.autograd.ADAgent lambda$new$3(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    37:37:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    36:36:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    35:35:float lambda$new$0(neureka.backend.api.ExecutionCall) -> d
    17:17:void <clinit>() -> <clinit>
neureka.backend.standard.operations.other.DimTrim -> neureka.backend.standard.operations.other.DimTrim:
    boolean $assertionsDisabled -> a
    28:85:void <init>() -> <init>
    89:132:neureka.Tsr _pad(neureka.Tsr,int[],boolean) -> a
    137:169:neureka.Tsr _trim(neureka.Tsr,boolean) -> a
    173:177:int[] endsFrom(int[]) -> endsFrom
    182:186:java.lang.String stringify(java.lang.String[]) -> stringify
    191:191:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    196:196:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    165:165:int lambda$_trim$17(java.lang.Integer) -> a
    164:164:int lambda$_trim$16(java.lang.Integer) -> b
    163:163:int lambda$_trim$15(java.lang.Integer) -> c
    162:162:int lambda$_trim$14(java.lang.Integer) -> d
    161:161:int lambda$_trim$13(java.lang.Integer) -> e
    129:129:int lambda$_pad$12(java.lang.Integer) -> f
    128:128:int lambda$_pad$11(java.lang.Integer) -> g
    127:127:int lambda$_pad$10(java.lang.Integer) -> h
    126:126:int lambda$_pad$9(java.lang.Integer) -> i
    125:125:int lambda$_pad$8(java.lang.Integer) -> j
    82:82:neureka.backend.api.ExecutionCall lambda$new$7(neureka.backend.api.ExecutionCall) -> a
    68:79:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    48:62:neureka.autograd.ADAgent lambda$new$5(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    62:62:neureka.Tsr lambda$new$4(int,int,neureka.autograd.GraphNode,neureka.Tsr) -> a
    58:60:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    44:44:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    43:43:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    42:42:float lambda$new$0(neureka.backend.api.ExecutionCall) -> d
    23:23:void <clinit>() -> <clinit>
neureka.backend.standard.operations.other.Randomization -> neureka.backend.standard.operations.other.Randomization:
    36:91:void <init>() -> <init>
    174:178:java.lang.String stringify(java.lang.String[]) -> stringify
    183:183:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    188:188:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    192:192:long initialScramble(long) -> initialScramble
    200:215:void gaussianFrom(long,double[]) -> gaussianFrom
    220:223:long _next(long) -> a
    227:227:double _doubleFrom(long,long) -> a
    1231:1231:int _intFrom(int,long):231:231 -> a
    1231:1231:double _doubleFrom(long,long):227 -> a
    2231:2231:int _intFrom(int,long):231:231 -> a
    2231:2231:double _doubleFrom(long,long):227 -> a
    153:168:void lambda$_newWorkloadFor$8(neureka.Tsr,long,int,int) -> a
    137:150:void lambda$_newWorkloadFor$7(neureka.Tsr,long,int,int) -> b
    118:133:void lambda$_newWorkloadFor$6(neureka.Tsr,long,int,int) -> c
    102:115:void lambda$_newWorkloadFor$5(neureka.Tsr,long,int,int) -> d
    86:86:void lambda$new$4(neureka.backend.api.ExecutionCall) -> a
    75:79:void lambda$new$3(neureka.backend.api.ExecutionCall) -> b
    3094:3152:neureka.devices.host.CPU$RangeWorkload _newWorkloadFor(neureka.backend.api.ExecutionCall):94:152 -> b
    3094:3152:void lambda$new$3(neureka.backend.api.ExecutionCall):79 -> b
    55:65:neureka.backend.api.ExecutionCall lambda$new$2(neureka.backend.api.ExecutionCall) -> c
    50:50:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> d
    49:49:boolean lambda$new$0(neureka.backend.api.ExecutionCall) -> e
neureka.backend.standard.operations.other.Reshape -> neureka.backend.standard.operations.other.Reshape:
    26:72:void <init>() -> <init>
    91:118:void makeFit(neureka.Tsr[],boolean) -> makeFit
    123:137:int[] invert(int[]) -> invert
    142:168:java.lang.String stringify(java.lang.String[]) -> stringify
    173:173:java.lang.String asDerivative(neureka.calculus.Function[],int) -> asDerivative
    179:179:double calculate(double[],int,int,neureka.calculus.Function[]) -> calculate
    145:147:java.lang.Boolean lambda$stringify$8(java.lang.String) -> a
    68:68:neureka.backend.api.ExecutionCall lambda$new$7(neureka.backend.api.ExecutionCall) -> a
    57:65:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall) -> a
    1076:1085:neureka.Tsr _reshaped(neureka.Tsr,int[],boolean):76:85 -> a
    1076:1085:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall):65 -> a
    1185:1195:void _shapeCheck(int[],neureka.Tsr):185:195 -> a
    1185:1195:neureka.Tsr _reshaped(neureka.Tsr,int[],boolean):79 -> a
    1185:1195:neureka.Tsr lambda$new$6(neureka.calculus.implementations.FunctionNode,neureka.backend.api.ExecutionCall):65 -> a
    46:51:neureka.autograd.ADAgent lambda$new$5(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    51:51:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    50:50:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    42:42:boolean lambda$new$2(neureka.backend.api.ExecutionCall) -> b
    41:41:boolean lambda$new$1(neureka.backend.api.ExecutionCall) -> c
    40:40:float lambda$new$0(neureka.backend.api.ExecutionCall) -> d
neureka.calculus.Function -> neureka.calculus.Function:
    83:83:neureka.calculus.Function of(java.lang.String) -> of
    97:97:neureka.calculus.Function of(java.lang.String,boolean) -> of
    boolean isDoingAD() -> isDoingAD
    boolean isFlat() -> isFlat
    neureka.backend.api.Operation getOperation() -> getOperation
    boolean dependsOn(int) -> dependsOn
    neureka.calculus.Function getDerivative(int) -> getDerivative
    java.util.List getSubFunctions() -> getSubFunctions
    143:148:java.util.List getAllFunctions() -> getAllFunctions
    152:158:int numberOfArgs() -> numberOfArgs
    163:163:double call(double) -> call
    164:164:double invoke(double) -> invoke
    double call(double[],int) -> call
    169:169:double invoke(double[],int) -> invoke
    172:172:double call(double[]) -> call
    173:173:double invoke(double[]) -> invoke
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    182:184:neureka.Tsr call(neureka.backend.api.Call$Builder) -> call
    188:190:neureka.Tsr invoke(neureka.backend.api.Call$Builder) -> invoke
    202:206:neureka.Tsr execute(neureka.backend.api.Call) -> execute
    215:215:neureka.calculus.Function$CallOptions callWith(neureka.calculus.args.Arg[]) -> callWith
    224:224:neureka.calculus.Function$CallOptions callWith(neureka.calculus.args.Args) -> callWith
    256:257:neureka.Tsr call(neureka.calculus.args.Args,neureka.Tsr[]) -> call
    261:262:neureka.Tsr invoke(neureka.calculus.args.Args,neureka.Tsr[]) -> invoke
    neureka.Tsr execute(neureka.calculus.args.Args,neureka.Tsr[]) -> execute
    273:273:neureka.Tsr execute(neureka.Tsr[]) -> execute
    278:278:neureka.Tsr execute(neureka.Tsr[],int) -> execute
    282:282:neureka.Tsr executeDerive(neureka.Tsr[],int,int) -> executeDerive
    286:286:neureka.Tsr executeDerive(neureka.Tsr[],int) -> executeDerive
    290:290:neureka.Tsr call(neureka.Tsr) -> call
    291:291:neureka.Tsr invoke(neureka.Tsr) -> invoke
    293:293:neureka.Tsr call(java.util.List) -> call
    294:294:neureka.Tsr invoke(java.util.List) -> invoke
    299:300:neureka.Tsr call(neureka.Tsr[],int) -> call
    303:303:neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    306:307:neureka.Tsr call(neureka.Tsr[]) -> call
    310:310:neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    315:316:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    320:321:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    326:326:neureka.Tsr derive(java.util.List,int,int) -> derive
    327:327:neureka.Tsr derive(java.util.List,int) -> derive
    java.lang.String toString() -> toString
    155:155:neureka.calculus.implementations.FunctionInput lambda$numberOfArgs$1(neureka.calculus.Function) -> a
    154:154:boolean lambda$numberOfArgs$0(neureka.calculus.Function) -> b
neureka.calculus.Function$1 -> neureka.calculus.Function$1:
    neureka.calculus.args.Args val$arguments -> a
    neureka.calculus.Function this$0 -> b
    224:224:void <init>(neureka.calculus.Function,neureka.calculus.args.Args) -> <init>
    225:225:neureka.Tsr call(neureka.Tsr[]) -> call
    226:226:neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    229:250:neureka.Tsr execute(neureka.Tsr[]) -> execute
    229:229:neureka.Tsr lambda$execute$0(neureka.calculus.args.Args,neureka.Tsr[]) -> a
neureka.calculus.Function$CallOptions -> neureka.calculus.Function$CallOptions:
    neureka.Tsr call(neureka.Tsr[]) -> call
    neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    neureka.Tsr execute(neureka.Tsr[]) -> execute
neureka.calculus.FunctionCache -> neureka.calculus.FunctionCache:
    org.slf4j.Logger _log -> a
    java.util.Map _functionCache -> b
    42:47:void <init>() -> <init>
    55:64:void put(neureka.calculus.Function) -> put
    67:68:neureka.calculus.Function get(java.lang.String,boolean) -> get
    72:73:boolean has(java.lang.String,boolean) -> has
    77:77:java.lang.String toString() -> toString
neureka.calculus.FunctionCache$1 -> neureka.calculus.FunctionCache$1:
    47:47:void <init>(neureka.calculus.FunctionCache) -> <init>
    50:50:boolean removeEldestEntry(java.util.Map$Entry) -> removeEldestEntry
neureka.calculus.Functions -> neureka.calculus.Functions:
    neureka.calculus.Function _dimTrim -> a
    neureka.calculus.Function _idy -> b
    neureka.calculus.Function _conv -> c
    neureka.calculus.Function _plus -> d
    neureka.calculus.Function _plusAssign -> e
    neureka.calculus.Function _minus -> f
    neureka.calculus.Function _minusAssign -> g
    neureka.calculus.Function _div -> h
    neureka.calculus.Function _divAssign -> i
    neureka.calculus.Function _pow -> j
    neureka.calculus.Function _powAssign -> k
    neureka.calculus.Function _mul -> l
    neureka.calculus.Function _mulAssign -> m
    neureka.calculus.Function _add -> n
    neureka.calculus.Function _addAssign -> o
    neureka.calculus.Function _mod -> p
    neureka.calculus.Function _modAssign -> q
    neureka.calculus.Function _neg -> r
    neureka.calculus.Function _matMul -> s
    neureka.calculus.Function _transpose2D -> t
    neureka.calculus.Function _random -> u
    31:53:void <init>(boolean) -> <init>
    55:55:neureka.calculus.Function getDimTrim() -> getDimTrim
    57:57:neureka.calculus.Function getIdy() -> getIdy
    59:59:neureka.calculus.Function getConv() -> getConv
    61:61:neureka.calculus.Function getPlus() -> getPlus
    63:63:neureka.calculus.Function getPlusAssign() -> getPlusAssign
    65:65:neureka.calculus.Function getMinus() -> getMinus
    67:67:neureka.calculus.Function getMinusAssign() -> getMinusAssign
    69:69:neureka.calculus.Function getDiv() -> getDiv
    71:71:neureka.calculus.Function getDivAssign() -> getDivAssign
    73:73:neureka.calculus.Function getPow() -> getPow
    75:75:neureka.calculus.Function getPowAssign() -> getPowAssign
    77:77:neureka.calculus.Function getMul() -> getMul
    79:79:neureka.calculus.Function getMulAssign() -> getMulAssign
    81:81:neureka.calculus.Function getAdd() -> getAdd
    83:83:neureka.calculus.Function getAddAssign() -> getAddAssign
    85:85:neureka.calculus.Function getMod() -> getMod
    87:87:neureka.calculus.Function getModAssign() -> getModAssign
    89:89:neureka.calculus.Function getNeg() -> getNeg
    91:91:neureka.calculus.Function getMatMul() -> getMatMul
    93:93:neureka.calculus.Function getTranspose2D() -> getTranspose2D
    95:95:neureka.calculus.Function getRandom() -> getRandom
    98:98:neureka.calculus.Function dimTrim() -> dimTrim
    102:102:neureka.calculus.Function idy() -> idy
    106:106:neureka.calculus.Function conv() -> conv
    110:110:neureka.calculus.Function plus() -> plus
    114:114:neureka.calculus.Function plusAssign() -> plusAssign
    118:118:neureka.calculus.Function minus() -> minus
    122:122:neureka.calculus.Function minusAssign() -> minusAssign
    126:126:neureka.calculus.Function div() -> div
    130:130:neureka.calculus.Function divAssign() -> divAssign
    134:134:neureka.calculus.Function pow() -> pow
    138:138:neureka.calculus.Function powAssign() -> powAssign
    142:142:neureka.calculus.Function mul() -> mul
    146:146:neureka.calculus.Function mulAssign() -> mulAssign
    150:150:neureka.calculus.Function add() -> add
    154:154:neureka.calculus.Function addAssign() -> addAssign
    158:158:neureka.calculus.Function mod() -> mod
    162:162:neureka.calculus.Function modAssign() -> modAssign
    166:166:neureka.calculus.Function neg() -> neg
    169:169:neureka.calculus.Function matMul() -> matMul
    171:171:neureka.calculus.Function transpose2D() -> transpose2D
    173:173:neureka.calculus.Function random() -> random
    177:188:java.lang.String toString() -> toString
    181:183:java.lang.String lambda$toString$0(java.lang.reflect.Field) -> a
neureka.calculus.args.Arg -> neureka.calculus.args.Arg:
    java.lang.Object _value -> a
    11:11:void <init>(java.lang.Object) -> <init>
    13:13:java.lang.Object get() -> get
    17:17:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    74:74:java.lang.String toString() -> toString
neureka.calculus.args.Arg$DerivIdx -> neureka.calculus.args.Arg$DerivIdx:
    37:37:neureka.calculus.args.Arg$DerivIdx of(int) -> of
    38:38:void <init>(int) -> <init>
neureka.calculus.args.Arg$Derivative -> neureka.calculus.args.Arg$Derivative:
    22:22:neureka.calculus.args.Arg$Derivative of(neureka.Tsr) -> of
    23:23:void <init>(neureka.Tsr) -> <init>
neureka.calculus.args.Arg$Ends -> neureka.calculus.args.Arg$Ends:
    42:42:neureka.calculus.args.Arg$Ends of(int[]) -> of
    43:43:void <init>(int[]) -> <init>
neureka.calculus.args.Arg$MinRank -> neureka.calculus.args.Arg$MinRank:
    63:63:neureka.calculus.args.Arg$MinRank of(int) -> of
    64:64:void <init>(int) -> <init>
neureka.calculus.args.Arg$Seed -> neureka.calculus.args.Arg$Seed:
    68:68:neureka.calculus.args.Arg$Seed of(long) -> of
    69:69:void <init>(long) -> <init>
neureka.calculus.args.Arg$TargetDevice -> neureka.calculus.args.Arg$TargetDevice:
    47:47:neureka.calculus.args.Arg$TargetDevice of(neureka.devices.Device) -> of
    48:48:void <init>(neureka.devices.Device) -> <init>
neureka.calculus.args.Arg$VarIdx -> neureka.calculus.args.Arg$VarIdx:
    58:58:neureka.calculus.args.Arg$VarIdx of(int) -> of
    59:59:void <init>(int) -> <init>
neureka.calculus.args.Args -> neureka.calculus.args.Args:
    6:6:void <init>() -> <init>
    9:13:neureka.calculus.args.Args of(neureka.calculus.args.Arg[]) -> of
    17:18:java.lang.Object valOf(java.lang.Class) -> valOf
    22:23:java.lang.Object valOfOr(java.lang.Class,java.lang.Object) -> valOfOr
    28:28:neureka.common.composition.Component _setOrReject(neureka.common.composition.Component) -> _setOrReject
    33:33:neureka.common.composition.Component _removeOrReject(neureka.common.composition.Component) -> _removeOrReject
neureka.calculus.assembly.FunctionBuilder -> neureka.calculus.assembly.FunctionBuilder:
    org.slf4j.Logger _LOG -> a
    java.util.regex.Pattern _variablePattern -> b
    java.util.regex.Pattern _inputPattern -> c
    java.util.regex.Pattern _constantPattern -> d
    java.util.regex.Pattern _reshapePattern -> e
    neureka.backend.api.BackendContext _context -> f
    boolean $assertionsDisabled -> g
    44:44:void <init>(neureka.backend.api.BackendContext) -> <init>
    54:62:neureka.calculus.Function build(neureka.backend.api.Operation,int,boolean) -> build
    72:87:neureka.calculus.Function build(java.lang.String,boolean) -> build
    98:205:neureka.calculus.Function _build(java.lang.String,boolean) -> a
    210:245:neureka.calculus.Function _buildFunction(java.lang.String,boolean) -> b
    254:307:neureka.calculus.Function _buildOperators(java.util.List,java.util.List,boolean) -> a
    311:323:java.util.List _groupAccordingToArity(int,java.util.List,java.lang.String) -> a
    314:314:int lambda$_groupAccordingToArity$2(int) -> a
    59:59:java.lang.String lambda$build$1(int) -> b
    57:57:int lambda$build$0(int) -> c
    27:36:void <clinit>() -> <clinit>
neureka.calculus.assembly.ParseUtil -> neureka.calculus.assembly.ParseUtil:
    boolean $assertionsDisabled -> a
    15:15:void <init>() -> <init>
    19:23:int numberOfOperationsWithin(java.util.List) -> numberOfOperationsWithin
    28:36:java.lang.String parsedOperation(java.lang.String,int) -> parsedOperation
    41:68:java.lang.String findComponentIn(java.lang.String,int) -> findComponentIn
    1073:1076:boolean _isOperationComponent(java.lang.String,int,int):73:76 -> findComponentIn
    1073:1076:java.lang.String findComponentIn(java.lang.String,int):63 -> findComponentIn
    81:104:java.util.List findParametersIn(java.lang.String,int) -> findParametersIn
    109:111:boolean isAnOperation(java.lang.String) -> isAnOperation
    121:128:java.lang.String groupBy(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> groupBy
    133:133:boolean isForbiddenChar(char) -> a
    139:178:java.lang.String cleanedHeadAndTail(java.lang.String) -> cleanedHeadAndTail
    183:236:java.lang.String unpackAndCorrect(java.lang.String) -> unpackAndCorrect
    247:257:java.lang.String assumptionBasedOn(java.lang.String) -> assumptionBasedOn
    269:303:double similarity(java.lang.String,java.lang.String) -> similarity
    15:15:void <clinit>() -> <clinit>
neureka.calculus.implementations.FunctionConstant -> neureka.calculus.implementations.FunctionConstant:
    double _value -> a
    28:28:double value() -> value
    31:45:void <init>(java.lang.String) -> <init>
    50:50:boolean isFlat() -> isFlat
    53:53:boolean isDoingAD() -> isDoingAD
    56:56:neureka.backend.api.operations.AbstractOperation getOperation() -> getOperation
    59:59:boolean dependsOn(int) -> dependsOn
    62:62:neureka.calculus.Function getDerivative(int) -> getDerivative
    65:65:java.util.List getSubFunctions() -> getSubFunctions
    70:70:double call(double[],int) -> call
    73:73:double derive(double[],int) -> derive
    76:76:double derive(double[],int,int) -> derive
    82:97:neureka.Tsr execute(neureka.calculus.args.Args,neureka.Tsr[]) -> execute
    103:103:java.lang.String toString() -> toString
    24:24:neureka.backend.api.Operation getOperation() -> getOperation
neureka.calculus.implementations.FunctionInput -> neureka.calculus.implementations.FunctionInput:
    int _index -> a
    36:52:neureka.calculus.Function of(java.lang.String) -> of
    55:57:void <init>(int) -> <init>
    61:61:boolean providesGradient() -> providesGradient
    66:66:boolean isFlat() -> isFlat
    69:69:boolean isDoingAD() -> isDoingAD
    72:72:neureka.backend.api.operations.AbstractOperation getOperation() -> getOperation
    75:75:boolean dependsOn(int) -> dependsOn
    78:78:neureka.calculus.Function getDerivative(int) -> getDerivative
    81:81:java.util.List getSubFunctions() -> getSubFunctions
    108:111:double call(double[],int) -> call
    115:115:double derive(double[],int) -> derive
    119:122:double derive(double[],int,int) -> derive
    129:141:neureka.Tsr execute(neureka.calculus.args.Args,neureka.Tsr[]) -> execute
    1087:1101:neureka.Tsr _extract(neureka.Tsr):87:101 -> execute
    1087:1101:neureka.Tsr execute(neureka.calculus.args.Args,neureka.Tsr[]):141 -> execute
    147:147:java.lang.String toString() -> toString
    149:149:int index() -> index
    31:31:neureka.backend.api.Operation getOperation() -> getOperation
neureka.calculus.implementations.FunctionNode -> neureka.calculus.implementations.FunctionNode:
    neureka.backend.api.Operation _operation -> a
    boolean _isFlat -> b
    boolean _isDoingAD -> c
    neureka.calculus.Function[] _src -> d
    41:61:void <init>(neureka.backend.api.Operation,java.util.List,boolean) -> <init>
    69:72:java.lang.String toString() -> toString
    78:79:boolean dependsOn(int) -> dependsOn
    83:83:neureka.calculus.Function getDerivative(int) -> getDerivative
    86:86:java.util.List getSubFunctions() -> getSubFunctions
    93:93:neureka.Tsr execute(neureka.calculus.args.Args,neureka.Tsr[]) -> execute
    1199:1217:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier):199:217 -> execute
    1199:1217:neureka.Tsr execute(neureka.calculus.args.Args,neureka.Tsr[]):93 -> execute
    1225:1234:neureka.Tsr commit(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier):225:234 -> execute
    1225:1234:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier):213 -> execute
    1225:1234:neureka.Tsr execute(neureka.calculus.args.Args,neureka.Tsr[]):93 -> execute
    131:134:neureka.Tsr _execute(neureka.backend.api.ExecutionCall) -> a
    174:174:double call(double[],int) -> call
    179:179:double derive(double[],int,int) -> derive
    184:184:double derive(double[],int) -> derive
    187:187:neureka.backend.api.Operation getOperation() -> getOperation
    189:189:boolean isFlat() -> isFlat
    191:191:boolean isDoingAD() -> isDoingAD
    242:246:void attachGraph(neureka.Tsr[],neureka.calculus.Function,neureka.autograd.GraphLock) -> a
    244:244:neureka.Tsr lambda$attachGraph$4(neureka.Tsr) -> a
    97:123:neureka.Tsr lambda$execute$3(neureka.Tsr[],neureka.calculus.args.Args) -> a
    2146:2150:neureka.devices.Device _deviceFor(neureka.Tsr[]):146:150 -> a
    2146:2150:neureka.Tsr lambda$execute$3(neureka.Tsr[],neureka.calculus.args.Args):100 -> a
    2155:2167:boolean _shareGuestDevice(neureka.Tsr[]):155:167 -> a
    2155:2167:neureka.devices.Device _deviceFor(neureka.Tsr[]):148 -> a
    2155:2167:neureka.Tsr lambda$execute$3(neureka.Tsr[],neureka.calculus.args.Args):100 -> a
    116:117:neureka.Tsr lambda$execute$2(neureka.Tsr[],neureka.backend.api.ExecutionCall) -> a
    72:72:java.lang.String[] lambda$toString$1(int) -> a
    71:71:java.lang.String lambda$toString$0(neureka.calculus.Function) -> a
    25:25:void <clinit>() -> <clinit>
neureka.calculus.implementations.FunctionVariable -> neureka.calculus.implementations.FunctionVariable:
    boolean _providesGradient -> a
    31:33:void <init>(java.lang.String) -> <init>
    35:35:boolean providesGradient() -> providesGradient
    38:38:boolean isFlat() -> isFlat
    41:41:boolean isDoingAD() -> isDoingAD
    44:44:neureka.backend.api.operations.AbstractOperation getOperation() -> getOperation
    47:47:boolean dependsOn(int) -> dependsOn
    50:50:neureka.calculus.Function getDerivative(int) -> getDerivative
    53:53:java.util.List getSubFunctions() -> getSubFunctions
    59:64:double call(double[],int) -> call
    68:68:double derive(double[],int) -> derive
    72:73:double derive(double[],int,int) -> derive
    79:97:neureka.Tsr execute(neureka.calculus.args.Args,neureka.Tsr[]) -> execute
    104:104:java.lang.String toString() -> toString
    27:27:neureka.backend.api.Operation getOperation() -> getOperation
neureka.calculus.internal.CalcUtil -> neureka.calculus.internal.CalcUtil:
    org.slf4j.Logger _LOG -> a
    boolean $assertionsDisabled -> b
    33:33:void <init>() -> <init>
    42:42:neureka.Tsr defaultRecursiveExecution(neureka.calculus.Function,neureka.backend.api.ExecutionCall) -> defaultRecursiveExecution
    51:58:neureka.Tsr executeFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,neureka.calculus.internal.RecursiveExecutor) -> executeFor
    1070:1119:neureka.Tsr _deepActivation(neureka.backend.api.ExecutionCall,neureka.calculus.Function[],neureka.backend.api.Operation,boolean,boolean,neureka.calculus.internal.RecursiveExecutor):70:119 -> executeFor
    1070:1119:neureka.Tsr executeFor(neureka.calculus.Function,neureka.backend.api.ExecutionCall,neureka.calculus.internal.RecursiveExecutor):56 -> executeFor
    135:151:int _indexOfFoundDerivative(neureka.Tsr[]) -> a
    161:271:neureka.Tsr _deepDerivative(neureka.backend.api.ExecutionCall,neureka.calculus.Function[],neureka.backend.api.Operation,neureka.calculus.internal.RecursiveExecutor) -> a
    275:281:void _deleteIfNotIn(neureka.Tsr[],neureka.Tsr) -> a
    292:339:neureka.Tsr recursiveExecution(neureka.backend.api.ExecutionCall,neureka.calculus.internal.RecursiveExecutor) -> recursiveExecution
    366:418:neureka.Tsr _recursiveReductionOf(neureka.backend.api.ExecutionCall,java.util.function.Function,neureka.calculus.internal.RecursiveExecutor) -> a
    429:429:neureka.Tsr[] srcActivation(neureka.Tsr[],int,int,int,neureka.calculus.Function[]) -> srcActivation
    431:457:neureka.Tsr[] lambda$srcActivation$9(neureka.calculus.Function[],int,int,int,neureka.Tsr[]) -> a
    398:398:neureka.Tsr lambda$_recursiveReductionOf$8(java.util.function.Function,neureka.calculus.internal.RecursiveExecutor,neureka.backend.api.ExecutionCall) -> a
    388:388:void lambda$_recursiveReductionOf$7(neureka.Tsr) -> a
    381:385:void lambda$_recursiveReductionOf$6(neureka.devices.Device,neureka.Tsr) -> a
    304:333:neureka.Tsr lambda$recursiveExecution$5(neureka.backend.api.ExecutionCall) -> a
    1463:1465:java.lang.String _couldNotFindSuitableAlgorithmFor(java.lang.Class):463:465 -> a
    1463:1465:neureka.Tsr lambda$recursiveExecution$5(neureka.backend.api.ExecutionCall):321 -> a
    1473:1476:java.lang.String _couldNotFindSuitableImplementationFor(neureka.backend.api.Algorithm,java.lang.Class):473:476 -> a
    1473:1476:neureka.Tsr lambda$recursiveExecution$5(neureka.backend.api.ExecutionCall):327 -> a
    162:162:neureka.Tsr lambda$_deepDerivative$4(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation,neureka.calculus.Function[],neureka.calculus.internal.RecursiveExecutor) -> a
    163:250:neureka.Tsr lambda$_deepDerivative$3(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation,neureka.calculus.Function[],neureka.calculus.internal.RecursiveExecutor) -> b
    2284:2286:void _delete(neureka.Tsr):284:286 -> b
    2284:2286:neureka.Tsr lambda$_deepDerivative$3(neureka.backend.api.ExecutionCall,neureka.backend.api.Operation,neureka.calculus.Function[],neureka.calculus.internal.RecursiveExecutor):248 -> b
    97:97:neureka.Tsr lambda$_deepActivation$2(java.lang.String,boolean,neureka.Tsr[]) -> a
    94:94:java.lang.String[] lambda$_deepActivation$1(int) -> a
    93:93:java.lang.String lambda$_deepActivation$0(int) -> b
    33:35:void <clinit>() -> <clinit>
neureka.calculus.internal.CallExecutor -> neureka.calculus.internal.CallExecutor:
    neureka.Tsr execute(neureka.backend.api.ExecutionCall) -> execute
neureka.calculus.internal.RecursiveExecutor -> neureka.calculus.internal.RecursiveExecutor:
    neureka.Tsr execute(neureka.backend.api.ExecutionCall,neureka.calculus.internal.CallExecutor) -> execute
neureka.common.composition.AbstractComponentOwner -> neureka.common.composition.AbstractComponentOwner:
    neureka.common.composition.Component[] _components -> a
    74:79:void <init>() -> <init>
    81:81:java.lang.Object _this() -> _this
    84:85:void _setComps(neureka.common.composition.Component[]) -> a
    88:121:void _addOrRemoveComp(neureka.common.composition.Component,boolean) -> a
    124:138:void _remove(neureka.common.composition.Component) -> a
    141:158:void _add(neureka.common.composition.Component) -> b
    173:180:int _orderOf(neureka.common.composition.Component) -> c
    195:207:void _transferFrom(neureka.common.composition.AbstractComponentOwner) -> _transferFrom
    213:213:void _deleteComponents() -> _deleteComponents
    227:232:neureka.common.composition.Component get(java.lang.Class) -> get
    246:256:java.util.List getAll(java.lang.Class) -> getAll
    269:272:java.lang.Object remove(java.lang.Class) -> remove
    282:282:boolean has(java.lang.Class) -> has
    296:304:java.lang.Object set(neureka.common.composition.Component) -> set
    308:309:void _set(neureka.common.composition.Component) -> _set
    neureka.common.composition.Component _setOrReject(neureka.common.composition.Component) -> _setOrReject
    neureka.common.composition.Component _removeOrReject(neureka.common.composition.Component) -> _removeOrReject
    352:357:boolean forComponent(java.lang.Class,java.util.function.Consumer) -> forComponent
    74:74:void access$000(neureka.common.composition.AbstractComponentOwner,neureka.common.composition.Component) -> a
    74:74:void access$100(neureka.common.composition.AbstractComponentOwner,neureka.common.composition.Component) -> b
neureka.common.composition.AbstractComponentOwner$1 -> neureka.common.composition.AbstractComponentOwner$1:
    neureka.common.composition.Component val$component -> a
    boolean[] val$changeExecuted -> b
    neureka.common.composition.AbstractComponentOwner this$0 -> c
    92:92:void <init>(neureka.common.composition.AbstractComponentOwner,neureka.common.composition.Component,boolean[]) -> <init>
    93:93:java.lang.Object getOldOwner() -> getOldOwner
    94:94:java.lang.Object getNewOwner() -> getNewOwner
    96:98:boolean executeChange() -> executeChange
neureka.common.composition.AbstractComponentOwner$2 -> neureka.common.composition.AbstractComponentOwner$2:
    neureka.common.composition.Component val$component -> a
    boolean[] val$changeExecuted -> b
    neureka.common.composition.AbstractComponentOwner this$0 -> c
    108:108:void <init>(neureka.common.composition.AbstractComponentOwner,neureka.common.composition.Component,boolean[]) -> <init>
    109:109:java.lang.Object getOldOwner() -> getOldOwner
    110:110:java.lang.Object getNewOwner() -> getNewOwner
    112:114:boolean executeChange() -> executeChange
neureka.common.composition.AbstractComponentOwner$3 -> neureka.common.composition.AbstractComponentOwner$3:
    neureka.common.composition.AbstractComponentOwner val$other -> a
    neureka.common.composition.AbstractComponentOwner this$0 -> b
    199:199:void <init>(neureka.common.composition.AbstractComponentOwner,neureka.common.composition.AbstractComponentOwner) -> <init>
    200:200:java.lang.Object getOldOwner() -> getOldOwner
    201:201:java.lang.Object getNewOwner() -> getNewOwner
    202:202:boolean executeChange() -> executeChange
neureka.common.composition.Component -> neureka.common.composition.Component:
    boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
neureka.common.composition.Component$IsBeing -> neureka.common.composition.Component$IsBeing:
    neureka.common.composition.Component$IsBeing REMOVED -> REMOVED
    neureka.common.composition.Component$IsBeing ADDED -> ADDED
    neureka.common.composition.Component$IsBeing REPLACED -> REPLACED
    neureka.common.composition.Component$IsBeing UPDATED -> UPDATED
    neureka.common.composition.Component$IsBeing[] $VALUES -> a
    21:21:neureka.common.composition.Component$IsBeing[] values() -> values
    21:21:neureka.common.composition.Component$IsBeing valueOf(java.lang.String) -> valueOf
    21:21:void <init>(java.lang.String,int) -> <init>
    21:21:void <clinit>() -> <clinit>
neureka.common.composition.Component$OwnerChangeRequest -> neureka.common.composition.Component$OwnerChangeRequest:
    java.lang.Object getOldOwner() -> getOldOwner
    java.lang.Object getNewOwner() -> getNewOwner
    boolean executeChange() -> executeChange
    65:68:neureka.common.composition.Component$IsBeing type() -> type
neureka.common.utility.Cache -> neureka.common.utility.Cache:
    java.lang.Object[] _buffer -> a
    int _size -> b
    17:21:void <init>(int) -> <init>
    29:36:java.lang.Object process(java.lang.Object) -> process
    1047:1047:java.lang.Object _getAt(int):47:47 -> process
    1047:1047:java.lang.Object process(java.lang.Object):31 -> process
    1056:1062:boolean _equalsFor(java.lang.Object,java.lang.Object):56:62 -> process
    1056:1062:java.lang.Object process(java.lang.Object):33 -> process
    2051:2053:void _setAt(int,java.lang.Object):51:53 -> process
    2051:2053:java.lang.Object process(java.lang.Object):34 -> process
    40:41:boolean has(java.lang.Object) -> has
    44:44:int size() -> size
    66:66:int _indexFor(java.lang.Object) -> a
    70:70:int _index(int) -> a
    75:94:int _index(int[]) -> a
neureka.common.utility.Cache$LazyEntry -> neureka.common.utility.Cache$LazyEntry:
    java.lang.Object _key -> a
    java.util.function.Function _valueSupplier -> b
    java.lang.Object _value -> c
    109:114:void <init>(java.lang.Object,java.util.function.Function) -> <init>
    117:118:java.lang.Object getValue() -> getValue
    123:126:boolean equals(java.lang.Object) -> equals
    131:131:int hashCode() -> hashCode
neureka.common.utility.DataConverter -> neureka.common.utility.DataConverter:
    org.slf4j.Logger _LOG -> a
    java.util.Map _converters -> b
    neureka.common.utility.DataConverter _instance -> c
    96:96:neureka.common.utility.DataConverter instance() -> instance
    104:172:void <init>() -> <init>
    188:202:void _set(java.lang.Class,java.lang.Class,neureka.common.utility.DataConverter$Conversion) -> a
    215:241:java.lang.Object convert(java.lang.Object,java.lang.Class) -> convert
    149:149:long[] lambda$new$5(java.util.List) -> a
    149:149:long lambda$new$4(java.lang.Object) -> a
    148:148:double[] lambda$new$3(java.util.List) -> b
    148:148:double lambda$new$2(java.lang.Object) -> b
    147:147:int[] lambda$new$1(java.util.List) -> c
    147:147:int lambda$new$0(java.lang.Object) -> c
    62:89:void <clinit>() -> <clinit>
neureka.common.utility.DataConverter$Conversion -> neureka.common.utility.DataConverter$a:
    java.lang.Object go(java.lang.Object) -> go
neureka.common.utility.DataConverter$ForTensor -> neureka.common.utility.DataConverter$ForTensor:
    neureka.ndim.config.NDConfiguration$IndexToIndexFunction _access -> a
    int _size -> b
    255:258:void <init>(neureka.Tsr) -> <init>
    261:265:float[] toFloatArray(java.util.function.Function) -> toFloatArray
    269:273:byte[] toByteArray(java.util.function.Function) -> toByteArray
    277:281:long[] toLongArray(java.util.function.Function) -> toLongArray
    285:289:int[] toIntArray(java.util.function.Function) -> toIntArray
    293:297:double[] toDoubleArray(java.util.function.Function) -> toDoubleArray
    301:305:short[] toShortArray(java.util.function.Function) -> toShortArray
    309:313:java.lang.Object[] toObjectArray(java.util.function.Function) -> toObjectArray
    312:312:void lambda$toObjectArray$6(java.lang.Object[],java.util.function.Function,int) -> a
    304:304:void lambda$toShortArray$5(short[],java.util.function.Function,int) -> a
    296:296:void lambda$toDoubleArray$4(double[],java.util.function.Function,int) -> a
    288:288:void lambda$toIntArray$3(int[],java.util.function.Function,int) -> a
    280:280:void lambda$toLongArray$2(long[],java.util.function.Function,int) -> a
    272:272:void lambda$toByteArray$1(byte[],java.util.function.Function,int) -> a
    264:264:void lambda$toFloatArray$0(float[],java.util.function.Function,int) -> a
neureka.common.utility.DataConverter$Utility -> neureka.common.utility.DataConverter$Utility:
    323:323:void <init>() -> <init>
    327:331:float[] objFloatsToPrimFloats(java.lang.Float[]) -> objFloatsToPrimFloats
    336:340:double[] objDoublesToPrimDoubles(java.lang.Double[]) -> objDoublesToPrimDoubles
    345:349:int[] objIntsToPrimInts(java.lang.Integer[]) -> objIntsToPrimInts
    354:358:long[] objLongsToPrimLongs(java.lang.Long[]) -> objLongsToPrimLongs
    363:367:short[] objShortsToPrimShorts(java.lang.Short[]) -> objShortsToPrimShorts
    372:376:byte[] objBytesToPrimBytes(java.lang.Byte[]) -> objBytesToPrimBytes
    381:385:boolean[] objBooleansToPrimBooleans(java.lang.Boolean[]) -> objBooleansToPrimBooleans
    390:394:char[] objCharsToPrimChars(java.lang.Character[]) -> objCharsToPrimChars
    399:399:double[] newSeededDoubleArray(java.lang.String,int) -> newSeededDoubleArray
    404:404:double[] newSeededDoubleArray(long,int) -> newSeededDoubleArray
    409:409:double[] seededDoubleArray(double[],java.lang.String) -> seededDoubleArray
    414:417:double[] seededDoubleArray(double[],long) -> seededDoubleArray
    422:422:float[] newSeededFloatArray(java.lang.String,int) -> newSeededFloatArray
    427:427:float[] newSeededFloatArray(long,int) -> newSeededFloatArray
    432:432:float[] seededFloatArray(float[],java.lang.String) -> seededFloatArray
    437:440:float[] seededFloatArray(float[],long) -> seededFloatArray
    445:445:int[] seededIntArray(int[],java.lang.String) -> seededIntArray
    450:453:int[] seededIntArray(int[],long) -> seededIntArray
    458:458:short[] seededShortArray(short[],java.lang.String) -> seededShortArray
    463:466:short[] seededShortArray(short[],long) -> seededShortArray
    471:471:byte[] seededByteArray(byte[],java.lang.String) -> seededByteArray
    476:479:byte[] seededByteArray(byte[],long) -> seededByteArray
    484:484:long[] seededLongArray(long[],java.lang.String) -> seededLongArray
    489:492:long[] seededLongArray(long[],long) -> seededLongArray
    497:497:boolean[] seededBooleanArray(boolean[],java.lang.String) -> seededBooleanArray
    502:505:boolean[] seededBooleanArray(boolean[],long) -> seededBooleanArray
    510:510:char[] seededCharacterArray(char[],java.lang.String) -> seededCharacterArray
    515:518:char[] seededCharacterArray(char[],long) -> seededCharacterArray
    524:527:long _longStringHash(java.lang.String) -> a
    532:535:short[] byteToShort(byte[]) -> byteToShort
    540:543:java.math.BigInteger[] byteToBigInteger(byte[]) -> byteToBigInteger
    548:557:float[] doubleToFloat(double[]) -> doubleToFloat
    562:565:byte[] doubleToByte(double[]) -> doubleToByte
    570:573:short[] doubleToShort(double[]) -> doubleToShort
    578:581:long[] doubleToLong(double[]) -> doubleToLong
    586:595:double[] floatToDouble(float[]) -> floatToDouble
    600:603:byte[] floatToByte(float[]) -> floatToByte
    608:611:short[] floatToShort(float[]) -> floatToShort
    616:619:long[] floatToLong(float[]) -> floatToLong
    624:627:double[] shortToDouble(short[]) -> shortToDouble
    632:635:double[] byteToDouble(byte[]) -> byteToDouble
    640:643:float[] byteToFloat(byte[]) -> byteToFloat
    648:651:float[] shortToFloat(short[]) -> shortToFloat
    656:659:int[] byteToInt(byte[]) -> byteToInt
    664:667:int[] shortToInt(short[]) -> shortToInt
    672:675:byte[] shortToByte(short[]) -> shortToByte
    680:683:long[] byteToLong(byte[]) -> byteToLong
    688:691:long[] shortToLong(short[]) -> shortToLong
    696:699:java.math.BigInteger[] shortToBigInteger(short[]) -> shortToBigInteger
    704:707:float[] intToFloat(int[]) -> intToFloat
    712:715:int[] floatToInt(float[]) -> floatToInt
    720:723:java.math.BigInteger[] floatToBigInteger(float[]) -> floatToBigInteger
    728:731:int[] doubleToInt(double[]) -> doubleToInt
    736:739:java.math.BigInteger[] doubleToBigInteger(double[]) -> doubleToBigInteger
    744:747:double[] intToDouble(int[]) -> intToDouble
    752:755:long[] intToLong(int[]) -> intToLong
    760:763:short[] intToShort(int[]) -> intToShort
    768:771:byte[] intToByte(int[]) -> intToByte
    776:779:java.math.BigInteger[] intToBigInteger(int[]) -> intToBigInteger
    784:787:byte[] longToByte(long[]) -> longToByte
    792:795:short[] longToShort(long[]) -> longToShort
    800:803:int[] longToInt(long[]) -> longToInt
    808:811:float[] longToFloat(long[]) -> longToFloat
    816:819:double[] longToDouble(long[]) -> longToDouble
    824:827:java.math.BigInteger[] longToBigInteger(long[]) -> longToBigInteger
    832:839:double[] objectsToDoubles(java.lang.Object[],int) -> objectsToDoubles
    844:849:float[] objectsToFloats(java.lang.Object[],int) -> objectsToFloats
    854:859:short[] objectsToShorts(java.lang.Object[],int) -> objectsToShorts
    864:869:byte[] objectsToBytes(java.lang.Object[],int) -> objectsToBytes
    874:879:long[] objectsToLongs(java.lang.Object[],int) -> objectsToLongs
    884:889:int[] objectsToInts(java.lang.Object[],int) -> objectsToInts
    593:593:void lambda$floatToDouble$1(double[],float[],int) -> a
    555:555:void lambda$doubleToFloat$0(float[],double[],int) -> a
neureka.common.utility.ListReader -> neureka.common.utility.ListReader:
    java.lang.Class _type -> a
    int _size -> b
    30:30:neureka.common.utility.ListReader$Result read(java.util.List,java.util.function.Function) -> read
    39:66:void <init>(java.lang.Object,int,java.util.List,java.util.List,java.util.function.Function) -> <init>
    1069:1081:java.lang.Class _findType(java.util.List):69:81 -> <init>
    1069:1081:void <init>(java.lang.Object,int,java.util.List,java.util.List,java.util.function.Function):57 -> <init>
    1085:1093:int _findSize(java.util.List,int):85:93 -> <init>
    1085:1093:void <init>(java.lang.Object,int,java.util.List,java.util.List,java.util.function.Function):58 -> <init>
    93:93:java.lang.Integer lambda$_findSize$10(neureka.common.utility.ListReader) -> b
    90:90:boolean lambda$_findSize$9(int,java.lang.Integer) -> a
    87:87:boolean lambda$_findSize$8(int,java.lang.Integer) -> b
    85:85:java.util.stream.Stream lambda$_findSize$7(java.util.List) -> a
    85:85:java.lang.Integer lambda$_findSize$6(neureka.common.utility.ListReader) -> c
    77:77:boolean lambda$_findType$5(java.lang.Class,java.lang.Class) -> a
    71:71:boolean lambda$_findType$4(java.lang.Class,java.lang.Class) -> b
    69:69:java.util.stream.Stream lambda$_findType$3(java.util.List) -> b
    69:69:java.lang.Class lambda$_findType$2(neureka.common.utility.ListReader) -> d
    54:54:neureka.common.utility.ListReader lambda$new$1(int,java.util.List,java.util.List,java.util.function.Function,java.lang.Object) -> a
    47:47:boolean lambda$new$0(java.lang.Object) -> a
    1097:1099:boolean _isLeave(java.lang.Object):97:99 -> a
    1097:1099:boolean lambda$new$0(java.lang.Object):47 -> a
    15:15:void <init>(java.lang.Object,int,java.util.List,java.util.List,java.util.function.Function,byte) -> <init>
    15:15:java.lang.Class access$200(neureka.common.utility.ListReader) -> a
neureka.common.utility.ListReader$Result -> neureka.common.utility.ListReader$Result:
    java.util.List _growingShape -> a
    java.util.List _growingData -> b
    java.lang.Class _type -> c
    104:118:void <init>(java.lang.Object,java.util.function.Function) -> <init>
    120:120:java.lang.Class getType() -> getType
    122:122:java.util.List getShape() -> getShape
    124:124:java.util.List getData() -> getData
    102:102:void <init>(java.lang.Object,java.util.function.Function,byte) -> <init>
neureka.common.utility.LogUtil -> neureka.common.utility.LogUtil:
    11:11:void <init>() -> <init>
    22:22:java.lang.String format(java.lang.String,java.lang.Object[]) -> format
    26:36:void nullArgCheck(java.lang.Object,java.lang.String,java.lang.Class,java.lang.String[]) -> nullArgCheck
neureka.common.utility.SettingsLoader -> neureka.common.utility.SettingsLoader:
    org.slf4j.Logger _LOG -> a
    java.lang.String _settings_source -> b
    java.lang.String _setup_source -> c
    61:61:void <init>() -> <init>
    64:101:void loadProperties(neureka.Neureka) -> loadProperties
    160:167:java.lang.Object tryGroovyClosureOn(java.lang.Object,java.lang.Object) -> tryGroovyClosureOn
    172:191:void tryGroovyScriptsOn(neureka.Neureka,java.util.function.Consumer) -> tryGroovyScriptsOn
    96:96:void lambda$loadProperties$23(neureka.Neureka$Settings,java.lang.Boolean) -> a
    95:95:void lambda$loadProperties$22(neureka.Neureka$Settings,java.lang.Class) -> a
    94:94:void lambda$loadProperties$21(neureka.Neureka$Settings,java.lang.Boolean) -> b
    93:93:void lambda$loadProperties$20(neureka.Neureka$Settings,java.lang.Boolean) -> c
    92:92:void lambda$loadProperties$19(neureka.Neureka$Settings,java.lang.String) -> a
    91:91:void lambda$loadProperties$18(neureka.Neureka$Settings,java.lang.String) -> b
    90:90:void lambda$loadProperties$17(neureka.Neureka$Settings,java.lang.String) -> c
    89:89:void lambda$loadProperties$16(neureka.Neureka$Settings,java.lang.Boolean) -> d
    88:88:void lambda$loadProperties$15(neureka.Neureka$Settings,java.lang.Boolean) -> e
    87:87:void lambda$loadProperties$14(neureka.Neureka$Settings,java.lang.Boolean) -> f
    86:86:void lambda$loadProperties$13(neureka.Neureka$Settings,java.lang.Boolean) -> g
    85:85:void lambda$loadProperties$12(neureka.Neureka$Settings,java.lang.Boolean) -> h
    84:84:void lambda$loadProperties$11(neureka.Neureka$Settings,java.lang.Integer) -> a
    83:83:void lambda$loadProperties$10(neureka.Neureka$Settings,java.lang.Boolean) -> i
    82:82:void lambda$loadProperties$9(neureka.Neureka$Settings,java.lang.Boolean) -> j
    81:81:void lambda$loadProperties$8(neureka.Neureka$Settings,java.lang.Boolean) -> k
    80:80:void lambda$loadProperties$7(neureka.Neureka$Settings,java.lang.Boolean) -> l
    79:79:void lambda$loadProperties$6(neureka.Neureka$Settings,java.lang.Integer) -> b
    78:78:void lambda$loadProperties$5(neureka.Neureka$Settings,java.lang.Boolean) -> m
    77:77:void lambda$loadProperties$4(neureka.Neureka$Settings,java.lang.Boolean) -> n
    76:76:void lambda$loadProperties$3(neureka.Neureka$Settings,java.lang.Boolean) -> o
    75:75:void lambda$loadProperties$2(neureka.Neureka$Settings,java.lang.Boolean) -> p
    74:74:void lambda$loadProperties$1(neureka.Neureka$Settings,java.lang.Boolean) -> q
    73:73:void lambda$loadProperties$0(neureka.Neureka$Settings,java.lang.Boolean) -> r
    55:55:org.slf4j.Logger access$000() -> a
    57:57:void <clinit>() -> <clinit>
neureka.common.utility.SettingsLoader$TypeChecker -> neureka.common.utility.SettingsLoader$a:
    java.util.Properties _properties -> a
    107:107:void <init>(java.util.Properties) -> <init>
    110:147:neureka.common.utility.SettingsLoader$TypeChecker checkAndAssign(java.lang.String,java.lang.Class,java.util.function.Consumer) -> a
neureka.devices.AbstractBaseDevice -> neureka.devices.AbstractBaseDevice:
    47:47:void <init>() -> <init>
    51:53:int size() -> size
    62:62:boolean isEmpty() -> isEmpty
    65:65:boolean contains(neureka.Tsr) -> contains
    68:68:java.util.Iterator iterator() -> iterator
    71:71:java.util.Spliterator spliterator() -> spliterator
neureka.devices.AbstractDevice -> neureka.devices.AbstractDevice:
    neureka.devices.DeviceCleaner _CLEANER -> a
    org.slf4j.Logger _log -> _log
    67:67:void <init>() -> <init>
    boolean _approveExecutionOf(neureka.Tsr[],int,neureka.backend.api.Operation) -> _approveExecutionOf
    85:102:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    107:108:neureka.devices.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    111:111:void _cleaning(java.lang.Object,java.lang.Runnable) -> _cleaning
    124:127:neureka.devices.Device approve(neureka.backend.api.ExecutionCall) -> approve
    132:133:neureka.devices.Storage store(neureka.Tsr) -> store
    63:63:void <clinit>() -> <clinit>
neureka.devices.CustomDeviceCleaner -> neureka.devices.a:
    java.lang.ref.ReferenceQueue _referenceQueue -> a
    int _registered -> b
    java.util.List list -> c
    14:20:void <init>() -> <init>
    37:42:void register(java.lang.Object,java.lang.Runnable) -> a
    46:59:void run() -> run
    63:63:java.lang.String toString() -> toString
neureka.devices.CustomDeviceCleaner$ReferenceWithCleanup -> neureka.devices.a$a:
    java.lang.Runnable _action -> a
    27:29:void <init>(java.lang.Object,java.lang.Runnable,java.lang.ref.ReferenceQueue) -> <init>
    31:32:void cleanup() -> a
neureka.devices.Device -> neureka.devices.Device:
    83:83:neureka.devices.Device find(java.lang.String[]) -> find
    98:130:neureka.devices.Device find(java.lang.Class,java.lang.String[]) -> find
    void dispose() -> dispose
    neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    boolean has(neureka.Tsr) -> has
    neureka.devices.Device free(neureka.Tsr) -> free
    neureka.devices.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    neureka.devices.Device write(neureka.Tsr,java.lang.Object) -> write
    neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    neureka.devices.Device approve(neureka.backend.api.ExecutionCall) -> approve
    neureka.devices.Device updateNDConf(neureka.Tsr) -> updateNDConf
    java.lang.Object valueFor(neureka.Tsr) -> valueFor
    java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    java.util.Collection getTensors() -> getTensors
    neureka.backend.api.Operation optimizedOperationOf(neureka.calculus.Function,java.lang.String) -> optimizedOperationOf
    231:240:neureka.calculus.Function optimizedFunctionOf(neureka.calculus.Function,java.lang.String) -> optimizedFunctionOf
    259:264:neureka.devices.Device$In use(neureka.Tsr,neureka.Tsr[]) -> use
    111:111:double lambda$find$0(java.lang.String,java.lang.String) -> a
neureka.devices.Device$1 -> neureka.devices.Device$1:
    java.util.List val$tensors -> a
    neureka.devices.Device val$thisDevice -> b
    264:264:void <init>(neureka.devices.Device,java.util.List,neureka.devices.Device) -> <init>
    267:273:java.lang.Object in(java.util.function.Supplier) -> in
neureka.devices.Device$In -> neureka.devices.Device$In:
    java.lang.Object in(java.util.function.Supplier) -> in
neureka.devices.DeviceCleaner -> neureka.devices.b:
    void register(java.lang.Object,java.lang.Runnable) -> a
neureka.devices.Storage -> neureka.devices.Storage:
    neureka.devices.Storage store(neureka.Tsr) -> store
    neureka.devices.Storage restore(neureka.Tsr) -> restore
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(neureka.Tsr) -> contains
neureka.devices.file.FileDevice -> neureka.devices.file.FileDevice:
    org.slf4j.Logger _LOG -> a
    neureka.common.utility.Cache _CACHE -> b
    java.util.Map _stored -> c
    java.lang.String _directory -> d
    java.util.List _loadable -> e
    java.util.List _loaded -> f
    boolean $assertionsDisabled -> g
    55:55:neureka.devices.file.FileDevice at(java.lang.String) -> at
    44:61:void <init>(java.lang.String) -> <init>
    68:92:void _updateFolderView() -> a
    94:94:neureka.Tsr load(java.lang.String) -> load
    97:108:neureka.Tsr load(java.lang.String,java.util.Map) -> load
    112:112:neureka.devices.file.FileHead fileHeadOf(neureka.Tsr) -> fileHeadOf
    117:119:void dispose() -> dispose
    123:131:neureka.devices.Device restore(neureka.Tsr) -> restore
    137:152:neureka.devices.Device store(neureka.Tsr) -> store
    157:157:neureka.devices.file.FileDevice store(neureka.Tsr,java.lang.String) -> store
    164:180:neureka.devices.file.FileDevice store(neureka.Tsr,java.lang.String,java.util.Map) -> store
    184:184:neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    188:188:boolean has(neureka.Tsr) -> has
    194:203:neureka.devices.Device free(neureka.Tsr) -> free
    208:208:neureka.devices.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    213:213:neureka.devices.Device write(neureka.Tsr,java.lang.Object) -> write
    218:218:neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    223:223:neureka.devices.Device approve(neureka.backend.api.ExecutionCall) -> approve
    228:228:neureka.devices.Device updateNDConf(neureka.Tsr) -> updateNDConf
    233:233:java.lang.Object valueFor(neureka.Tsr) -> valueFor
    238:238:java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    243:243:java.util.Collection getTensors() -> getTensors
    248:248:neureka.backend.api.Operation optimizedOperationOf(neureka.calculus.Function,java.lang.String) -> optimizedOperationOf
    253:261:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    266:266:java.lang.String toString() -> toString
    270:270:java.lang.String getDirectory() -> getDirectory
    274:274:java.util.List getLoadable() -> getLoadable
    278:278:java.util.List getLoaded() -> getLoaded
    38:38:neureka.devices.Storage restore(neureka.Tsr) -> restore
    38:38:neureka.devices.Storage store(neureka.Tsr) -> store
    87:91:void lambda$_updateFolderView$0(java.lang.String) -> a
    38:42:void <clinit>() -> <clinit>
neureka.devices.file.FileHead -> neureka.devices.file.FileHead:
    neureka.devices.file.heads.util.HeadFactory FACTORY -> FACTORY
    neureka.Tsr load() -> load
    java.lang.Object free() -> free
    int getValueSize() -> getValueSize
    int getDataSize() -> getDataSize
    int getTotalSize() -> getTotalSize
    java.lang.String getLocation() -> getLocation
    java.lang.String getFileName() -> getFileName
    neureka.dtype.DataType getDataType() -> getDataType
    int[] getShape() -> getShape
    java.lang.String extension() -> extension
    13:13:void <clinit>() -> <clinit>
neureka.devices.file.heads.AbstractFileHead -> neureka.devices.file.heads.AbstractFileHead:
    org.slf4j.Logger _LOG -> _LOG
    java.lang.String _fileName -> _fileName
    int _size -> _size
    23:46:void <init>(java.lang.String) -> <init>
    49:49:int size() -> size
    53:53:boolean isEmpty() -> isEmpty
    57:57:boolean contains(neureka.Tsr) -> contains
    java.lang.Object _loadData() -> _loadData
    65:72:java.io.File _loadFile() -> _loadFile
    77:89:java.io.FileInputStream _loadFileInputStream() -> _loadFileInputStream
    95:101:java.lang.Object free() -> free
    106:106:java.lang.String getLocation() -> getLocation
    111:112:java.lang.String getFileName() -> getFileName
    118:124:neureka.devices.Storage restore(neureka.Tsr) -> restore
neureka.devices.file.heads.CSVHead -> neureka.devices.file.heads.CSVHead:
    java.lang.String _tensorName -> a
    java.lang.String _delimiter -> b
    boolean _firstRowIsLabels -> c
    java.lang.String[] _colLabels -> d
    boolean _firstColIsIndex -> e
    java.lang.String[] _rowLabels -> f
    java.lang.Integer _numberOfRows -> g
    java.lang.Integer _numberOfColumns -> h
    java.lang.Integer _numberOfBytes -> i
    java.lang.ref.WeakReference _rawData -> j
    boolean $assertionsDisabled -> k
    37:85:void <init>(neureka.Tsr,java.lang.String) -> <init>
    37:101:void <init>(java.lang.String,java.util.Map) -> <init>
    104:176:java.lang.String[] _lazyLoad() -> a
    180:183:void _parseTensorNameFromFileName() -> b
    187:187:neureka.devices.Storage store(neureka.Tsr) -> store
    192:192:java.lang.Object _loadData() -> _loadData
    197:223:neureka.Tsr load() -> load
    227:228:java.lang.String getTensorName() -> getTensorName
    234:236:int getValueSize() -> getValueSize
    241:243:int getDataSize() -> getDataSize
    248:248:int getTotalSize() -> getTotalSize
    253:253:neureka.dtype.DataType getDataType() -> getDataType
    258:258:int[] getShape() -> getShape
    263:263:java.lang.String extension() -> extension
    267:267:java.lang.String getDelimiter() -> getDelimiter
    271:271:boolean isFirstRowIsLabels() -> isFirstRowIsLabels
    275:275:java.lang.String[] getColLabels() -> getColLabels
    279:279:boolean isFirstColIsIndex() -> isFirstColIsIndex
    283:283:java.lang.String[] getRowLabels() -> getRowLabels
    287:287:java.lang.Integer getNumberOfRows() -> getNumberOfRows
    291:291:java.lang.Integer getNumberOfColumns() -> getNumberOfColumns
    24:28:void <clinit>() -> <clinit>
neureka.devices.file.heads.IDXHead -> neureka.devices.file.heads.IDXHead:
    neureka.dtype.DataType _dataType -> a
    int _dataOffset -> b
    int _valueSize -> c
    int[] _shape -> d
    java.util.Map TYPE_MAP -> e
    java.util.Map CODE_MAP -> f
    boolean $assertionsDisabled -> g
    59:66:void <init>(java.lang.String) -> <init>
    1078:1101:void _loadHead():78:101 -> <init>
    1078:1101:void <init>(java.lang.String):61 -> <init>
    69:74:void <init>(neureka.Tsr,java.lang.String) -> <init>
    107:152:neureka.devices.file.heads.IDXHead store(neureka.Tsr) -> store
    157:170:java.lang.Object _loadData() -> _loadData
    176:180:neureka.Tsr load() -> load
    185:188:int getDataSize() -> getDataSize
    193:193:int getTotalSize() -> getTotalSize
    198:198:java.lang.String extension() -> extension
    203:203:neureka.dtype.DataType getDataType() -> getDataType
    207:207:int getValueSize() -> getValueSize
    211:211:int[] getShape() -> getShape
    26:26:neureka.devices.Storage store(neureka.Tsr) -> store
    26:51:void <clinit>() -> <clinit>
neureka.devices.file.heads.JPEGHead -> neureka.devices.file.heads.JPEGHead:
    int _width -> a
    int _height -> b
    boolean $assertionsDisabled -> c
    35:41:void <init>(java.lang.String) -> <init>
    1056:1086:void _loadHead():56:86 -> <init>
    1056:1086:void <init>(java.lang.String):37 -> <init>
    44:51:void <init>(neureka.Tsr,java.lang.String) -> <init>
    90:92:neureka.Tsr load() -> load
    98:118:java.lang.Object _loadData() -> _loadData
    124:124:int getValueSize() -> getValueSize
    129:129:int getDataSize() -> getDataSize
    134:134:int getTotalSize() -> getTotalSize
    139:139:neureka.dtype.DataType getDataType() -> getDataType
    144:144:int[] getShape() -> getShape
    149:149:java.lang.String extension() -> extension
    155:168:neureka.devices.Storage store(neureka.Tsr) -> store
    110:111:void lambda$_loadData$0(short[],neureka.dtype.custom.UI8,byte[],int,int) -> a
    24:28:void <clinit>() -> <clinit>
neureka.devices.file.heads.util.HeadFactory -> neureka.devices.file.heads.util.HeadFactory:
    java.util.Map _LOADERS -> a
    java.util.Map _SAVERS -> b
    28:41:void <init>() -> <init>
    44:44:boolean hasLoader(java.lang.String) -> hasLoader
    48:48:boolean hasSaver(java.lang.String) -> hasSaver
    52:52:neureka.devices.file.heads.util.HeadFactory$Loader getLoader(java.lang.String) -> getLoader
    56:56:neureka.devices.file.heads.util.HeadFactory$Saver getSaver(java.lang.String) -> getSaver
    40:40:neureka.devices.file.FileHead lambda$new$7(java.lang.String,neureka.Tsr,java.util.Map) -> a
    39:39:neureka.devices.file.FileHead lambda$new$6(java.lang.String,neureka.Tsr,java.util.Map) -> b
    38:38:neureka.devices.file.FileHead lambda$new$5(java.lang.String,neureka.Tsr,java.util.Map) -> c
    37:37:neureka.devices.file.FileHead lambda$new$4(java.lang.String,neureka.Tsr,java.util.Map) -> d
    35:35:neureka.devices.file.FileHead lambda$new$3(java.lang.String,java.util.Map) -> a
    34:34:neureka.devices.file.FileHead lambda$new$2(java.lang.String,java.util.Map) -> b
    33:33:neureka.devices.file.FileHead lambda$new$1(java.lang.String,java.util.Map) -> c
    32:32:neureka.devices.file.FileHead lambda$new$0(java.lang.String,java.util.Map) -> d
neureka.devices.file.heads.util.HeadFactory$Loader -> neureka.devices.file.heads.util.HeadFactory$Loader:
    neureka.devices.file.FileHead load(java.lang.String,java.util.Map) -> load
neureka.devices.file.heads.util.HeadFactory$Saver -> neureka.devices.file.heads.util.HeadFactory$Saver:
    neureka.devices.file.FileHead save(java.lang.String,neureka.Tsr,java.util.Map) -> save
neureka.devices.file.heads.util.NumberReader -> neureka.devices.file.heads.util.NumberReader:
    java.io.FileInputStream _fileInputStream -> a
    int _bytesRead -> b
    java.util.Map _byteMap -> c
    boolean $assertionsDisabled -> d
    13:23:void <init>(java.io.FileInputStream) -> <init>
    26:26:java.io.FileInputStream getStream() -> getStream
    30:32:java.lang.Object read(neureka.dtype.NumericType) -> read
    39:39:int bytesRead() -> bytesRead
    10:10:void <clinit>() -> <clinit>
neureka.devices.host.CPU -> neureka.devices.host.CPU:
    org.slf4j.Logger _LOG -> a
    neureka.devices.host.CPU _INSTANCE -> b
    neureka.devices.host.concurrent.WorkScheduler$Divider _DIVIDER -> c
    java.util.function.IntSupplier _PARALLELISM -> d
    int PARALLELIZATION_THRESHOLD -> PARALLELIZATION_THRESHOLD
    neureka.devices.host.CPU$JVMExecutor _executor -> e
    java.util.Set _tensors -> f
    46:49:void <init>() -> <init>
    59:59:neureka.devices.host.CPU get() -> get
    68:68:neureka.devices.host.CPU$JVMExecutor getExecutor() -> getExecutor
    71:71:boolean _approveExecutionOf(neureka.Tsr[],int,neureka.backend.api.Operation) -> _approveExecutionOf
    79:85:void dispose() -> dispose
    88:88:neureka.devices.Device write(neureka.Tsr,java.lang.Object) -> write
    91:91:java.lang.Object valueFor(neureka.Tsr) -> valueFor
    94:94:java.lang.Number valueFor(neureka.Tsr,int) -> valueFor
    97:97:neureka.devices.host.CPU restore(neureka.Tsr) -> restore
    102:103:neureka.devices.host.CPU store(neureka.Tsr) -> store
    108:110:neureka.devices.host.CPU store(neureka.Tsr,neureka.Tsr) -> store
    114:114:boolean has(neureka.Tsr) -> has
    118:119:neureka.devices.host.CPU free(neureka.Tsr) -> free
    123:123:neureka.devices.host.CPU swap(neureka.Tsr,neureka.Tsr) -> swap
    127:127:neureka.devices.Device updateNDConf(neureka.Tsr) -> updateNDConf
    131:131:java.util.Collection getTensors() -> getTensors
    134:134:neureka.backend.api.Operation optimizedOperationOf(neureka.calculus.Function,java.lang.String) -> optimizedOperationOf
    145:146:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    158:158:int getCoreCount() -> getCoreCount
    162:162:java.lang.String toString() -> toString
    30:30:neureka.devices.Storage store(neureka.Tsr) -> store
    30:30:java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    30:30:neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    30:30:neureka.devices.Device free(neureka.Tsr) -> free
    30:30:neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    30:30:neureka.devices.Storage restore(neureka.Tsr) -> restore
    30:30:java.util.function.IntSupplier access$000() -> a
    30:30:neureka.devices.host.concurrent.WorkScheduler$Divider access$100() -> b
    32:44:void <clinit>() -> <clinit>
neureka.devices.host.CPU$JVMExecutor -> neureka.devices.host.CPU$JVMExecutor:
    java.util.concurrent.atomic.AtomicInteger _COUNTER -> a
    java.lang.ThreadGroup _GROUP -> b
    java.util.concurrent.ThreadPoolExecutor _pool -> c
    185:204:void <init>() -> <init>
    1208:1208:java.util.concurrent.ThreadFactory _newThreadFactory(java.lang.String):208:208 -> <init>
    1208:1208:void <init>():204 -> <init>
    1213:1215:java.util.concurrent.ThreadFactory _newThreadFactory(java.lang.ThreadGroup,java.lang.String):213:215 -> <init>
    1213:1215:java.util.concurrent.ThreadFactory _newThreadFactory(java.lang.String):208 -> <init>
    1213:1215:void <init>():204 -> <init>
    226:226:java.util.concurrent.ThreadPoolExecutor getPool() -> getPool
    236:242:void threaded(int,neureka.devices.host.CPU$RangeWorkload) -> threaded
    252:253:void sequential(int,neureka.devices.host.CPU$RangeWorkload) -> sequential
    268:271:void threaded(int,int,neureka.devices.host.CPU$RangeWorkload) -> threaded
    216:222:java.lang.Thread lambda$_newThreadFactory$0(java.lang.ThreadGroup,java.lang.String,java.lang.Runnable) -> a
    187:188:void <clinit>() -> <clinit>
neureka.devices.host.CPU$RangeWorkload -> neureka.devices.host.CPU$RangeWorkload:
    void execute(int,int) -> execute
neureka.devices.host.concurrent.Parallelism -> neureka.devices.host.concurrent.Parallelism:
    neureka.devices.host.concurrent.Parallelism THREADS -> THREADS
    neureka.devices.host.concurrent.Parallelism CORES -> CORES
    neureka.devices.host.concurrent.Parallelism UNITS -> UNITS
    neureka.devices.host.concurrent.Parallelism EIGHT -> EIGHT
    neureka.devices.host.concurrent.Parallelism FOUR -> FOUR
    neureka.devices.host.concurrent.Parallelism TWO -> TWO
    neureka.devices.host.concurrent.Parallelism ONE -> ONE
    java.util.function.IntSupplier _supplier -> a
    neureka.devices.host.concurrent.Parallelism[] $VALUES -> b
    13:13:neureka.devices.host.concurrent.Parallelism[] values() -> values
    13:13:neureka.devices.host.concurrent.Parallelism valueOf(java.lang.String) -> valueOf
    46:48:void <init>(java.lang.String,int,java.util.function.IntSupplier) -> <init>
    51:51:int getAsInt() -> getAsInt
    42:42:int lambda$static$6() -> a
    38:38:int lambda$static$5() -> b
    34:34:int lambda$static$4() -> c
    30:30:int lambda$static$3() -> d
    26:26:int lambda$static$2() -> e
    22:22:int lambda$static$1() -> f
    18:18:int lambda$static$0() -> g
    13:42:void <clinit>() -> <clinit>
neureka.devices.host.concurrent.WorkScheduler -> neureka.devices.host.concurrent.WorkScheduler:
    74:93:void _call(java.util.concurrent.ExecutorService,int,int,int,int,neureka.devices.host.CPU$RangeWorkload) -> b
    96:97:void <init>() -> <init>
    111:120:void invoke(int,int,int) -> invoke
    void _work(int,int) -> _work
    82:82:void lambda$_call$1(java.util.concurrent.ExecutorService,int,int,int,int,neureka.devices.host.CPU$RangeWorkload) -> c
    81:81:void lambda$_call$0(java.util.concurrent.ExecutorService,int,int,int,int,neureka.devices.host.CPU$RangeWorkload) -> d
    16:16:void access$000(java.util.concurrent.ExecutorService,int,int,int,int,neureka.devices.host.CPU$RangeWorkload) -> a
neureka.devices.host.concurrent.WorkScheduler$Divider -> neureka.devices.host.concurrent.WorkScheduler$Divider:
    java.util.concurrent.ExecutorService _executor -> a
    java.util.function.IntSupplier _parallelism -> b
    int _threshold -> c
    26:33:void <init>(java.util.concurrent.ExecutorService) -> <init>
    36:37:void divide(int,neureka.devices.host.CPU$RangeWorkload) -> divide
    40:48:void divide(int,int,neureka.devices.host.CPU$RangeWorkload) -> divide
    53:56:neureka.devices.host.concurrent.WorkScheduler$Divider parallelism(java.util.function.IntSupplier) -> parallelism
    60:61:neureka.devices.host.concurrent.WorkScheduler$Divider threshold(int) -> threshold
neureka.devices.host.machine.BasicMachine -> neureka.devices.host.machine.BasicMachine:
    long memory -> memory
    int threads -> threads
    23:27:void <init>(long,int) -> <init>
    31:32:void <init>() -> <init>
    36:42:boolean equals(java.lang.Object) -> equals
    48:52:int hashCode() -> hashCode
    58:70:java.lang.String toString() -> toString
neureka.devices.host.machine.CommonMachine -> neureka.devices.host.machine.CommonMachine:
    long K -> K
    java.lang.String architecture -> architecture
    long cache -> cache
    int cores -> cores
    int units -> units
    30:38:void <init>(neureka.devices.host.machine.Hardware,java.lang.Runtime) -> <init>
    50:57:void <init>(java.lang.String,neureka.devices.host.machine.BasicMachine[]) -> <init>
    62:77:boolean equals(java.lang.Object) -> equals
    82:88:int hashCode() -> hashCode
neureka.devices.host.machine.ConcreteMachine -> neureka.devices.host.machine.ConcreteMachine:
    org.slf4j.Logger _LOG -> a
    neureka.devices.host.machine.ConcreteMachine ENVIRONMENT -> ENVIRONMENT
    neureka.devices.host.machine.Hardware myHardware -> b
    42:49:java.lang.String getArchitecture() -> getArchitecture
    54:54:long getMemory() -> getMemory
    58:58:int getThreads() -> getThreads
    66:70:void <init>(neureka.devices.host.machine.Hardware,java.lang.Runtime) -> <init>
    74:81:boolean equals(java.lang.Object) -> equals
    86:89:int hashCode() -> hashCode
    94:94:java.lang.String toString() -> toString
    9:31:void <clinit>() -> <clinit>
neureka.devices.host.machine.Hardware -> neureka.devices.host.machine.Hardware:
    long OS_MEMORY_PAGE_SIZE -> OS_MEMORY_PAGE_SIZE
    java.util.Set PREDEFINED -> PREDEFINED
    neureka.devices.host.machine.Hardware PPC__01 -> a
    neureka.devices.host.machine.Hardware X86__01 -> b
    neureka.devices.host.machine.Hardware X86__02 -> c
    neureka.devices.host.machine.Hardware X86_64__02 -> d
    neureka.devices.host.machine.Hardware X86_64__04 -> e
    neureka.devices.host.machine.Hardware X86_64__04_1_L2 -> f
    neureka.devices.host.machine.Hardware X86_64__04_1_L3 -> g
    neureka.devices.host.machine.Hardware X86_64__04_2 -> h
    neureka.devices.host.machine.Hardware X86_64__08 -> i
    neureka.devices.host.machine.Hardware X86_64__12 -> j
    neureka.devices.host.machine.Hardware X86_64__16 -> k
    neureka.devices.host.machine.Hardware X86_64__64 -> l
    neureka.devices.host.machine.Hardware X86_64__96 -> m
    neureka.devices.host.machine.BasicMachine[] myLevels -> n
    417:417:neureka.devices.host.machine.Hardware makeSimple() -> makeSimple
    422:446:neureka.devices.host.machine.Hardware makeSimple(java.lang.String,long,int) -> makeSimple
    465:472:void <init>(java.lang.String,neureka.devices.host.machine.BasicMachine[]) -> <init>
    475:486:int compareTo(neureka.devices.host.machine.Hardware) -> compareTo
    492:505:boolean equals(java.lang.Object) -> equals
    510:513:int hashCode() -> hashCode
    517:517:boolean isL2Specified() -> isL2Specified
    521:521:boolean isL3Specified() -> isL3Specified
    527:537:java.lang.String toString() -> toString
    541:541:neureka.devices.host.machine.ConcreteMachine virtualize() -> virtualize
    32:32:int compareTo(java.lang.Object) -> compareTo
    42:414:void <clinit>() -> <clinit>
neureka.devices.opencl.CLContext -> neureka.devices.opencl.CLContext:
    org.slf4j.Logger _LOG -> a
    java.util.List _platforms -> b
    41:47:void <init>() -> <init>
    52:52:java.util.List getPlatforms() -> getPlatforms
    63:66:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    71:73:java.lang.String toString() -> toString
    84:107:java.util.List _findLoadAndCompileForAllPlatforms() -> a
    112:128:neureka.backend.api.BackendExtension$DeviceOption find(java.lang.String) -> find
    138:145:void dispose() -> dispose
    117:117:double lambda$find$1(java.lang.String,java.lang.String) -> a
    104:104:boolean lambda$_findLoadAndCompileForAllPlatforms$0(neureka.devices.opencl.OpenCLPlatform) -> a
    39:39:void <clinit>() -> <clinit>
neureka.devices.opencl.KernelCache -> neureka.devices.opencl.KernelCache:
    java.util.Map _adhocKernels -> a
    6:10:void <init>() -> <init>
    20:21:void put(java.lang.String,neureka.devices.opencl.OpenCLDevice$cl_ad_hoc) -> put
    24:24:boolean has(java.lang.String) -> has
    28:28:neureka.devices.opencl.OpenCLDevice$cl_ad_hoc get(java.lang.String) -> get
neureka.devices.opencl.KernelCache$1 -> neureka.devices.opencl.KernelCache$1:
    11:11:void <init>(neureka.devices.opencl.KernelCache,int) -> <init>
    14:14:boolean removeEldestEntry(java.util.Map$Entry) -> removeEldestEntry
neureka.devices.opencl.KernelCaller -> neureka.devices.opencl.KernelCaller:
    org.jocl.cl_command_queue _queue -> a
    org.jocl.cl_kernel _kernel -> b
    java.util.List _inputs -> c
    int _argId -> d
    boolean $assertionsDisabled -> e
    24:35:void <init>(org.jocl.cl_kernel,org.jocl.cl_command_queue) -> <init>
    44:47:neureka.devices.opencl.KernelCaller passAllOf(neureka.Tsr) -> passAllOf
    60:62:neureka.devices.opencl.KernelCaller passConfOf(neureka.Tsr) -> passConfOf
    72:75:neureka.devices.opencl.KernelCaller pass(neureka.Tsr) -> pass
    84:86:neureka.devices.opencl.KernelCaller pass(int) -> pass
    95:97:neureka.devices.opencl.KernelCaller pass(float) -> pass
    106:121:void call(int) -> call
    125:141:void call(long[],long[]) -> call
    145:151:void _releaseEvents(neureka.Tsr[]) -> a
    155:162:org.jocl.cl_event[] _getWaitList(neureka.Tsr[]) -> b
    18:18:void <clinit>() -> <clinit>
neureka.devices.opencl.KernelCode -> neureka.devices.opencl.KernelCode:
    java.lang.String _name -> a
    java.lang.String _code -> b
    11:14:void <init>(java.lang.String,java.lang.String) -> <init>
    16:16:java.lang.String getName() -> getName
    18:18:java.lang.String getCode() -> getCode
    22:25:boolean equals(java.lang.Object) -> equals
    30:30:int hashCode() -> hashCode
neureka.devices.opencl.KernelSource -> neureka.devices.opencl.KernelSource:
    neureka.devices.opencl.KernelCode getKernelFor(neureka.backend.api.ExecutionCall) -> getKernelFor
neureka.devices.opencl.OpenCLDevice -> neureka.devices.opencl.OpenCLDevice:
    org.slf4j.Logger _LOG -> a
    java.util.Set _tensors -> b
    neureka.devices.opencl.KernelCache _kernelCache -> c
    org.jocl.cl_device_id _deviceId -> d
    neureka.devices.opencl.OpenCLPlatform _platform -> e
    org.jocl.cl_command_queue _queue -> f
    boolean $assertionsDisabled -> g
    85:86:neureka.devices.opencl.OpenCLDevice newInstanceOf(neureka.devices.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> newInstanceOf
    175:223:void <init>(neureka.devices.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> <init>
    226:226:java.lang.String toString() -> toString
    230:230:org.jocl.cl_device_id getDeviceId() -> getDeviceId
    234:234:neureka.devices.opencl.OpenCLPlatform getPlatform() -> getPlatform
    238:238:boolean hasAdHocKernel(java.lang.String) -> hasAdHocKernel
    242:244:neureka.devices.opencl.KernelCaller getAdHocKernel(java.lang.String) -> getAdHocKernel
    262:317:neureka.devices.opencl.OpenCLDevice compileAdHocKernel(java.lang.String,java.lang.String) -> compileAdHocKernel
    329:334:java.util.Collection getTensors() -> getTensors
    339:339:neureka.backend.api.Operation optimizedOperationOf(neureka.calculus.Function,java.lang.String) -> optimizedOperationOf
    347:350:void dispose() -> dispose
    363:375:neureka.devices.Device restore(neureka.Tsr) -> restore
    380:381:neureka.devices.Device store(neureka.Tsr,neureka.Tsr) -> store
    1385:1388:neureka.devices.Device _store(neureka.Tsr,neureka.Tsr,java.lang.Runnable):385:388 -> store
    1385:1388:neureka.devices.Device store(neureka.Tsr,neureka.Tsr):380 -> store
    392:444:void _add(neureka.Tsr,neureka.devices.opencl.OpenCLDevice$cl_tsr,java.lang.Runnable) -> a
    448:474:neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config _writeNDConfig(neureka.ndim.config.NDConfiguration) -> a
    488:488:boolean has(neureka.Tsr) -> has
    497:534:void _store(neureka.Tsr,neureka.devices.opencl.OpenCLDevice$cl_tsr,int) -> a
    539:544:neureka.devices.Device free(neureka.Tsr) -> free
    550:552:neureka.devices.Device write(neureka.Tsr,java.lang.Object) -> write
    557:575:neureka.devices.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    580:598:neureka.devices.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    603:608:neureka.devices.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    613:627:neureka.devices.Device updateNDConf(neureka.Tsr) -> updateNDConf
    632:638:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    1642:1646:void _updateInternal(neureka.Tsr,java.lang.Runnable):642:646 -> update
    1642:1646:boolean update(neureka.common.composition.Component$OwnerChangeRequest):635 -> update
    649:650:double[] value64f(neureka.Tsr) -> value64f
    654:668:double[] _value64f(neureka.devices.opencl.OpenCLDevice$cl_tsr,int,int) -> a
    673:674:float[] value32f(neureka.Tsr) -> value32f
    678:692:float[] _value32f(neureka.devices.opencl.OpenCLDevice$cl_tsr,int,int) -> b
    697:697:java.lang.Object valueFor(neureka.Tsr) -> valueFor
    702:702:java.lang.Number valueFor(neureka.Tsr,int) -> valueFor
    706:707:double value64f(neureka.Tsr,int) -> value64f
    711:712:float value32f(neureka.Tsr,int) -> value32f
    721:735:neureka.devices.opencl.KernelCaller getKernel(neureka.backend.api.ExecutionCall) -> getKernel
    740:740:boolean _approveExecutionOf(neureka.Tsr[],int,neureka.backend.api.Operation) -> _approveExecutionOf
    775:775:java.lang.String name() -> name
    779:779:java.lang.String vendor() -> vendor
    783:783:java.lang.String version() -> version
    787:794:neureka.devices.opencl.OpenCLDevice$Type type() -> type
    798:798:int maxComputeUnits() -> maxComputeUnits
    802:802:long maxWorkItemSimensions() -> maxWorkItemSimensions
    806:806:long[] maxWorkItemSizes() -> maxWorkItemSizes
    810:810:long maxWorkGroupSize() -> maxWorkGroupSize
    814:814:long maxClockFrequenzy() -> maxClockFrequenzy
    818:818:int maxAddressBits() -> maxAddressBits
    822:822:long maxMemAllocSize() -> maxMemAllocSize
    826:826:long globalMemSize() -> globalMemSize
    830:830:int errorCorrectionSupport() -> errorCorrectionSupport
    834:834:int localMemType() -> localMemType
    838:838:long localMemSize() -> localMemSize
    842:842:long maxConstantBufferSize() -> maxConstantBufferSize
    846:846:long maxConstantBufferSizeKB() -> maxConstantBufferSizeKB
    861:861:int imageSupport() -> imageSupport
    865:865:int maxReadImageArgs() -> maxReadImageArgs
    869:869:int maxWriteImageArgs() -> maxWriteImageArgs
    873:873:long singleFPConfig() -> singleFPConfig
    877:877:long image2DMaxWidth() -> image2DMaxWidth
    881:881:long image2DMaxHeight() -> image2DMaxHeight
    885:885:long image3DMaxWidth() -> image3DMaxWidth
    889:889:long image3DMaxHeight() -> image3DMaxHeight
    893:893:long image3DMaxDepth() -> image3DMaxDepth
    897:897:int prefVecWidthChar() -> prefVecWidthChar
    901:901:int prefVecWidthShort() -> prefVecWidthShort
    905:905:int prefVecWidthInt() -> prefVecWidthInt
    909:909:int prefVecWidthLong() -> prefVecWidthLong
    913:913:int prefVecWidthFloat() -> prefVecWidthFloat
    917:917:int prefVecWidthDouble() -> prefVecWidthDouble
    80:80:java.lang.Object valueFor(neureka.Tsr,int) -> valueFor
    80:80:neureka.devices.Storage restore(neureka.Tsr) -> restore
    473:473:void lambda$_writeNDConfig$6(org.jocl.cl_mem) -> a
    407:409:void lambda$_add$5(org.jocl.cl_event,org.jocl.cl_mem) -> a
    380:380:void lambda$store$4(neureka.Tsr) -> a
    331:331:void lambda$getTensors$3(java.util.Collection,java.util.Collection) -> a
    332:333:void lambda$getTensors$2(java.util.Collection,neureka.Tsr) -> a
    314:316:void lambda$compileAdHocKernel$1(org.jocl.cl_kernel,org.jocl.cl_program) -> a
    213:213:void lambda$new$0() -> a
    80:82:void <clinit>() -> <clinit>
neureka.devices.opencl.OpenCLDevice$DeviceQuery -> neureka.devices.opencl.OpenCLDevice$DeviceQuery:
    920:920:void <init>() -> <init>
    929:929:int getInt(org.jocl.cl_device_id,int) -> getInt
    941:943:int[] getInts(org.jocl.cl_device_id,int,int) -> getInts
    954:954:long getLong(org.jocl.cl_device_id,int) -> getLong
    966:968:long[] getLongs(org.jocl.cl_device_id,int,int) -> getLongs
    980:988:java.lang.String getString(org.jocl.cl_device_id,int) -> getString
    1000:1008:java.lang.String getString(org.jocl.cl_platform_id,int) -> getString
    1019:1019:long getSize(org.jocl.cl_device_id,int) -> getSize
    1033:1051:long[] getSizes(org.jocl.cl_device_id,int,int) -> getSizes
neureka.devices.opencl.OpenCLDevice$Type -> neureka.devices.opencl.OpenCLDevice$Type:
    neureka.devices.opencl.OpenCLDevice$Type CPU -> CPU
    neureka.devices.opencl.OpenCLDevice$Type GPU -> GPU
    neureka.devices.opencl.OpenCLDevice$Type ACCELERATOR -> ACCELERATOR
    neureka.devices.opencl.OpenCLDevice$Type DEFAULT -> DEFAULT
    neureka.devices.opencl.OpenCLDevice$Type CUSTOM -> CUSTOM
    neureka.devices.opencl.OpenCLDevice$Type ALL -> ALL
    neureka.devices.opencl.OpenCLDevice$Type UNKNOWN -> UNKNOWN
    neureka.devices.opencl.OpenCLDevice$Type[] $VALUES -> a
    89:89:neureka.devices.opencl.OpenCLDevice$Type[] values() -> values
    89:89:neureka.devices.opencl.OpenCLDevice$Type valueOf(java.lang.String) -> valueOf
    89:89:void <init>(java.lang.String,int) -> <init>
    89:90:void <clinit>() -> <clinit>
neureka.devices.opencl.OpenCLDevice$cl_ad_hoc -> neureka.devices.opencl.OpenCLDevice$a:
    java.lang.String source -> a
    org.jocl.cl_kernel kernel -> b
    162:166:void <init>(java.lang.String,org.jocl.cl_kernel,org.jocl.cl_program) -> <init>
neureka.devices.opencl.OpenCLDevice$cl_tsr -> neureka.devices.opencl.OpenCLDevice$cl_tsr:
    int fp -> a
    neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config config -> b
    neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_value value -> c
    107:134:void <init>() -> <init>
    141:142:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config -> neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_config:
    org.jocl.cl_mem data -> data
    130:130:void <init>() -> <init>
neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_value -> neureka.devices.opencl.OpenCLDevice$cl_tsr$cl_value:
    int size -> size
    org.jocl.cl_mem data -> data
    org.jocl.cl_event event -> event
    117:118:void <init>() -> <init>
neureka.devices.opencl.OpenCLPlatform -> neureka.devices.opencl.OpenCLPlatform:
    org.slf4j.Logger _LOG -> a
    org.jocl.cl_platform_id _pid -> b
    org.jocl.cl_context _context -> c
    java.util.Map _id_device -> d
    java.util.Map _kernels -> e
    26:73:void <init>(org.jocl.cl_platform_id) -> <init>
    76:80:void recompile() -> recompile
    94:203:void _compile(org.jocl.cl_device_id[]) -> a
    206:208:java.util.List getDevices() -> getDevices
    215:215:boolean has(org.jocl.cl_device_id) -> has
    218:218:neureka.devices.opencl.OpenCLDevice get(org.jocl.cl_device_id) -> get
    222:223:void put(org.jocl.cl_device_id,neureka.devices.opencl.OpenCLDevice) -> put
    226:226:org.jocl.cl_kernel getKernel(java.lang.String) -> getKernel
    230:230:boolean hasKernel(java.lang.String) -> hasKernel
    234:234:org.jocl.cl_platform_id getPid() -> getPid
    238:238:org.jocl.cl_context getContext() -> getContext
    242:243:void dispose() -> dispose
    247:250:java.lang.String toString() -> toString
    207:207:void lambda$getDevices$1(java.util.List,org.jocl.cl_device_id,neureka.devices.opencl.OpenCLDevice) -> a
    155:157:void lambda$_compile$0(java.util.ArrayList,java.util.ArrayList,java.lang.String,java.lang.String) -> a
    20:20:void <clinit>() -> <clinit>
neureka.devices.opencl.StaticKernelSource -> neureka.devices.opencl.StaticKernelSource:
    7:7:neureka.devices.opencl.KernelCode getKernelCode() -> getKernelCode
neureka.devices.opencl.utility.CLFunctionCompiler -> neureka.devices.opencl.utility.CLFunctionCompiler:
    neureka.devices.opencl.OpenCLDevice _device -> a
    neureka.calculus.Function _functionToBeOptimized -> b
    java.lang.String _functionName -> c
    int[] _argPointer -> d
    34:44:void <init>(neureka.devices.opencl.OpenCLDevice,neureka.calculus.Function,java.lang.String) -> <init>
    48:100:neureka.backend.api.Operation optimize() -> optimize
    107:203:void _adHocKernelFor(neureka.backend.api.ExecutionCall) -> a
    1227:1239:java.lang.String _readAndGetIndexMapper():227:239 -> a
    1227:1239:void _adHocKernelFor(neureka.backend.api.ExecutionCall):176 -> a
    206:217:java.lang.String _clTypeOf(neureka.Tsr) -> a
    207:209:java.lang.String lambda$_clTypeOf$19(java.lang.Class) -> a
    192:192:java.lang.String lambda$_adHocKernelFor$18(java.util.List,int,int) -> a
    184:184:java.lang.String lambda$_adHocKernelFor$17(java.util.List,int) -> a
    168:170:java.lang.String lambda$_adHocKernelFor$16(java.lang.String,java.lang.String) -> a
    156:156:java.lang.String lambda$_adHocKernelFor$15(java.util.List,int) -> b
    149:151:java.util.List lambda$_adHocKernelFor$14(int[]) -> a
    146:146:int[] lambda$_adHocKernelFor$13(neureka.Tsr) -> b
    122:130:java.lang.String lambda$_adHocKernelFor$12(neureka.Tsr) -> c
    108:108:neureka.Tsr lambda$_adHocKernelFor$11(neureka.backend.api.ExecutionCall,int) -> a
    86:93:neureka.backend.api.ExecutionCall lambda$optimize$10(neureka.backend.api.ExecutionCall) -> b
    78:80:neureka.autograd.ADAgent lambda$optimize$9(neureka.calculus.Function,neureka.backend.api.ExecutionCall,boolean) -> a
    80:80:neureka.Tsr lambda$optimize$8(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    79:79:neureka.Tsr lambda$optimize$7(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    74:74:boolean lambda$optimize$6(neureka.backend.api.ExecutionCall) -> c
    73:73:boolean lambda$optimize$5(neureka.backend.api.ExecutionCall) -> d
    72:72:float lambda$optimize$4(neureka.backend.api.ExecutionCall) -> e
    62:66:java.lang.String lambda$optimize$3(java.lang.String[]) -> a
    49:49:boolean lambda$optimize$2(neureka.calculus.Function) -> a
    41:41:int lambda$new$1(neureka.calculus.Function) -> b
    40:40:boolean lambda$new$0(neureka.calculus.Function) -> c
neureka.devices.opencl.utility.DeviceQuery -> neureka.devices.opencl.utility.DeviceQuery:
    22:22:void <init>() -> <init>
    31:190:java.lang.String query() -> query
    1278:1286:java.lang.String getString(org.jocl.cl_platform_id,int):278:286 -> query
    1278:1286:java.lang.String query():46 -> query
    202:202:int getInt(org.jocl.cl_device_id,int) -> a
    215:217:int[] getInts(org.jocl.cl_device_id,int,int) -> a
    229:229:long getLong(org.jocl.cl_device_id,int) -> b
    242:244:long[] getLongs(org.jocl.cl_device_id,int,int) -> b
    257:265:java.lang.String getString(org.jocl.cl_device_id,int) -> c
    298:298:long getSize(org.jocl.cl_device_id,int) -> d
    313:332:long[] getSizes(org.jocl.cl_device_id,int,int) -> c
neureka.devices.opencl.utility.DispatchUtility -> neureka.devices.opencl.utility.DispatchUtility:
    boolean $assertionsDisabled -> a
    9:9:void <init>() -> <init>
    12:18:void _revert(int[]) -> a
    21:23:int _productOf(int[]) -> b
    28:154:int[] parseTile(int,int[]) -> parseTile
    1184:1205:int[] _primeFactors(int):184:205 -> parseTile
    1184:1205:int[] parseTile(int,int[]):35 -> parseTile
    2164:2167:int _productOfNewDimension(int[],int,int,int):164:167 -> parseTile
    2164:2167:int[] parseTile(int,int[]):114 -> parseTile
    2176:2179:int _inversionProductOfNewDimension(int[],int[],int,int):176:179 -> parseTile
    2176:2179:int[] parseTile(int,int[]):139 -> parseTile
    219:229:int[] findBestParams(int,int,int,int,int) -> findBestParams
    235:242:int[] bestMatMulMatch(int,int,int,int) -> bestMatMulMatch
    205:205:int lambda$_primeFactors$0(java.lang.Integer) -> a
    7:7:void <clinit>() -> <clinit>
neureka.devices.opencl.utility.Messages -> neureka.devices.opencl.utility.Messages:
    15:15:void <init>() -> <init>
    18:22:java.lang.String clContextCreationFailed() -> clContextCreationFailed
    27:30:java.lang.String clContextCouldNotFindAnyDevices() -> clContextCouldNotFindAnyDevices
    36:70:neureka.devices.opencl.utility.Messages$Tips findTip() -> findTip
neureka.devices.opencl.utility.Messages$Tips -> neureka.devices.opencl.utility.Messages$Tips:
    neureka.devices.opencl.utility.Messages$Tips UBUNTU -> UBUNTU
    neureka.devices.opencl.utility.Messages$Tips FEDORA -> FEDORA
    neureka.devices.opencl.utility.Messages$Tips WINDOWS -> WINDOWS
    neureka.devices.opencl.utility.Messages$Tips UNKNOWN -> UNKNOWN
    java.lang.String HOW_TO_INSTALL_OPENCL -> HOW_TO_INSTALL_OPENCL
    java.lang.String HOW_TO_INSTALL_OPENCL_DRIVERS -> a
    neureka.devices.opencl.utility.Messages$Tips[] $VALUES -> b
    73:73:neureka.devices.opencl.utility.Messages$Tips[] values() -> values
    73:73:neureka.devices.opencl.utility.Messages$Tips valueOf(java.lang.String) -> valueOf
    94:97:void <init>(java.lang.String,int,java.lang.String,java.lang.String) -> <init>
    100:102:java.lang.String bootstrapTip() -> bootstrapTip
    73:73:java.lang.String access$000(neureka.devices.opencl.utility.Messages$Tips) -> a
    73:86:void <clinit>() -> <clinit>
neureka.devices.opencl.utility.WeakTensorReference -> neureka.devices.opencl.utility.WeakTensorReference:
    int _hash -> a
    24:26:void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    29:29:int hashCode() -> hashCode
    33:37:boolean equals(java.lang.Object) -> equals
neureka.dtype.AbstractNumericType -> neureka.dtype.AbstractNumericType:
    java.util.Map _NUMERIC_TYPE_RELATIONS -> a
    21:21:void <init>() -> <init>
    45:45:java.lang.Class getNumericTypeTarget() -> getNumericTypeTarget
    51:55:void writeDataTo(java.io.DataOutput,java.util.Iterator) -> writeDataTo
    31:41:void <clinit>() -> <clinit>
neureka.dtype.DataType -> neureka.dtype.DataType:
    java.util.Map _instances -> a
    org.slf4j.Logger _log -> b
    java.lang.Class _typeClass -> c
    92:99:neureka.dtype.DataType of(java.lang.Class) -> of
    1075:1087:java.lang.Class _numericTypeRepresentationOf(java.lang.Class):75:87 -> of
    1075:1087:neureka.dtype.DataType of(java.lang.Class):92 -> of
    106:111:void <init>(java.lang.Class) -> <init>
    118:133:java.lang.Object getTypeClassInstance() -> getTypeClassInstance
    141:141:boolean typeClassImplements(java.lang.Class) -> typeClassImplements
    145:149:java.lang.Class dataArrayType() -> dataArrayType
    155:170:java.lang.Object virtualize(java.lang.Object) -> virtualize
    176:213:java.lang.Object actualize(java.lang.Object,int) -> actualize
    218:235:java.lang.Object allocate(int) -> allocate
    240:240:org.slf4j.Logger getLog() -> getLog
    244:254:boolean equals(java.lang.Object) -> equals
    258:264:int hashCode() -> hashCode
    268:268:java.lang.String toString() -> toString
    272:272:java.lang.Class getTypeClass() -> getTypeClass
    276:279:java.lang.Class getJVMTypeClass() -> getJVMTypeClass
    60:60:void <clinit>() -> <clinit>
neureka.dtype.DataType$1 -> neureka.dtype.DataType$1:
    60:60:void <init>() -> <init>
    63:63:boolean removeEldestEntry(java.util.Map$Entry) -> removeEldestEntry
neureka.dtype.NumericType -> neureka.dtype.NumericType:
    boolean signed() -> signed
    int numberOfBytes() -> numberOfBytes
    java.lang.Class targetType() -> targetType
    java.lang.Class targetArrayType() -> targetArrayType
    java.lang.Class holderType() -> holderType
    java.lang.Class holderArrayType() -> holderArrayType
    java.lang.Class getNumericTypeTarget() -> getNumericTypeTarget
    java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    java.lang.Object toTarget(java.lang.Object) -> toTarget
    byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    void writeDataTo(java.io.DataOutput,java.util.Iterator) -> writeDataTo
    java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
neureka.dtype.custom.F32 -> neureka.dtype.custom.F32:
    14:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:49:java.lang.Float foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    54:54:java.lang.Float toTarget(java.lang.Float) -> toTarget
    59:60:byte[] targetToForeignHolderBytes(java.lang.Float) -> targetToForeignHolderBytes
    70:70:float[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    75:77:float[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    83:83:float[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    88:88:float[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    94:107:java.lang.Float convertToHolder(java.lang.Object) -> convertToHolder
    112:112:float[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    117:117:java.lang.Float convertToTarget(java.lang.Object) -> convertToTarget
    122:122:float[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.F64 -> neureka.dtype.custom.F64:
    15:16:void <init>() -> <init>
    20:20:boolean signed() -> signed
    25:25:int numberOfBytes() -> numberOfBytes
    30:30:java.lang.Class targetType() -> targetType
    35:35:java.lang.Class targetArrayType() -> targetArrayType
    40:40:java.lang.Class holderType() -> holderType
    45:45:java.lang.Class holderArrayType() -> holderArrayType
    50:50:java.lang.Double foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    55:55:java.lang.Double toTarget(java.lang.Double) -> toTarget
    60:61:byte[] targetToForeignHolderBytes(java.lang.Double) -> targetToForeignHolderBytes
    75:75:double[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    80:82:double[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    87:87:double[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    92:94:double[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    99:112:java.lang.Double convertToHolder(java.lang.Object) -> convertToHolder
    117:117:double[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    122:122:java.lang.Double convertToTarget(java.lang.Object) -> convertToTarget
    127:127:double[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    131:137:double[] _readFrom(java.io.DataInput,int) -> a
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I16 -> neureka.dtype.custom.I16:
    java.nio.ByteBuffer buffer -> a
    13:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:51:java.lang.Short foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    56:56:java.lang.Short toTarget(java.lang.Short) -> toTarget
    61:62:byte[] targetToForeignHolderBytes(java.lang.Short) -> targetToForeignHolderBytes
    67:67:short[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    72:72:short[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    77:77:short[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    82:82:short[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    87:100:java.lang.Short convertToHolder(java.lang.Object) -> convertToHolder
    105:105:short[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    110:110:java.lang.Short convertToTarget(java.lang.Object) -> convertToTarget
    115:115:short[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    119:125:short[] _readData(java.io.DataInput,int) -> a
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I32 -> neureka.dtype.custom.I32:
    15:16:void <init>() -> <init>
    20:20:boolean signed() -> signed
    25:25:int numberOfBytes() -> numberOfBytes
    30:30:java.lang.Class targetType() -> targetType
    35:35:java.lang.Class targetArrayType() -> targetArrayType
    40:40:java.lang.Class holderType() -> holderType
    45:45:java.lang.Class holderArrayType() -> holderArrayType
    50:50:java.lang.Integer foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    56:56:java.lang.Integer toTarget(java.lang.Integer) -> toTarget
    61:65:byte[] targetToForeignHolderBytes(java.lang.Integer) -> targetToForeignHolderBytes
    71:71:int[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    76:76:int[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    81:81:int[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    86:86:int[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    91:104:java.lang.Integer convertToHolder(java.lang.Object) -> convertToHolder
    109:109:int[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    114:114:java.lang.Integer convertToTarget(java.lang.Object) -> convertToTarget
    119:119:int[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    123:129:int[] _readData(java.io.DataInput,int) -> a
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I64 -> neureka.dtype.custom.I64:
    java.nio.ByteBuffer buffer -> a
    13:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:51:java.lang.Long foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    57:57:java.lang.Long toTarget(java.lang.Long) -> toTarget
    62:63:byte[] targetToForeignHolderBytes(java.lang.Long) -> targetToForeignHolderBytes
    68:68:long[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    73:73:long[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    78:78:long[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    83:83:long[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    88:101:java.lang.Long convertToHolder(java.lang.Object) -> convertToHolder
    106:106:long[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    111:111:java.lang.Long convertToTarget(java.lang.Object) -> convertToTarget
    116:116:long[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.I8 -> neureka.dtype.custom.I8:
    18:19:void <init>() -> <init>
    23:23:boolean signed() -> signed
    28:28:int numberOfBytes() -> numberOfBytes
    33:33:java.lang.Class targetType() -> targetType
    38:38:java.lang.Class targetArrayType() -> targetArrayType
    43:43:java.lang.Class holderType() -> holderType
    48:48:java.lang.Class holderArrayType() -> holderArrayType
    53:53:java.lang.Byte foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    58:58:java.lang.Byte toTarget(java.lang.Byte) -> toTarget
    63:63:byte[] targetToForeignHolderBytes(java.lang.Byte) -> targetToForeignHolderBytes
    68:70:byte[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    75:75:byte[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    80:82:byte[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    87:87:byte[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    92:105:java.lang.Byte convertToHolder(java.lang.Object) -> convertToHolder
    110:110:byte[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    115:115:java.lang.Byte convertToTarget(java.lang.Object) -> convertToTarget
    120:120:byte[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    15:15:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    15:15:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    15:15:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    15:15:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    15:15:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    15:15:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    15:15:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    15:15:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    15:15:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    15:15:java.lang.Object toTarget(java.lang.Object) -> toTarget
    15:15:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI16 -> neureka.dtype.custom.UI16:
    15:16:void <init>() -> <init>
    20:20:boolean signed() -> signed
    25:25:int numberOfBytes() -> numberOfBytes
    30:30:java.lang.Class targetType() -> targetType
    35:35:java.lang.Class targetArrayType() -> targetArrayType
    40:40:java.lang.Class holderType() -> holderType
    45:45:java.lang.Class holderArrayType() -> holderArrayType
    50:51:java.lang.Integer foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    59:59:java.lang.Integer toTarget(java.lang.Short) -> toTarget
    64:66:byte[] targetToForeignHolderBytes(java.lang.Integer) -> targetToForeignHolderBytes
    71:77:int[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    82:82:int[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    87:87:short[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    92:92:short[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    97:97:java.lang.Short convertToHolder(java.lang.Object) -> convertToHolder
    102:102:short[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    107:107:java.lang.Integer convertToTarget(java.lang.Object) -> convertToTarget
    112:112:int[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI32 -> neureka.dtype.custom.UI32:
    11:11:void <init>() -> <init>
    16:16:boolean signed() -> signed
    21:21:int numberOfBytes() -> numberOfBytes
    26:26:java.lang.Class targetType() -> targetType
    31:31:java.lang.Class targetArrayType() -> targetArrayType
    36:36:java.lang.Class holderType() -> holderType
    41:41:java.lang.Class holderArrayType() -> holderArrayType
    46:47:java.lang.Long foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    55:55:java.lang.Long toTarget(java.lang.Integer) -> toTarget
    60:63:byte[] targetToForeignHolderBytes(java.lang.Long) -> targetToForeignHolderBytes
    68:68:long[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    73:73:long[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    78:78:int[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    83:83:int[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    88:88:java.lang.Integer convertToHolder(java.lang.Object) -> convertToHolder
    93:93:int[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    98:98:java.lang.Long convertToTarget(java.lang.Object) -> convertToTarget
    103:103:long[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI64 -> neureka.dtype.custom.UI64:
    14:14:void <init>() -> <init>
    18:18:boolean signed() -> signed
    23:23:int numberOfBytes() -> numberOfBytes
    28:28:java.lang.Class targetType() -> targetType
    33:33:java.lang.Class targetArrayType() -> targetArrayType
    38:38:java.lang.Class holderType() -> holderType
    43:43:java.lang.Class holderArrayType() -> holderArrayType
    49:52:java.math.BigInteger foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    57:57:java.math.BigInteger toTarget(java.lang.Long) -> toTarget
    62:69:byte[] targetToForeignHolderBytes(java.math.BigInteger) -> targetToForeignHolderBytes
    74:74:java.math.BigInteger[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    79:79:java.math.BigInteger[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    84:84:long[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    89:89:long[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    94:94:java.lang.Long convertToHolder(java.lang.Object) -> convertToHolder
    99:99:long[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    104:104:java.math.BigInteger convertToTarget(java.lang.Object) -> convertToTarget
    109:109:java.math.BigInteger[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    11:11:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    11:11:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    11:11:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    11:11:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    11:11:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    11:11:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    11:11:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    11:11:java.lang.Object toTarget(java.lang.Object) -> toTarget
    11:11:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.dtype.custom.UI8 -> neureka.dtype.custom.UI8:
    14:15:void <init>() -> <init>
    19:19:boolean signed() -> signed
    24:24:int numberOfBytes() -> numberOfBytes
    29:29:java.lang.Class targetType() -> targetType
    34:34:java.lang.Class targetArrayType() -> targetArrayType
    39:39:java.lang.Class holderType() -> holderType
    44:44:java.lang.Class holderArrayType() -> holderArrayType
    49:49:java.lang.Short foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
    55:55:java.lang.Short toTarget(java.lang.Byte) -> toTarget
    61:61:byte[] targetToForeignHolderBytes(java.lang.Short) -> targetToForeignHolderBytes
    66:72:short[] readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    77:77:short[] readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    82:88:byte[] readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    93:93:byte[] readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    98:98:java.lang.Byte convertToHolder(java.lang.Object) -> convertToHolder
    103:103:byte[] convertToHolderArray(java.lang.Object) -> convertToHolderArray
    108:121:java.lang.Short convertToTarget(java.lang.Object) -> convertToTarget
    126:126:short[] convertToTargetArray(java.lang.Object) -> convertToTargetArray
    10:10:java.lang.Object convertToTargetArray(java.lang.Object) -> convertToTargetArray
    10:10:java.lang.Object convertToTarget(java.lang.Object) -> convertToTarget
    10:10:java.lang.Object convertToHolderArray(java.lang.Object) -> convertToHolderArray
    10:10:java.lang.Object convertToHolder(java.lang.Object) -> convertToHolder
    10:10:java.lang.Object readForeignDataFrom(java.util.Iterator,int) -> readForeignDataFrom
    10:10:java.lang.Object readForeignDataFrom(java.io.DataInput,int) -> readForeignDataFrom
    10:10:java.lang.Object readAndConvertForeignDataFrom(java.util.Iterator,int) -> readAndConvertForeignDataFrom
    10:10:java.lang.Object readAndConvertForeignDataFrom(java.io.DataInput,int) -> readAndConvertForeignDataFrom
    10:10:byte[] targetToForeignHolderBytes(java.lang.Object) -> targetToForeignHolderBytes
    10:10:java.lang.Object toTarget(java.lang.Object) -> toTarget
    10:10:java.lang.Object foreignHolderBytesToTarget(byte[]) -> foreignHolderBytesToTarget
neureka.fluent.building.TensorBuilder -> neureka.fluent.building.TensorBuilder:
    org.slf4j.Logger _LOG -> a
    neureka.dtype.DataType _dataType -> b
    int[] _shape -> c
    java.lang.Object _from -> d
    java.lang.Object _to -> e
    neureka.devices.Device _device -> f
    71:78:void <init>(java.lang.Class) -> <init>
    81:81:neureka.Tsr _get(java.lang.Object) -> a
    96:96:neureka.Tsr andFill(java.lang.Object[]) -> andFill
    107:107:neureka.Tsr andWhere(neureka.ndim.Filler) -> andWhere
    1086:1086:neureka.Tsr _get(neureka.ndim.Filler):86:86 -> andWhere
    1086:1086:neureka.Tsr andWhere(neureka.ndim.Filler):107 -> andWhere
    110:110:neureka.fluent.building.states.To iterativelyFilledFrom(java.lang.Object) -> iterativelyFilledFrom
    113:113:neureka.Tsr all(java.lang.Object) -> all
    117:133:neureka.Tsr andSeed(java.lang.Object) -> andSeed
    139:144:neureka.fluent.building.states.IterByOrIterFromOrAll withShape(int[]) -> withShape
    149:150:neureka.Tsr vector(java.lang.Object[]) -> vector
    155:161:neureka.Tsr scalar(java.lang.Object) -> scalar
    172:184:java.lang.Object _checked(java.lang.Object) -> b
    188:188:neureka.fluent.building.states.Step to(java.lang.Object) -> to
    192:258:neureka.Tsr step(double) -> step
    262:264:int _size() -> a
    269:270:neureka.fluent.building.states.WithShapeOrScalarOrVector on(neureka.devices.Device) -> on
    226:226:long lambda$step$5(java.util.List,int) -> a
    224:224:int lambda$step$4(int) -> a
    215:215:double lambda$step$3(java.util.List,int) -> b
    213:213:int lambda$step$2(int) -> b
    204:204:int lambda$step$1(java.util.List,int) -> c
    202:202:int lambda$step$0(int) -> c
    65:65:void <clinit>() -> <clinit>
neureka.fluent.building.states.IterByOrIterFromOrAll -> neureka.fluent.building.states.IterByOrIterFromOrAll:
    neureka.Tsr andFill(java.lang.Object[]) -> andFill
    34:34:neureka.Tsr andFill(java.util.List) -> andFill
    neureka.Tsr andWhere(neureka.ndim.Filler) -> andWhere
    neureka.fluent.building.states.To iterativelyFilledFrom(java.lang.Object) -> iterativelyFilledFrom
    neureka.Tsr all(java.lang.Object) -> all
    neureka.Tsr andSeed(java.lang.Object) -> andSeed
neureka.fluent.building.states.Step -> neureka.fluent.building.states.Step:
    neureka.Tsr step(double) -> step
neureka.fluent.building.states.To -> neureka.fluent.building.states.To:
    neureka.fluent.building.states.Step to(java.lang.Object) -> to
neureka.fluent.building.states.WithShapeOrScalarOrVector -> neureka.fluent.building.states.WithShapeOrScalarOrVector:
    neureka.fluent.building.states.IterByOrIterFromOrAll withShape(int[]) -> withShape
    neureka.Tsr vector(java.lang.Object[]) -> vector
    neureka.Tsr scalar(java.lang.Object) -> scalar
neureka.fluent.building.states.WithShapeOrScalarOrVectorOnDevice -> neureka.fluent.building.states.WithShapeOrScalarOrVectorOnDevice:
    neureka.fluent.building.states.WithShapeOrScalarOrVector on(neureka.devices.Device) -> on
neureka.fluent.slicing.AxisSliceBuilder -> neureka.fluent.slicing.AxisSliceBuilder:
    neureka.fluent.slicing.AxisSliceBuilder$Resolution _then -> a
    int _from -> b
    int _to -> c
    int _steps -> d
    20:25:void <init>(int,neureka.fluent.slicing.AxisSliceBuilder$Resolution) -> <init>
    38:39:neureka.fluent.slicing.states.To from(int) -> from
    53:54:neureka.fluent.slicing.states.StepsOrAxisOrGet to(int) -> to
    68:69:neureka.fluent.slicing.states.AxisOrGet step(int) -> step
    83:85:neureka.fluent.slicing.states.AxisOrGet at(int) -> at
    94:94:neureka.fluent.slicing.states.FromOrAt axis(int) -> axis
    99:99:neureka.Tsr get() -> get
    104:105:void resolve() -> resolve
neureka.fluent.slicing.AxisSliceBuilder$Resolution -> neureka.fluent.slicing.AxisSliceBuilder$a:
    neureka.fluent.slicing.SliceBuilder resolve(int,int,int) -> resolve
neureka.fluent.slicing.SliceBuilder -> neureka.fluent.slicing.SliceBuilder:
    java.util.function.Supplier _create -> a
    neureka.fluent.slicing.AxisSliceBuilder[] _axisSliceBuilders -> b
    39:72:void <init>(neureka.Tsr,neureka.fluent.slicing.SliceBuilder$CreationCallback) -> <init>
    84:85:neureka.fluent.slicing.states.FromOrAt axis(int) -> axis
    97:97:neureka.Tsr get() -> get
    67:70:neureka.Tsr lambda$new$1(neureka.fluent.slicing.SliceBuilder$CreationCallback,int[],int[],int[]) -> a
    50:63:neureka.fluent.slicing.SliceBuilder lambda$new$0(int[],int,int[],int[],int[],int,int,int) -> a
neureka.fluent.slicing.SliceBuilder$CreationCallback -> neureka.fluent.slicing.SliceBuilder$CreationCallback:
    neureka.Tsr sliceOf(int[],int[],int[]) -> sliceOf
neureka.fluent.slicing.SmartSlicer -> neureka.fluent.slicing.SmartSlicer:
    org.slf4j.Logger _LOG -> a
    17:17:void <init>() -> <init>
    29:137:neureka.Tsr slice(java.lang.Object[],neureka.Tsr,neureka.fluent.slicing.SliceBuilder$CreationCallback) -> slice
    22:22:void <clinit>() -> <clinit>
neureka.fluent.slicing.states.AxisOrGet -> neureka.fluent.slicing.states.AxisOrGet:
    neureka.fluent.slicing.states.FromOrAt axis(int) -> axis
    neureka.Tsr get() -> get
neureka.fluent.slicing.states.FromOrAt -> neureka.fluent.slicing.states.FromOrAt:
    neureka.fluent.slicing.states.To from(int) -> from
    neureka.fluent.slicing.states.AxisOrGet at(int) -> at
neureka.fluent.slicing.states.StepsOrAxisOrGet -> neureka.fluent.slicing.states.StepsOrAxisOrGet:
    neureka.fluent.slicing.states.AxisOrGet step(int) -> step
neureka.fluent.slicing.states.To -> neureka.fluent.slicing.states.To:
    neureka.fluent.slicing.states.StepsOrAxisOrGet to(int) -> to
neureka.framing.NDFrame -> neureka.framing.NDFrame:
    java.util.List _hiddenKeys -> a
    java.util.Map _mapping -> b
    java.lang.String _tensorName -> c
    35:60:void <init>(java.util.List,java.lang.String) -> <init>
    35:66:void <init>(int,java.lang.String) -> <init>
    35:87:void <init>(java.util.Map,neureka.Tsr,java.lang.String) -> <init>
    90:90:int[] get(java.util.List) -> get
    94:103:int[] get(java.lang.Object[]) -> get
    118:164:neureka.framing.fluent.AxisFrame atAxis(java.lang.Object) -> atAxis
    168:180:java.util.Map _initializeIdxmap(java.lang.Object,java.lang.Object,int) -> a
    191:203:java.lang.String _paddedCentered(java.lang.String,int) -> a
    210:270:java.lang.String toString() -> toString
    276:278:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    282:282:java.util.Map getMapping() -> getMapping
    286:286:java.lang.String getTensorName() -> getTensorName
    240:256:void lambda$toString$14(java.lang.Object[],int[],java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    244:245:void lambda$toString$13(int[],java.lang.Object[],java.lang.Object,java.lang.Integer) -> a
    223:229:void lambda$toString$12(java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    218:218:java.lang.Boolean lambda$toString$11(int,int,java.lang.Integer) -> a
    157:161:java.util.List lambda$atAxis$10(java.lang.Object,java.lang.Integer) -> a
    159:159:void lambda$atAxis$9(java.lang.Integer,java.util.List,java.lang.Object,java.lang.Integer) -> a
    147:152:java.util.List lambda$atAxis$8(java.lang.Object) -> a
    150:150:void lambda$atAxis$7(java.util.List,java.lang.Object,java.lang.Integer) -> a
    138:138:neureka.framing.fluent.With lambda$atAxis$6(java.lang.Object,java.lang.Object) -> a
    139:142:neureka.framing.NDFrame lambda$atAxis$5(java.lang.Object,java.lang.Object,java.lang.Object) -> a
    130:130:neureka.framing.fluent.AxisFrame$Set lambda$atAxis$4(java.lang.Object,java.lang.Object) -> b
    132:134:neureka.framing.NDFrame lambda$atAxis$3(java.lang.Object,java.lang.Object,int) -> b
    120:120:neureka.framing.fluent.Get lambda$atAxis$2(java.lang.Object,java.lang.Object) -> c
    122:126:java.lang.Integer lambda$atAxis$1(java.lang.Object,java.lang.Object) -> d
    73:86:void lambda$new$0(int[],neureka.Tsr,java.lang.Object,java.util.List) -> a
neureka.framing.Relation -> neureka.framing.Relation:
    neureka.Tsr _parent -> a
    java.lang.ref.WeakReference[] _children -> b
    int[][] _shapeRelations -> c
    59:59:void <init>() -> <init>
    99:123:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    129:130:neureka.framing.Relation addParent(neureka.Tsr) -> addParent
    136:149:neureka.framing.Relation addChild(neureka.Tsr) -> addChild
    172:178:neureka.framing.Relation addReshapeRelationFor(neureka.Tsr,int[]) -> addReshapeRelationFor
    201:207:int[] getReshapeRelationFor(neureka.Tsr) -> getReshapeRelationFor
    212:222:neureka.framing.Relation foreachChild(java.util.function.Consumer) -> foreachChild
    234:237:neureka.Tsr findRootTensor() -> findRootTensor
    242:242:boolean hasParent() -> hasParent
    247:247:boolean hasChildren() -> hasChildren
    252:252:int childCount() -> childCount
    257:257:neureka.framing.Relation remove(neureka.Tsr) -> remove
    261:261:java.lang.String toString() -> toString
    265:265:neureka.Tsr getParent() -> getParent
neureka.framing.fluent.At -> neureka.framing.fluent.At:
    java.lang.Object at(java.lang.Object) -> at
neureka.framing.fluent.AxisFrame -> neureka.framing.fluent.AxisFrame:
    neureka.framing.fluent.At _keyBasedGetter -> a
    neureka.framing.fluent.At _keyBasedSetter -> b
    neureka.framing.fluent.Replace _replace -> c
    java.util.function.Supplier _allAliasGetter -> d
    java.util.function.Function _allAliasGetterForIndex -> e
    36:42:void <init>(neureka.framing.fluent.At,neureka.framing.fluent.At,neureka.framing.fluent.Replace,java.util.function.Supplier,java.util.function.Function) -> <init>
    45:45:neureka.framing.fluent.AxisFrame$Builder builder() -> builder
    49:49:java.lang.Object getIndexAtAlias(java.lang.Object) -> getIndexAtAlias
    53:53:neureka.framing.fluent.AxisFrame$Set atIndexAlias(java.lang.Object) -> atIndexAlias
    57:57:neureka.framing.fluent.With replace(java.lang.Object) -> replace
    61:61:java.util.List getAllAliases() -> getAllAliases
    65:65:java.util.List getAllAliasesForIndex(int) -> getAllAliasesForIndex
    16:16:void <init>(neureka.framing.fluent.At,neureka.framing.fluent.At,neureka.framing.fluent.Replace,java.util.function.Supplier,java.util.function.Function,byte) -> <init>
neureka.framing.fluent.AxisFrame$Builder -> neureka.framing.fluent.AxisFrame$Builder:
    neureka.framing.fluent.At keyBasedGetter -> a
    neureka.framing.fluent.At keyBasedSetter -> b
    neureka.framing.fluent.Replace replacer -> c
    java.util.function.Supplier allAliasGetter -> d
    java.util.function.Function allAliasGetterForIndex -> e
    76:76:void <init>() -> <init>
    79:80:neureka.framing.fluent.AxisFrame$Builder getter(neureka.framing.fluent.At) -> getter
    84:85:neureka.framing.fluent.AxisFrame$Builder setter(neureka.framing.fluent.At) -> setter
    89:90:neureka.framing.fluent.AxisFrame$Builder replacer(neureka.framing.fluent.Replace) -> replacer
    94:95:neureka.framing.fluent.AxisFrame$Builder allAliasGetter(java.util.function.Supplier) -> allAliasGetter
    99:100:neureka.framing.fluent.AxisFrame$Builder allAliasGetterFor(java.util.function.Function) -> allAliasGetterFor
    104:104:neureka.framing.fluent.AxisFrame build() -> build
neureka.framing.fluent.AxisFrame$Set -> neureka.framing.fluent.AxisFrame$Set:
    neureka.framing.NDFrame setIndex(int) -> setIndex
neureka.framing.fluent.Get -> neureka.framing.fluent.Get:
    java.lang.Object get() -> get
neureka.framing.fluent.Replace -> neureka.framing.fluent.Replace:
    neureka.framing.fluent.With replace(java.lang.Object) -> replace
neureka.framing.fluent.Set -> neureka.framing.fluent.Set:
    neureka.framing.NDFrame set(int) -> set
neureka.framing.fluent.With -> neureka.framing.fluent.With:
    java.lang.Object with(java.lang.Object) -> with
neureka.ndim.AbstractTensor -> neureka.ndim.AbstractTensor:
    org.slf4j.Logger _LOG -> _LOG
    neureka.ndim.config.NDConfiguration _NDConf -> a
    neureka.dtype.DataType _dataType -> b
    java.lang.Object _data -> c
    boolean $assertionsDisabled -> d
    70:86:void <init>() -> <init>
    boolean isDeleted() -> isDeleted
    97:97:void _guardGet(java.lang.String) -> _guardGet
    98:98:void _guardSet(java.lang.String) -> _guardSet
    99:99:void _guardMod(java.lang.String) -> _guardMod
    109:113:void _guard(java.lang.String) -> a
    119:119:neureka.ndim.config.NDConfiguration getNDConf() -> getNDConf
    128:128:neureka.dtype.DataType getDataType() -> getDataType
    137:137:java.lang.Object getData() -> getData
    144:144:java.lang.Class getValueClass() -> getValueClass
    162:162:java.lang.Class getRepresentativeValueClass() -> getRepresentativeValueClass
    177:184:java.lang.Object _setDataType(neureka.dtype.DataType) -> _setDataType
    193:209:void _setData(java.lang.Object) -> _setData
    213:260:void _initData(neureka.ndim.Filler) -> _initData
    272:272:void _allocate(int) -> _allocate
    java.lang.Object setIsVirtual(boolean) -> setIsVirtual
    boolean isVirtual() -> isVirtual
    void _setIsVirtual(boolean) -> _setIsVirtual
    317:318:neureka.ndim.TsrConstructor createConstructionAPI() -> createConstructionAPI
    339:339:void _virtualize() -> _virtualize
    351:351:void _actualize() -> _actualize
    355:365:java.lang.Object _convertedDataOfType(java.lang.Class) -> _convertedDataOfType
    377:378:boolean is(java.lang.Class) -> is
    392:402:java.lang.Object _setNDConf(neureka.ndim.config.NDConfiguration) -> _setNDConf
    neureka.ndim.AbstractTensor$Unsafe getUnsafe() -> getUnsafe
    395:395:int lambda$_setNDConf$10(int,int) -> a
    394:394:int lambda$_setNDConf$9(int,int) -> b
    257:259:void lambda$_initData$8(java.lang.Object,neureka.ndim.Filler,int,int) -> a
    252:254:void lambda$_initData$7(java.lang.Object,neureka.ndim.Filler,int,int) -> b
    247:249:void lambda$_initData$6(java.lang.Object,neureka.ndim.Filler,int,int) -> c
    242:244:void lambda$_initData$5(java.lang.Object,neureka.ndim.Filler,int,int) -> d
    237:239:void lambda$_initData$4(java.lang.Object,neureka.ndim.Filler,int,int) -> e
    232:234:void lambda$_initData$3(java.lang.Object,neureka.ndim.Filler,int,int) -> f
    227:229:void lambda$_initData$2(java.lang.Object,neureka.ndim.Filler,int,int) -> g
    222:224:void lambda$_initData$1(java.lang.Object,neureka.ndim.Filler,int,int) -> h
    217:219:void lambda$_initData$0(java.lang.Object,neureka.ndim.Filler,int,int) -> i
    70:70:void <clinit>() -> <clinit>
neureka.ndim.AbstractTensor$1 -> neureka.ndim.AbstractTensor$1:
    neureka.ndim.AbstractTensor val$nda -> a
    319:319:void <init>(neureka.ndim.AbstractTensor,neureka.ndim.AbstractTensor) -> <init>
    320:320:void setType(neureka.dtype.DataType) -> setType
    321:321:void setConf(neureka.ndim.config.NDConfiguration) -> setConf
    322:322:void setData(java.lang.Object) -> setData
    323:323:void allocate(int) -> allocate
    324:324:java.lang.Object getData() -> getData
    325:325:void setIsVirtual(boolean) -> setIsVirtual
neureka.ndim.AbstractTensor$Unsafe -> neureka.ndim.AbstractTensor$Unsafe:
    neureka.Tsr setNDConf(neureka.ndim.config.NDConfiguration) -> setNDConf
    neureka.Tsr toType(java.lang.Class) -> toType
    neureka.Tsr setDataType(neureka.dtype.DataType) -> setDataType
    neureka.Tsr toLayout(neureka.ndim.config.NDConfiguration$Layout) -> toLayout
    neureka.Tsr incrementVersion(neureka.backend.api.ExecutionCall) -> incrementVersion
    neureka.Tsr setIsIntermediate(boolean) -> setIsIntermediate
    neureka.Tsr delete() -> delete
neureka.ndim.AbstractTensor$Utility -> neureka.ndim.AbstractTensor$Utility:
    526:526:void <init>() -> <init>
    530:533:java.lang.String shapeString(int[]) -> shapeString
    538:559:int[][] makeFit(int[],int[]) -> makeFit
neureka.ndim.Filler -> neureka.ndim.Filler:
    java.lang.Object init(int,int[]) -> init
neureka.ndim.NDimensional -> neureka.ndim.NDimensional:
    24:24:int rank() -> rank
    29:29:int getRank() -> getRank
    34:34:java.util.List shape() -> shape
    39:39:java.util.List getShape() -> getShape
    41:41:java.util.List indicesMap() -> indicesMap
    43:43:java.util.List translation() -> translation
    45:45:java.util.List spread() -> spread
    47:47:java.util.List offset() -> offset
    neureka.ndim.config.NDConfiguration getNDConf() -> getNDConf
    63:63:int shape(int) -> shape
    68:68:int size() -> size
    73:73:int getSize() -> getSize
    89:89:int indexOfIndex(int) -> indexOfIndex
    100:100:int[] indicesOfIndex(int) -> indicesOfIndex
    110:110:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.NDimensional$Util -> neureka.ndim.NDimensional$Util:
    113:113:void <init>() -> <init>
    116:118:java.util.List asList(int[]) -> asList
neureka.ndim.TensorAPI -> neureka.ndim.TensorAPI:
    java.lang.Class getValueClass() -> getValueClass
    28:28:java.lang.Class valueClass() -> valueClass
    neureka.Tsr getAt(int[]) -> getAt
    48:48:neureka.Tsr getAt(java.lang.Number) -> getAt
    58:58:neureka.Tsr get(int[]) -> get
    neureka.Tsr getAt(java.lang.Object[]) -> getAt
    79:79:neureka.Tsr get(java.lang.Object[]) -> get
    90:90:neureka.Tsr getAt(int) -> getAt
    100:100:neureka.Tsr get(int) -> get
    110:110:neureka.Tsr get(java.lang.Number) -> get
    neureka.Tsr getAt(java.util.Map) -> getAt
    neureka.Tsr getAt(java.lang.Object) -> getAt
    149:149:neureka.Tsr get(java.lang.Object) -> get
    neureka.Tsr putAt(java.util.Map,neureka.Tsr) -> putAt
    neureka.Tsr putAt(int[],java.lang.Object) -> putAt
    178:178:neureka.Tsr set(int[],java.lang.Object) -> set
    194:194:neureka.Tsr putAt(int,java.lang.Object) -> putAt
    209:209:neureka.Tsr set(int,java.lang.Object) -> set
    neureka.Tsr putAt(java.util.List,neureka.Tsr) -> putAt
    225:225:neureka.Tsr putAt(java.util.List,java.lang.Object) -> putAt
    java.lang.Object getDataAt(int) -> getDataAt
    neureka.Tsr setDataAt(int,java.lang.Object) -> setDataAt
    neureka.Tsr setValueAt(int,java.lang.Object) -> setValueAt
    261:261:java.lang.Object getValueAt(int) -> getValueAt
    273:273:java.lang.Object getValueAt(int[]) -> getValueAt
neureka.ndim.TsrConstructor -> neureka.ndim.TsrConstructor:
    org.slf4j.Logger _LOG -> a
    neureka.ndim.TsrConstructor$API _API -> b
    47:47:void <init>(neureka.ndim.TsrConstructor$API) -> <init>
    62:88:void configureFromNewShape(int[],boolean,boolean) -> configureFromNewShape
    91:112:void tryConstructing(int[],neureka.dtype.DataType,java.lang.Object) -> tryConstructing
    1115:1120:java.lang.Object _autoConvertAndOptimizeObjectArray(java.lang.Object[],neureka.dtype.DataType,int):115:120 -> tryConstructing
    1115:1120:void tryConstructing(int[],neureka.dtype.DataType,java.lang.Object):97 -> tryConstructing
    124:137:boolean constructAllFromOne(int[],java.lang.Object) -> constructAllFromOne
    1146:1148:void _constructAllF32(int[],float):146:148 -> constructAllFromOne
    1146:1148:boolean constructAllFromOne(int[],java.lang.Object):125 -> constructAllFromOne
    1151:1153:void _constructAllI32(int[],int):151:153 -> constructAllFromOne
    1151:1153:boolean constructAllFromOne(int[],java.lang.Object):126 -> constructAllFromOne
    1156:1158:void _constructAllI16(int[],short):156:158 -> constructAllFromOne
    1156:1158:boolean constructAllFromOne(int[],java.lang.Object):127 -> constructAllFromOne
    1161:1163:void _constructAllI8(int[],byte):161:163 -> constructAllFromOne
    1161:1163:boolean constructAllFromOne(int[],java.lang.Object):128 -> constructAllFromOne
    1166:1168:void _constructAllI64(int[],long):166:168 -> constructAllFromOne
    1166:1168:boolean constructAllFromOne(int[],java.lang.Object):129 -> constructAllFromOne
    1171:1173:void _constructAllBool(int[],boolean):171:173 -> constructAllFromOne
    1171:1173:boolean constructAllFromOne(int[],java.lang.Object):130 -> constructAllFromOne
    1176:1178:void _constructAllChar(int[],char):176:178 -> constructAllFromOne
    1176:1178:boolean constructAllFromOne(int[],java.lang.Object):131 -> constructAllFromOne
    1181:1183:void _constructAll(int[],java.lang.Object):181:183 -> constructAllFromOne
    1181:1183:boolean constructAllFromOne(int[],java.lang.Object):135 -> constructAllFromOne
    141:143:void _constructAllF64(int[],double) -> a
    186:189:void _constructAll(int[],java.lang.Class) -> a
    199:221:void constructFor(java.util.List) -> constructFor
    225:233:void constructForDoubles(int[],double[]) -> constructForDoubles
    237:244:void constructForFloats(int[],float[]) -> constructForFloats
    248:255:void constructForInts(int[],int[]) -> constructForInts
    259:266:void constructForShorts(int[],short[]) -> constructForShorts
    270:277:void constructForBooleans(int[],boolean[]) -> constructForBooleans
    281:288:void constructForBytes(int[],byte[]) -> constructForBytes
    292:299:void constructForLongs(int[],long[]) -> constructForLongs
    302:325:void constructSeeded(java.lang.Class,int[],java.lang.Object) -> constructSeeded
    336:362:java.lang.Object optimizeObjectArray(neureka.dtype.DataType,java.lang.Object[],int) -> optimizeObjectArray
    342:342:long lambda$optimizeObjectArray$8(java.lang.Object[],int) -> a
    341:341:int lambda$optimizeObjectArray$7(java.lang.Object[],int) -> b
    340:340:double lambda$optimizeObjectArray$6(java.lang.Object[],int) -> c
    339:339:int lambda$optimizeObjectArray$5(java.lang.Object[],int) -> d
    337:337:int lambda$optimizeObjectArray$4(int) -> a
    202:202:boolean lambda$constructFor$3(int,java.util.List) -> a
    199:199:boolean lambda$constructFor$2(java.util.List) -> a
    199:199:boolean lambda$constructFor$1(java.lang.Object) -> a
    115:115:boolean lambda$_autoConvertAndOptimizeObjectArray$0(neureka.dtype.DataType,java.lang.Object) -> a
    30:30:void <clinit>() -> <clinit>
neureka.ndim.TsrConstructor$API -> neureka.ndim.TsrConstructor$API:
    void setType(neureka.dtype.DataType) -> setType
    void setConf(neureka.ndim.config.NDConfiguration) -> setConf
    void setData(java.lang.Object) -> setData
    void allocate(int) -> allocate
    java.lang.Object getData() -> getData
    void setIsVirtual(boolean) -> setIsVirtual
neureka.ndim.config.AbstractNDC -> neureka.ndim.config.AbstractNDC:
    neureka.common.utility.Cache _CACHED_NDCS -> a
    neureka.common.utility.Cache _CACHED_INT_ARRAYS -> b
    25:25:void <init>() -> <init>
    63:63:int[] _cacheArray(int[]) -> _cacheArray
    71:80:int hashCode() -> hashCode
    86:92:boolean equals(neureka.ndim.config.NDConfiguration) -> equals
    104:157:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    1187:1190:boolean _isSimpleTransposedConfiguration(int[],int[],int[]):187:190 -> construct
    1187:1190:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]):116 -> construct
    162:162:neureka.ndim.config.NDConfiguration _cached(neureka.ndim.config.NDConfiguration) -> _cached
    173:179:boolean _isSimpleConfiguration(int[],int[],int[],int[],int[]) -> a
    197:203:java.lang.String toString() -> toString
    209:222:neureka.ndim.config.NDConfiguration _simpleReshape(int[],neureka.ndim.config.NDConfiguration) -> _simpleReshape
    235:238:neureka.ndim.config.NDConfiguration newReshaped(int[]) -> newReshaped
    37:49:void <clinit>() -> <clinit>
neureka.ndim.config.NDConfiguration -> neureka.ndim.config.NDConfiguration:
    97:111:neureka.ndim.config.NDConfiguration$Layout getLayout() -> getLayout
    123:123:boolean isSlice() -> isSlice
    int rank() -> rank
    136:136:int size() -> size
    int[] shape() -> shape
    int shape(int) -> shape
    int[] indicesMap() -> indicesMap
    int indicesMap(int) -> indicesMap
    int[] translation() -> translation
    int translation(int) -> translation
    int[] spread() -> spread
    int spread(int) -> spread
    int[] offset() -> offset
    int offset(int) -> offset
    int indexOfIndex(int) -> indexOfIndex
    int[] indicesOfIndex(int) -> indicesOfIndex
    int indexOfIndices(int[]) -> indexOfIndices
    258:266:int[] asInlineArray() -> asInlineArray
    int hashCode() -> hashCode
    boolean equals(neureka.ndim.config.NDConfiguration) -> equals
    neureka.ndim.config.NDConfiguration newReshaped(int[]) -> newReshaped
    298:303:boolean isSimple() -> isSimple
    314:317:boolean isCompact() -> isCompact
    324:324:boolean isVirtual() -> isVirtual
    327:328:neureka.ndim.config.NDConfiguration$IndexToIndexFunction getIndexToIndexAccessPattern() -> getIndexToIndexAccessPattern
    317:317:boolean lambda$isCompact$2(int) -> a
    315:315:boolean lambda$isCompact$1(int) -> b
    136:136:int lambda$size$0(int,int) -> a
neureka.ndim.config.NDConfiguration$IndexToIndexFunction -> neureka.ndim.config.NDConfiguration$IndexToIndexFunction:
    int map(int) -> map
neureka.ndim.config.NDConfiguration$Layout -> neureka.ndim.config.NDConfiguration$Layout:
    neureka.ndim.config.NDConfiguration$Layout ROW_MAJOR -> ROW_MAJOR
    neureka.ndim.config.NDConfiguration$Layout COLUMN_MAJOR -> COLUMN_MAJOR
    neureka.ndim.config.NDConfiguration$Layout UNSPECIFIC -> UNSPECIFIC
    neureka.ndim.config.NDConfiguration$Layout[] $VALUES -> a
    50:50:neureka.ndim.config.NDConfiguration$Layout[] values() -> values
    50:50:neureka.ndim.config.NDConfiguration$Layout valueOf(java.lang.String) -> valueOf
    50:50:void <init>(java.lang.String,int) -> <init>
    56:72:int[] newTranslationFor(int[]) -> newTranslationFor
    77:83:int[] rearrange(int[],int[],int[]) -> rearrange
    50:52:void <clinit>() -> <clinit>
neureka.ndim.config.NDConfiguration$Utility -> neureka.ndim.config.NDConfiguration$Utility:
    338:338:void <init>() -> <init>
    342:347:int[] rearrange(int[],int[]) -> rearrange
    352:354:void increment(int[],int[]) -> increment
    1359:1368:int _incrementAt(int,int[],int[]):359:368 -> increment
    1359:1368:void increment(int[],int[]):353 -> increment
    373:375:void decrement(int[],int[]) -> decrement
    1380:1389:int _decrementAt(int,int[],int[]):380:389 -> decrement
    1380:1389:void decrement(int[],int[]):374 -> decrement
    395:397:int sizeOfShape(int[]) -> sizeOfShape
neureka.ndim.config.types.D1C -> neureka.ndim.config.types.D1C:
    5:5:void <init>() -> <init>
    int indexOfIndices(int) -> indexOfIndices
neureka.ndim.config.types.D2C -> neureka.ndim.config.types.D2C:
    5:5:void <init>() -> <init>
    int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.D3C -> neureka.ndim.config.types.D3C:
    5:5:void <init>() -> <init>
    int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.reshaped.Reshaped1DConfiguration -> neureka.ndim.config.types.reshaped.Reshaped1DConfiguration:
    int _shape -> _shape
    int _translation -> a
    int _indicesMap -> b
    boolean $assertionsDisabled -> c
    25:25:neureka.ndim.config.types.reshaped.Reshaped1DConfiguration construct(int[],int[],int[]) -> construct
    32:38:void <init>(int,int,int) -> <init>
    41:41:int rank() -> rank
    44:44:int[] shape() -> shape
    47:47:int shape(int) -> shape
    50:50:int[] indicesMap() -> indicesMap
    53:53:int indicesMap(int) -> indicesMap
    56:56:int[] translation() -> translation
    59:59:int translation(int) -> translation
    62:62:int[] spread() -> spread
    65:65:int spread(int) -> spread
    68:68:int[] offset() -> offset
    71:71:int offset(int) -> offset
    74:74:int indexOfIndex(int) -> indexOfIndex
    77:77:int[] indicesOfIndex(int) -> indicesOfIndex
    80:80:int indexOfIndices(int[]) -> indexOfIndices
    83:83:int indexOfIndices(int) -> indexOfIndices
    5:5:void <clinit>() -> <clinit>
neureka.ndim.config.types.reshaped.Reshaped2DConfiguration -> neureka.ndim.config.types.reshaped.Reshaped2DConfiguration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _translation1 -> a
    int _translation2 -> b
    int _indicesMap1 -> c
    int _indicesMap2 -> d
    27:34:void <init>(int[],int[],int[]) -> <init>
    41:41:neureka.ndim.config.types.reshaped.Reshaped2DConfiguration construct(int[],int[],int[]) -> construct
    45:45:int rank() -> rank
    48:48:int[] shape() -> shape
    51:51:int shape(int) -> shape
    54:54:int[] indicesMap() -> indicesMap
    57:57:int indicesMap(int) -> indicesMap
    60:60:int[] translation() -> translation
    63:63:int translation(int) -> translation
    66:66:int[] spread() -> spread
    69:69:int spread(int) -> spread
    72:72:int[] offset() -> offset
    75:75:int offset(int) -> offset
    79:79:int indexOfIndex(int) -> indexOfIndex
    85:89:int[] indicesOfIndex(int) -> indicesOfIndex
    94:97:int indexOfIndices(int[]) -> indexOfIndices
    102:105:int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.reshaped.Reshaped3DConfiguration -> neureka.ndim.config.types.reshaped.Reshaped3DConfiguration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _shape3 -> _shape3
    int _translation1 -> a
    int _translation2 -> b
    int _translation3 -> c
    int _indicesMap1 -> d
    int _indicesMap2 -> e
    int _indicesMap3 -> f
    30:40:void <init>(int[],int[],int[]) -> <init>
    47:47:neureka.ndim.config.types.reshaped.Reshaped3DConfiguration construct(int[],int[],int[]) -> construct
    52:52:int rank() -> rank
    57:57:int[] shape() -> shape
    62:62:int shape(int) -> shape
    67:67:int[] indicesMap() -> indicesMap
    72:72:int indicesMap(int) -> indicesMap
    77:77:int[] translation() -> translation
    82:82:int translation(int) -> translation
    87:87:int[] spread() -> spread
    92:92:int spread(int) -> spread
    97:97:int[] offset() -> offset
    102:102:int offset(int) -> offset
    108:113:int indexOfIndex(int) -> indexOfIndex
    121:126:int[] indicesOfIndex(int) -> indicesOfIndex
    131:131:int indexOfIndices(int[]) -> indexOfIndices
    138:138:int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.reshaped.ReshapedNDConfiguration -> neureka.ndim.config.types.reshaped.ReshapedNDConfiguration:
    int[] _shape -> a
    int[] _translation -> b
    int[] _indicesMap -> c
    31:35:void <init>(int[],int[],int[]) -> <init>
    42:42:neureka.ndim.config.types.reshaped.ReshapedNDConfiguration construct(int[],int[],int[]) -> construct
    47:47:int rank() -> rank
    52:52:int[] shape() -> shape
    57:57:int shape(int) -> shape
    62:62:int[] indicesMap() -> indicesMap
    67:67:int indicesMap(int) -> indicesMap
    72:72:int[] translation() -> translation
    77:77:int translation(int) -> translation
    82:84:int[] spread() -> spread
    89:89:int spread(int) -> spread
    94:96:int[] offset() -> offset
    101:101:int offset(int) -> offset
    106:106:int indexOfIndex(int) -> indexOfIndex
    111:116:int[] indicesOfIndex(int) -> indicesOfIndex
    121:124:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.simple.Simple0DConfiguration -> neureka.ndim.config.types.simple.Simple0DConfiguration:
    8:8:neureka.ndim.config.types.simple.Simple0DConfiguration construct() -> construct
    11:11:void <init>() -> <init>
    15:15:int rank() -> rank
    20:20:int[] shape() -> shape
    25:25:int shape(int) -> shape
    30:30:int[] indicesMap() -> indicesMap
    35:35:int indicesMap(int) -> indicesMap
    40:40:int[] translation() -> translation
    45:45:int translation(int) -> translation
    50:50:int[] spread() -> spread
    55:55:int spread(int) -> spread
    60:60:int[] offset() -> offset
    65:65:int offset(int) -> offset
    70:70:int indexOfIndex(int) -> indexOfIndex
    75:75:int[] indicesOfIndex(int) -> indicesOfIndex
    80:80:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.simple.Simple1DConfiguration -> neureka.ndim.config.types.simple.Simple1DConfiguration:
    int _shape -> _shape
    int _translation_and_indicesMap -> a
    22:22:neureka.ndim.config.types.simple.Simple1DConfiguration construct(int[],int[]) -> construct
    28:31:void <init>(int,int) -> <init>
    34:34:int rank() -> rank
    37:37:int[] shape() -> shape
    40:40:int shape(int) -> shape
    43:43:int[] indicesMap() -> indicesMap
    46:46:int indicesMap(int) -> indicesMap
    49:49:int[] translation() -> translation
    52:52:int translation(int) -> translation
    55:55:int[] spread() -> spread
    58:58:int spread(int) -> spread
    61:61:int[] offset() -> offset
    64:64:int offset(int) -> offset
    67:67:int indexOfIndex(int) -> indexOfIndex
    70:70:int[] indicesOfIndex(int) -> indicesOfIndex
    73:73:int indexOfIndices(int[]) -> indexOfIndices
    76:76:int indexOfIndices(int) -> indexOfIndices
neureka.ndim.config.types.simple.Simple2DConfiguration -> neureka.ndim.config.types.simple.Simple2DConfiguration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _translation1 -> a
    int _translation2 -> b
    22:27:void <init>(int[],int[]) -> <init>
    33:33:neureka.ndim.config.types.simple.Simple2DConfiguration construct(int[],int[]) -> construct
    38:38:int rank() -> rank
    41:41:int[] shape() -> shape
    44:44:int shape(int) -> shape
    47:47:int[] indicesMap() -> indicesMap
    50:50:int indicesMap(int) -> indicesMap
    53:53:int[] translation() -> translation
    56:56:int translation(int) -> translation
    59:59:int[] spread() -> spread
    62:62:int spread(int) -> spread
    65:65:int[] offset() -> offset
    68:68:int offset(int) -> offset
    72:72:int indexOfIndex(int) -> indexOfIndex
    78:82:int[] indicesOfIndex(int) -> indicesOfIndex
    87:90:int indexOfIndices(int[]) -> indexOfIndices
    95:98:int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.simple.Simple3DConfiguration -> neureka.ndim.config.types.simple.Simple3DConfiguration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _shape3 -> _shape3
    int _translation1 -> a
    int _translation2 -> b
    int _translation3 -> c
    23:30:void <init>(int[],int[]) -> <init>
    36:36:neureka.ndim.config.types.simple.Simple3DConfiguration construct(int[],int[]) -> construct
    41:41:int rank() -> rank
    46:46:int[] shape() -> shape
    51:51:int shape(int) -> shape
    56:56:int[] indicesMap() -> indicesMap
    61:61:int indicesMap(int) -> indicesMap
    66:66:int[] translation() -> translation
    71:71:int translation(int) -> translation
    76:76:int[] spread() -> spread
    81:81:int spread(int) -> spread
    86:86:int[] offset() -> offset
    91:91:int offset(int) -> offset
    100:105:int indexOfIndex(int) -> indexOfIndex
    113:118:int[] indicesOfIndex(int) -> indicesOfIndex
    123:123:int indexOfIndices(int[]) -> indexOfIndices
    130:130:int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.simple.SimpleNDConfiguration -> neureka.ndim.config.types.simple.SimpleNDConfiguration:
    int[] _shape -> _shape
    int[] _translation_and_indicesMap -> a
    22:25:void <init>(int[],int[]) -> <init>
    31:31:neureka.ndim.config.types.simple.SimpleNDConfiguration construct(int[],int[]) -> construct
    36:36:int rank() -> rank
    41:41:int[] shape() -> shape
    46:46:int shape(int) -> shape
    51:51:int[] indicesMap() -> indicesMap
    56:56:int indicesMap(int) -> indicesMap
    61:61:int[] translation() -> translation
    66:66:int translation(int) -> translation
    71:73:int[] spread() -> spread
    78:78:int spread(int) -> spread
    83:83:int[] offset() -> offset
    88:88:int offset(int) -> offset
    96:96:int indexOfIndex(int) -> indexOfIndex
    101:106:int[] indicesOfIndex(int) -> indicesOfIndex
    111:113:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.sliced.Sliced0DConfiguration -> neureka.ndim.config.types.sliced.Sliced0DConfiguration:
    int _shape -> a
    int _offset -> b
    24:24:neureka.ndim.config.types.sliced.Sliced0DConfiguration construct(int[],int[]) -> construct
    30:33:void <init>(int,int) -> <init>
    37:37:int rank() -> rank
    42:42:int[] shape() -> shape
    47:47:int shape(int) -> shape
    52:52:int[] indicesMap() -> indicesMap
    57:57:int indicesMap(int) -> indicesMap
    62:62:int[] translation() -> translation
    67:67:int translation(int) -> translation
    72:72:int[] spread() -> spread
    77:77:int spread(int) -> spread
    82:82:int[] offset() -> offset
    87:87:int offset(int) -> offset
    93:93:int indexOfIndex(int) -> indexOfIndex
    98:98:int[] indicesOfIndex(int) -> indicesOfIndex
    103:103:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.sliced.Sliced1DConfiguration -> neureka.ndim.config.types.sliced.Sliced1DConfiguration:
    int _shape -> _shape
    int _translation -> a
    int _indicesMap -> b
    int _spread -> c
    int _offset -> d
    boolean $assertionsDisabled -> e
    36:36:neureka.ndim.config.types.sliced.Sliced1DConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    45:54:void <init>(int,int,int,int,int) -> <init>
    57:57:int rank() -> rank
    60:60:int[] shape() -> shape
    63:63:int shape(int) -> shape
    66:66:int[] indicesMap() -> indicesMap
    69:69:int indicesMap(int) -> indicesMap
    72:72:int[] translation() -> translation
    75:75:int translation(int) -> translation
    78:78:int[] spread() -> spread
    81:81:int spread(int) -> spread
    84:84:int[] offset() -> offset
    87:87:int offset(int) -> offset
    90:90:int indexOfIndex(int) -> indexOfIndex
    93:93:int[] indicesOfIndex(int) -> indicesOfIndex
    96:96:int indexOfIndices(int[]) -> indexOfIndices
    99:99:int indexOfIndices(int) -> indexOfIndices
    5:5:void <clinit>() -> <clinit>
neureka.ndim.config.types.sliced.Sliced2DConfiguration -> neureka.ndim.config.types.sliced.Sliced2DConfiguration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _translation1 -> a
    int _translation2 -> b
    int _indicesMap1 -> c
    int _indicesMap2 -> d
    int _spread1 -> e
    int _spread2 -> f
    int _offset1 -> g
    int _offset2 -> h
    40:51:void <init>(int[],int[],int[],int[],int[]) -> <init>
    60:60:neureka.ndim.config.types.sliced.Sliced2DConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    64:64:int rank() -> rank
    67:67:int[] shape() -> shape
    70:70:int shape(int) -> shape
    73:73:int[] indicesMap() -> indicesMap
    76:76:int indicesMap(int) -> indicesMap
    79:79:int[] translation() -> translation
    82:82:int translation(int) -> translation
    85:85:int[] spread() -> spread
    88:88:int spread(int) -> spread
    91:91:int[] offset() -> offset
    94:94:int offset(int) -> offset
    98:98:int indexOfIndex(int) -> indexOfIndex
    104:108:int[] indicesOfIndex(int) -> indicesOfIndex
    113:116:int indexOfIndices(int[]) -> indexOfIndices
    121:124:int indexOfIndices(int,int) -> indexOfIndices
neureka.ndim.config.types.sliced.Sliced3DConfiguration -> neureka.ndim.config.types.sliced.Sliced3DConfiguration:
    int _shape1 -> _shape1
    int _shape2 -> _shape2
    int _shape3 -> _shape3
    int _translation1 -> a
    int _translation2 -> b
    int _translation3 -> c
    int _indicesMap1 -> d
    int _indicesMap2 -> e
    int _indicesMap3 -> f
    int _spread1 -> g
    int _spread2 -> h
    int _spread3 -> i
    int _offset1 -> j
    int _offset2 -> k
    int _offset3 -> l
    45:61:void <init>(int[],int[],int[],int[],int[]) -> <init>
    70:70:neureka.ndim.config.types.sliced.Sliced3DConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    75:75:int rank() -> rank
    80:80:int[] shape() -> shape
    85:85:int shape(int) -> shape
    90:90:int[] indicesMap() -> indicesMap
    95:95:int indicesMap(int) -> indicesMap
    100:100:int[] translation() -> translation
    105:105:int translation(int) -> translation
    110:110:int[] spread() -> spread
    115:115:int spread(int) -> spread
    120:120:int[] offset() -> offset
    125:125:int offset(int) -> offset
    131:136:int indexOfIndex(int) -> indexOfIndex
    144:149:int[] indicesOfIndex(int) -> indicesOfIndex
    154:154:int indexOfIndices(int[]) -> indexOfIndices
    161:161:int indexOfIndices(int,int,int) -> indexOfIndices
neureka.ndim.config.types.sliced.SlicedNDConfiguration -> neureka.ndim.config.types.sliced.SlicedNDConfiguration:
    int[] _shape -> a
    int[] _translation -> b
    int[] _indicesMap -> c
    int[] _spread -> d
    int[] _offset -> e
    39:45:void <init>(int[],int[],int[],int[],int[]) -> <init>
    54:54:neureka.ndim.config.types.sliced.SlicedNDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    59:59:int rank() -> rank
    64:64:int[] shape() -> shape
    69:69:int shape(int) -> shape
    74:74:int[] indicesMap() -> indicesMap
    79:79:int indicesMap(int) -> indicesMap
    84:84:int[] translation() -> translation
    89:89:int translation(int) -> translation
    94:94:int[] spread() -> spread
    99:99:int spread(int) -> spread
    104:104:int[] offset() -> offset
    109:109:int offset(int) -> offset
    114:114:int indexOfIndex(int) -> indexOfIndex
    119:124:int[] indicesOfIndex(int) -> indicesOfIndex
    129:132:int indexOfIndices(int[]) -> indexOfIndices
neureka.ndim.config.types.views.SimpleReshapeView -> neureka.ndim.config.types.views.SimpleReshapeView:
    neureka.ndim.config.NDConfiguration _toBeViewed -> a
    int[] _form -> b
    int[] _formTranslator -> c
    int[] _shape -> d
    int[] _translation -> e
    int[] _indicesMap -> f
    int[] _spread -> g
    int[] _offset -> h
    23:44:void <init>(int[],neureka.ndim.config.NDConfiguration) -> <init>
    48:48:int rank() -> rank
    53:53:int[] shape() -> shape
    58:58:int shape(int) -> shape
    63:63:int[] indicesMap() -> indicesMap
    68:68:int indicesMap(int) -> indicesMap
    73:73:int[] translation() -> translation
    78:78:int translation(int) -> translation
    83:83:int[] spread() -> spread
    88:88:int spread(int) -> spread
    93:93:int[] offset() -> offset
    98:98:int offset(int) -> offset
    103:103:int indexOfIndex(int) -> indexOfIndex
    108:113:int[] indicesOfIndex(int) -> indicesOfIndex
    118:119:int indexOfIndices(int[]) -> indexOfIndices
    1124:1127:int[] _rearrange(int[],int[],int[]):124:127 -> indexOfIndices
    1124:1127:int indexOfIndices(int[]):118 -> indexOfIndices
    35:35:int lambda$new$0(java.lang.Integer) -> a
neureka.ndim.config.types.views.virtual.VirtualNDConfiguration -> neureka.ndim.config.types.views.virtual.VirtualNDConfiguration:
    int[] _shape -> a
    16:16:void <init>(int[]) -> <init>
    21:21:neureka.ndim.config.types.views.virtual.VirtualNDConfiguration construct(int[]) -> construct
    25:25:int rank() -> rank
    28:28:int[] shape() -> shape
    31:31:int shape(int) -> shape
    34:34:int[] indicesMap() -> indicesMap
    37:37:int indicesMap(int) -> indicesMap
    40:40:int[] translation() -> translation
    43:43:int translation(int) -> translation
    46:46:int[] spread() -> spread
    49:49:int spread(int) -> spread
    52:52:int[] offset() -> offset
    55:55:int offset(int) -> offset
    58:58:int indexOfIndex(int) -> indexOfIndex
    61:61:int[] indicesOfIndex(int) -> indicesOfIndex
    64:64:int indexOfIndices(int[]) -> indexOfIndices
    67:67:boolean isVirtual() -> isVirtual
neureka.ndim.iterator.NDIterator -> neureka.ndim.iterator.NDIterator:
    82:82:neureka.ndim.iterator.NDIterator of(neureka.Tsr) -> of
    94:94:neureka.ndim.iterator.NDIterator of(neureka.Tsr,neureka.ndim.iterator.NDIterator$NonVirtual) -> of
    107:121:neureka.ndim.iterator.NDIterator of(neureka.ndim.config.NDConfiguration,neureka.ndim.iterator.NDIterator$NonVirtual) -> of
    int shape(int) -> shape
    int[] shape() -> shape
    void increment() -> increment
    132:134:int getIndexAndIncrement() -> getIndexAndIncrement
    void decrement() -> decrement
    int i() -> i
    int get(int) -> get
    int[] get() -> get
    void set(int,int) -> set
    void set(int[]) -> set
    int rank() -> rank
neureka.ndim.iterator.NDIterator$NonVirtual -> neureka.ndim.iterator.NDIterator$NonVirtual:
    neureka.ndim.iterator.NDIterator$NonVirtual TRUE -> TRUE
    neureka.ndim.iterator.NDIterator$NonVirtual FALSE -> FALSE
    neureka.ndim.iterator.NDIterator$NonVirtual[] $VALUES -> a
    73:73:neureka.ndim.iterator.NDIterator$NonVirtual[] values() -> values
    73:73:neureka.ndim.iterator.NDIterator$NonVirtual valueOf(java.lang.String) -> valueOf
    73:73:void <init>(java.lang.String,int) -> <init>
    73:73:void <clinit>() -> <clinit>
neureka.ndim.iterator.types.reshaped.Reshaped2DCIterator -> neureka.ndim.iterator.types.reshaped.Reshaped2DCIterator:
    int _d1 -> a
    int _d2 -> b
    8:13:void <init>(neureka.ndim.config.types.reshaped.Reshaped2DConfiguration) -> <init>
    17:22:void increment() -> increment
    26:31:void decrement() -> decrement
    35:35:int i() -> i
    40:40:int get(int) -> get
    45:45:int[] get() -> get
    50:52:void set(int,int) -> set
    56:58:void set(int[]) -> set
neureka.ndim.iterator.types.reshaped.Reshaped3DCIterator -> neureka.ndim.iterator.types.reshaped.Reshaped3DCIterator:
    int _d1 -> a
    int _d2 -> b
    int _d3 -> c
    8:14:void <init>(neureka.ndim.config.types.reshaped.Reshaped3DConfiguration) -> <init>
    19:28:void increment() -> increment
    32:41:void decrement() -> decrement
    45:45:int i() -> i
    50:50:int get(int) -> get
    55:55:int[] get() -> get
    60:63:void set(int,int) -> set
    67:70:void set(int[]) -> set
neureka.ndim.iterator.types.simple.Simple1DCIterator -> neureka.ndim.iterator.types.simple.Simple1DCIterator:
    int _d1 -> a
    12:13:void <init>(neureka.ndim.config.types.simple.Simple1DConfiguration) -> <init>
    18:19:void increment() -> increment
    23:24:void decrement() -> decrement
    29:29:int i() -> i
    34:34:int get(int) -> get
    39:39:int[] get() -> get
    44:45:void set(int,int) -> set
    49:50:void set(int[]) -> set
neureka.ndim.iterator.types.simple.Simple2DCIterator -> neureka.ndim.iterator.types.simple.Simple2DCIterator:
    int _d1 -> a
    int _d2 -> b
    8:13:void <init>(neureka.ndim.config.types.simple.Simple2DConfiguration) -> <init>
    17:22:void increment() -> increment
    26:31:void decrement() -> decrement
    35:35:int i() -> i
    40:40:int get(int) -> get
    45:45:int[] get() -> get
    50:52:void set(int,int) -> set
    56:58:void set(int[]) -> set
neureka.ndim.iterator.types.simple.Simple3DCIterator -> neureka.ndim.iterator.types.simple.Simple3DCIterator:
    int _d1 -> _d1
    int _d2 -> _d2
    int _d3 -> _d3
    8:14:void <init>(neureka.ndim.config.types.simple.Simple3DConfiguration) -> <init>
    19:28:void increment() -> increment
    32:41:void decrement() -> decrement
    45:45:int i() -> i
    50:50:int get(int) -> get
    55:55:int[] get() -> get
    60:63:void set(int,int) -> set
    67:70:void set(int[]) -> set
neureka.ndim.iterator.types.sliced.Sliced1DCIterator -> neureka.ndim.iterator.types.sliced.Sliced1DCIterator:
    int _d1 -> a
    11:12:void <init>(neureka.ndim.config.types.sliced.Sliced1DConfiguration) -> <init>
    15:15:void increment() -> increment
    18:18:void decrement() -> decrement
    21:21:int i() -> i
    24:24:int get(int) -> get
    27:27:int[] get() -> get
    30:30:void set(int,int) -> set
    33:33:void set(int[]) -> set
neureka.ndim.iterator.types.sliced.Sliced2DCIterator -> neureka.ndim.iterator.types.sliced.Sliced2DCIterator:
    int _d1 -> a
    int _d2 -> b
    8:13:void <init>(neureka.ndim.config.types.sliced.Sliced2DConfiguration) -> <init>
    18:23:void increment() -> increment
    27:32:void decrement() -> decrement
    36:36:int i() -> i
    41:41:int get(int) -> get
    46:46:int[] get() -> get
    51:53:void set(int,int) -> set
    57:59:void set(int[]) -> set
neureka.ndim.iterator.types.sliced.Sliced3DCIterator -> neureka.ndim.iterator.types.sliced.Sliced3DCIterator:
    int _d1 -> a
    int _d2 -> b
    int _d3 -> c
    8:14:void <init>(neureka.ndim.config.types.sliced.Sliced3DConfiguration) -> <init>
    19:28:void increment() -> increment
    32:41:void decrement() -> decrement
    45:45:int i() -> i
    50:50:int get(int) -> get
    55:55:int[] get() -> get
    60:63:void set(int,int) -> set
    67:70:void set(int[]) -> set
neureka.ndim.iterator.types.sliced.SlicedNDIterator -> neureka.ndim.iterator.types.sliced.SlicedNDIterator:
    int[] _indices -> a
    int[] _shape -> b
    neureka.ndim.config.NDConfiguration _conf -> c
    12:16:void <init>(neureka.ndim.config.NDConfiguration) -> <init>
    20:20:int shape(int) -> shape
    25:25:int[] shape() -> shape
    30:31:void increment() -> increment
    35:36:void decrement() -> decrement
    40:40:int i() -> i
    45:45:int get(int) -> get
    50:50:int[] get() -> get
    55:56:void set(int,int) -> set
    60:61:void set(int[]) -> set
    65:65:int rank() -> rank
neureka.ndim.iterator.types.virtual.VirtualNDIterator -> neureka.ndim.iterator.types.virtual.VirtualNDIterator:
    neureka.ndim.config.types.views.virtual.VirtualNDConfiguration _conf -> a
    10:10:void <init>(neureka.ndim.config.types.views.virtual.VirtualNDConfiguration) -> <init>
    13:13:int shape(int) -> shape
    16:16:int[] shape() -> shape
    21:21:void increment() -> increment
    26:26:void decrement() -> decrement
    30:30:int i() -> i
    35:35:int get(int) -> get
    44:44:int[] get() -> get
    54:54:void set(int,int) -> set
    59:59:void set(int[]) -> set
    62:62:int rank() -> rank
neureka.optimization.Optimization -> neureka.optimization.Optimization:
    neureka.Tsr optimize(neureka.Tsr) -> optimize
neureka.optimization.Optimizer -> neureka.optimization.Optimizer:
    44:44:neureka.optimization.Optimizer of(neureka.optimization.Optimization) -> of
    51:51:neureka.optimization.Optimizer ofGradient(neureka.optimization.Optimization) -> ofGradient
neureka.optimization.Optimizer$1 -> neureka.optimization.Optimizer$1:
    neureka.optimization.Optimization val$o -> a
    44:44:void <init>(neureka.optimization.Optimization) -> <init>
    45:45:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    46:46:neureka.Tsr optimize(neureka.Tsr) -> optimize
neureka.optimization.Optimizer$2 -> neureka.optimization.Optimizer$2:
    neureka.optimization.Optimization val$o -> a
    51:51:void <init>(neureka.optimization.Optimization) -> <init>
    52:52:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
    53:53:neureka.Tsr optimize(neureka.Tsr) -> optimize
neureka.optimization.implementations.ADAM -> neureka.optimization.implementations.ADAM:
    neureka.Tsr a -> a
    neureka.Tsr b1 -> b
    neureka.Tsr b2 -> c
    neureka.Tsr e -> d
    neureka.Tsr m -> e
    neureka.Tsr v -> f
    62:70:void <init>(neureka.Tsr) -> <init>
    88:88:neureka.Tsr optimize(neureka.Tsr) -> optimize
    1073:1083:neureka.Tsr _optimize(neureka.Tsr):73:83 -> optimize
    1073:1083:neureka.Tsr optimize(neureka.Tsr):88 -> optimize
    93:94:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
neureka.optimization.implementations.SGD -> neureka.optimization.implementations.SGD:
    double _learningRate -> a
    neureka.calculus.Function _function -> b
    60:63:void <init>(double) -> <init>
    67:68:neureka.Tsr optimize(neureka.Tsr) -> optimize
    72:72:double learningRate() -> learningRate
    77:78:boolean update(neureka.common.composition.Component$OwnerChangeRequest) -> update
neureka.view.TsrAsString -> neureka.view.TsrAsString:
    int _cellSize -> a
    int _rowLimit -> b
    boolean _hasGradient -> c
    boolean _isCompact -> d
    boolean _isMultiline -> e
    boolean _haveSlimNumbers -> f
    boolean _hasValue -> g
    boolean _hasShape -> h
    boolean _hasRecursiveGraph -> i
    boolean _hasDerivatives -> j
    boolean _isCellBound -> k
    java.lang.String _prefix -> l
    java.lang.String _postfix -> m
    int[] _shape -> n
    neureka.Tsr _tensor -> o
    boolean _legacy -> p
    neureka.view.TsrStringSettings _config -> q
    java.lang.StringBuilder _asStr -> r
    boolean $assertionsDisabled -> s
    87:87:neureka.view.TsrAsString$Builder representing(neureka.Tsr) -> representing
    111:135:void <init>(neureka.Tsr,neureka.view.TsrStringSettings) -> <init>
    148:148:neureka.view.TsrAsString _$(java.lang.String) -> a
    161:161:neureka.view.TsrAsString _$(int) -> a
    175:196:neureka.view.TsrAsString$ValStringifier _createValStringifierAndFormatter(java.lang.Object) -> a
    1206:1247:neureka.view.TsrAsString$ValStringifier _createBasicStringifierFor(java.lang.Object,boolean):206:247 -> a
    1206:1247:neureka.view.TsrAsString$ValStringifier _createValStringifierAndFormatter(java.lang.Object):175 -> a
    251:311:java.lang.String toString() -> toString
    1316:1323:java.lang.String _postProcessed(java.lang.String):316:323 -> toString
    1316:1323:java.lang.String toString():311 -> toString
    328:340:void _stringifyAllValues() -> a
    356:365:void _buildRow(int,int,int,int[],neureka.view.TsrAsString$NDValStringifier,java.lang.String) -> a
    381:445:void _recursiveFormatting(int[],int) -> a
    448:458:neureka.view.TsrAsString _buildSingleLabel(neureka.framing.NDFrame,int,int[]) -> a
    467:474:void _strShape() -> b
    479:494:java.lang.String formatFP(double) -> a
    418:418:java.lang.String lambda$_recursiveFormatting$17(neureka.view.TsrAsString$ValStringifier,int[]) -> a
    417:417:java.lang.String lambda$_recursiveFormatting$16(neureka.view.TsrAsString$ValStringifier,int[]) -> b
    404:404:java.lang.String lambda$_recursiveFormatting$15(neureka.view.TsrAsString$ValStringifier,int[]) -> c
    306:308:void lambda$toString$14(neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    288:299:void lambda$toString$13(java.lang.String,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    275:278:void lambda$toString$12(neureka.view.TsrStringSettings) -> a
    247:247:java.lang.String lambda$_createBasicStringifierFor$11(java.lang.Object,int) -> a
    245:245:java.lang.String lambda$_createBasicStringifierFor$10(java.lang.Object,int) -> b
    243:243:java.lang.String lambda$_createBasicStringifierFor$9(java.lang.Object,int) -> c
    239:241:java.lang.String lambda$_createBasicStringifierFor$8(boolean,java.lang.Object,int) -> a
    235:237:java.lang.String lambda$_createBasicStringifierFor$7(boolean,java.lang.Object,int) -> b
    231:233:java.lang.String lambda$_createBasicStringifierFor$6(boolean,java.lang.Object,int) -> c
    227:229:java.lang.String lambda$_createBasicStringifierFor$5(boolean,java.lang.Object,int) -> d
    223:225:java.lang.String lambda$_createBasicStringifierFor$4(boolean,java.util.function.Function,java.lang.Object,int) -> a
    219:221:java.lang.String lambda$_createBasicStringifierFor$3(boolean,java.util.function.Function,java.lang.Object,int) -> b
    210:215:java.lang.String lambda$_createBasicStringifierFor$2(java.lang.String) -> b
    189:192:java.lang.String lambda$_createValStringifierAndFormatter$1(neureka.view.TsrAsString$ValStringifier,int,int) -> a
    179:183:java.lang.String lambda$_createValStringifierAndFormatter$0(neureka.view.TsrAsString$ValStringifier,int,int) -> b
    58:58:void <init>(neureka.Tsr,neureka.view.TsrStringSettings,byte) -> <init>
    58:58:void <clinit>() -> <clinit>
neureka.view.TsrAsString$1 -> neureka.view.TsrAsString$1:
    neureka.Tsr val$t -> a
    87:87:void <init>(neureka.Tsr) -> <init>
    94:94:neureka.view.TsrAsString withConfig(neureka.view.TsrStringSettings) -> withConfig
    101:101:neureka.view.TsrAsString withConfig(java.lang.String) -> withConfig
    106:106:neureka.view.TsrAsString byDefaults() -> byDefaults
neureka.view.TsrAsString$Builder -> neureka.view.TsrAsString$Builder:
    neureka.view.TsrAsString withConfig(neureka.view.TsrStringSettings) -> withConfig
    neureka.view.TsrAsString withConfig(java.lang.String) -> withConfig
    neureka.view.TsrAsString byDefaults() -> byDefaults
neureka.view.TsrAsString$NDValStringifier -> neureka.view.TsrAsString$a:
    java.lang.String stringify(int[]) -> stringify
neureka.view.TsrAsString$Util -> neureka.view.TsrAsString$Util:
    545:545:void <init>() -> <init>
    548:548:java.lang.String indent(int) -> indent
    552:552:java.lang.String pad(int,java.lang.String) -> pad
    557:557:java.lang.String pad(java.lang.String,int) -> pad
neureka.view.TsrAsString$ValStringifier -> neureka.view.TsrAsString$b:
    java.lang.String stringify(int) -> stringify
neureka.view.TsrStringSettings -> neureka.view.TsrStringSettings:
    java.util.function.Supplier _notModifyable -> a
    int _cellSize -> b
    int _rowLimit -> c
    boolean _hasGradient -> d
    boolean _isScientific -> e
    boolean _multiline -> f
    boolean _haveSlimNumbers -> g
    boolean _hasValue -> h
    boolean _hasShape -> i
    boolean _hasRecursiveGraph -> j
    boolean _hasDerivatives -> k
    boolean _isCellBound -> l
    java.lang.String _prefix -> m
    java.lang.String _postfix -> n
    java.lang.String _indent -> o
    boolean _legacy -> p
    28:43:void <init>(java.util.function.Supplier) -> <init>
    46:48:neureka.view.TsrStringSettings clone() -> clone
    52:53:neureka.view.TsrStringSettings with(neureka.view.TsrStringSettings) -> with
    63:77:void _imposeOn(neureka.view.TsrStringSettings) -> a
    89:89:int getCellSize() -> getCellSize
    102:104:neureka.view.TsrStringSettings setCellSize(int) -> setCellSize
    117:117:int getRowLimit() -> getRowLimit
    130:132:neureka.view.TsrStringSettings setRowLimit(int) -> setRowLimit
    139:139:boolean getHasGradient() -> getHasGradient
    146:148:neureka.view.TsrStringSettings setHasGradient(boolean) -> setHasGradient
    155:155:boolean getIsScientific() -> getIsScientific
    162:164:neureka.view.TsrStringSettings setIsScientific(boolean) -> setIsScientific
    171:171:boolean getIsMultiline() -> getIsMultiline
    178:180:neureka.view.TsrStringSettings setIsMultiline(boolean) -> setIsMultiline
    187:187:boolean getHasSlimNumbers() -> getHasSlimNumbers
    194:196:neureka.view.TsrStringSettings setHasSlimNumbers(boolean) -> setHasSlimNumbers
    203:203:boolean getHasValue() -> getHasValue
    210:212:neureka.view.TsrStringSettings setHasValue(boolean) -> setHasValue
    219:219:boolean getHasShape() -> getHasShape
    226:228:neureka.view.TsrStringSettings setHasShape(boolean) -> setHasShape
    236:236:boolean getHasRecursiveGraph() -> getHasRecursiveGraph
    245:247:neureka.view.TsrStringSettings setHasRecursiveGraph(boolean) -> setHasRecursiveGraph
    251:251:boolean getHasDerivatives() -> getHasDerivatives
    255:257:neureka.view.TsrStringSettings setHasDerivatives(boolean) -> setHasDerivatives
    261:261:boolean getIsCellBound() -> getIsCellBound
    265:267:neureka.view.TsrStringSettings setIsCellBound(boolean) -> setIsCellBound
    274:274:java.lang.String getPrefix() -> getPrefix
    281:283:neureka.view.TsrStringSettings setPrefix(java.lang.String) -> setPrefix
    290:290:java.lang.String getPostfix() -> getPostfix
    297:299:neureka.view.TsrStringSettings setPostfix(java.lang.String) -> setPostfix
    308:308:java.lang.String getIndent() -> getIndent
    317:319:neureka.view.TsrStringSettings setIndent(java.lang.String) -> setIndent
    330:330:boolean getIsLegacy() -> getIsLegacy
    341:343:neureka.view.TsrStringSettings setIsLegacy(boolean) -> setIsLegacy
    352:369:neureka.view.TsrStringSettings with(java.lang.String) -> with
    9:9:java.lang.Object clone() -> clone
    46:46:java.lang.Boolean lambda$clone$0() -> a
