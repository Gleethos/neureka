neureka.Component -> neureka.Component:
    void update(java.lang.Object,java.lang.Object) -> update
neureka.Neureka -> neureka.Neureka:
    java.lang.ThreadLocal _INSTANCES -> a
    java.lang.String _VERSION -> b
    boolean _GROOVY_AVAILABLE -> c
    boolean _OPENCL_AVAILABLE -> d
    neureka.Neureka$Settings _settings -> e
    neureka.Neureka$Utility _utility -> f
    29:32:void <init>() -> <init>
    35:43:neureka.Neureka instance() -> instance
    47:48:void setContext(neureka.Neureka) -> setContext
    51:55:neureka.Neureka instance(java.lang.Object) -> instance
    59:59:boolean canAccessGroovy() -> canAccessGroovy
    63:63:boolean canAccessOpenCL() -> canAccessOpenCL
    67:67:neureka.Neureka$Settings settings() -> settings
    71:72:neureka.Neureka$Settings settings(java.lang.Object) -> settings
    76:76:neureka.Neureka$Utility utility() -> utility
    80:80:java.lang.String version() -> version
    84:95:void reset() -> reset
    98:98:boolean _currentThreadIsAuthorized() -> a
    21:24:void <clinit>() -> <clinit>
neureka.Neureka$Settings -> neureka.Neureka$Settings:
    neureka.Neureka$Settings$Debug _debug -> b
    neureka.Neureka$Settings$AutoGrad _autograd -> c
    neureka.Neureka$Settings$Indexing _indexing -> d
    neureka.Neureka$Settings$View _view -> e
    neureka.Neureka$Settings$NDim _ndim -> f
    boolean _isLocked -> g
    neureka.Neureka this$0 -> a
    109:117:void <init>(neureka.Neureka) -> <init>
    120:120:neureka.Neureka$Settings$Debug debug() -> debug
    124:125:neureka.Neureka$Settings$Debug debug(java.lang.Object) -> debug
    129:129:neureka.Neureka$Settings$AutoGrad autograd() -> autograd
    133:134:neureka.Neureka$Settings$AutoGrad autograd(java.lang.Object) -> autograd
    138:138:neureka.Neureka$Settings$Indexing indexing() -> indexing
    142:143:neureka.Neureka$Settings$Indexing indexing(java.lang.Object) -> indexing
    147:147:neureka.Neureka$Settings$View view() -> view
    151:152:neureka.Neureka$Settings$View view(java.lang.Object) -> view
    156:156:neureka.Neureka$Settings$NDim ndim() -> ndim
    160:161:neureka.Neureka$Settings$NDim ndim(java.lang.Object) -> ndim
    165:165:boolean isLocked() -> isLocked
    169:170:void setIsLocked(boolean) -> setIsLocked
neureka.Neureka$Settings$AutoGrad -> neureka.Neureka$Settings$AutoGrad:
    boolean _isPreventingInlineOperations -> a
    boolean _isRetainingPendingErrorForJITProp -> b
    boolean _isApplyingGradientWhenTensorIsUsed -> c
    boolean _isApplyingGradientWhenRequested -> d
    neureka.Neureka$Settings this$1 -> e
    202:233:void <init>(neureka.Neureka$Settings) -> <init>
    236:236:boolean isPreventingInlineOperations() -> isPreventingInlineOperations
    240:242:void setIsPreventingInlineOperations(boolean) -> setIsPreventingInlineOperations
    245:245:boolean isRetainingPendingErrorForJITProp() -> isRetainingPendingErrorForJITProp
    249:251:void setIsRetainingPendingErrorForJITProp(boolean) -> setIsRetainingPendingErrorForJITProp
    254:254:boolean isApplyingGradientWhenTensorIsUsed() -> isApplyingGradientWhenTensorIsUsed
    258:260:void setIsApplyingGradientWhenTensorIsUsed(boolean) -> setIsApplyingGradientWhenTensorIsUsed
    263:263:boolean isApplyingGradientWhenRequested() -> isApplyingGradientWhenRequested
    267:269:void setIsApplyingGradientWhenRequested(boolean) -> setIsApplyingGradientWhenRequested
neureka.Neureka$Settings$Debug -> neureka.Neureka$Settings$Debug:
    boolean _isKeepingDerivativeTargetPayloads -> a
    neureka.Neureka$Settings this$1 -> b
    172:189:void <init>(neureka.Neureka$Settings) -> <init>
    192:192:boolean isKeepingDerivativeTargetPayloads() -> isKeepingDerivativeTargetPayloads
    196:198:void setIsKeepingDerivativeTargetPayloads(boolean) -> setIsKeepingDerivativeTargetPayloads
neureka.Neureka$Settings$Indexing -> neureka.Neureka$Settings$Indexing:
    boolean _isUsingLegacyIndexing -> a
    boolean _isUsingThoroughIndexing -> b
    neureka.Neureka$Settings this$1 -> c
    273:275:void <init>(neureka.Neureka$Settings) -> <init>
    280:280:boolean isUsingLegacyIndexing() -> isUsingLegacyIndexing
    284:286:void setIsUsingLegacyIndexing(boolean) -> setIsUsingLegacyIndexing
    289:289:boolean isUsingThoroughIndexing() -> isUsingThoroughIndexing
    293:295:void setIsUsingThoroughIndexing(boolean) -> setIsUsingThoroughIndexing
neureka.Neureka$Settings$NDim -> neureka.Neureka$Settings$NDim:
    boolean _isOnlyUsingDefaultNDConfiguration -> a
    neureka.Neureka$Settings this$1 -> b
    314:321:void <init>(neureka.Neureka$Settings) -> <init>
    324:324:boolean isOnlyUsingDefaultNDConfiguration() -> isOnlyUsingDefaultNDConfiguration
    328:330:void setIsOnlyUsingDefaultNDConfiguration(boolean) -> setIsOnlyUsingDefaultNDConfiguration
neureka.Neureka$Settings$View -> neureka.Neureka$Settings$View:
    boolean _isUsingLegacyView -> a
    neureka.Neureka$Settings this$1 -> b
    299:301:void <init>(neureka.Neureka$Settings) -> <init>
    304:304:boolean isUsingLegacyView() -> isUsingLegacyView
    308:310:void setIsUsingLegacyView(boolean) -> setIsUsingLegacyView
neureka.Neureka$Utility -> neureka.Neureka$Utility:
    336:336:void <init>() -> <init>
    346:359:java.lang.String readResource(java.lang.String) -> readResource
    364:378:boolean isPresent(java.lang.String) -> isPresent
neureka.Tsr -> neureka.Tsr:
    neureka.acceleration.Device _CPU -> a
    int _flags -> b
    int _version -> c
    49:49:int version() -> version
    53:65:neureka.Tsr incrementVersionBecauseOf(neureka.calculus.backend.ExecutionCall) -> incrementVersionBecauseOf
    71:73:neureka.Tsr setRqsGradient(boolean) -> setRqsGradient
    77:77:boolean rqsGradient() -> rqsGradient
    81:85:void _setRqsGradient(boolean) -> _setRqsGradient
    90:112:neureka.Tsr setIsOutsourced(boolean) -> setIsOutsourced
    116:116:boolean isOutsourced() -> isOutsourced
    120:124:void _setIsOutsourced(boolean) -> _setIsOutsourced
    129:149:neureka.Tsr setIsVirtual(boolean) -> setIsVirtual
    153:153:boolean isVirtual() -> isVirtual
    157:161:void _setIsVirtual(boolean) -> _setIsVirtual
    166:177:neureka.Tsr setGradientApplyRqd(boolean) -> setGradientApplyRqd
    181:181:boolean gradientApplyRqd() -> gradientApplyRqd
    198:220:neureka.Component _addOrReject(neureka.Component) -> _addOrReject
    235:238:neureka.Component _removeOrReject(neureka.Component) -> _removeOrReject
    245:245:boolean isEmpty() -> isEmpty
    249:249:boolean isUndefined() -> isUndefined
    253:254:boolean isSlice() -> isSlice
    258:259:int sliceCount() -> sliceCount
    263:264:boolean isSliceParent() -> isSliceParent
    268:268:boolean belongsToGraph() -> belongsToGraph
    272:272:boolean isLeave() -> isLeave
    276:276:boolean isBranch() -> isBranch
    280:280:boolean hasGradient() -> hasGradient
    284:284:neureka.Tsr getGradient() -> getGradient
    294:295:neureka.acceleration.Device device() -> device
    303:303:neureka.autograd.GraphNode getGraphNode() -> getGraphNode
    311:311:neureka.framing.IndexAlias index() -> index
    318:332:neureka.Tsr _become(neureka.Tsr) -> _become
    336:347:neureka.Tsr delete() -> delete
    357:373:void _configureFromNewShape(int[],boolean) -> _configureFromNewShape
    35:379:void <init>() -> <init>
    35:384:void <init>(java.lang.Object) -> <init>
    35:392:void <init>(java.lang.String,java.util.List) -> <init>
    35:409:void <init>(java.util.List,java.lang.String) -> <init>
    35:424:void <init>(java.util.List,java.util.List) -> <init>
    35:455:void <init>(java.util.List) -> <init>
    35:459:void <init>(java.lang.Object,java.lang.Object) -> <init>
    35:462:void <init>(java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:465:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:468:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:471:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:474:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:477:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:480:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:483:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    35:487:void <init>(int[],java.lang.String) -> <init>
    490:492:void _construct(int[],java.lang.String) -> a
    495:501:int[] _intArray(java.lang.Object[]) -> a
    505:512:double[] _doubleArray(java.lang.Object[]) -> b
    35:517:void <init>(java.lang.Object[]) -> <init>
    520:581:void _construct(java.lang.Object[]) -> c
    35:585:void <init>(double) -> <init>
    35:589:void <init>(int[]) -> <init>
    592:594:void _construct(int[]) -> a
    35:598:void <init>(int[],double) -> <init>
    601:606:void _construct(int[],double) -> a
    35:610:void <init>(int[],double[]) -> <init>
    613:620:void _construct(int[],double[]) -> a
    35:627:void <init>(neureka.Tsr,java.lang.String) -> <init>
    35:631:void <init>(neureka.Tsr[],java.lang.String) -> <init>
    35:635:void <init>(neureka.Tsr[],java.lang.String,boolean) -> <init>
    638:641:void _construct(neureka.Tsr[],java.lang.String,boolean) -> a
    645:647:neureka.Tsr mean() -> mean
    661:664:neureka.Tsr backward(neureka.Tsr) -> backward
    677:678:neureka.Tsr backward(double) -> backward
    689:690:neureka.Tsr backward() -> backward
    694:704:void applyGradient() -> applyGradient
    707:708:void detach() -> detach
    713:716:neureka.Tsr T() -> T
    720:720:neureka.Tsr plus(neureka.Tsr) -> plus
    723:723:neureka.Tsr plusAssign(neureka.Tsr) -> plusAssign
    726:726:neureka.Tsr plus(java.lang.Double) -> plus
    729:729:neureka.Tsr minus(neureka.Tsr) -> minus
    732:732:neureka.Tsr minusAssign(neureka.Tsr) -> minusAssign
    735:735:neureka.Tsr negative() -> negative
    738:738:neureka.Tsr multiply(neureka.Tsr) -> multiply
    741:741:neureka.Tsr timesAssign(neureka.Tsr) -> timesAssign
    744:744:neureka.Tsr multiply(java.lang.Double) -> multiply
    747:747:neureka.Tsr div(neureka.Tsr) -> div
    750:750:neureka.Tsr div(java.lang.Double) -> div
    753:753:neureka.Tsr divAssign(neureka.Tsr) -> divAssign
    756:756:neureka.Tsr mod(neureka.Tsr) -> mod
    759:759:neureka.Tsr modAssign(neureka.Tsr) -> modAssign
    762:762:neureka.Tsr power(neureka.Tsr) -> power
    765:765:neureka.Tsr power(java.lang.Double) -> power
    768:768:neureka.Tsr xor(neureka.Tsr) -> xor
    771:771:neureka.Tsr xor(java.lang.Double) -> xor
    774:783:neureka.Tsr dot(neureka.Tsr) -> dot
    786:790:boolean isCase(neureka.Tsr) -> isCase
    793:793:boolean contains(neureka.Tsr) -> contains
    797:809:neureka.Tsr label(java.lang.String[][]) -> label
    813:815:neureka.Tsr label(java.util.List) -> label
    819:820:neureka.Tsr label(java.util.Map) -> label
    824:835:neureka.Tsr putAt(java.lang.Object,neureka.Tsr) -> putAt
    839:839:double getAt(int[]) -> getAt
    843:844:java.lang.Object getAt(java.lang.Object,java.lang.Object) -> getAt
    848:927:java.lang.Object getAt(java.lang.Object) -> getAt
    942:1016:int _configureSubsetFromRanges(java.lang.Object[],int[],int[],int) -> a
    1100:1104:neureka.Tsr setValue64(double[]) -> setValue64
    1108:1112:neureka.Tsr setValue32(float[]) -> setValue32
    1116:1127:neureka.Tsr setValue(java.lang.Object) -> setValue
    1131:1135:java.lang.Object getValue() -> getValue
    1139:1141:double[] gradient64() -> gradient64
    1145:1147:float[] gradient32() -> gradient32
    1151:1156:neureka.Tsr addToGradient(neureka.Tsr) -> addToGradient
    1160:1167:neureka.Tsr to32() -> to32
    1171:1178:neureka.Tsr to64() -> to64
    1182:1188:double value64(int) -> value64
    1193:1202:double[] value64() -> value64
    1206:1212:float value32(int) -> value32
    1217:1225:float[] value32() -> value32
    1233:1233:java.lang.String toString(java.lang.String) -> toString
    1237:1299:java.lang.String _toString(java.lang.String,java.lang.String) -> _toString
    1303:1315:java.lang.String _stringified(double[],boolean,int) -> a
    1319:1319:java.lang.String toString() -> toString
    1324:1340:void makeFit(neureka.Tsr[]) -> makeFit
    1388:1388:void update(neureka.Tsr,neureka.Tsr) -> update
    23:23:void update(java.lang.Object,java.lang.Object) -> update
    1293:1295:void lambda$_toString$18(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1275:1285:void lambda$_toString$17(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1154:1154:void lambda$addToGradient$16(neureka.Tsr,neureka.acceleration.Device) -> a
    1152:1152:void lambda$addToGradient$15(neureka.Tsr,neureka.Tsr) -> a
    787:787:void lambda$isCase$14(neureka.Tsr,boolean[],neureka.framing.Relation) -> a
    788:789:void lambda$isCase$13(neureka.Tsr,boolean[],neureka.Tsr) -> a
    697:703:void lambda$applyGradient$12(neureka.Tsr) -> b
    697:697:void lambda$applyGradient$11(neureka.optimization.Optimizer) -> a
    661:661:void lambda$backward$10(neureka.Tsr,neureka.autograd.GraphNode) -> a
    404:404:neureka.Tsr[] lambda$new$9(int) -> a
    388:388:neureka.Tsr[] lambda$new$8(int) -> b
    341:341:void lambda$delete$7(neureka.acceleration.Device) -> a
    337:340:void lambda$delete$6(neureka.autograd.GraphNode) -> a
    207:207:void lambda$_addOrReject$5(neureka.Tsr) -> c
    205:205:void lambda$_addOrReject$4(neureka.Tsr) -> d
    136:136:void lambda$setIsVirtual$3(neureka.Tsr) -> e
    97:107:void lambda$setIsOutsourced$2(neureka.acceleration.Device) -> b
    102:102:void lambda$setIsOutsourced$1(neureka.Tsr) -> f
    103:105:void lambda$setIsOutsourced$0(neureka.Tsr,neureka.acceleration.Device) -> b
    23:23:neureka.ndim.config.NDConfiguration access$002(neureka.Tsr,neureka.ndim.config.NDConfiguration) -> a
    23:23:neureka.ndim.config.NDConfiguration access$100(neureka.Tsr) -> a
    25:25:void <clinit>() -> <clinit>
neureka.Tsr$Create -> neureka.Tsr$Create:
    1344:1344:void <init>() -> <init>
    1347:1347:neureka.Tsr E(int[]) -> E
    1351:1351:neureka.Tsr newRandom(int[]) -> newRandom
    1355:1356:neureka.Tsr newRandom(int[],long) -> newRandom
    1360:1364:neureka.Tsr newTsrLike(neureka.Tsr,double) -> newTsrLike
    1368:1372:neureka.Tsr newTsrLike(neureka.Tsr) -> newTsrLike
    1376:1378:neureka.Tsr _newEmptyLike(neureka.Tsr) -> a
neureka.Tsr$IO -> neureka.Tsr$IO:
    1021:1021:void <init>() -> <init>
    1024:1026:double getFrom(neureka.Tsr,int) -> getFrom
    1030:1031:double getFrom(neureka.Tsr,int[]) -> getFrom
    1035:1037:void setInto(neureka.Tsr,int,double) -> setInto
    1040:1042:void setInto(neureka.Tsr,int[],double) -> setInto
    1045:1047:void addInto(neureka.Tsr,int,double) -> addInto
    1050:1052:void addInto(neureka.Tsr,int[],double) -> addInto
    1055:1057:neureka.Tsr addInto(neureka.Tsr,neureka.Tsr) -> addInto
    1061:1063:void subInto(neureka.Tsr,int,double) -> subInto
    1066:1068:void subInto(neureka.Tsr,int[],double) -> subInto
    1071:1082:void subInto(neureka.Tsr,neureka.Tsr) -> subInto
    1085:1087:void mulInto(neureka.Tsr,int,double) -> mulInto
    1090:1092:void mulInto(neureka.Tsr,int[],double) -> mulInto
neureka.acceleration.AbstractDevice -> neureka.acceleration.AbstractDevice:
    java.lang.ref.Cleaner _CLEANER -> a
    11:11:void <init>() -> <init>
    void _enqueue(neureka.Tsr[],int,neureka.calculus.backend.operations.OperationType) -> _enqueue
    19:20:void update(neureka.Tsr,neureka.Tsr) -> update
    24:25:neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    29:30:void _cleaning(java.lang.Object,java.lang.Runnable) -> _cleaning
    35:47:neureka.acceleration.Device execute(neureka.calculus.backend.ExecutionCall) -> execute
    11:11:void update(java.lang.Object,java.lang.Object) -> update
    45:45:void lambda$execute$0(neureka.calculus.backend.ExecutionCall) -> a
    13:13:void <clinit>() -> <clinit>
neureka.acceleration.Device -> neureka.acceleration.Device:
    31:62:neureka.acceleration.Device find(java.lang.String) -> find
    void dispose() -> dispose
    neureka.acceleration.Device get(neureka.Tsr) -> get
    neureka.acceleration.Device add(neureka.Tsr) -> add
    neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    boolean has(neureka.Tsr) -> has
    neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    neureka.acceleration.Device execute(neureka.calculus.backend.ExecutionCall) -> execute
    double[] value64f(neureka.Tsr) -> value64f
    float[] value32f(neureka.Tsr) -> value32f
    double value64f(neureka.Tsr,int) -> value64f
    float value32f(neureka.Tsr,int) -> value32f
    java.util.Collection tensors() -> tensors
neureka.acceleration.host.HostCPU -> neureka.acceleration.host.HostCPU:
    neureka.acceleration.host.HostCPU _instance -> a
    neureka.acceleration.host.HostCPU$NativeExecutor _executor -> b
    24:26:void <init>() -> <init>
    29:29:neureka.acceleration.host.HostCPU instance() -> instance
    33:33:neureka.acceleration.host.HostCPU$NativeExecutor getExecutor() -> getExecutor
    39:47:void _enqueue(neureka.Tsr[],int,neureka.calculus.backend.operations.OperationType) -> _enqueue
    51:52:void dispose() -> dispose
    56:56:neureka.acceleration.Device get(neureka.Tsr) -> get
    61:61:neureka.acceleration.Device add(neureka.Tsr) -> add
    66:66:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    71:71:boolean has(neureka.Tsr) -> has
    76:76:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    81:81:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    86:86:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    91:91:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    96:96:double[] value64f(neureka.Tsr) -> value64f
    101:101:float[] value32f(neureka.Tsr) -> value32f
    106:106:double value64f(neureka.Tsr,int) -> value64f
    111:111:float value32f(neureka.Tsr,int) -> value32f
    116:116:java.util.Collection tensors() -> tensors
    19:20:void <clinit>() -> <clinit>
neureka.acceleration.host.HostCPU$NativeExecutor -> neureka.acceleration.host.HostCPU$NativeExecutor:
    java.util.concurrent.ThreadPoolExecutor _pool -> a
    123:127:void <init>(neureka.acceleration.host.HostCPU) -> <init>
    131:131:java.util.concurrent.ThreadPoolExecutor getPool() -> getPool
    138:162:void threaded(int,neureka.acceleration.host.HostCPU$Range) -> threaded
    148:150:void lambda$threaded$0(neureka.Neureka,neureka.acceleration.host.HostCPU$Range,int,int) -> a
neureka.acceleration.host.HostCPU$Range -> neureka.acceleration.host.HostCPU$Range:
    void execute(int,int) -> execute
neureka.acceleration.host.execution.HostExecutor -> neureka.acceleration.host.execution.HostExecutor:
    neureka.calculus.backend.executions.ExecutorFor$ExecutionOn _creator -> a
    int _arity -> b
    18:21:void <init>(neureka.calculus.backend.executions.ExecutorFor$ExecutionOn,int) -> <init>
    26:26:neureka.calculus.backend.executions.ExecutorFor$ExecutionOn getExecution() -> getExecution
    31:31:int arity() -> arity
neureka.acceleration.opencl.KernelBuilder -> neureka.acceleration.opencl.KernelBuilder:
    org.jocl.cl_command_queue _queue -> a
    org.jocl.cl_kernel _kernel -> b
    int _argId -> c
    java.util.List _inputs -> d
    18:23:void <init>(org.jocl.cl_kernel,org.jocl.cl_command_queue) -> <init>
    32:37:neureka.acceleration.opencl.KernelBuilder pass(neureka.Tsr) -> pass
    41:43:neureka.acceleration.opencl.KernelBuilder pass(int) -> pass
    47:49:neureka.acceleration.opencl.KernelBuilder pass(float) -> pass
    54:69:void call(int) -> call
    1081:1088:org.jocl.cl_event[] _getWaitList(neureka.Tsr[]):81:88 -> call
    1081:1088:void call(int):54 -> call
    72:78:void _releaseEvents(neureka.Tsr[]) -> a
neureka.acceleration.opencl.OpenCLDevice -> neureka.acceleration.opencl.OpenCLDevice:
    java.util.Set _tensors -> a
    org.jocl.cl_device_id _did -> b
    neureka.acceleration.opencl.OpenCLPlatform _platform -> c
    org.jocl.cl_command_queue _queue -> d
    47:47:org.jocl.cl_device_id CLDeviceID() -> CLDeviceID
    42:84:void <init>(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> <init>
    87:88:neureka.acceleration.opencl.OpenCLDevice instance(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> instance
    96:99:java.util.Collection tensors() -> tensors
    104:106:void dispose() -> dispose
    110:114:neureka.acceleration.Device get(neureka.Tsr) -> get
    119:123:neureka.acceleration.Device add(neureka.Tsr) -> add
    128:132:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    137:218:void _add(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr) -> a
    222:222:boolean has(neureka.Tsr) -> has
    226:264:void _store(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr,int) -> a
    269:274:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    288:306:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    331:351:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    356:361:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    366:367:double[] value64f(neureka.Tsr) -> value64f
    371:386:double[] _value64f(neureka.acceleration.opencl.OpenCLDevice$cl_tsr,int,int) -> a
    392:393:float[] value32f(neureka.Tsr) -> value32f
    398:413:float[] _value32f(neureka.acceleration.opencl.OpenCLDevice$cl_tsr,int,int) -> b
    419:420:double value64f(neureka.Tsr,int) -> value64f
    425:426:float value32f(neureka.Tsr,int) -> value32f
    430:432:neureka.acceleration.opencl.KernelBuilder getKernel(neureka.calculus.backend.ExecutionCall) -> getKernel
    438:447:void _enqueue(neureka.Tsr[],int,neureka.calculus.backend.operations.OperationType) -> _enqueue
    450:450:java.lang.String name() -> name
    454:454:java.lang.String vendor() -> vendor
    458:458:java.lang.String version() -> version
    462:471:java.lang.String type() -> type
    475:475:int maxComputeUnits() -> maxComputeUnits
    479:479:long maxWorkItemSimensions() -> maxWorkItemSimensions
    483:483:long[] maxWorkItemSizes() -> maxWorkItemSizes
    487:487:long maxWorkGroupSize() -> maxWorkGroupSize
    491:491:long maxClockFrequenzy() -> maxClockFrequenzy
    495:495:int maxAddressBits() -> maxAddressBits
    499:499:long maxMemAllocSize() -> maxMemAllocSize
    503:503:long globalMemSize() -> globalMemSize
    507:507:int errorCorrectionSupport() -> errorCorrectionSupport
    511:511:int localMemType() -> localMemType
    515:515:long localMemSize() -> localMemSize
    519:519:long maxConstantBufferSize() -> maxConstantBufferSize
    523:523:long maxConstantBufferSizeKB() -> maxConstantBufferSizeKB
    537:537:int imageSupport() -> imageSupport
    541:541:int maxReadImageArgs() -> maxReadImageArgs
    545:545:int maxWriteImageArgs() -> maxWriteImageArgs
    549:549:long singleFPConfig() -> singleFPConfig
    553:553:long image2DMaxWidth() -> image2DMaxWidth
    557:557:long image2DMaxHeight() -> image2DMaxHeight
    561:561:long image3DMaxWidth() -> image3DMaxWidth
    565:565:long image3DMaxHeight() -> image3DMaxHeight
    569:569:long image3DMaxDepth() -> image3DMaxDepth
    573:573:int prefVecWidthChar() -> prefVecWidthChar
    577:577:int prefVecWidthShort() -> prefVecWidthShort
    581:581:int prefVecWidthInt() -> prefVecWidthInt
    585:585:int prefVecWidthLong() -> prefVecWidthLong
    589:589:int prefVecWidthFloat() -> prefVecWidthFloat
    593:593:int prefVecWidthDouble() -> prefVecWidthDouble
    153:155:void lambda$_add$3(org.jocl.cl_event,org.jocl.cl_mem) -> a
    140:140:void lambda$_add$2(org.jocl.cl_mem) -> a
    98:98:void lambda$tensors$1(java.util.Collection,java.util.Collection) -> a
    98:98:void lambda$tensors$0(java.util.Collection,neureka.Tsr) -> a
neureka.acceleration.opencl.OpenCLDevice$DeviceQuery -> neureka.acceleration.opencl.OpenCLDevice$DeviceQuery:
    596:596:void <init>() -> <init>
    605:605:int getInt(org.jocl.cl_device_id,int) -> getInt
    617:619:int[] getInts(org.jocl.cl_device_id,int,int) -> getInts
    630:630:long getLong(org.jocl.cl_device_id,int) -> getLong
    642:644:long[] getLongs(org.jocl.cl_device_id,int,int) -> getLongs
    656:664:java.lang.String getString(org.jocl.cl_device_id,int) -> getString
    676:684:java.lang.String getString(org.jocl.cl_platform_id,int) -> getString
    695:695:long getSize(org.jocl.cl_device_id,int) -> getSize
    709:723:long[] getSizes(org.jocl.cl_device_id,int,int) -> getSizes
neureka.acceleration.opencl.OpenCLDevice$cl_config -> neureka.acceleration.opencl.OpenCLDevice$a:
    org.jocl.cl_mem data -> a
    27:27:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLDevice$cl_tsr -> neureka.acceleration.opencl.OpenCLDevice$b:
    int fp -> a
    neureka.acceleration.opencl.OpenCLDevice$cl_config config -> b
    neureka.acceleration.opencl.OpenCLDevice$cl_value value -> c
    31:33:void <init>() -> <init>
    31:31:void update(java.lang.Object,java.lang.Object) -> update
neureka.acceleration.opencl.OpenCLDevice$cl_value -> neureka.acceleration.opencl.OpenCLDevice$c:
    org.jocl.cl_mem data -> a
    int size -> b
    org.jocl.cl_event event -> c
    21:23:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLPlatform -> neureka.acceleration.opencl.OpenCLPlatform:
    org.jocl.cl_platform_id _pid -> a
    java.util.Map _id_device -> b
    org.jocl.cl_context _context -> c
    java.util.Map _kernels -> d
    23:52:void <init>(org.jocl.cl_platform_id) -> <init>
    55:59:void recompile() -> recompile
    64:158:void _compile(org.jocl.cl_device_id[]) -> a
    162:162:org.jocl.cl_platform_id getID() -> getID
    166:168:java.util.List getDevices() -> getDevices
    172:172:boolean has(org.jocl.cl_device_id) -> has
    176:176:neureka.acceleration.opencl.OpenCLDevice get(org.jocl.cl_device_id) -> get
    180:181:void put(org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> put
    184:184:java.util.Map getKernels() -> getKernels
    188:188:org.jocl.cl_context getContext() -> getContext
    192:192:java.util.List PLATFORMS() -> PLATFORMS
    167:167:void lambda$getDevices$1(java.util.List,org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> a
    125:127:void lambda$_compile$0(java.util.ArrayList,java.util.ArrayList,java.lang.String,java.lang.String) -> a
neureka.acceleration.opencl.OpenCLPlatform$_setup -> neureka.acceleration.opencl.OpenCLPlatform$a:
    java.util.List PLATFORMS -> a
    197:197:void <clinit>() -> <clinit>
    1202:1211:java.util.List findAllPlatforms():202:211 -> <clinit>
    1202:1211:void <clinit>():197 -> <clinit>
neureka.acceleration.opencl.execution.CLExecutor -> neureka.acceleration.opencl.execution.CLExecutor:
    java.util.function.Function _aliasSwapper -> a
    java.util.function.Function asAdvanced -> b
    java.lang.String _source -> c
    java.lang.String _name -> d
    neureka.calculus.backend.executions.ExecutorFor$ExecutionOn _lambda -> e
    int _arity -> f
    48:48:java.lang.String getSource() -> getSource
    51:51:java.lang.String getName() -> getName
    56:56:neureka.calculus.backend.executions.ExecutorFor$ExecutionOn getExecution() -> getExecution
    61:61:int arity() -> arity
    19:70:void <init>(neureka.calculus.backend.executions.ExecutorFor$ExecutionOn,int) -> <init>
    19:105:void <init>(neureka.calculus.backend.executions.ExecutorFor$ExecutionOn,int,java.lang.String,java.lang.String,java.lang.String,neureka.calculus.backend.operations.AbstractOperationType) -> <init>
    1118:1146:java.util.Map _getParsedKernelsFromTemplate(java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.calculus.backend.operations.AbstractOperationType):118:146 -> <init>
    1118:1146:void <init>(neureka.calculus.backend.executions.ExecutorFor$ExecutionOn,int,java.lang.String,java.lang.String,java.lang.String,neureka.calculus.backend.operations.AbstractOperationType):94 -> <init>
    124:134:void lambda$_getParsedKernelsFromTemplate$2(java.lang.String[],java.lang.String,java.util.Map,java.lang.String,java.lang.String,java.lang.String) -> a
    36:39:java.lang.String lambda$new$1(java.lang.String) -> a
    21:31:java.lang.String lambda$new$0(java.lang.String) -> b
neureka.acceleration.opencl.execution.CLExecutor$Parser -> neureka.acceleration.opencl.execution.CLExecutor$a:
    void apply(java.lang.String,java.lang.String,java.lang.String) -> apply
neureka.acceleration.opencl.utility.DeviceQuery -> neureka.acceleration.opencl.utility.DeviceQuery:
    14:14:void <init>() -> <init>
    23:182:java.lang.String query() -> query
    1270:1278:java.lang.String getString(org.jocl.cl_platform_id,int):270:278 -> query
    1270:1278:java.lang.String query():38 -> query
    194:194:int getInt(org.jocl.cl_device_id,int) -> a
    207:209:int[] getInts(org.jocl.cl_device_id,int,int) -> a
    221:221:long getLong(org.jocl.cl_device_id,int) -> b
    234:236:long[] getLongs(org.jocl.cl_device_id,int,int) -> b
    249:257:java.lang.String getString(org.jocl.cl_device_id,int) -> c
    290:290:long getSize(org.jocl.cl_device_id,int) -> d
    305:324:long[] getSizes(org.jocl.cl_device_id,int,int) -> c
neureka.acceleration.opencl.utility.WeakTensorReference -> neureka.acceleration.opencl.utility.WeakTensorReference:
    int _hash -> a
    24:26:void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    30:30:int hashCode() -> hashCode
    35:35:boolean equals(java.lang.Object) -> equals
neureka.autograd.ADAgent -> neureka.autograd.ADAgent:
    neureka.autograd.ADAgent$ADAction _fad -> a
    neureka.autograd.ADAgent$ADAction _bad -> b
    java.util.Map _context -> c
    19:23:void <init>(neureka.Tsr) -> <init>
    26:27:neureka.autograd.ADAgent withForward(neureka.autograd.ADAgent$ADAction) -> withForward
    31:32:neureka.autograd.ADAgent withBackward(neureka.autograd.ADAgent$ADAction) -> withBackward
    36:36:neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    40:40:neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    44:44:neureka.Tsr derivative() -> derivative
    48:48:boolean isForward() -> isForward
    53:59:java.lang.String toString() -> toString
neureka.autograd.ADAgent$ADAction -> neureka.autograd.ADAgent$ADAction:
    neureka.Tsr execute(neureka.autograd.GraphNode,neureka.Tsr) -> execute
neureka.autograd.GraphLock -> neureka.autograd.GraphLock:
    neureka.calculus.Function _owner -> a
    boolean _is_locked -> b
    22:31:void <init>(neureka.calculus.Function,neureka.Tsr[]) -> <init>
    37:37:boolean isLocked() -> isLocked
    45:46:void release() -> release
    53:53:java.lang.String toString() -> toString
neureka.autograd.GraphNode -> neureka.autograd.GraphNode:
    neureka.calculus.Function MUL -> a
    int _mode -> b
    boolean _allows_forward -> c
    boolean _relies_on_JIPProp -> d
    neureka.autograd.PendingError _pending_error -> e
    boolean _is_used_as_derivative -> f
    neureka.calculus.Function _function -> g
    neureka.autograd.GraphNode[] _parents -> h
    java.lang.ref.WeakReference _payload -> i
    int _reference_payload_version -> j
    java.util.TreeMap _targets_derivatives -> k
    neureka.autograd.GraphLock _lock -> l
    java.util.List _children -> m
    long _nid -> n
    51:51:boolean usesAD() -> usesAD
    60:60:boolean usesForwardAD() -> usesForwardAD
    69:69:boolean usesReverseAD() -> usesReverseAD
    104:104:boolean reliesOnJustInTimeProp() -> reliesOnJustInTimeProp
    119:121:neureka.autograd.PendingError getAndRemovePendingError() -> getAndRemovePendingError
    130:130:neureka.autograd.PendingError getPendingError() -> getPendingError
    143:143:boolean isUsedAsDerivative() -> isUsedAsDerivative
    154:154:neureka.calculus.Function getFunction() -> getFunction
    167:167:neureka.autograd.GraphNode[] getParents() -> getParents
    196:196:neureka.Tsr getPayload() -> getPayload
    200:217:void _setPayload(neureka.Tsr) -> a
    221:222:void update(neureka.Tsr,neureka.Tsr) -> update
    236:236:int referenceVersion() -> referenceVersion
    257:257:neureka.autograd.GraphLock lock() -> lock
    268:268:java.util.List getChildren() -> getChildren
    277:280:void _attachChild(neureka.autograd.GraphNode) -> a
    288:288:long nid() -> nid
    300:300:boolean isCachable() -> isCachable
    309:310:void obtainLocking(neureka.autograd.GraphLock) -> obtainLocking
    318:318:boolean isLeave() -> isLeave
    322:326:boolean isGraphLeave() -> isGraphLeave
    333:333:boolean isVirtual() -> isVirtual
    107:383:void <init>(neureka.calculus.Function,java.lang.Object,java.util.function.Supplier) -> <init>
    387:519:void _construct(neureka.Tsr,neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,neureka.autograd.GraphLock) -> a
    534:552:int _modeOf(neureka.calculus.backend.ExecutionCall,neureka.calculus.Function) -> a
    563:568:void _migrateAndOrApplyError(neureka.Tsr,java.util.function.Consumer) -> a
    581:593:void backward(neureka.Tsr) -> backward
    611:633:void _backward(neureka.Tsr,java.util.Set,boolean) -> a
    645:653:void _carryPendingBackPropToGradients(java.util.Set) -> a
    669:671:void backwardJIT(neureka.Tsr) -> backwardJIT
    674:700:void _backwardJIT(neureka.Tsr,neureka.autograd.GraphNode) -> a
    712:716:void _deleteDerivativesRecursively() -> a
    724:733:int _numberOfReverseModeADChildren() -> b
    740:740:int mode() -> mode
    747:747:neureka.calculus.Function function() -> function
    755:763:void put(neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> put
    772:773:java.util.List get(neureka.autograd.GraphNode) -> get
    784:785:boolean has(neureka.autograd.GraphNode) -> has
    795:795:int size() -> size
    802:806:void forEachDerivative(java.util.function.BiConsumer) -> forEachDerivative
    812:818:void forEachBackward(neureka.Tsr,java.util.function.BiConsumer) -> forEachBackward
    824:831:void forEachForward(neureka.Tsr,java.util.function.BiConsumer) -> forEachForward
    837:839:void forEachTarget(java.util.function.Consumer) -> forEachTarget
    845:856:void forEachTargetAgentPair(java.util.function.BiConsumer) -> forEachTargetAgentPair
    863:863:boolean hasDerivatives() -> hasDerivatives
    870:875:java.lang.String type() -> type
    880:880:java.lang.String toString() -> toString
    888:895:java.lang.String toString(java.lang.String) -> toString
    911:924:java.lang.String _toString(java.lang.String,boolean) -> a
    28:28:void update(java.lang.Object,java.lang.Object) -> update
    849:849:void lambda$forEachTargetAgentPair$17(java.util.function.BiConsumer,neureka.autograd.GraphNode,java.util.List) -> a
    850:850:void lambda$forEachTargetAgentPair$16(java.util.function.BiConsumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    838:838:void lambda$forEachTarget$15(java.util.function.Consumer,neureka.autograd.GraphNode,java.util.List) -> a
    826:830:void lambda$forEachForward$14(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,java.util.List) -> a
    814:817:void lambda$forEachBackward$13(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,java.util.List) -> b
    804:804:void lambda$forEachDerivative$12(java.util.function.BiConsumer,neureka.autograd.GraphNode,java.util.List) -> b
    804:804:void lambda$forEachDerivative$11(java.util.function.BiConsumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> b
    755:755:int lambda$put$10(neureka.autograd.GraphNode,neureka.autograd.GraphNode) -> a
    697:697:void lambda$_backwardJIT$9(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> a
    696:696:void lambda$_backwardJIT$8(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> b
    676:681:void lambda$_backwardJIT$7(neureka.autograd.GraphNode,neureka.Tsr) -> a
    646:646:void lambda$_carryPendingBackPropToGradients$6(java.util.Set,neureka.autograd.GraphNode) -> a
    630:630:void lambda$_backward$5(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> a
    629:629:void lambda$_backward$4(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> b
    587:590:void lambda$backward$3(neureka.autograd.GraphNode) -> b
    584:584:void lambda$backward$2(java.util.Set,neureka.autograd.GraphNode) -> b
    454:491:void lambda$_construct$1(neureka.Tsr,neureka.calculus.backend.ExecutionCall,neureka.calculus.Function,int,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    205:215:void lambda$_setPayload$0() -> c
    30:31:void <clinit>() -> <clinit>
neureka.autograd.JITProp -> neureka.autograd.JITProp:
    java.util.Set _finished -> a
    java.util.Set _pending -> b
    16:20:void <init>(java.util.Set) -> <init>
    27:30:void addPending(java.util.Set) -> addPending
    37:46:void noteFinished(neureka.autograd.GraphNode) -> noteFinished
    49:49:int finishedCount() -> finishedCount
    53:53:int pendingCount() -> pendingCount
    61:71:void execute() -> execute
    78:78:boolean isDone() -> isDone
    86:88:java.lang.String toString() -> toString
    95:95:void update(neureka.Tsr,neureka.Tsr) -> update
    10:10:void update(java.lang.Object,java.lang.Object) -> update
    63:68:void lambda$execute$0(neureka.autograd.GraphNode) -> a
neureka.autograd.PendingError -> neureka.autograd.PendingError:
    int _toBeReceived -> a
    neureka.Tsr _error -> b
    11:14:void <init>(neureka.Tsr,int) -> <init>
    17:21:void accumulate(neureka.Tsr) -> accumulate
    24:24:boolean isFullyAccumulated() -> isFullyAccumulated
    28:28:int getToBeReceived() -> getToBeReceived
    32:32:neureka.Tsr getAccumulatedError() -> getAccumulatedError
neureka.calculus.Function -> neureka.calculus.Function:
    neureka.calculus.frontend.Cache CACHE -> CACHE
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    60:60:neureka.calculus.Function create(java.lang.String) -> create
    64:64:neureka.calculus.Function create(java.lang.String,boolean) -> create
    neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    boolean doesAD() -> doesAD
    boolean isFlat() -> isFlat
    int id() -> id
    neureka.calculus.backend.operations.OperationType type() -> type
    boolean dependsOn(int) -> dependsOn
    double call(double) -> call
    double invoke(double) -> invoke
    double call(double[],int) -> call
    double invoke(double[],int) -> invoke
    double call(double[]) -> call
    double invoke(double[]) -> invoke
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    neureka.Tsr call(neureka.Tsr) -> call
    neureka.Tsr invoke(neureka.Tsr) -> invoke
    neureka.Tsr call(java.util.List) -> call
    neureka.Tsr invoke(java.util.List) -> invoke
    neureka.Tsr call(neureka.Tsr[],int) -> call
    neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    neureka.Tsr call(neureka.Tsr[]) -> call
    neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    neureka.Tsr derive(neureka.Tsr[],int) -> derive
    neureka.Tsr derive(java.util.List,int,int) -> derive
    neureka.Tsr derive(java.util.List,int) -> derive
    java.lang.String toString() -> toString
    17:34:void <clinit>() -> <clinit>
neureka.calculus.Function$Detached -> neureka.calculus.Function$Detached:
    neureka.calculus.Function IDY -> IDY
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function ADD -> ADD
    neureka.calculus.Function ADD_ASSIGN -> ADD_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    37:37:void <init>() -> <init>
    39:56:void <clinit>() -> <clinit>
neureka.calculus.Function$Setup -> neureka.calculus.Function$Setup:
    67:67:void <init>() -> <init>
    70:70:neureka.Tsr commit(neureka.Tsr[],java.lang.String,boolean) -> commit
    74:74:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],java.lang.String,boolean) -> commit
    78:78:neureka.Tsr commit(neureka.Tsr[],neureka.calculus.Function) -> commit
    82:82:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function) -> commit
    87:110:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier) -> commit
    92:92:neureka.Tsr lambda$commit$0(neureka.Tsr) -> a
neureka.calculus.backend.ExecutionCall -> neureka.calculus.backend.ExecutionCall:
    neureka.acceleration.Device _device -> a
    neureka.Tsr[] _tensors -> b
    int _d -> c
    int _j -> d
    neureka.calculus.backend.operations.OperationType _type -> e
    neureka.calculus.backend.implementations.OperationTypeImplementation _implementation -> f
    java.util.Map _context -> g
    boolean $assertionsDisabled -> h
    29:47:void <init>(neureka.acceleration.Device,neureka.Tsr[],int,neureka.calculus.backend.operations.OperationType) -> <init>
    29:62:void <init>(neureka.acceleration.Device,neureka.Tsr[],int,int,neureka.calculus.backend.operations.OperationType) -> <init>
    65:65:int getJ() -> getJ
    68:68:neureka.acceleration.Device getDevice() -> getDevice
    70:70:neureka.Tsr[] getTensors() -> getTensors
    72:72:neureka.Tsr getTensor(int) -> getTensor
    74:74:int getDerivativeIndex() -> getDerivativeIndex
    76:76:neureka.calculus.backend.operations.OperationType getType() -> getType
    79:81:neureka.calculus.backend.implementations.OperationTypeImplementation getImplementation() -> getImplementation
    85:85:boolean allowsForward() -> allowsForward
    89:95:neureka.autograd.ADAgent getADAgentFrom(neureka.calculus.Function,neureka.Tsr,neureka.calculus.backend.ExecutionCall,boolean) -> getADAgentFrom
    99:100:void mutateArguments(neureka.calculus.backend.ExecutionCall$Mutator) -> mutateArguments
    103:103:neureka.calculus.backend.ExecutionCall withNew(neureka.Tsr[]) -> withNew
    107:107:neureka.calculus.backend.ExecutionCall withNew(neureka.acceleration.Device) -> withNew
    111:112:java.lang.Object getAt(java.lang.Class) -> getAt
    116:117:java.lang.Object getAt(java.lang.String) -> getAt
    121:123:neureka.calculus.backend.ExecutionCall putAt(java.lang.String,neureka.Tsr) -> putAt
    127:127:java.util.Map getContext() -> getContext
    131:133:void takeContext(java.util.Map) -> takeContext
    20:20:void <clinit>() -> <clinit>
neureka.calculus.backend.ExecutionCall$Mutator -> neureka.calculus.backend.ExecutionCall$Mutator:
    neureka.Tsr[] mutate(neureka.Tsr[]) -> mutate
neureka.calculus.backend.executions.ExecutorFor -> neureka.calculus.backend.executions.ExecutorFor:
    neureka.calculus.backend.executions.ExecutorFor$ExecutionOn getExecution() -> getExecution
    int arity() -> arity
neureka.calculus.backend.executions.ExecutorFor$ExecutionOn -> neureka.calculus.backend.executions.ExecutorFor$ExecutionOn:
    void run(neureka.calculus.backend.ExecutionCall) -> run
neureka.calculus.backend.implementations.AbstractBaseOperationTypeImplementation -> neureka.calculus.backend.implementations.AbstractBaseOperationTypeImplementation:
    java.lang.String _name -> a
    java.util.Map _executions -> _executions
    17:19:void <init>(java.lang.String) -> <init>
    24:24:java.lang.String getName() -> getName
    33:70:neureka.Tsr recursiveReductionOf(neureka.calculus.backend.ExecutionCall,java.util.function.Consumer) -> recursiveReductionOf
    78:82:java.lang.Object setExecutor(java.lang.Class,neureka.calculus.backend.executions.ExecutorFor) -> setExecutor
    87:87:neureka.calculus.backend.executions.ExecutorFor getExecutor(java.lang.Class) -> getExecutor
    58:58:neureka.Tsr lambda$recursiveReductionOf$1(java.util.function.Consumer,neureka.calculus.backend.ExecutionCall) -> a
    44:44:void lambda$recursiveReductionOf$0(neureka.Tsr) -> a
neureka.calculus.backend.implementations.AbstractFunctionalOperationTypeImplementation -> neureka.calculus.backend.implementations.AbstractFunctionalOperationTypeImplementation:
    neureka.calculus.backend.implementations.OperationTypeImplementation$SuitabilityChecker _suitabilityChecker -> a
    neureka.calculus.backend.implementations.OperationTypeImplementation$DeviceFinder _finder -> b
    neureka.calculus.backend.implementations.OperationTypeImplementation$ADAnalyzer _analyzer -> c
    neureka.calculus.backend.implementations.OperationTypeImplementation$ADAgentSupplier _adaCreator -> d
    neureka.calculus.backend.implementations.OperationTypeImplementation$InitialCallHook _hook -> e
    neureka.calculus.backend.implementations.OperationTypeImplementation$RecursiveJunctionAgent _RJAgent -> f
    neureka.calculus.backend.implementations.OperationTypeImplementation$DrainInstantiation _instantiation -> g
    38:39:void <init>(java.lang.String) -> <init>
    45:45:boolean isImplementationSuitableFor(neureka.calculus.backend.ExecutionCall) -> isImplementationSuitableFor
    49:50:java.lang.Object setSuitabilityChecker(neureka.calculus.backend.implementations.OperationTypeImplementation$SuitabilityChecker) -> setSuitabilityChecker
    57:57:neureka.acceleration.Device findDeviceFor(neureka.calculus.backend.ExecutionCall) -> findDeviceFor
    61:62:java.lang.Object setDeviceFinder(neureka.calculus.backend.implementations.OperationTypeImplementation$DeviceFinder) -> setDeviceFinder
    69:69:boolean canImplementationPerformADFor(neureka.calculus.backend.ExecutionCall) -> canImplementationPerformADFor
    73:73:neureka.calculus.backend.implementations.OperationTypeImplementation$ADAnalyzer getADAnalyzer() -> getADAnalyzer
    77:78:java.lang.Object setADAnalyzer(neureka.calculus.backend.implementations.OperationTypeImplementation$ADAnalyzer) -> setADAnalyzer
    85:85:neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> supplyADAgentFor
    89:89:neureka.calculus.backend.implementations.OperationTypeImplementation$ADAgentSupplier getADAgentSupplier() -> getADAgentSupplier
    93:94:java.lang.Object setADAgentSupplier(neureka.calculus.backend.implementations.OperationTypeImplementation$ADAgentSupplier) -> setADAgentSupplier
    102:102:neureka.Tsr handleInsteadOfDevice(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> handleInsteadOfDevice
    106:106:neureka.calculus.backend.implementations.OperationTypeImplementation$InitialCallHook getCallHook() -> getCallHook
    110:111:java.lang.Object setCallHock(neureka.calculus.backend.implementations.OperationTypeImplementation$InitialCallHook) -> setCallHock
    119:119:neureka.Tsr handleRecursivelyAccordingToArity(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> handleRecursivelyAccordingToArity
    123:123:neureka.calculus.backend.implementations.OperationTypeImplementation$RecursiveJunctionAgent getRJAgent() -> getRJAgent
    127:128:java.lang.Object setRJAgent(neureka.calculus.backend.implementations.OperationTypeImplementation$RecursiveJunctionAgent) -> setRJAgent
    135:135:neureka.calculus.backend.ExecutionCall instantiateNewTensorsForExecutionIn(neureka.calculus.backend.ExecutionCall) -> instantiateNewTensorsForExecutionIn
    139:139:neureka.calculus.backend.implementations.OperationTypeImplementation$DrainInstantiation getDrainInstantiation() -> getDrainInstantiation
    143:144:java.lang.Object setDrainInstantiation(neureka.calculus.backend.implementations.OperationTypeImplementation$DrainInstantiation) -> setDrainInstantiation
neureka.calculus.backend.implementations.OperationTypeImplementation -> neureka.calculus.backend.implementations.OperationTypeImplementation:
    java.lang.String getName() -> getName
    boolean isImplementationSuitableFor(neureka.calculus.backend.ExecutionCall) -> isImplementationSuitableFor
    neureka.acceleration.Device findDeviceFor(neureka.calculus.backend.ExecutionCall) -> findDeviceFor
    boolean canImplementationPerformADFor(neureka.calculus.backend.ExecutionCall) -> canImplementationPerformADFor
    neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> supplyADAgentFor
    neureka.Tsr handleInsteadOfDevice(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> handleInsteadOfDevice
    neureka.Tsr handleRecursivelyAccordingToArity(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> handleRecursivelyAccordingToArity
    neureka.calculus.backend.ExecutionCall instantiateNewTensorsForExecutionIn(neureka.calculus.backend.ExecutionCall) -> instantiateNewTensorsForExecutionIn
    neureka.Tsr recursiveReductionOf(neureka.calculus.backend.ExecutionCall,java.util.function.Consumer) -> recursiveReductionOf
    java.lang.Object setExecutor(java.lang.Class,neureka.calculus.backend.executions.ExecutorFor) -> setExecutor
    neureka.calculus.backend.executions.ExecutorFor getExecutor(java.lang.Class) -> getExecutor
neureka.calculus.backend.implementations.OperationTypeImplementation$ADAgentSupplier -> neureka.calculus.backend.implementations.OperationTypeImplementation$ADAgentSupplier:
    neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> getADAgentOf
neureka.calculus.backend.implementations.OperationTypeImplementation$ADAnalyzer -> neureka.calculus.backend.implementations.OperationTypeImplementation$ADAnalyzer:
    boolean allowsForward(neureka.calculus.backend.ExecutionCall) -> allowsForward
neureka.calculus.backend.implementations.OperationTypeImplementation$DeviceFinder -> neureka.calculus.backend.implementations.OperationTypeImplementation$DeviceFinder:
    neureka.acceleration.Device findFor(neureka.calculus.backend.ExecutionCall) -> findFor
neureka.calculus.backend.implementations.OperationTypeImplementation$DrainInstantiation -> neureka.calculus.backend.implementations.OperationTypeImplementation$DrainInstantiation:
    neureka.calculus.backend.ExecutionCall handle(neureka.calculus.backend.ExecutionCall) -> handle
neureka.calculus.backend.implementations.OperationTypeImplementation$InitialCallHook -> neureka.calculus.backend.implementations.OperationTypeImplementation$InitialCallHook:
    neureka.Tsr handle(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> handle
neureka.calculus.backend.implementations.OperationTypeImplementation$RecursiveJunctionAgent -> neureka.calculus.backend.implementations.OperationTypeImplementation$RecursiveJunctionAgent:
    neureka.Tsr handle(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> handle
neureka.calculus.backend.implementations.OperationTypeImplementation$SuitabilityChecker -> neureka.calculus.backend.implementations.OperationTypeImplementation$SuitabilityChecker:
    boolean canHandle(neureka.calculus.backend.ExecutionCall) -> canHandle
neureka.calculus.backend.implementations.functional.Activation -> neureka.calculus.backend.implementations.functional.Activation:
    13:15:void <init>() -> <init>
    18:18:java.lang.String getKernelSource() -> getKernelSource
    27:40:void activate(neureka.Tsr,int,int,neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer) -> activate
    14:14:boolean lambda$new$0(neureka.calculus.backend.ExecutionCall) -> a
neureka.calculus.backend.implementations.functional.Broadcast -> neureka.calculus.backend.implementations.functional.Broadcast:
    13:33:void <init>() -> <init>
    36:36:java.lang.String getKernelSource() -> getKernelSource
    45:127:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer) -> broadcast
    17:30:boolean lambda$new$0(neureka.calculus.backend.ExecutionCall) -> a
neureka.calculus.backend.implementations.functional.Convolution -> neureka.calculus.backend.implementations.functional.Convolution:
    13:15:void <init>() -> <init>
    19:19:java.lang.String getKernelSource() -> getKernelSource
    28:163:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer) -> convolve
    14:14:boolean lambda$new$0(neureka.calculus.backend.ExecutionCall) -> a
neureka.calculus.backend.implementations.functional.GenericImplementation -> neureka.calculus.backend.implementations.functional.GenericImplementation:
    8:9:void <init>(java.lang.String) -> <init>
neureka.calculus.backend.implementations.functional.Operator -> neureka.calculus.backend.implementations.functional.Operator:
    12:20:void <init>() -> <init>
    23:23:java.lang.String getKernelSource() -> getKernelSource
    33:47:void operate(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer) -> operate
    15:17:boolean lambda$new$0(neureka.calculus.backend.ExecutionCall) -> a
neureka.calculus.backend.implementations.functional.Scalarization -> neureka.calculus.backend.implementations.functional.Scalarization:
    13:15:void <init>() -> <init>
    19:19:java.lang.String getKernelSource() -> getKernelSource
    29:40:void scalarize(neureka.Tsr,int,int,neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer) -> scalarize
    14:14:boolean lambda$new$0(neureka.calculus.backend.ExecutionCall) -> a
neureka.calculus.backend.operations.AbstractOperationType -> neureka.calculus.backend.operations.AbstractOperationType:
    neureka.calculus.backend.operations.OperationType$Stringifier _stringifier -> a
    int _id -> _id
    java.lang.String _function -> _function
    java.lang.String _operator -> _operator
    int _arity -> _arity
    boolean _isOperator -> _isOperator
    boolean _isIndexer -> _isIndexer
    boolean _isCommutative -> _isCommutative
    boolean _isAssociative -> _isAssociative
    java.util.Map _implementations -> b
    39:181:void <init>(java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    187:187:neureka.calculus.backend.implementations.AbstractFunctionalOperationTypeImplementation getImplementation(java.lang.Class) -> getImplementation
    191:191:boolean supportsImplementation(java.lang.Class) -> supportsImplementation
    195:196:neureka.calculus.backend.operations.OperationType setImplementation(java.lang.Class,neureka.calculus.backend.implementations.AbstractFunctionalOperationTypeImplementation) -> setImplementation
    201:202:neureka.calculus.backend.operations.OperationType forEachImplementation(java.util.function.Consumer) -> forEachImplementation
    209:210:neureka.calculus.backend.operations.OperationType setStringifier(neureka.calculus.backend.operations.OperationType$Stringifier) -> setStringifier
    215:215:neureka.calculus.backend.operations.OperationType$Stringifier getStringifier() -> getStringifier
    222:225:neureka.calculus.backend.implementations.OperationTypeImplementation implementationOf(neureka.calculus.backend.ExecutionCall) -> implementationOf
    232:232:java.lang.String getFunction() -> getFunction
    237:237:java.lang.String getOperator() -> getOperator
    242:242:int getId() -> getId
    247:247:int getArity() -> getArity
    252:252:boolean isOperator() -> isOperator
    257:257:boolean isIndexer() -> isIndexer
    262:262:boolean isCommutative() -> isCommutative
    267:267:boolean supports(java.lang.Class) -> supports
    160:176:void lambda$new$1(neureka.calculus.backend.ExecutionCall) -> a
    168:174:void lambda$new$0(double[],neureka.calculus.backend.ExecutionCall,neureka.calculus.Function,int,int) -> a
neureka.calculus.backend.operations.AbstractOperationType$1 -> neureka.calculus.backend.operations.AbstractOperationType$1:
    79:79:void <init>(neureka.calculus.backend.operations.AbstractOperationType,java.lang.String) -> <init>
    82:87:boolean isImplementationSuitableFor(neureka.calculus.backend.ExecutionCall) -> isImplementationSuitableFor
    92:92:neureka.acceleration.Device findDeviceFor(neureka.calculus.backend.ExecutionCall) -> findDeviceFor
    97:97:boolean canImplementationPerformADFor(neureka.calculus.backend.ExecutionCall) -> canImplementationPerformADFor
    103:127:neureka.autograd.ADAgent supplyADAgentFor(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> supplyADAgentFor
    133:133:neureka.Tsr handleInsteadOfDevice(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> handleInsteadOfDevice
    139:139:neureka.Tsr handleRecursivelyAccordingToArity(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> handleRecursivelyAccordingToArity
    144:154:neureka.calculus.backend.ExecutionCall instantiateNewTensorsForExecutionIn(neureka.calculus.backend.ExecutionCall) -> instantiateNewTensorsForExecutionIn
    127:127:neureka.Tsr lambda$supplyADAgentFor$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    126:126:neureka.Tsr lambda$supplyADAgentFor$2(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    119:119:neureka.Tsr lambda$supplyADAgentFor$1(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    108:108:neureka.Tsr lambda$supplyADAgentFor$0(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
neureka.calculus.backend.operations.OperationContext -> neureka.calculus.backend.operations.OperationContext:
    java.lang.ThreadLocal _INSTANCES -> a
    java.util.Map _LOOKUP -> b
    java.util.ArrayList _REGISTER -> c
    int _ID -> d
    68:68:neureka.calculus.backend.operations.OperationContext instance() -> instance
    72:73:void setInstance(neureka.calculus.backend.operations.OperationContext) -> setInstance
    79:83:void <init>() -> <init>
    89:89:java.util.Map getLookup() -> getLookup
    96:96:java.util.List getRegister() -> getRegister
    103:103:int getID() -> getID
    107:108:void incrementID() -> incrementID
    111:111:java.util.List instances() -> instances
    115:115:neureka.calculus.backend.operations.AbstractOperationType instance(int) -> instance
    119:119:neureka.calculus.backend.operations.AbstractOperationType instance(java.lang.String) -> instance
    125:129:neureka.calculus.backend.operations.OperationContext clone() -> clone
    30:30:java.lang.Object clone() -> clone
    32:32:neureka.calculus.backend.operations.OperationContext lambda$static$0() -> a
    32:62:void <clinit>() -> <clinit>
neureka.calculus.backend.operations.OperationType -> neureka.calculus.backend.operations.OperationType:
    16:16:java.util.List instances() -> instances
    20:20:neureka.calculus.backend.operations.AbstractOperationType instance(int) -> instance
    24:24:neureka.calculus.backend.operations.AbstractOperationType[] ALL() -> ALL
    28:28:int COUNT() -> COUNT
    33:33:neureka.calculus.backend.operations.AbstractOperationType instance(java.lang.String) -> instance
    neureka.calculus.backend.implementations.OperationTypeImplementation implementationOf(neureka.calculus.backend.ExecutionCall) -> implementationOf
    java.lang.String getFunction() -> getFunction
    neureka.calculus.backend.implementations.AbstractFunctionalOperationTypeImplementation getImplementation(java.lang.Class) -> getImplementation
    boolean supportsImplementation(java.lang.Class) -> supportsImplementation
    neureka.calculus.backend.operations.OperationType setImplementation(java.lang.Class,neureka.calculus.backend.implementations.AbstractFunctionalOperationTypeImplementation) -> setImplementation
    neureka.calculus.backend.operations.OperationType forEachImplementation(java.util.function.Consumer) -> forEachImplementation
    neureka.calculus.backend.operations.OperationType setStringifier(neureka.calculus.backend.operations.OperationType$Stringifier) -> setStringifier
    neureka.calculus.backend.operations.OperationType$Stringifier getStringifier() -> getStringifier
    int getId() -> getId
    java.lang.String getOperator() -> getOperator
    int getArity() -> getArity
    boolean isOperator() -> isOperator
    boolean isIndexer() -> isIndexer
    boolean isCommutative() -> isCommutative
    boolean supports(java.lang.Class) -> supports
    double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator -> neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator:
    java.lang.Object create(neureka.Tsr[],int) -> create
neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer -> neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer:
    double execute(int[]) -> execute
neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator -> neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator:
    java.lang.Object create(neureka.Tsr[],double,int) -> create
neureka.calculus.backend.operations.OperationType$SecondaryNDXConsumer -> neureka.calculus.backend.operations.OperationType$SecondaryNDXConsumer:
    double execute(int[],int[]) -> execute
neureka.calculus.backend.operations.OperationType$Stringifier -> neureka.calculus.backend.operations.OperationType$Stringifier:
    java.lang.String asString(java.util.List) -> asString
neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer -> neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer:
    double execute(int[],int[],int[]) -> execute
neureka.calculus.backend.operations.OperationType$Utility -> neureka.calculus.backend.operations.OperationType$Utility:
    112:112:void <init>() -> <init>
    114:120:neureka.Tsr[] _subset(neureka.Tsr[],int,int,int) -> _subset
    124:126:neureka.Tsr[] _without(neureka.Tsr[],int) -> _without
    130:142:neureka.Tsr[] _offsetted(neureka.Tsr[],int) -> _offsetted
neureka.calculus.backend.operations.OperationTypeFactory -> neureka.calculus.backend.operations.OperationTypeFactory:
    java.lang.String _name -> a
    java.lang.String _identifier -> b
    java.lang.Integer _arity -> c
    java.lang.Boolean _isOperator -> d
    java.lang.Boolean _isIndexer -> e
    java.lang.Boolean _isCommutative -> f
    java.lang.Boolean _isAssociative -> g
    10:21:void <init>() -> <init>
    24:52:neureka.calculus.backend.operations.AbstractOperationType create() -> create
neureka.calculus.backend.operations.OperationTypeFactory$1 -> neureka.calculus.backend.operations.OperationTypeFactory$1:
    45:45:void <init>(neureka.calculus.backend.operations.OperationTypeFactory,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    48:48:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.convolution.XMultiplication -> neureka.calculus.backend.operations.convolution.XMultiplication:
    23:278:void <init>() -> <init>
    283:283:double calculate(double[],int,int,java.util.List) -> calculate
    264:271:java.lang.String lambda$new$17(java.util.List) -> a
    238:245:java.lang.String lambda$new$16(java.util.List) -> b
    203:212:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    184:186:void lambda$new$14(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    188:192:void lambda$new$13(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    163:173:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> b
    136:157:neureka.Tsr lambda$new$11(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    114:130:neureka.autograd.ADAgent lambda$new$10(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    131:131:neureka.Tsr lambda$new$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    129:129:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    102:109:boolean lambda$new$7(neureka.calculus.backend.ExecutionCall) -> c
    87:92:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$6(neureka.Tsr[],int) -> a
    93:94:double lambda$new$5(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    90:90:double lambda$new$4(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    48:81:neureka.Tsr lambda$new$3(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    79:79:neureka.Tsr[] lambda$new$2(neureka.Tsr[]) -> a
    76:76:neureka.Tsr[] lambda$new$1(neureka.Tsr[]) -> b
    35:42:java.lang.String lambda$new$0(java.util.List) -> c
neureka.calculus.backend.operations.convolution.XMultiplication$1 -> neureka.calculus.backend.operations.convolution.XMultiplication$1:
    228:228:void <init>(neureka.calculus.backend.operations.convolution.XMultiplication,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    232:232:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.convolution.XMultiplication$2 -> neureka.calculus.backend.operations.convolution.XMultiplication$2:
    256:256:void <init>(neureka.calculus.backend.operations.convolution.XMultiplication,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    259:259:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.function.Absolute -> neureka.calculus.backend.operations.function.Absolute:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _activationCreator -> a
    18:151:void <init>() -> <init>
    155:158:double calculate(double[],int,int,java.util.List) -> calculate
    163:164:double calculate(double,boolean) -> calculate
    134:142:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    118:120:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> b
    122:125:void lambda$new$13(neureka.calculus.backend.ExecutionCall,int,int) -> a
    98:108:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> c
    95:95:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    93:93:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    52:86:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    87:87:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    85:85:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    73:73:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    60:60:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    42:47:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> d
    31:35:java.lang.String lambda$new$3(java.util.List) -> a
    20:22:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    22:22:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    21:21:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.backend.operations.function.Cosinus -> neureka.calculus.backend.operations.function.Cosinus:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    18:158:void <init>() -> <init>
    162:165:double calculate(double[],int,int,java.util.List) -> calculate
    170:171:double calculate(double,boolean) -> calculate
    140:148:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    124:126:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> b
    128:131:void lambda$new$13(neureka.calculus.backend.ExecutionCall,int,int) -> a
    104:114:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> c
    101:101:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    99:99:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    60:93:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    94:94:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    92:92:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    81:81:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    68:68:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    50:55:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> d
    39:43:java.lang.String lambda$new$3(java.util.List) -> a
    20:22:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    22:22:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    21:21:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.backend.operations.function.Gaussian -> neureka.calculus.backend.operations.function.Gaussian:
    21:166:void <init>() -> <init>
    170:173:double calculate(double[],int,int,java.util.List) -> calculate
    178:179:double calculate(double,boolean) -> calculate
    141:149:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    125:127:void lambda$new$14(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    129:132:void lambda$new$13(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    105:115:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> b
    102:102:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    100:100:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    61:94:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    95:95:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    93:93:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    82:82:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    69:69:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    51:56:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> c
    36:40:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$3(neureka.Tsr[],int) -> a
    41:42:double lambda$new$2(double[],neureka.Tsr[],int[],int[],int[]) -> a
    38:38:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> b
    25:29:java.lang.String lambda$new$0(java.util.List) -> a
neureka.calculus.backend.operations.function.Identity -> neureka.calculus.backend.operations.function.Identity:
    23:266:void <init>() -> <init>
    270:273:double calculate(double[],int,int,java.util.List) -> calculate
    278:279:double calculate(double,boolean) -> calculate
    246:255:void lambda$new$30(neureka.calculus.backend.ExecutionCall) -> a
    227:239:void lambda$new$29(neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    232:235:void lambda$new$28(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,double,int,int) -> a
    208:218:neureka.calculus.backend.ExecutionCall lambda$new$27(neureka.calculus.backend.ExecutionCall) -> b
    205:205:neureka.Tsr lambda$new$26(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    203:203:neureka.Tsr lambda$new$25(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    164:197:neureka.autograd.ADAgent lambda$new$24(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    198:198:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    196:196:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    185:185:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    172:172:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    154:159:boolean lambda$new$19(neureka.calculus.backend.ExecutionCall) -> c
    148:149:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$18(neureka.Tsr[],double,int) -> a
    149:149:double lambda$new$17(double,int[]) -> a
    148:148:double lambda$new$16(double,int[]) -> b
    126:136:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> d
    110:112:void lambda$new$14(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    114:117:void lambda$new$13(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    99:101:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> e
    96:96:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> b
    94:94:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    55:88:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    89:89:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    87:87:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    76:76:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    63:63:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    45:50:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> f
    37:39:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$3(neureka.Tsr[],int) -> a
    39:39:double lambda$new$2(int[],int[],int[]) -> a
    38:38:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    27:31:java.lang.String lambda$new$0(java.util.List) -> a
neureka.calculus.backend.operations.function.Ligmoid -> neureka.calculus.backend.operations.function.Ligmoid:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    20:172:void <init>() -> <init>
    176:179:double calculate(double[],int,int,java.util.List) -> calculate
    184:185:double calculate(double,boolean) -> calculate
    136:144:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    120:122:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> b
    124:127:void lambda$new$13(neureka.calculus.backend.ExecutionCall,int,int) -> a
    98:108:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> c
    95:95:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    93:93:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    54:87:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    88:88:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    86:86:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    75:75:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    62:62:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    44:49:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> d
    33:37:java.lang.String lambda$new$3(java.util.List) -> a
    22:24:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    24:24:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    23:23:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.backend.operations.function.Quadratic -> neureka.calculus.backend.operations.function.Quadratic:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    19:167:void <init>() -> <init>
    171:174:double calculate(double[],int,int,java.util.List) -> calculate
    179:180:double calculate(double,boolean) -> calculate
    148:156:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    132:134:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> b
    136:139:void lambda$new$13(neureka.calculus.backend.ExecutionCall,int,int) -> a
    112:122:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> c
    109:109:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    107:107:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    65:100:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    101:101:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    99:99:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    86:86:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    73:73:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    55:60:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> d
    44:48:java.lang.String lambda$new$3(java.util.List) -> a
    21:27:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    27:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.backend.operations.function.ReLU -> neureka.calculus.backend.operations.function.ReLU:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    19:168:void <init>() -> <init>
    172:175:double calculate(double[],int,int,java.util.List) -> calculate
    181:188:double calculate(double,boolean) -> calculate
    149:157:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    133:135:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> b
    137:140:void lambda$new$13(neureka.calculus.backend.ExecutionCall,int,int) -> a
    113:123:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> c
    110:110:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    109:109:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    70:103:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    104:104:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    102:102:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    91:91:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    78:78:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    60:65:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> d
    49:53:java.lang.String lambda$new$3(java.util.List) -> a
    21:28:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    29:30:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.backend.operations.function.Sigmoid -> neureka.calculus.backend.operations.function.Sigmoid:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    19:174:void <init>() -> <init>
    178:181:double calculate(double[],int,int,java.util.List) -> calculate
    186:189:double calculate(double,boolean) -> calculate
    153:161:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    137:139:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> b
    141:144:void lambda$new$13(neureka.calculus.backend.ExecutionCall,int,int) -> a
    116:126:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> c
    113:113:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    111:111:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    69:104:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    105:105:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    103:103:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    90:90:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    77:77:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    59:64:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> d
    48:52:java.lang.String lambda$new$3(java.util.List) -> a
    21:25:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    26:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    23:23:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.backend.operations.function.Sinus -> neureka.calculus.backend.operations.function.Sinus:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    19:157:void <init>() -> <init>
    161:164:double calculate(double[],int,int,java.util.List) -> calculate
    169:170:double calculate(double,boolean) -> calculate
    136:144:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    120:122:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> b
    124:127:void lambda$new$13(neureka.calculus.backend.ExecutionCall,int,int) -> a
    100:110:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> c
    97:97:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    95:95:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    53:88:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    89:89:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    87:87:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    74:74:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    61:61:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    43:48:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> d
    32:36:java.lang.String lambda$new$3(java.util.List) -> a
    21:23:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    23:23:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.backend.operations.function.Tanh -> neureka.calculus.backend.operations.function.Tanh:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    19:175:void <init>() -> <init>
    179:182:double calculate(double[],int,int,java.util.List) -> calculate
    187:191:double calculate(double,boolean) -> calculate
    154:162:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> a
    138:140:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> b
    142:145:void lambda$new$13(neureka.calculus.backend.ExecutionCall,int,int) -> a
    118:128:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> c
    115:115:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    113:113:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    71:106:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    107:107:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    105:105:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    92:92:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    79:79:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    61:66:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> d
    50:54:java.lang.String lambda$new$3(java.util.List) -> a
    22:29:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$2(neureka.Tsr[],int) -> a
    30:31:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    25:26:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.backend.operations.indexer.Product -> neureka.calculus.backend.operations.indexer.Product:
    26:334:void <init>() -> <init>
    340:360:double calculate(double[],int,int,java.util.List) -> calculate
    366:385:double calculate(double[],int,java.util.List) -> calculate
    313:321:void lambda$new$30(neureka.calculus.backend.ExecutionCall) -> a
    297:299:void lambda$new$29(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    301:304:void lambda$new$28(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    278:288:neureka.calculus.backend.ExecutionCall lambda$new$27(neureka.calculus.backend.ExecutionCall) -> b
    273:273:neureka.Tsr lambda$new$26(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    216:266:neureka.autograd.ADAgent lambda$new$25(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    267:267:neureka.Tsr lambda$new$24(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    265:265:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    256:256:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    254:254:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    237:237:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    224:224:neureka.Tsr lambda$new$19(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    212:212:boolean lambda$new$18(neureka.calculus.backend.ExecutionCall) -> c
    205:207:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$17(neureka.Tsr[],int) -> a
    207:207:double lambda$new$16(double[],neureka.Tsr[],int[],int[],int[]) -> a
    206:206:double lambda$new$15(double[],neureka.Tsr[],int[],int[],int[]) -> b
    181:190:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> d
    162:164:void lambda$new$13(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> b
    166:172:void lambda$new$12(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> b
    142:152:neureka.calculus.backend.ExecutionCall lambda$new$11(neureka.calculus.backend.ExecutionCall) -> e
    137:137:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    108:131:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    132:132:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    130:130:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    116:116:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    104:104:boolean lambda$new$5(neureka.calculus.backend.ExecutionCall) -> f
    90:95:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$4(neureka.Tsr[],int) -> b
    96:97:double lambda$new$3(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    93:93:double lambda$new$2(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    48:79:neureka.Tsr lambda$new$1(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    38:42:java.lang.String lambda$new$0(java.util.List) -> a
neureka.calculus.backend.operations.indexer.Summation -> neureka.calculus.backend.operations.indexer.Summation:
    26:326:void <init>() -> <init>
    330:343:double calculate(double[],int,int,java.util.List) -> calculate
    349:371:double calculate(double[],int,java.util.List) -> calculate
    305:316:void lambda$new$30(neureka.calculus.backend.ExecutionCall) -> a
    289:291:void lambda$new$29(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    293:296:void lambda$new$28(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    270:280:neureka.calculus.backend.ExecutionCall lambda$new$27(neureka.calculus.backend.ExecutionCall) -> b
    265:265:neureka.Tsr lambda$new$26(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    208:258:neureka.autograd.ADAgent lambda$new$25(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    259:259:neureka.Tsr lambda$new$24(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    257:257:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    248:248:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    246:246:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    229:229:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    216:216:neureka.Tsr lambda$new$19(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    204:204:boolean lambda$new$18(neureka.calculus.backend.ExecutionCall) -> c
    197:199:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$17(neureka.Tsr[],int) -> a
    199:199:double lambda$new$16(double[],neureka.Tsr[],int[],int[],int[]) -> a
    198:198:double lambda$new$15(double[],neureka.Tsr[],int[],int[],int[]) -> b
    172:181:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> d
    153:155:void lambda$new$13(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> b
    157:163:void lambda$new$12(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> b
    132:142:neureka.calculus.backend.ExecutionCall lambda$new$11(neureka.calculus.backend.ExecutionCall) -> e
    127:127:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    95:121:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    122:122:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    120:120:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    103:103:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    91:91:boolean lambda$new$5(neureka.calculus.backend.ExecutionCall) -> f
    83:86:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$4(neureka.Tsr[],int) -> b
    86:86:double lambda$new$3(int[],int[],int[]) -> a
    85:85:double lambda$new$2(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    49:73:neureka.Tsr lambda$new$1(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    39:43:java.lang.String lambda$new$0(java.util.List) -> a
neureka.calculus.backend.operations.operator.Addition -> neureka.calculus.backend.operations.operator.Addition:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    neureka.calculus.backend.implementations.functional.Broadcast _broadcast -> b
    95:552:void <init>() -> <init>
    560:573:double calculate(double[],int,int,java.util.List) -> calculate
    579:591:double calculate(double[],int,java.util.List) -> calculate
    523:530:java.lang.String lambda$new$53(java.util.List) -> a
    516:518:neureka.calculus.backend.ExecutionCall lambda$new$52(neureka.calculus.backend.ExecutionCall) -> a
    513:513:neureka.Tsr lambda$new$51(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    511:511:neureka.Tsr lambda$new$50(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    479:505:neureka.autograd.ADAgent lambda$new$49(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    506:506:neureka.Tsr lambda$new$48(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    504:504:neureka.Tsr lambda$new$47(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    487:487:neureka.Tsr lambda$new$46(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    469:474:boolean lambda$new$45(neureka.calculus.backend.ExecutionCall) -> b
    416:425:void lambda$new$44(neureka.calculus.backend.ExecutionCall) -> c
    398:409:void lambda$new$43(neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    403:406:void lambda$new$42(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,double,int,int) -> a
    384:388:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$41(neureka.Tsr[],double,int) -> a
    388:388:double lambda$new$40(int[]) -> a
    387:387:double lambda$new$39(int[]) -> b
    385:385:double lambda$new$38(double[],neureka.Tsr[],double,int[]) -> a
    368:378:neureka.calculus.backend.ExecutionCall lambda$new$37(neureka.calculus.backend.ExecutionCall) -> d
    363:363:neureka.Tsr lambda$new$36(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    324:357:neureka.autograd.ADAgent lambda$new$35(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    358:358:neureka.Tsr lambda$new$34(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    356:356:neureka.Tsr lambda$new$33(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    345:345:neureka.Tsr lambda$new$32(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    332:332:neureka.Tsr lambda$new$31(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    319:319:boolean lambda$new$30(neureka.calculus.backend.ExecutionCall) -> e
    295:304:void lambda$new$29(neureka.calculus.backend.ExecutionCall) -> f
    279:281:void lambda$new$28(neureka.calculus.backend.ExecutionCall) -> g
    283:286:void lambda$new$27(neureka.calculus.backend.ExecutionCall,int,int) -> a
    251:260:void lambda$new$26(neureka.calculus.backend.ExecutionCall) -> h
    232:234:void lambda$new$25(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    236:242:void lambda$new$24(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    211:221:neureka.calculus.backend.ExecutionCall lambda$new$23(neureka.calculus.backend.ExecutionCall) -> i
    206:206:neureka.Tsr lambda$new$22(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> c
    164:199:neureka.autograd.ADAgent lambda$new$21(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> c
    200:200:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    198:198:neureka.Tsr lambda$new$19(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    185:185:neureka.Tsr lambda$new$18(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    172:172:neureka.Tsr lambda$new$17(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    160:160:boolean lambda$new$16(neureka.calculus.backend.ExecutionCall) -> j
    153:156:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$15(neureka.Tsr[],int) -> a
    156:156:double lambda$new$14(int[]) -> c
    155:155:double lambda$new$13(double[],neureka.Tsr[],double[],int[]) -> a
    120:144:neureka.Tsr lambda$new$12(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> b
    107:114:java.lang.String lambda$new$11(java.util.List) -> b
    79:89:neureka.calculus.backend.ExecutionCall lambda$static$10(neureka.calculus.backend.ExecutionCall) -> k
    76:76:neureka.Tsr lambda$static$9(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> c
    74:74:neureka.Tsr lambda$static$8(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> d
    44:67:neureka.autograd.ADAgent lambda$static$7(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> d
    68:68:neureka.Tsr lambda$static$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    66:66:neureka.Tsr lambda$static$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> m
    52:52:neureka.Tsr lambda$static$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> n
    34:39:boolean lambda$static$3(neureka.calculus.backend.ExecutionCall) -> l
    25:28:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> b
    28:28:double lambda$static$1(int[],int[],int[]) -> a
    27:27:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    23:77:void <clinit>() -> <clinit>
neureka.calculus.backend.operations.operator.Addition$1 -> neureka.calculus.backend.operations.operator.Addition$1:
    440:440:void <init>(neureka.calculus.backend.operations.operator.Addition,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    443:443:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Addition$2 -> neureka.calculus.backend.operations.operator.Addition$2:
    449:449:void <init>(neureka.calculus.backend.operations.operator.Addition,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    452:452:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Addition$3 -> neureka.calculus.backend.operations.operator.Addition$3:
    460:460:void <init>(neureka.calculus.backend.operations.operator.Addition,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    463:463:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Addition$4 -> neureka.calculus.backend.operations.operator.Addition$4:
    536:536:void <init>(neureka.calculus.backend.operations.operator.Addition,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    539:539:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Addition$5 -> neureka.calculus.backend.operations.operator.Addition$5:
    544:544:void <init>(neureka.calculus.backend.operations.operator.Addition,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    547:547:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Division -> neureka.calculus.backend.operations.operator.Division:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    44:611:void <init>() -> <init>
    619:637:double calculate(double[],int,int,java.util.List) -> calculate
    643:664:double calculate(double[],int,java.util.List) -> calculate
    600:607:java.lang.String lambda$new$51(java.util.List) -> a
    581:588:java.lang.String lambda$new$50(java.util.List) -> b
    561:568:java.lang.String lambda$new$49(java.util.List) -> c
    554:556:neureka.calculus.backend.ExecutionCall lambda$new$48(neureka.calculus.backend.ExecutionCall) -> a
    551:551:neureka.Tsr lambda$new$47(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    549:549:neureka.Tsr lambda$new$46(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    517:543:neureka.autograd.ADAgent lambda$new$45(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    544:544:neureka.Tsr lambda$new$44(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    542:542:neureka.Tsr lambda$new$43(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    525:525:neureka.Tsr lambda$new$42(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    507:512:boolean lambda$new$41(neureka.calculus.backend.ExecutionCall) -> b
    449:458:void lambda$new$40(neureka.calculus.backend.ExecutionCall) -> c
    431:442:void lambda$new$39(neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    436:439:void lambda$new$38(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,double,int,int) -> a
    411:421:neureka.calculus.backend.ExecutionCall lambda$new$37(neureka.calculus.backend.ExecutionCall) -> d
    406:406:neureka.Tsr lambda$new$36(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    367:400:neureka.autograd.ADAgent lambda$new$35(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    401:401:neureka.Tsr lambda$new$34(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    399:399:neureka.Tsr lambda$new$33(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    388:388:neureka.Tsr lambda$new$32(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    375:375:neureka.Tsr lambda$new$31(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    363:363:boolean lambda$new$30(neureka.calculus.backend.ExecutionCall) -> e
    352:357:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$29(neureka.Tsr[],double,int) -> a
    357:357:double lambda$new$28(double,double[],neureka.Tsr[],int[]) -> a
    356:356:double lambda$new$27(double,int[]) -> a
    354:354:double lambda$new$26(double[],neureka.Tsr[],double,int[]) -> a
    324:333:void lambda$new$25(neureka.calculus.backend.ExecutionCall) -> f
    308:310:void lambda$new$24(neureka.calculus.backend.ExecutionCall) -> g
    312:315:void lambda$new$23(neureka.calculus.backend.ExecutionCall,int,int) -> a
    288:298:neureka.calculus.backend.ExecutionCall lambda$new$22(neureka.calculus.backend.ExecutionCall) -> h
    283:283:neureka.Tsr lambda$new$21(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> c
    254:277:neureka.autograd.ADAgent lambda$new$20(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> c
    278:278:neureka.Tsr lambda$new$19(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    276:276:neureka.Tsr lambda$new$18(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    262:262:neureka.Tsr lambda$new$17(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    250:250:boolean lambda$new$16(neureka.calculus.backend.ExecutionCall) -> i
    221:230:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> j
    202:204:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> k
    206:212:void lambda$new$13(neureka.calculus.backend.ExecutionCall,int,int) -> b
    183:193:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> l
    178:178:neureka.Tsr lambda$new$11(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> d
    139:172:neureka.autograd.ADAgent lambda$new$10(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> d
    173:173:neureka.Tsr lambda$new$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    171:171:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    160:160:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> m
    147:147:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> n
    129:134:boolean lambda$new$5(neureka.calculus.backend.ExecutionCall) -> m
    67:119:neureka.Tsr lambda$new$4(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> b
    54:61:java.lang.String lambda$new$3(java.util.List) -> d
    26:31:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> a
    32:35:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    29:29:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    24:24:void <clinit>() -> <clinit>
neureka.calculus.backend.operations.operator.Division$1 -> neureka.calculus.backend.operations.operator.Division$1:
    478:478:void <init>(neureka.calculus.backend.operations.operator.Division,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    481:481:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Division$2 -> neureka.calculus.backend.operations.operator.Division$2:
    486:486:void <init>(neureka.calculus.backend.operations.operator.Division,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    489:489:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Division$3 -> neureka.calculus.backend.operations.operator.Division$3:
    497:497:void <init>(neureka.calculus.backend.operations.operator.Division,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    500:500:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Division$4 -> neureka.calculus.backend.operations.operator.Division$4:
    574:574:void <init>(neureka.calculus.backend.operations.operator.Division,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    577:577:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Division$5 -> neureka.calculus.backend.operations.operator.Division$5:
    593:593:void <init>(neureka.calculus.backend.operations.operator.Division,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    596:596:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Modulo -> neureka.calculus.backend.operations.operator.Modulo:
    24:455:void <init>() -> <init>
    461:469:double calculate(double[],int,java.util.List) -> calculate
    477:486:double calculate(double[],int,int,java.util.List) -> calculate
    411:420:void lambda$new$45(neureka.calculus.backend.ExecutionCall) -> a
    393:404:void lambda$new$44(neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    398:401:void lambda$new$43(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,double,int,int) -> a
    381:383:neureka.calculus.backend.ExecutionCall lambda$new$42(neureka.calculus.backend.ExecutionCall) -> b
    378:378:neureka.Tsr lambda$new$41(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    376:376:neureka.Tsr lambda$new$40(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    337:370:neureka.autograd.ADAgent lambda$new$39(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    371:371:neureka.Tsr lambda$new$38(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    369:369:neureka.Tsr lambda$new$37(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    358:358:neureka.Tsr lambda$new$36(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    345:345:neureka.Tsr lambda$new$35(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    327:332:boolean lambda$new$34(neureka.calculus.backend.ExecutionCall) -> c
    315:320:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$33(neureka.Tsr[],double,int) -> a
    320:320:double lambda$new$32(double,double[],neureka.Tsr[],int[]) -> a
    319:319:double lambda$new$31(double,int[]) -> a
    317:317:double lambda$new$30(double[],neureka.Tsr[],double,int[]) -> a
    287:296:void lambda$new$29(neureka.calculus.backend.ExecutionCall) -> d
    271:273:void lambda$new$28(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    275:278:void lambda$new$27(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    251:261:neureka.calculus.backend.ExecutionCall lambda$new$26(neureka.calculus.backend.ExecutionCall) -> e
    248:248:neureka.Tsr lambda$new$25(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> b
    246:246:neureka.Tsr lambda$new$24(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    217:240:neureka.autograd.ADAgent lambda$new$23(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    241:241:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    239:239:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    225:225:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    207:212:boolean lambda$new$19(neureka.calculus.backend.ExecutionCall) -> f
    186:191:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$18(neureka.Tsr[],int) -> a
    192:198:double lambda$new$17(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    189:189:double lambda$new$16(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    156:165:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> g
    137:139:void lambda$new$14(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> b
    141:147:void lambda$new$13(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> b
    117:127:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> h
    114:114:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> c
    112:112:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> c
    73:106:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> c
    107:107:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    105:105:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    94:94:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    81:81:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    63:68:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> i
    46:50:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$3(neureka.Tsr[],int) -> b
    51:54:double lambda$new$2(int,double[],neureka.Tsr[],double[],int[]) -> a
    48:48:double lambda$new$1(double[],neureka.Tsr[],double[],int[]) -> a
    30:37:java.lang.String lambda$new$0(java.util.List) -> a
neureka.calculus.backend.operations.operator.Modulo$1 -> neureka.calculus.backend.operations.operator.Modulo$1:
    441:441:void <init>(neureka.calculus.backend.operations.operator.Modulo,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    444:444:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Modulo$2 -> neureka.calculus.backend.operations.operator.Modulo$2:
    449:449:void <init>(neureka.calculus.backend.operations.operator.Modulo,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    452:452:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Multiplication -> neureka.calculus.backend.operations.operator.Multiplication:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    40:665:void <init>() -> <init>
    674:693:double calculate(double[],int,int,java.util.List) -> calculate
    699:717:double calculate(double[],int,java.util.List) -> calculate
    642:651:void lambda$new$67(neureka.calculus.backend.ExecutionCall) -> a
    626:628:void lambda$new$66(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    630:633:void lambda$new$65(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    607:609:neureka.calculus.backend.ExecutionCall lambda$new$64(neureka.calculus.backend.ExecutionCall) -> b
    604:604:neureka.Tsr lambda$new$63(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    602:602:neureka.Tsr lambda$new$62(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    573:596:neureka.autograd.ADAgent lambda$new$61(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    597:597:neureka.Tsr lambda$new$60(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    595:595:neureka.Tsr lambda$new$59(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    581:581:neureka.Tsr lambda$new$58(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    563:568:boolean lambda$new$57(neureka.calculus.backend.ExecutionCall) -> c
    541:550:void lambda$new$56(neureka.calculus.backend.ExecutionCall) -> d
    525:527:void lambda$new$55(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> b
    529:532:void lambda$new$54(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> b
    506:508:neureka.calculus.backend.ExecutionCall lambda$new$53(neureka.calculus.backend.ExecutionCall) -> e
    503:503:neureka.Tsr lambda$new$52(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> b
    501:501:neureka.Tsr lambda$new$51(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    472:495:neureka.autograd.ADAgent lambda$new$50(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    496:496:neureka.Tsr lambda$new$49(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    494:494:neureka.Tsr lambda$new$48(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    480:480:neureka.Tsr lambda$new$47(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    462:467:boolean lambda$new$46(neureka.calculus.backend.ExecutionCall) -> f
    454:456:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$45(neureka.Tsr[],int) -> a
    456:456:double lambda$new$44(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    426:435:void lambda$new$43(neureka.calculus.backend.ExecutionCall) -> g
    408:419:void lambda$new$42(neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    413:416:void lambda$new$41(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,double,int,int) -> a
    388:398:neureka.calculus.backend.ExecutionCall lambda$new$40(neureka.calculus.backend.ExecutionCall) -> h
    383:383:neureka.Tsr lambda$new$39(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> c
    341:376:neureka.autograd.ADAgent lambda$new$38(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> c
    377:377:neureka.Tsr lambda$new$37(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    375:375:neureka.Tsr lambda$new$36(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    362:362:neureka.Tsr lambda$new$35(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    349:349:neureka.Tsr lambda$new$34(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    337:337:boolean lambda$new$33(neureka.calculus.backend.ExecutionCall) -> i
    327:331:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$32(neureka.Tsr[],double,int) -> a
    331:331:double lambda$new$31(double[],neureka.Tsr[],int[]) -> a
    330:330:double lambda$new$30(double,int[]) -> a
    328:328:double lambda$new$29(double[],neureka.Tsr[],double,int[]) -> a
    300:309:void lambda$new$28(neureka.calculus.backend.ExecutionCall) -> j
    284:286:void lambda$new$27(neureka.calculus.backend.ExecutionCall) -> k
    288:291:void lambda$new$26(neureka.calculus.backend.ExecutionCall,int,int) -> a
    265:275:neureka.calculus.backend.ExecutionCall lambda$new$25(neureka.calculus.backend.ExecutionCall) -> l
    260:260:neureka.Tsr lambda$new$24(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> d
    231:254:neureka.autograd.ADAgent lambda$new$23(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> d
    255:255:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    253:253:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    239:239:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> m
    227:227:boolean lambda$new$19(neureka.calculus.backend.ExecutionCall) -> m
    202:211:void lambda$new$18(neureka.calculus.backend.ExecutionCall) -> n
    183:185:void lambda$new$17(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> c
    187:193:void lambda$new$16(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> c
    164:174:neureka.calculus.backend.ExecutionCall lambda$new$15(neureka.calculus.backend.ExecutionCall) -> o
    159:159:neureka.Tsr lambda$new$14(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> e
    120:153:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> e
    154:154:neureka.Tsr lambda$new$12(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> n
    152:152:neureka.Tsr lambda$new$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> o
    141:141:neureka.Tsr lambda$new$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> p
    128:128:neureka.Tsr lambda$new$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> q
    116:116:boolean lambda$new$8(neureka.calculus.backend.ExecutionCall) -> p
    100:107:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$7(neureka.Tsr[],int) -> b
    108:109:double lambda$new$6(int,double[],neureka.Tsr[],double[],int[]) -> a
    105:105:double lambda$new$5(double[],neureka.Tsr[],double[],int[]) -> a
    60:91:neureka.Tsr lambda$new$4(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> c
    47:54:java.lang.String lambda$new$3(java.util.List) -> a
    26:31:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> c
    32:33:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    29:29:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    24:24:void <clinit>() -> <clinit>
neureka.calculus.backend.operations.operator.Multiplication$1 -> neureka.calculus.backend.operations.operator.Multiplication$1:
    514:514:void <init>(neureka.calculus.backend.operations.operator.Multiplication,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    517:517:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Multiplication$2 -> neureka.calculus.backend.operations.operator.Multiplication$2:
    615:615:void <init>(neureka.calculus.backend.operations.operator.Multiplication,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    618:618:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Power -> neureka.calculus.backend.operations.operator.Power:
    neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator _creator -> a
    50:624:void <init>() -> <init>
    640:662:double calculate(double[],int,int,java.util.List) -> calculate
    668:693:double calculate(double[],int,java.util.List) -> calculate
    597:604:java.lang.String lambda$new$52(java.util.List) -> a
    590:592:neureka.calculus.backend.ExecutionCall lambda$new$51(neureka.calculus.backend.ExecutionCall) -> a
    587:587:neureka.Tsr lambda$new$50(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    585:585:neureka.Tsr lambda$new$49(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    553:579:neureka.autograd.ADAgent lambda$new$48(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    580:580:neureka.Tsr lambda$new$47(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    578:578:neureka.Tsr lambda$new$46(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    561:561:neureka.Tsr lambda$new$45(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    543:548:boolean lambda$new$44(neureka.calculus.backend.ExecutionCall) -> b
    487:496:void lambda$new$43(neureka.calculus.backend.ExecutionCall) -> c
    469:480:void lambda$new$42(neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    474:477:void lambda$new$41(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,double,int,int) -> a
    449:459:neureka.calculus.backend.ExecutionCall lambda$new$40(neureka.calculus.backend.ExecutionCall) -> d
    444:444:neureka.Tsr lambda$new$39(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    405:438:neureka.autograd.ADAgent lambda$new$38(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    439:439:neureka.Tsr lambda$new$37(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    437:437:neureka.Tsr lambda$new$36(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    426:426:neureka.Tsr lambda$new$35(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    413:413:neureka.Tsr lambda$new$34(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    401:401:boolean lambda$new$33(neureka.calculus.backend.ExecutionCall) -> e
    386:393:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$32(neureka.Tsr[],double,int) -> a
    393:393:double lambda$new$31(double[],neureka.Tsr[],double,int[]) -> a
    391:391:double lambda$new$30(double,double[],neureka.Tsr[],int[]) -> a
    388:388:double lambda$new$29(double[],neureka.Tsr[],double,int[]) -> b
    358:367:void lambda$new$28(neureka.calculus.backend.ExecutionCall) -> f
    342:344:void lambda$new$27(neureka.calculus.backend.ExecutionCall) -> g
    346:349:void lambda$new$26(neureka.calculus.backend.ExecutionCall,int,int) -> a
    322:332:neureka.calculus.backend.ExecutionCall lambda$new$25(neureka.calculus.backend.ExecutionCall) -> h
    317:317:neureka.Tsr lambda$new$24(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> c
    288:311:neureka.autograd.ADAgent lambda$new$23(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> c
    312:312:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    310:310:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    296:296:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    284:284:boolean lambda$new$19(neureka.calculus.backend.ExecutionCall) -> i
    254:265:void lambda$new$18(neureka.calculus.backend.ExecutionCall) -> j
    234:236:void lambda$new$17(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    238:244:void lambda$new$16(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    215:225:neureka.calculus.backend.ExecutionCall lambda$new$15(neureka.calculus.backend.ExecutionCall) -> k
    209:209:neureka.Tsr lambda$new$14(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> d
    170:203:neureka.autograd.ADAgent lambda$new$13(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> d
    204:204:neureka.Tsr lambda$new$12(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    202:202:neureka.Tsr lambda$new$11(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> l
    191:191:neureka.Tsr lambda$new$10(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> m
    178:178:neureka.Tsr lambda$new$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> n
    166:166:boolean lambda$new$8(neureka.calculus.backend.ExecutionCall) -> l
    96:158:neureka.Tsr lambda$new$7(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> b
    71:76:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$6(neureka.Tsr[],int) -> a
    78:88:double lambda$new$5(int,double[],neureka.Tsr[],double[],int[]) -> a
    74:74:double lambda$new$4(double[],neureka.Tsr[],double[],int[]) -> a
    55:62:java.lang.String lambda$new$3(java.util.List) -> b
    26:31:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$static$2(neureka.Tsr[],int) -> b
    32:42:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    29:29:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    24:24:void <clinit>() -> <clinit>
neureka.calculus.backend.operations.operator.Power$1 -> neureka.calculus.backend.operations.operator.Power$1:
    516:516:void <init>(neureka.calculus.backend.operations.operator.Power,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    519:519:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Power$2 -> neureka.calculus.backend.operations.operator.Power$2:
    522:522:void <init>(neureka.calculus.backend.operations.operator.Power,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    525:525:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Power$3 -> neureka.calculus.backend.operations.operator.Power$3:
    533:533:void <init>(neureka.calculus.backend.operations.operator.Power,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    536:536:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Power$4 -> neureka.calculus.backend.operations.operator.Power$4:
    608:608:void <init>(neureka.calculus.backend.operations.operator.Power,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    611:611:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Power$5 -> neureka.calculus.backend.operations.operator.Power$5:
    614:614:void <init>(neureka.calculus.backend.operations.operator.Power,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    617:617:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Subtraction -> neureka.calculus.backend.operations.operator.Subtraction:
    25:443:void <init>() -> <init>
    450:467:double calculate(double[],int,int,java.util.List) -> calculate
    473:489:double calculate(double[],int,java.util.List) -> calculate
    414:421:java.lang.String lambda$new$38(java.util.List) -> a
    366:376:neureka.calculus.backend.ExecutionCall lambda$new$37(neureka.calculus.backend.ExecutionCall) -> a
    361:361:neureka.Tsr lambda$new$36(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    332:355:neureka.autograd.ADAgent lambda$new$35(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    356:356:neureka.Tsr lambda$new$34(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    354:354:neureka.Tsr lambda$new$33(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    340:340:neureka.Tsr lambda$new$32(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    328:328:boolean lambda$new$31(neureka.calculus.backend.ExecutionCall) -> b
    298:307:void lambda$new$30(neureka.calculus.backend.ExecutionCall) -> c
    279:291:void lambda$new$29(neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    285:288:void lambda$new$28(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,double,int,int) -> a
    259:269:neureka.calculus.backend.ExecutionCall lambda$new$27(neureka.calculus.backend.ExecutionCall) -> d
    254:254:neureka.Tsr lambda$new$26(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    215:248:neureka.autograd.ADAgent lambda$new$25(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    249:249:neureka.Tsr lambda$new$24(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    247:247:neureka.Tsr lambda$new$23(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    236:236:neureka.Tsr lambda$new$22(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    223:223:neureka.Tsr lambda$new$21(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    211:211:boolean lambda$new$20(neureka.calculus.backend.ExecutionCall) -> e
    202:205:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$19(neureka.Tsr[],double,int) -> a
    205:205:double lambda$new$18(int[]) -> a
    205:205:double lambda$new$17(int[]) -> b
    203:203:double lambda$new$16(double[],neureka.Tsr[],double,int[]) -> a
    174:183:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> f
    155:157:void lambda$new$14(neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    159:165:void lambda$new$13(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$DefaultOperatorCreator,int,int) -> a
    135:145:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> g
    130:130:neureka.Tsr lambda$new$11(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> c
    91:124:neureka.autograd.ADAgent lambda$new$10(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> c
    125:125:neureka.Tsr lambda$new$9(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    123:123:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> i
    112:112:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> j
    99:99:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> k
    87:87:boolean lambda$new$5(neureka.calculus.backend.ExecutionCall) -> h
    78:82:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$4(neureka.Tsr[],int) -> a
    82:82:double lambda$new$3(int,int[]) -> a
    81:81:double lambda$new$2(double[],neureka.Tsr[],double[],int[]) -> a
    45:69:neureka.Tsr lambda$new$1(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    31:38:java.lang.String lambda$new$0(java.util.List) -> b
neureka.calculus.backend.operations.operator.Subtraction$1 -> neureka.calculus.backend.operations.operator.Subtraction$1:
    387:387:void <init>(neureka.calculus.backend.operations.operator.Subtraction,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    390:390:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Subtraction$2 -> neureka.calculus.backend.operations.operator.Subtraction$2:
    395:395:void <init>(neureka.calculus.backend.operations.operator.Subtraction,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    398:398:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Subtraction$3 -> neureka.calculus.backend.operations.operator.Subtraction$3:
    407:407:void <init>(neureka.calculus.backend.operations.operator.Subtraction,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    410:410:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Subtraction$4 -> neureka.calculus.backend.operations.operator.Subtraction$4:
    427:427:void <init>(neureka.calculus.backend.operations.operator.Subtraction,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    430:430:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.operator.Subtraction$5 -> neureka.calculus.backend.operations.operator.Subtraction$5:
    435:435:void <init>(neureka.calculus.backend.operations.operator.Subtraction,java.lang.String,java.lang.String,int,boolean,boolean,boolean,boolean) -> <init>
    438:438:double calculate(double[],int,int,java.util.List) -> calculate
neureka.calculus.backend.operations.other.CopyLeft -> neureka.calculus.backend.operations.other.CopyLeft:
    21:264:void <init>() -> <init>
    269:269:double calculate(double[],int,int,java.util.List) -> calculate
    254:259:void lambda$new$26(neureka.calculus.backend.ExecutionCall) -> a
    241:246:void lambda$new$25(neureka.calculus.backend.ExecutionCall) -> b
    226:229:neureka.calculus.backend.ExecutionCall lambda$new$24(neureka.calculus.backend.ExecutionCall) -> c
    222:222:neureka.Tsr lambda$new$23(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    220:220:neureka.Tsr lambda$new$22(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    181:214:neureka.autograd.ADAgent lambda$new$21(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    215:215:neureka.Tsr lambda$new$20(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    213:213:neureka.Tsr lambda$new$19(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    202:202:neureka.Tsr lambda$new$18(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    189:189:neureka.Tsr lambda$new$17(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    171:176:boolean lambda$new$16(neureka.calculus.backend.ExecutionCall) -> d
    146:155:void lambda$new$15(neureka.calculus.backend.ExecutionCall) -> e
    128:139:void lambda$new$14(neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    133:136:void lambda$new$13(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,double,int,int) -> a
    116:118:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$12(neureka.Tsr[],double,int) -> a
    117:117:double lambda$new$11(double[],neureka.Tsr[],double,int[]) -> a
    102:106:neureka.calculus.backend.ExecutionCall lambda$new$10(neureka.calculus.backend.ExecutionCall) -> f
    98:98:neureka.Tsr lambda$new$9(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> b
    97:97:neureka.Tsr lambda$new$8(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> b
    59:92:neureka.autograd.ADAgent lambda$new$7(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> b
    93:93:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    91:91:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> f
    80:80:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> g
    67:67:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> h
    49:54:boolean lambda$new$2(neureka.calculus.backend.ExecutionCall) -> g
    42:44:boolean lambda$new$1(neureka.calculus.backend.ExecutionCall) -> h
    27:32:java.lang.String lambda$new$0(java.util.List) -> a
neureka.calculus.backend.operations.other.CopyRight -> neureka.calculus.backend.operations.other.CopyRight:
    23:151:void <init>() -> <init>
    155:155:double calculate(double[],int,int,java.util.List) -> calculate
    135:146:void lambda$new$14(neureka.calculus.backend.ExecutionCall) -> a
    117:128:void lambda$new$13(neureka.calculus.backend.ExecutionCall) -> b
    106:108:neureka.calculus.backend.ExecutionCall lambda$new$12(neureka.calculus.backend.ExecutionCall) -> c
    103:103:neureka.Tsr lambda$new$11(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    101:101:neureka.Tsr lambda$new$10(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    60:94:neureka.autograd.ADAgent lambda$new$9(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    95:95:neureka.Tsr lambda$new$8(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    93:93:neureka.Tsr lambda$new$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    81:81:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    68:68:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    48:55:boolean lambda$new$4(neureka.calculus.backend.ExecutionCall) -> d
    40:42:neureka.calculus.backend.operations.OperationType$TertiaryNDXConsumer lambda$new$3(neureka.Tsr[],int) -> a
    42:42:double lambda$new$2(double[],neureka.Tsr[],int[],int[],int[]) -> a
    41:41:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> b
    27:34:java.lang.String lambda$new$0(java.util.List) -> a
neureka.calculus.backend.operations.other.Randomization -> neureka.calculus.backend.operations.other.Randomization:
    22:128:void <init>() -> <init>
    132:132:double calculate(double[],int,int,java.util.List) -> calculate
    109:111:void lambda$new$12(neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,neureka.calculus.backend.ExecutionCall) -> a
    113:119:void lambda$new$11(neureka.calculus.backend.ExecutionCall,neureka.calculus.backend.operations.OperationType$ScalarOperatorCreator,int,int) -> a
    98:100:neureka.calculus.backend.ExecutionCall lambda$new$10(neureka.calculus.backend.ExecutionCall) -> a
    95:95:neureka.Tsr lambda$new$9(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    93:93:neureka.Tsr lambda$new$8(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    54:87:neureka.autograd.ADAgent lambda$new$7(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    88:88:neureka.Tsr lambda$new$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    86:86:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    75:75:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    62:62:neureka.Tsr lambda$new$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    42:49:boolean lambda$new$2(neureka.calculus.backend.ExecutionCall) -> b
    30:30:neureka.calculus.backend.operations.OperationType$PrimaryNDXConsumer lambda$new$1(neureka.Tsr[],double,int) -> a
    31:35:double lambda$new$0(double,int[]) -> a
neureka.calculus.backend.operations.other.Reshape -> neureka.calculus.backend.operations.other.Reshape:
    24:167:void <init>() -> <init>
    172:187:neureka.Tsr reshaped(neureka.Tsr,int[],boolean) -> reshaped
    193:193:double calculate(double[],int,int,java.util.List) -> calculate
    148:158:neureka.calculus.backend.ExecutionCall lambda$new$9(neureka.calculus.backend.ExecutionCall) -> a
    116:144:neureka.Tsr lambda$new$8(neureka.calculus.backend.ExecutionCall,java.util.function.Function) -> a
    88:111:neureka.Tsr lambda$new$7(neureka.calculus.frontend.AbstractFunction,neureka.calculus.backend.ExecutionCall) -> a
    73:81:neureka.autograd.ADAgent lambda$new$6(neureka.calculus.Function,neureka.calculus.backend.ExecutionCall,boolean) -> a
    82:82:neureka.Tsr lambda$new$5(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    80:80:neureka.Tsr lambda$new$4(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    69:69:boolean lambda$new$3(neureka.calculus.backend.ExecutionCall) -> b
    68:68:boolean lambda$new$2(neureka.calculus.backend.ExecutionCall) -> c
    35:63:java.lang.String lambda$new$1(java.util.List) -> a
    39:41:java.lang.Boolean lambda$new$0(java.lang.String) -> a
neureka.calculus.frontend.AbstractBaseFunction -> neureka.calculus.frontend.AbstractBaseFunction:
    20:20:void <init>() -> <init>
    25:25:double call(double) -> call
    30:30:neureka.Tsr call(neureka.Tsr) -> call
    37:37:neureka.Tsr call(java.util.List) -> call
    42:42:neureka.Tsr invoke(java.util.List) -> invoke
    49:49:double invoke(double) -> invoke
    54:54:double invoke(double[],int) -> invoke
    59:59:double invoke(double[]) -> invoke
    66:66:neureka.Tsr invoke(neureka.Tsr) -> invoke
    71:71:neureka.Tsr invoke(neureka.Tsr[],int) -> invoke
    76:76:neureka.Tsr invoke(neureka.Tsr[]) -> invoke
    83:83:neureka.Tsr derive(java.util.List,int,int) -> derive
    88:88:neureka.Tsr derive(java.util.List,int) -> derive
neureka.calculus.frontend.AbstractFunction -> neureka.calculus.frontend.AbstractFunction:
    neureka.calculus.backend.operations.OperationType _type -> a
    boolean _isFlat -> b
    boolean _doAD -> c
    java.util.List _src -> d
    37:56:void <init>(neureka.calculus.backend.operations.OperationType,java.util.List,boolean) -> <init>
    62:62:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    67:67:boolean isFlat() -> isFlat
    72:72:boolean doesAD() -> doesAD
    77:77:int id() -> id
    82:82:neureka.calculus.backend.operations.OperationType type() -> type
    90:91:java.lang.String toString() -> toString
    96:97:boolean dependsOn(int) -> dependsOn
    112:135:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int) -> _tensor_activation
    1322:1326:neureka.acceleration.Device _device(neureka.Tsr[]):322:326 -> _tensor_activation
    1322:1326:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):113 -> _tensor_activation
    141:145:neureka.Tsr __flat_execution(neureka.calculus.backend.ExecutionCall) -> a
    149:149:java.util.List getChildren() -> getChildren
    154:179:neureka.Tsr __deep_activation(neureka.calculus.backend.ExecutionCall) -> b
    212:292:neureka.Tsr _deep_derivative(neureka.calculus.backend.ExecutionCall) -> c
    297:317:neureka.Tsr[] srcActivation(neureka.Tsr[],int,int,int) -> srcActivation
    331:344:boolean _shareGuestDevice(neureka.Tsr[]) -> a
    215:275:neureka.Tsr lambda$_deep_derivative$3(neureka.calculus.backend.ExecutionCall) -> d
    2194:2207:int ___indexOfFoundDerivative(neureka.Tsr[]):194:207 -> d
    2194:2207:neureka.Tsr lambda$_deep_derivative$3(neureka.calculus.backend.ExecutionCall):240 -> d
    171:171:java.lang.String lambda$__deep_activation$2(int) -> a
    130:130:neureka.Tsr lambda$_tensor_activation$1(neureka.calculus.backend.ExecutionCall) -> e
    90:90:java.lang.String lambda$toString$0(neureka.calculus.Function) -> a
neureka.calculus.frontend.Cache -> neureka.calculus.frontend.Cache:
    neureka.calculus.frontend.Cache _cache -> a
    java.util.Map FUNCTIONS -> b
    java.util.Map PROCESSING -> c
    16:31:void <init>() -> <init>
    20:22:neureka.calculus.frontend.Cache instance() -> instance
    28:28:java.util.Map FUNCTIONS() -> FUNCTIONS
    35:37:void free(neureka.autograd.GraphLock) -> free
    41:71:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier,int,int) -> preprocess
    76:86:neureka.Tsr _get(neureka.Tsr[],int,int) -> a
    91:101:void _put(neureka.Tsr,neureka.autograd.GraphNode,int,int) -> a
    104:104:int _keyed(int) -> a
    96:96:int lambda$_put$2(java.lang.Long,java.lang.Long) -> a
    59:59:neureka.Tsr lambda$preprocess$1(neureka.Tsr) -> a
    31:31:int lambda$new$0(neureka.autograd.GraphLock,neureka.autograd.GraphLock) -> a
    14:14:void <clinit>() -> <clinit>
neureka.calculus.frontend.assembly.FunctionBuilder -> neureka.calculus.frontend.assembly.FunctionBuilder:
    12:12:void <init>() -> <init>
    21:37:neureka.calculus.Function build(neureka.calculus.backend.operations.AbstractOperationType,int,boolean) -> build
    48:61:neureka.calculus.Function build(java.lang.String,boolean) -> build
    70:271:neureka.calculus.Function _build(java.lang.String,boolean) -> a
    281:288:java.util.List _rebindPairwise(java.util.List,int) -> a
neureka.calculus.frontend.assembly.FunctionParser -> neureka.calculus.frontend.assembly.FunctionParser:
    boolean $assertionsDisabled -> a
    13:13:void <init>() -> <init>
    16:20:int numberOfOperationsWithin(java.util.List) -> numberOfOperationsWithin
    24:32:java.lang.String parsedOperation(java.lang.String,int) -> parsedOperation
    36:67:java.lang.String findComponentIn(java.lang.String,int) -> findComponentIn
    71:94:java.util.List findParametersIn(java.lang.String,int) -> findParametersIn
    98:99:boolean isBasicOperation(java.lang.String) -> isBasicOperation
    103:110:java.lang.String groupBy(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> groupBy
    114:114:boolean isForbiddenChar(char) -> a
    119:154:java.lang.String cleanedHeadAndTail(java.lang.String) -> cleanedHeadAndTail
    158:207:java.lang.String unpackAndCorrect(java.lang.String) -> unpackAndCorrect
    211:221:java.lang.String assumptionBasedOn(java.lang.String) -> assumptionBasedOn
    225:257:double similarity(java.lang.String,java.lang.String) -> similarity
    13:13:void <clinit>() -> <clinit>
neureka.calculus.frontend.implementations.FunctionConstant -> neureka.calculus.frontend.implementations.FunctionConstant:
    double _value -> a
    8:8:void <init>() -> <init>
    12:12:double value() -> value
    19:19:boolean isFlat() -> isFlat
    24:24:boolean doesAD() -> doesAD
    29:29:int id() -> id
    34:34:neureka.calculus.backend.operations.AbstractOperationType type() -> type
    39:39:boolean dependsOn(int) -> dependsOn
    45:58:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    65:65:double call(double[],int) -> call
    70:70:double call(double[]) -> call
    75:75:double derive(double[],int) -> derive
    80:80:double derive(double[],int,int) -> derive
    87:87:neureka.Tsr call(neureka.Tsr[],int) -> call
    92:92:neureka.Tsr call(neureka.Tsr[]) -> call
    97:97:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    102:102:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    109:109:java.lang.String toString() -> toString
    8:8:neureka.calculus.backend.operations.OperationType type() -> type
neureka.calculus.frontend.implementations.FunctionInput -> neureka.calculus.frontend.implementations.FunctionInput:
    int _index -> a
    10:10:void <init>() -> <init>
    17:17:boolean providesGradient() -> providesGradient
    24:24:boolean isFlat() -> isFlat
    29:29:boolean doesAD() -> doesAD
    34:34:int id() -> id
    39:39:neureka.calculus.backend.operations.AbstractOperationType type() -> type
    44:44:boolean dependsOn(int) -> dependsOn
    52:72:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    77:87:neureka.Tsr _extract(neureka.Tsr) -> a
    94:94:double call(double[],int) -> call
    99:99:double call(double[]) -> call
    104:104:double derive(double[],int) -> derive
    109:109:double derive(double[],int,int) -> derive
    116:116:neureka.Tsr call(neureka.Tsr[],int) -> call
    121:121:neureka.Tsr call(neureka.Tsr[]) -> call
    126:126:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    131:133:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    140:140:java.lang.String toString() -> toString
    144:144:int index() -> index
    10:10:neureka.calculus.backend.operations.OperationType type() -> type
neureka.calculus.frontend.implementations.FunctionNode -> neureka.calculus.frontend.implementations.FunctionNode:
    13:14:void <init>(neureka.calculus.backend.operations.OperationType,java.util.List,boolean) -> <init>
    20:20:neureka.Tsr call(neureka.Tsr[],int) -> call
    25:25:neureka.Tsr call(neureka.Tsr[]) -> call
    30:30:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    35:35:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    42:42:double call(double[],int) -> call
    47:47:double call(double[]) -> call
    52:52:double derive(double[],int,int) -> derive
    57:57:double derive(double[],int) -> derive
    35:35:neureka.Tsr lambda$derive$3(neureka.Tsr[],int) -> a
    30:30:neureka.Tsr lambda$derive$2(neureka.Tsr[],int,int) -> a
    25:25:neureka.Tsr lambda$call$1(neureka.Tsr[]) -> a
    20:20:neureka.Tsr lambda$call$0(neureka.Tsr[],int) -> b
neureka.calculus.frontend.implementations.FunctionVariable -> neureka.calculus.frontend.implementations.FunctionVariable:
    boolean _providesGradient -> a
    9:11:void <init>() -> <init>
    14:14:boolean providesGradient() -> providesGradient
    19:19:boolean isFlat() -> isFlat
    24:24:boolean doesAD() -> doesAD
    29:29:int id() -> id
    34:34:neureka.calculus.backend.operations.AbstractOperationType type() -> type
    39:39:boolean dependsOn(int) -> dependsOn
    45:46:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    53:53:double call(double[],int) -> call
    58:60:double call(double[]) -> call
    65:65:double derive(double[],int) -> derive
    70:71:double derive(double[],int,int) -> derive
    77:77:neureka.Tsr call(neureka.Tsr[],int) -> call
    82:84:neureka.Tsr call(neureka.Tsr[]) -> call
    89:89:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    94:94:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    101:101:java.lang.String toString() -> toString
    9:9:neureka.calculus.backend.operations.OperationType type() -> type
neureka.calculus.frontend.implementations.GradientProvider -> neureka.calculus.frontend.implementations.GradientProvider:
    boolean providesGradient() -> providesGradient
neureka.framing.IndexAlias -> neureka.framing.IndexAlias:
    java.util.Map _mapping -> a
    13:23:void <init>(java.util.List) -> <init>
    25:28:void <init>(int) -> <init>
    30:43:void <init>(java.util.Map,neureka.Tsr) -> <init>
    46:46:int[] get(java.util.List) -> get
    50:61:int[] get(java.lang.Object[]) -> get
    66:68:int get(java.lang.Object,java.lang.Object) -> get
    73:76:void replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    79:85:void _initializeIdxmap(java.lang.Object,int,java.lang.Object,int) -> a
    89:92:void set(java.lang.Object,java.lang.Object,int) -> set
    96:100:java.util.List keysOf(java.lang.Object) -> keysOf
    104:108:java.util.List keysOf(java.lang.Object,int) -> keysOf
    112:120:java.lang.String _fixed(java.lang.String,int) -> a
    126:188:java.lang.String toString() -> toString
    195:195:void update(neureka.Tsr,neureka.Tsr) -> update
    8:8:void update(java.lang.Object,java.lang.Object) -> update
    159:174:void lambda$toString$6(java.lang.Object[],int[],java.lang.StringBuilder,int[],java.lang.Object,java.lang.Object) -> a
    162:163:void lambda$toString$5(int[],java.lang.Object[],java.lang.Object,java.lang.Integer) -> a
    141:147:void lambda$toString$4(int[],int[],java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    134:134:java.lang.Boolean lambda$toString$3(int,int,java.lang.Integer) -> a
    106:106:void lambda$keysOf$2(int,java.util.List,java.lang.Object,java.lang.Integer) -> a
    98:98:void lambda$keysOf$1(java.util.List,java.lang.Object,java.lang.Integer) -> a
    34:42:void lambda$new$0(neureka.Tsr,int[],java.lang.Object,java.util.List) -> a
neureka.framing.Relation -> neureka.framing.Relation:
    neureka.Tsr _parent -> a
    java.lang.ref.WeakReference[] _children -> b
    9:9:void <init>() -> <init>
    17:34:void update(neureka.Tsr,neureka.Tsr) -> update
    38:39:neureka.framing.Relation addParent(neureka.Tsr) -> addParent
    44:52:neureka.framing.Relation addChild(neureka.Tsr) -> addChild
    57:67:neureka.framing.Relation foreachChild(java.util.function.Consumer) -> foreachChild
    71:75:neureka.Tsr findRootTensor() -> findRootTensor
    80:80:boolean hasParent() -> hasParent
    84:84:boolean hasChildren() -> hasChildren
    88:88:int childCount() -> childCount
    9:9:void update(java.lang.Object,java.lang.Object) -> update
neureka.ndim.AbstractComponentOwner -> neureka.ndim.AbstractComponentOwner:
    java.util.List _components -> _components
    19:24:void <init>() -> <init>
    31:36:java.lang.Object find(java.lang.Class) -> find
    45:53:java.lang.Object remove(java.lang.Class) -> remove
    62:62:boolean has(java.lang.Class) -> has
    72:83:java.lang.Object add(neureka.Component) -> add
    neureka.Component _addOrReject(neureka.Component) -> _addOrReject
    neureka.Component _removeOrReject(neureka.Component) -> _removeOrReject
    106:110:boolean forComponent(java.lang.Class,java.util.function.Consumer) -> forComponent
neureka.ndim.AbstractNDArray -> neureka.ndim.AbstractNDArray:
    neureka.ndim.config.NDConfiguration _conf -> _conf
    java.lang.Object _value -> _value
    25:25:void <init>() -> <init>
    34:34:boolean is64() -> is64
    38:38:boolean is32() -> is32
    44:44:int i_of_i(int) -> i_of_i
    48:48:int[] idx_of_i(int) -> idx_of_i
    52:52:int i_of_idx(int[]) -> i_of_idx
    58:58:neureka.ndim.config.NDConfiguration getNDConf() -> getNDConf
    62:63:java.lang.Object setNDConf(neureka.ndim.config.NDConfiguration) -> setNDConf
    69:69:int rank() -> rank
    73:73:java.util.List shape() -> shape
    77:77:int shape(int) -> shape
    81:81:java.util.List idxmap() -> idxmap
    85:85:java.util.List translation() -> translation
    89:89:java.util.List spread() -> spread
    93:93:java.util.List offset() -> offset
    97:97:int size() -> size
    101:103:java.util.List _asList(int[]) -> _asList
neureka.ndim.AbstractNDArray$Utility -> neureka.ndim.AbstractNDArray$Utility:
    113:113:void <init>() -> <init>
neureka.ndim.AbstractNDArray$Utility$Indexing -> neureka.ndim.AbstractNDArray$Utility$Indexing:
    148:148:void <init>() -> <init>
    153:156:void increment(int[],int[]) -> increment
    1160:1185:int _incrementAt(int,int[],int[]):160:185 -> increment
    1160:1185:void increment(int[],int[]):155 -> increment
    191:204:int[] newTlnOf(int[]) -> newTlnOf
    209:214:int[] rearrange(int[],int[]) -> rearrange
    219:224:int[] shpCheck(int[],neureka.Tsr) -> shpCheck
    229:235:int[] rearrange(int[],int[],int[]) -> rearrange
    240:261:int[][] makeFit(int[],int[]) -> makeFit
    266:268:int[] shpOfCon(int[],int[]) -> shpOfCon
    273:280:int[] shpOfBrc(int[],int[]) -> shpOfBrc
    285:287:int szeOfShp(int[]) -> szeOfShp
neureka.ndim.AbstractNDArray$Utility$Stringify -> neureka.ndim.AbstractNDArray$Utility$Stringify:
    115:115:void <init>() -> <init>
    119:133:java.lang.String formatFP(double) -> formatFP
    138:140:java.lang.String strConf(int[]) -> strConf
neureka.ndim.config.AbstractNDC -> neureka.ndim.config.AbstractNDC:
    java.util.Map _CACHED_NDCS -> a
    java.util.Map _CACHED_INT_ARRAYS -> b
    13:13:void <init>() -> <init>
    36:59:int[] _cacheArray(int[]) -> _cacheArray
    68:72:long keyCode() -> keyCode
    78:82:boolean equals(neureka.ndim.config.NDConfiguration) -> equals
    94:118:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    1142:1148:boolean _isSimpleConfiguration(int[],int[],int[],int[],int[]):142:148 -> construct
    1142:1148:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]):97 -> construct
    123:131:neureka.ndim.config.NDConfiguration _cached(neureka.ndim.config.NDConfiguration) -> _cached
    155:160:java.lang.String toString() -> toString
    21:32:void <clinit>() -> <clinit>
neureka.ndim.config.NDConfiguration -> neureka.ndim.config.NDConfiguration:
    int rank() -> rank
    int[] shape() -> shape
    int shape(int) -> shape
    int[] idxmap() -> idxmap
    int idxmap(int) -> idxmap
    int[] translation() -> translation
    int translation(int) -> translation
    int[] spread() -> spread
    int spread(int) -> spread
    int[] offset() -> offset
    int offset(int) -> offset
    int i_of_i(int) -> i_of_i
    int[] idx_of_i(int) -> idx_of_i
    int i_of_idx(int[]) -> i_of_idx
    long keyCode() -> keyCode
    boolean equals(neureka.ndim.config.NDConfiguration) -> equals
neureka.ndim.config.complex.D1Configuration -> neureka.ndim.config.complex.D1Configuration:
    int _shape -> a
    int _translation -> b
    int _idxmap -> c
    int _spread -> d
    int _offset -> e
    39:39:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    48:54:void <init>(int,int,int,int,int) -> <init>
    58:58:int rank() -> rank
    63:63:int[] shape() -> shape
    68:68:int shape(int) -> shape
    73:73:int[] idxmap() -> idxmap
    78:78:int idxmap(int) -> idxmap
    83:83:int[] translation() -> translation
    88:88:int translation(int) -> translation
    93:93:int[] spread() -> spread
    98:98:int spread(int) -> spread
    103:103:int[] offset() -> offset
    108:108:int offset(int) -> offset
    114:114:int i_of_i(int) -> i_of_i
    119:119:int[] idx_of_i(int) -> idx_of_i
    123:123:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.complex.D2Configuration -> neureka.ndim.config.complex.D2Configuration:
    int _shape1 -> a
    int _shape2 -> b
    int _translation1 -> c
    int _translation2 -> d
    int _idxmap1 -> e
    int _idxmap2 -> f
    int _spread1 -> g
    int _spread2 -> h
    int _offset1 -> i
    int _offset2 -> j
    15:26:void <init>(int[],int[],int[],int[],int[]) -> <init>
    35:35:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    69:69:int rank() -> rank
    74:74:int[] shape() -> shape
    79:79:int shape(int) -> shape
    84:84:int[] idxmap() -> idxmap
    89:89:int idxmap(int) -> idxmap
    94:94:int[] translation() -> translation
    99:99:int translation(int) -> translation
    104:104:int[] spread() -> spread
    109:109:int spread(int) -> spread
    114:114:int[] offset() -> offset
    119:119:int offset(int) -> offset
    127:131:int i_of_i(int) -> i_of_i
    138:148:int[] idx_of_i(int) -> idx_of_i
    153:156:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.complex.D3Configuration -> neureka.ndim.config.complex.D3Configuration:
    int _shape1 -> a
    int _shape2 -> b
    int _shape3 -> c
    int _translation1 -> d
    int _translation2 -> e
    int _translation3 -> f
    int _idxmap1 -> g
    int _idxmap2 -> h
    int _idxmap3 -> i
    int _spread1 -> j
    int _spread2 -> k
    int _spread3 -> l
    int _offset1 -> m
    int _offset2 -> n
    int _offset3 -> o
    15:31:void <init>(int[],int[],int[],int[],int[]) -> <init>
    40:40:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    79:79:int rank() -> rank
    84:84:int[] shape() -> shape
    89:89:int shape(int) -> shape
    94:94:int[] idxmap() -> idxmap
    99:99:int idxmap(int) -> idxmap
    104:104:int[] translation() -> translation
    109:109:int translation(int) -> translation
    114:114:int[] spread() -> spread
    119:119:int spread(int) -> spread
    124:124:int[] offset() -> offset
    129:129:int offset(int) -> offset
    138:151:int i_of_i(int) -> i_of_i
    159:172:int[] idx_of_i(int) -> idx_of_i
    177:177:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.complex.DefaultNDConfiguration -> neureka.ndim.config.complex.DefaultNDConfiguration:
    int[] _shape -> a
    int[] _translation -> b
    int[] _idxmap -> c
    int[] _spread -> d
    int[] _offset -> e
    16:22:void <init>(int[],int[],int[],int[],int[]) -> <init>
    31:31:neureka.ndim.config.NDConfiguration construct(int[],int[],int[],int[],int[]) -> construct
    60:60:int rank() -> rank
    65:65:int[] shape() -> shape
    70:70:int shape(int) -> shape
    75:75:int[] idxmap() -> idxmap
    80:80:int idxmap(int) -> idxmap
    85:85:int[] translation() -> translation
    90:90:int translation(int) -> translation
    95:95:int[] spread() -> spread
    100:100:int spread(int) -> spread
    105:105:int[] offset() -> offset
    110:110:int offset(int) -> offset
    118:118:int i_of_i(int) -> i_of_i
    123:135:int[] idx_of_i(int) -> idx_of_i
    140:142:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.complex.ScalarConfiguration -> neureka.ndim.config.complex.ScalarConfiguration:
    int _shape -> a
    int _offset -> b
    27:27:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    33:36:void <init>(int,int) -> <init>
    40:40:int rank() -> rank
    45:45:int[] shape() -> shape
    50:50:int shape(int) -> shape
    55:55:int[] idxmap() -> idxmap
    60:60:int idxmap(int) -> idxmap
    65:65:int[] translation() -> translation
    70:70:int translation(int) -> translation
    75:75:int[] spread() -> spread
    80:80:int spread(int) -> spread
    85:85:int[] offset() -> offset
    90:90:int offset(int) -> offset
    96:96:int i_of_i(int) -> i_of_i
    101:101:int[] idx_of_i(int) -> idx_of_i
    106:106:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleD1Configuration -> neureka.ndim.config.simple.SimpleD1Configuration:
    int _shape -> a
    int _translation_and_idxmap -> b
    23:23:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    29:32:void <init>(int,int) -> <init>
    36:36:int rank() -> rank
    41:41:int[] shape() -> shape
    46:46:int shape(int) -> shape
    51:51:int[] idxmap() -> idxmap
    56:56:int idxmap(int) -> idxmap
    61:61:int[] translation() -> translation
    66:66:int translation(int) -> translation
    71:71:int[] spread() -> spread
    76:76:int spread(int) -> spread
    81:81:int[] offset() -> offset
    86:86:int offset(int) -> offset
    92:92:int i_of_i(int) -> i_of_i
    97:97:int[] idx_of_i(int) -> idx_of_i
    101:101:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleD2Configuration -> neureka.ndim.config.simple.SimpleD2Configuration:
    int _shape1 -> a
    int _shape2 -> b
    int _translation1 -> c
    int _translation2 -> d
    13:18:void <init>(int[],int[]) -> <init>
    24:24:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    41:41:int rank() -> rank
    46:46:int[] shape() -> shape
    51:51:int shape(int) -> shape
    56:56:int[] idxmap() -> idxmap
    61:61:int idxmap(int) -> idxmap
    66:66:int[] translation() -> translation
    71:71:int translation(int) -> translation
    76:76:int[] spread() -> spread
    81:81:int spread(int) -> spread
    86:86:int[] offset() -> offset
    91:91:int offset(int) -> offset
    99:103:int i_of_i(int) -> i_of_i
    110:120:int[] idx_of_i(int) -> idx_of_i
    125:128:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleD3Configuration -> neureka.ndim.config.simple.SimpleD3Configuration:
    int _shape1 -> a
    int _shape2 -> b
    int _shape3 -> c
    int _translation1 -> d
    int _translation2 -> e
    int _translation3 -> f
    13:20:void <init>(int[],int[]) -> <init>
    26:26:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    44:44:int rank() -> rank
    49:49:int[] shape() -> shape
    54:54:int shape(int) -> shape
    59:59:int[] idxmap() -> idxmap
    64:64:int idxmap(int) -> idxmap
    69:69:int[] translation() -> translation
    74:74:int translation(int) -> translation
    79:79:int[] spread() -> spread
    84:84:int spread(int) -> spread
    89:89:int[] offset() -> offset
    94:94:int offset(int) -> offset
    103:116:int i_of_i(int) -> i_of_i
    124:137:int[] idx_of_i(int) -> idx_of_i
    142:142:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleDefaultNDConfiguration -> neureka.ndim.config.simple.SimpleDefaultNDConfiguration:
    int[] _shape -> a
    int[] _translation_and_idxmap -> b
    14:17:void <init>(int[],int[]) -> <init>
    23:23:neureka.ndim.config.NDConfiguration construct(int[],int[]) -> construct
    38:38:int rank() -> rank
    43:43:int[] shape() -> shape
    48:48:int shape(int) -> shape
    53:53:int[] idxmap() -> idxmap
    58:58:int idxmap(int) -> idxmap
    63:63:int[] translation() -> translation
    68:68:int translation(int) -> translation
    73:75:int[] spread() -> spread
    80:80:int spread(int) -> spread
    85:85:int[] offset() -> offset
    90:90:int offset(int) -> offset
    98:98:int i_of_i(int) -> i_of_i
    103:115:int[] idx_of_i(int) -> idx_of_i
    120:122:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.simple.SimpleScalarConfiguration -> neureka.ndim.config.simple.SimpleScalarConfiguration:
    9:9:neureka.ndim.config.NDConfiguration construct() -> construct
    12:12:void <init>() -> <init>
    16:16:int rank() -> rank
    21:21:int[] shape() -> shape
    26:26:int shape(int) -> shape
    31:31:int[] idxmap() -> idxmap
    36:36:int idxmap(int) -> idxmap
    41:41:int[] translation() -> translation
    46:46:int translation(int) -> translation
    51:51:int[] spread() -> spread
    56:56:int spread(int) -> spread
    61:61:int[] offset() -> offset
    66:66:int offset(int) -> offset
    71:71:int i_of_i(int) -> i_of_i
    76:76:int[] idx_of_i(int) -> idx_of_i
    81:81:int i_of_idx(int[]) -> i_of_idx
neureka.ndim.config.virtual.VirtualNDConfiguration -> neureka.ndim.config.virtual.VirtualNDConfiguration:
    int[] _shape -> a
    12:14:void <init>(int[]) -> <init>
    19:19:neureka.ndim.config.NDConfiguration construct(int[]) -> construct
    24:24:int rank() -> rank
    29:29:int[] shape() -> shape
    34:34:int shape(int) -> shape
    39:39:int[] idxmap() -> idxmap
    44:44:int idxmap(int) -> idxmap
    49:49:int[] translation() -> translation
    54:54:int translation(int) -> translation
    59:59:int[] spread() -> spread
    64:64:int spread(int) -> spread
    69:69:int[] offset() -> offset
    74:74:int offset(int) -> offset
    79:79:int i_of_i(int) -> i_of_i
    84:84:int[] idx_of_i(int) -> idx_of_i
    89:89:int i_of_idx(int[]) -> i_of_idx
neureka.optimization.Optimizer -> neureka.optimization.Optimizer:
    void optimize(neureka.Tsr) -> optimize
neureka.optimization.implementations.ADAM -> neureka.optimization.implementations.ADAM:
    neureka.Tsr m -> a
    neureka.Tsr v -> b
    40:41:void optimize(neureka.Tsr) -> optimize
    1029:1036:void _optimize(neureka.Tsr):29:36 -> optimize
    1029:1036:void optimize(neureka.Tsr):40 -> optimize
    46:46:void update(neureka.Tsr,neureka.Tsr) -> update
    7:7:void update(java.lang.Object,java.lang.Object) -> update
neureka.optimization.implementations.Template -> neureka.optimization.implementations.Template:
    6:6:void <init>() -> <init>
neureka.utility.DataHelper -> neureka.utility.DataHelper:
    5:5:void <init>() -> <init>
    9:9:double[] newSeededDoubleArray(java.lang.String,int) -> newSeededDoubleArray
    13:13:double[] newSeededDoubleArray(long,int) -> newSeededDoubleArray
    17:17:double[] seededDoubleArray(double[],java.lang.String) -> seededDoubleArray
    21:24:double[] seededDoubleArray(double[],long) -> seededDoubleArray
    28:28:float[] newSeededFloatArray(java.lang.String,int) -> newSeededFloatArray
    32:32:float[] newSeededFloatArray(long,int) -> newSeededFloatArray
    36:36:float[] seededFloatArray(float[],java.lang.String) -> seededFloatArray
    40:43:float[] seededFloatArray(float[],long) -> seededFloatArray
    48:51:long _longStringHash(java.lang.String) -> a
    55:58:float[] doubleToFloat(double[]) -> doubleToFloat
    62:65:double[] floatToDouble(float[]) -> floatToDouble
neureka.utility.SettingsLoader -> neureka.utility.SettingsLoader:
    java.lang.String _settings_source -> a
    java.lang.String _setup_source -> b
    20:20:void <init>() -> <init>
    26:27:java.lang.Object tryGroovyClosureOn(java.lang.Object,java.lang.Object) -> tryGroovyClosureOn
    32:51:void tryGroovyScriptsOn(neureka.Neureka) -> tryGroovyScriptsOn
