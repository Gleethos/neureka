neureka.Component -> neureka.Component:
    void update(java.lang.Object,java.lang.Object) -> update
neureka.Neureka -> neureka.Neureka:
    java.util.Map _instances -> a
    java.lang.String _settings_source -> b
    java.lang.String _setup_source -> c
    neureka.Neureka$Settings _settings -> d
    neureka.Neureka$Utility _utility -> e
    27:30:void <init>() -> <init>
    33:33:neureka.Neureka instance() -> instance
    37:38:void setContext(java.lang.Thread,neureka.Neureka) -> setContext
    41:53:neureka.Neureka instance(java.lang.Thread) -> instance
    58:60:neureka.Neureka instance(groovy.lang.Closure) -> instance
    64:64:neureka.Neureka$Settings settings() -> settings
    68:70:neureka.Neureka$Settings settings(groovy.lang.Closure) -> settings
    74:74:neureka.Neureka$Utility utility() -> utility
    78:78:java.lang.String version() -> version
    24:25:void <clinit>() -> <clinit>
neureka.Neureka$Settings -> neureka.Neureka$Settings:
    neureka.Neureka$Settings$Debug _debug -> a
    neureka.Neureka$Settings$AutoDiff _autoDiff -> b
    neureka.Neureka$Settings$Indexing _indexing -> c
    neureka.Neureka$Settings$View _view -> d
    boolean _isLocked -> e
    88:95:void <init>(neureka.Neureka) -> <init>
    98:98:neureka.Neureka$Settings$Debug debug() -> debug
    102:104:neureka.Neureka$Settings$Debug debug(groovy.lang.Closure) -> debug
    108:108:neureka.Neureka$Settings$AutoDiff autoDiff() -> autoDiff
    112:114:neureka.Neureka$Settings$AutoDiff autoDiff(groovy.lang.Closure) -> autoDiff
    118:118:neureka.Neureka$Settings$Indexing indexing() -> indexing
    122:124:neureka.Neureka$Settings$Indexing indexing(groovy.lang.Closure) -> indexing
    128:128:neureka.Neureka$Settings$View view() -> view
    132:134:neureka.Neureka$Settings$View view(groovy.lang.Closure) -> view
    138:138:boolean isLocked() -> isLocked
    142:143:void setIsLocked(boolean) -> setIsLocked
    146:150:void reset() -> reset
neureka.Neureka$Settings$AutoDiff -> neureka.Neureka$Settings$AutoDiff:
    boolean _retainPendingErrorForJITProp -> a
    boolean _applyGradientWhenTensorIsUsed -> b
    neureka.Neureka$Settings this$1 -> c
    210:212:void <init>(neureka.Neureka$Settings) -> <init>
    215:217:void reset() -> reset
    220:220:boolean retainPendingErrorForJITProp() -> retainPendingErrorForJITProp
    224:226:void setRetainPendingErrorForJITProp(boolean) -> setRetainPendingErrorForJITProp
    229:229:boolean applyGradientWhenTensorIsUsed() -> applyGradientWhenTensorIsUsed
    233:235:void setApplyGradientWhenTensorIsUsed(boolean) -> setApplyGradientWhenTensorIsUsed
neureka.Neureka$Settings$Debug -> neureka.Neureka$Settings$Debug:
    boolean _keepDerivativeTargetPayloads -> a
    neureka.Neureka$Settings this$1 -> b
    171:173:void <init>(neureka.Neureka$Settings) -> <init>
    176:177:void reset() -> reset
    180:180:boolean keepDerivativeTargetPayloads() -> keepDerivativeTargetPayloads
    184:186:void setKeepDerivativeTargetPayloads(boolean) -> setKeepDerivativeTargetPayloads
neureka.Neureka$Settings$Indexing -> neureka.Neureka$Settings$Indexing:
    boolean _legacyIndexing -> a
    neureka.Neureka$Settings this$1 -> b
    243:245:void <init>(neureka.Neureka$Settings) -> <init>
    248:249:void reset() -> reset
    252:252:boolean legacy() -> legacy
    256:258:void setLegacy(boolean) -> setLegacy
neureka.Neureka$Settings$View -> neureka.Neureka$Settings$View:
    boolean _legacyView -> a
    neureka.Neureka$Settings this$1 -> b
    267:269:void <init>(neureka.Neureka$Settings) -> <init>
    272:273:void reset() -> reset
    276:276:boolean legacy() -> legacy
    280:282:void setLegacy(boolean) -> setLegacy
neureka.Neureka$Utility -> neureka.Neureka$Utility:
    288:288:void <init>() -> <init>
    298:311:java.lang.String readResource(java.lang.String) -> readResource
neureka.Tsr -> neureka.Tsr:
    neureka.acceleration.Device _CPU -> a
    int _flags -> b
    43:45:neureka.Tsr setRqsGradient(boolean) -> setRqsGradient
    49:49:boolean rqsGradient() -> rqsGradient
    53:57:void _setRqsGradient(boolean) -> _setRqsGradient
    62:79:neureka.Tsr setIsOutsourced(boolean) -> setIsOutsourced
    83:83:boolean isOutsourced() -> isOutsourced
    87:91:void _setIsOutsourced(boolean) -> _setIsOutsourced
    96:118:neureka.Tsr setIsVirtual(boolean) -> setIsVirtual
    122:122:boolean isVirtual() -> isVirtual
    126:130:void _setIsVirtual(boolean) -> _setIsVirtual
    146:152:java.lang.Object _addOrReject(java.lang.Object) -> _addOrReject
    159:159:boolean isEmpty() -> isEmpty
    163:163:boolean isUndefined() -> isUndefined
    167:168:boolean isSlice() -> isSlice
    172:173:int sliceCount() -> sliceCount
    177:178:boolean isSliceParent() -> isSliceParent
    182:182:boolean belongsToGraph() -> belongsToGraph
    186:186:boolean isLeave() -> isLeave
    190:190:boolean isBranch() -> isBranch
    200:201:neureka.acceleration.Device device() -> device
    209:209:neureka.autograd.GraphNode graphNode() -> graphNode
    217:217:neureka.framing.IndexAlias index() -> index
    224:242:neureka.Tsr _become(neureka.Tsr) -> _become
    246:259:neureka.Tsr delete() -> delete
    270:279:void _configureFromNewShape(int[]) -> _configureFromNewShape
    33:287:void <init>(java.lang.Object) -> <init>
    33:311:void <init>(java.lang.Object,java.lang.Object) -> <init>
    33:314:void <init>(java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:317:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:320:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:323:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:326:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:329:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:332:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:335:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    33:339:void <init>(int[],java.lang.String) -> <init>
    342:344:void _construct(int[],java.lang.String) -> a
    347:356:int[] _intArray(java.lang.Object[]) -> a
    360:367:double[] _doubleArray(java.lang.Object[]) -> b
    33:372:void <init>(java.lang.Object[]) -> <init>
    375:441:void _construct(java.lang.Object[]) -> c
    33:443:void <init>() -> <init>
    33:447:void <init>(double) -> <init>
    33:451:void <init>(int[]) -> <init>
    454:456:void _construct(int[]) -> d
    33:460:void <init>(int[],double) -> <init>
    463:468:void _construct(int[],double) -> a
    33:472:void <init>(int[],double[]) -> <init>
    475:477:void _construct(int[],double[]) -> a
    33:497:void <init>(neureka.Tsr,boolean) -> <init>
    33:505:void <init>(neureka.Tsr,java.lang.String) -> <init>
    33:509:void <init>(neureka.Tsr[],java.lang.String) -> <init>
    33:513:void <init>(neureka.Tsr[],java.lang.String,boolean) -> <init>
    516:519:void _construct(neureka.Tsr[],java.lang.String,boolean) -> a
    531:534:neureka.Tsr backward(neureka.Tsr) -> backward
    543:544:neureka.Tsr backward(double) -> backward
    548:554:void applyGradient() -> applyGradient
    559:562:neureka.Tsr T() -> T
    566:566:neureka.Tsr plus(neureka.Tsr) -> plus
    569:569:neureka.Tsr plus(java.lang.Double) -> plus
    572:572:neureka.Tsr minus(neureka.Tsr) -> minus
    575:575:neureka.Tsr negative() -> negative
    578:578:neureka.Tsr multiply(neureka.Tsr) -> multiply
    581:581:neureka.Tsr multiply(java.lang.Double) -> multiply
    584:584:neureka.Tsr div(neureka.Tsr) -> div
    587:587:neureka.Tsr div(java.lang.Double) -> div
    590:590:neureka.Tsr mod(neureka.Tsr) -> mod
    593:593:neureka.Tsr power(neureka.Tsr) -> power
    596:596:neureka.Tsr power(java.lang.Double) -> power
    599:599:neureka.Tsr xor(neureka.Tsr) -> xor
    602:602:neureka.Tsr xor(java.lang.Double) -> xor
    605:605:boolean equals(neureka.Tsr) -> equals
    609:621:neureka.Tsr label(java.lang.String[][]) -> label
    625:627:neureka.Tsr label(java.util.List) -> label
    631:632:neureka.Tsr label(java.util.Map) -> label
    636:647:neureka.Tsr putAt(java.lang.Object,neureka.Tsr) -> putAt
    651:651:double getAt(int[]) -> getAt
    655:708:java.lang.Object getAt(java.lang.Object) -> getAt
    723:781:int _configureSubsetFromRanges(java.lang.Object[],int[],int[],int) -> a
    889:891:neureka.Tsr setValue64(double[]) -> setValue64
    895:897:neureka.Tsr setValue32(float[]) -> setValue32
    901:912:neureka.Tsr setValue(java.lang.Object) -> setValue
    916:920:java.lang.Object getValue() -> getValue
    924:926:double[] gradient64() -> gradient64
    930:932:float[] gradient32() -> gradient32
    936:941:neureka.Tsr addToGradient(neureka.Tsr) -> addToGradient
    945:952:neureka.Tsr to32() -> to32
    956:963:neureka.Tsr to64() -> to64
    967:972:double value64(int) -> value64
    977:986:double[] value64() -> value64
    990:995:float value32(int) -> value32
    1000:1008:float[] value32() -> value32
    1012:1014:neureka.Tsr setValue(double[]) -> setValue
    1023:1023:java.lang.String toString(java.lang.String) -> toString
    1027:1101:java.lang.String _toString(java.lang.String,java.lang.String) -> _toString
    1105:1117:java.lang.String _stringified(double[],boolean,int) -> a
    1121:1121:java.lang.String toString() -> toString
    1128:1144:void makeFit(neureka.Tsr[]) -> makeFit
    1091:1096:void lambda$_toString$17(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1071:1081:void lambda$_toString$16(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    960:960:void lambda$to64$15(java.lang.Object) -> a
    949:949:void lambda$to32$14(java.lang.Object) -> b
    939:939:void lambda$addToGradient$13(neureka.Tsr,java.lang.Object) -> a
    937:938:void lambda$addToGradient$12(neureka.Tsr,java.lang.Object) -> b
    550:553:void lambda$applyGradient$11(java.lang.Object) -> c
    550:550:void lambda$applyGradient$10(java.lang.Object,java.lang.Object) -> a
    548:548:void lambda$applyGradient$9(java.lang.Object) -> d
    531:531:void lambda$backward$8(neureka.Tsr,java.lang.Object) -> c
    257:257:void lambda$delete$7(java.lang.Object) -> e
    248:251:void lambda$delete$6(java.lang.Object) -> f
    246:246:void lambda$delete$5(java.lang.Object) -> g
    233:234:void lambda$_become$4(neureka.Tsr,java.lang.Object) -> d
    104:104:void lambda$setIsVirtual$3(neureka.Tsr) -> g
    67:75:void lambda$setIsOutsourced$2(java.lang.Object) -> h
    70:70:void lambda$setIsOutsourced$1(java.lang.Object) -> i
    71:73:void lambda$setIsOutsourced$0(java.lang.Object,java.lang.Object) -> b
    19:19:int access$000(neureka.Tsr,int) -> a
    19:19:int access$100(neureka.Tsr,int) -> b
    19:19:int access$200(neureka.Tsr,int) -> c
    19:19:int access$300(neureka.Tsr,int) -> d
    19:19:int access$400(neureka.Tsr,int) -> e
    19:19:int[] access$502(neureka.Tsr,int[]) -> a
    19:19:int[] access$600(neureka.Tsr) -> a
    19:19:int[] access$700(int[]) -> a
    19:19:int[] access$802(neureka.Tsr,int[]) -> b
    19:19:int[] access$900(neureka.Tsr) -> b
    19:19:int[] access$1000(neureka.Tsr) -> c
    19:19:int[] access$1100(int[]) -> b
    19:19:int[] access$1202(neureka.Tsr,int[]) -> c
    19:19:int[] access$1300(neureka.Tsr) -> d
    19:19:int[] access$1400(int[]) -> c
    19:19:int[] access$1502(neureka.Tsr,int[]) -> d
    19:19:int[] access$1600(neureka.Tsr) -> e
    19:19:int[] access$1702(neureka.Tsr,int[]) -> e
    19:19:int[] access$1800(neureka.Tsr) -> f
    19:19:int[] access$1902(neureka.Tsr,int[]) -> f
    22:23:void <clinit>() -> <clinit>
neureka.Tsr$Create -> neureka.Tsr$Create:
    1146:1146:void <init>() -> <init>
    1149:1149:neureka.Tsr E(int[]) -> E
    1153:1153:neureka.Tsr newRandom(int[]) -> newRandom
    1157:1158:neureka.Tsr newRandom(int[],long) -> newRandom
    1162:1166:neureka.Tsr newTsrLike(neureka.Tsr,double) -> newTsrLike
    1170:1174:neureka.Tsr newTsrLike(neureka.Tsr) -> newTsrLike
    1178:1182:neureka.Tsr _newEmptyLike(neureka.Tsr) -> a
neureka.Tsr$Exec -> neureka.Tsr$Exec:
    859:859:void <init>() -> <init>
    862:880:neureka.Tsr reshaped(neureka.Tsr,int[],boolean) -> reshaped
neureka.Tsr$IO -> neureka.Tsr$IO:
    784:784:void <init>() -> <init>
    787:789:double getFrom(neureka.Tsr,int) -> getFrom
    793:794:double getFrom(neureka.Tsr,int[]) -> getFrom
    798:800:void setInto(neureka.Tsr,int,double) -> setInto
    803:805:void setInto(neureka.Tsr,int[],double) -> setInto
    808:810:void addInto(neureka.Tsr,int,double) -> addInto
    813:815:void addInto(neureka.Tsr,int[],double) -> addInto
    818:820:neureka.Tsr addInto(neureka.Tsr,neureka.Tsr) -> addInto
    824:826:void subInto(neureka.Tsr,int,double) -> subInto
    829:831:void subInto(neureka.Tsr,int[],double) -> subInto
    834:845:void subInto(neureka.Tsr,neureka.Tsr) -> subInto
    848:850:void mulInto(neureka.Tsr,int,double) -> mulInto
    853:855:void mulInto(neureka.Tsr,int[],double) -> mulInto
neureka.abstraction.AbstractComponentOwner -> neureka.abstraction.AbstractComponentOwner:
    java.util.ArrayList _components -> _components
    15:20:void <init>() -> <init>
    27:34:java.lang.Object find(java.lang.Class) -> find
    43:51:neureka.abstraction.AbstractComponentOwner remove(java.lang.Class) -> remove
    60:60:boolean has(java.lang.Class) -> has
    69:81:neureka.abstraction.AbstractComponentOwner add(java.lang.Object) -> add
    java.lang.Object _addOrReject(java.lang.Object) -> _addOrReject
    97:102:boolean forComponent(java.lang.Class,java.util.function.Consumer) -> forComponent
neureka.abstraction.AbstractNDArray -> neureka.abstraction.AbstractNDArray:
    java.util.Map _CONFIGS -> a
    int[] _shape -> _shape
    int[] _translation -> _translation
    int[] _idxmap -> _idxmap
    java.lang.Object _value -> _value
    25:25:void <init>() -> <init>
    59:59:boolean is64() -> is64
    63:63:boolean is32() -> is32
    68:91:int[] _cached(int[]) -> _cached
    98:105:int i_of_idx(int[]) -> i_of_idx
    109:109:int _i_of_i(int) -> _i_of_i
    113:125:int[] idx_of_i(int) -> idx_of_i
    131:131:int[] shape() -> shape
    135:135:int shape(int) -> shape
    139:139:int rank() -> rank
    143:143:int[] idxmap() -> idxmap
    147:147:int[] translation() -> translation
    151:151:int size() -> size
    29:30:void <clinit>() -> <clinit>
neureka.abstraction.AbstractNDArray$Utility -> neureka.abstraction.AbstractNDArray$Utility:
    162:162:void <init>() -> <init>
neureka.abstraction.AbstractNDArray$Utility$Indexing -> neureka.abstraction.AbstractNDArray$Utility$Indexing:
    196:196:void <init>() -> <init>
    201:204:void increment(int[],int[]) -> increment
    1208:1233:int _incrementAt(int,int[],int[]):208:233 -> increment
    1208:1233:void increment(int[],int[]):203 -> increment
    239:252:int[] newTlnOf(int[]) -> newTlnOf
    257:262:int[] rearrange(int[],int[]) -> rearrange
    267:272:int[] shpCheck(int[],neureka.Tsr) -> shpCheck
    277:283:int[] rearrange(int[],int[],int[]) -> rearrange
    288:290:int[] shpOfCon(int[],int[]) -> shpOfCon
    295:302:int[] shpOfBrc(int[],int[]) -> shpOfBrc
    307:309:int szeOfShp(int[]) -> szeOfShp
neureka.abstraction.AbstractNDArray$Utility$Stringify -> neureka.abstraction.AbstractNDArray$Utility$Stringify:
    164:164:void <init>() -> <init>
    168:182:java.lang.String formatFP(double) -> formatFP
    187:189:java.lang.String strConf(int[]) -> strConf
neureka.acceleration.AbstractDevice -> neureka.acceleration.AbstractDevice:
    java.lang.ref.Cleaner CLEANER -> a
    java.lang.ref.ReferenceQueue _reference_queue -> _reference_queue
    11:11:void <init>() -> <init>
    void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    23:24:void update(neureka.Tsr,neureka.Tsr) -> update
    28:29:neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    34:35:neureka.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    40:73:void _execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> _execute
    1197:1206:void _createNewDrainTensorIn(neureka.acceleration.Device,neureka.Tsr[],neureka.calculus.environment.OperationType):197:206 -> _execute
    1197:1206:void _execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int):52 -> _execute
    77:165:neureka.Tsr _execute_recursively(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> a
    172:194:void _execute_tensor_scalar(neureka.Tsr,double,neureka.calculus.environment.OperationType,int) -> _execute_tensor_scalar
    11:11:void update(java.lang.Object,java.lang.Object) -> update
    13:13:void <clinit>() -> <clinit>
neureka.acceleration.AbstractDevice$Utility -> neureka.acceleration.AbstractDevice$Utility:
    209:209:void <init>() -> <init>
    213:219:neureka.Tsr[] _subset(neureka.Tsr[],int,int,int) -> _subset
    222:224:neureka.Tsr[] _without(neureka.Tsr[],int) -> _without
    228:240:neureka.Tsr[] _offsetted(neureka.Tsr[],int) -> _offsetted
neureka.acceleration.Device -> neureka.acceleration.Device:
    13:23:neureka.acceleration.Device find(java.lang.String) -> find
    void dispose() -> dispose
    neureka.acceleration.Device get(neureka.Tsr) -> get
    neureka.acceleration.Device add(neureka.Tsr) -> add
    neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    boolean has(neureka.Tsr) -> has
    neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    neureka.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    double[] value64Of(neureka.Tsr) -> value64Of
    float[] value32Of(neureka.Tsr) -> value32Of
    java.util.Collection tensors() -> tensors
    16:22:void lambda$find$1(java.lang.String,neureka.acceleration.Device[],neureka.acceleration.opencl.OpenCLPlatform) -> a
    17:21:void lambda$find$0(java.lang.String,neureka.acceleration.Device[],neureka.acceleration.opencl.OpenCLDevice) -> a
neureka.acceleration.host.HostCPU -> neureka.acceleration.host.HostCPU:
    neureka.acceleration.host.HostCPU _instance -> a
    neureka.acceleration.host.HostCPU$NativeExecutor _executor -> b
    24:26:void <init>() -> <init>
    29:29:neureka.acceleration.host.HostCPU instance() -> instance
    33:33:neureka.acceleration.host.HostCPU$NativeExecutor getExecutor() -> getExecutor
    38:56:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    60:66:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    70:71:void dispose() -> dispose
    75:75:neureka.acceleration.Device get(neureka.Tsr) -> get
    80:80:neureka.acceleration.Device add(neureka.Tsr) -> add
    85:85:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    90:90:boolean has(neureka.Tsr) -> has
    95:95:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    100:100:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    105:105:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    110:110:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    115:115:double[] value64Of(neureka.Tsr) -> value64Of
    120:120:float[] value32Of(neureka.Tsr) -> value32Of
    125:125:java.util.Collection tensors() -> tensors
    19:20:void <clinit>() -> <clinit>
neureka.acceleration.host.HostCPU$NativeExecutor -> neureka.acceleration.host.HostCPU$NativeExecutor:
    java.util.concurrent.ThreadPoolExecutor _pool -> a
    132:135:void <init>(neureka.acceleration.host.HostCPU) -> <init>
    138:138:java.util.concurrent.ThreadPoolExecutor getPool() -> getPool
    142:149:void activate(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> activate
    152:161:void broadcast(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> broadcast
    164:171:void convolve(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> convolve
    174:182:void scalar(neureka.Tsr[],double,int,neureka.calculus.environment.OperationType) -> scalar
    188:213:void _threaded(int,neureka.acceleration.host.HostCPU$Range) -> a
    199:201:void lambda$_threaded$4(neureka.Neureka,neureka.acceleration.host.HostCPU$Range,int,int) -> a
    177:179:void lambda$scalar$3(neureka.Tsr[],neureka.calculus.environment.OperationType,double,int,int,int) -> a
    165:168:void lambda$convolve$2(neureka.Tsr[],int,neureka.calculus.environment.OperationType,int,int) -> a
    155:158:void lambda$broadcast$1(neureka.Tsr[],int,neureka.calculus.environment.OperationType,int,int) -> b
    144:146:void lambda$activate$0(neureka.Tsr[],neureka.calculus.environment.OperationType,int,int,int) -> a
neureka.acceleration.host.HostCPU$Range -> neureka.acceleration.host.HostCPU$a:
    void execute(int,int) -> execute
neureka.acceleration.host.Kernel -> neureka.acceleration.host.Kernel:
    7:7:void <init>() -> <init>
    15:150:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$DefaultOperator) -> convolve
    158:240:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$DefaultOperator) -> broadcast
    248:261:void activate(neureka.Tsr,int,int,neureka.calculus.environment.Type$DefaultOperator) -> a
neureka.acceleration.opencl.OpenCLDevice -> neureka.acceleration.opencl.OpenCLDevice:
    java.util.Map _mapping -> a
    org.jocl.cl_device_id _did -> b
    neureka.acceleration.opencl.OpenCLPlatform _platform -> c
    org.jocl.cl_command_queue _queue -> d
    39:39:org.jocl.cl_device_id CLDeviceID() -> CLDeviceID
    34:77:void <init>(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> <init>
    80:81:neureka.acceleration.opencl.OpenCLDevice instance(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> instance
    89:95:java.util.Collection tensors() -> tensors
    100:102:void dispose() -> dispose
    106:110:neureka.acceleration.Device get(neureka.Tsr) -> get
    115:116:neureka.acceleration.Device add(neureka.Tsr) -> add
    121:127:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    131:202:neureka.acceleration.Device _add(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr) -> a
    207:207:boolean has(neureka.Tsr) -> has
    211:250:void _store$56fffdf2(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr,int) -> a
    255:261:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    274:292:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    296:302:void _releaseEvents(neureka.Tsr[]) -> a
    305:312:org.jocl.cl_event[] _getWaitList(neureka.Tsr[]) -> b
    317:337:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    342:345:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    350:366:double[] value64Of(neureka.Tsr) -> value64Of
    372:388:float[] value32Of(neureka.Tsr) -> value32Of
    395:476:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    480:505:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    509:509:java.lang.String name() -> name
    513:513:java.lang.String vendor() -> vendor
    517:517:java.lang.String version() -> version
    521:530:java.lang.String type() -> type
    534:534:int maxComputeUnits() -> maxComputeUnits
    538:538:long maxWorkItemSimensions() -> maxWorkItemSimensions
    542:542:long[] maxWorkItemSizes() -> maxWorkItemSizes
    546:546:long maxWorkGroupSize() -> maxWorkGroupSize
    550:550:long maxClockFrequenzy() -> maxClockFrequenzy
    554:554:int maxAddressBits() -> maxAddressBits
    558:558:long maxMemAllocSize() -> maxMemAllocSize
    562:562:long globalMemSize() -> globalMemSize
    566:566:int errorCorrectionSupport() -> errorCorrectionSupport
    570:570:int localMemType() -> localMemType
    574:574:long localMemSize() -> localMemSize
    578:578:long maxConstantBufferSize() -> maxConstantBufferSize
    582:582:long maxConstantBufferSizeKB() -> maxConstantBufferSizeKB
    586:587:boolean queueExecIsOrdered() -> queueExecIsOrdered
    591:592:boolean queueProfilingIsEnabled() -> queueProfilingIsEnabled
    596:596:int imageSupport() -> imageSupport
    600:600:int maxReadImageArgs() -> maxReadImageArgs
    604:604:int maxWriteImageArgs() -> maxWriteImageArgs
    608:608:long singleFPConfig() -> singleFPConfig
    612:612:long image2DMaxWidth() -> image2DMaxWidth
    616:616:long image2DMaxHeight() -> image2DMaxHeight
    620:620:long image3DMaxWidth() -> image3DMaxWidth
    624:624:long image3DMaxHeight() -> image3DMaxHeight
    628:628:long image3DMaxDepth() -> image3DMaxDepth
    632:632:int prefVecWidthChar() -> prefVecWidthChar
    636:636:int prefVecWidthShort() -> prefVecWidthShort
    640:640:int prefVecWidthInt() -> prefVecWidthInt
    644:644:int prefVecWidthLong() -> prefVecWidthLong
    648:648:int prefVecWidthFloat() -> prefVecWidthFloat
    652:652:int prefVecWidthDouble() -> prefVecWidthDouble
    195:195:void lambda$_add$3(java.lang.ref.WeakReference) -> a
    1265:1270:void _rmv(java.lang.ref.WeakReference):265:270 -> a
    1265:1270:void lambda$_add$3(java.lang.ref.WeakReference):195 -> a
    108:108:void lambda$get$2(java.lang.Object) -> a
    100:100:void lambda$dispose$1(java.lang.Object,neureka.acceleration.opencl.OpenCLDevice$cl_tsr) -> a
    92:94:void lambda$tensors$0(java.util.Collection,java.lang.Object) -> a
neureka.acceleration.opencl.OpenCLDevice$DeviceQuery -> neureka.acceleration.opencl.OpenCLDevice$DeviceQuery:
    655:655:void <init>() -> <init>
    664:664:int getInt(org.jocl.cl_device_id,int) -> getInt
    676:678:int[] getInts(org.jocl.cl_device_id,int,int) -> getInts
    689:689:long getLong(org.jocl.cl_device_id,int) -> getLong
    701:703:long[] getLongs(org.jocl.cl_device_id,int,int) -> getLongs
    715:723:java.lang.String getString(org.jocl.cl_device_id,int) -> getString
    735:743:java.lang.String getString(org.jocl.cl_platform_id,int) -> getString
    754:754:long getSize(org.jocl.cl_device_id,int) -> getSize
    768:782:long[] getSizes(org.jocl.cl_device_id,int,int) -> getSizes
neureka.acceleration.opencl.OpenCLDevice$cl_value -> neureka.acceleration.opencl.OpenCLDevice$a:
    org.jocl.cl_mem data -> a
    int uses -> b
    int size -> c
    org.jocl.cl_event event -> d
    21:24:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLDevice$cl_tsr -> neureka.acceleration.opencl.OpenCLDevice$b:
    int fp -> a
    org.jocl.cl_mem config -> b
    neureka.acceleration.opencl.OpenCLDevice$cl_value value -> c
    28:31:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLPlatform -> neureka.acceleration.opencl.OpenCLPlatform:
    org.jocl.cl_platform_id _pid -> a
    java.util.Map _id_device -> b
    org.jocl.cl_context _context -> c
    java.util.Map _kernels -> d
    java.util.Map OPERATION_TO_KERNEL_MAPPING -> e
    61:61:java.lang.String kernelNameOf(neureka.calculus.environment.OperationType) -> kernelNameOf
    65:94:void <init>(org.jocl.cl_platform_id) -> <init>
    97:101:void recompile() -> recompile
    106:170:void _compile(org.jocl.cl_device_id[]) -> a
    178:254:java.util.Map _getParsedKernelsFromTemplate(java.lang.String,java.lang.String) -> a
    258:258:org.jocl.cl_platform_id getID() -> getID
    262:264:java.util.List getDevices() -> getDevices
    269:269:boolean has(org.jocl.cl_device_id) -> has
    272:272:neureka.acceleration.opencl.OpenCLDevice get(org.jocl.cl_device_id) -> get
    275:276:void put(org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> put
    280:280:java.util.Map getKernels() -> getKernels
    284:284:org.jocl.cl_context getContext() -> getContext
    288:288:java.util.List PLATFORMS() -> PLATFORMS
    263:263:void lambda$getDevices$4(java.util.List,org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> a
    204:214:void lambda$_getParsedKernelsFromTemplate$3(java.lang.String[],java.lang.String,java.util.function.Function,java.util.function.Function,java.util.Map,java.lang.String,java.lang.String,java.lang.String) -> a
    198:201:java.lang.String lambda$_getParsedKernelsFromTemplate$2(java.lang.String) -> a
    184:194:java.lang.String lambda$_getParsedKernelsFromTemplate$1(java.lang.String) -> b
    137:139:void lambda$_compile$0(java.util.ArrayList,java.util.ArrayList,java.lang.String,java.lang.String) -> a
    18:58:void <clinit>() -> <clinit>
neureka.acceleration.opencl.OpenCLPlatform$Parser -> neureka.acceleration.opencl.OpenCLPlatform$a:
    void apply(java.lang.String,java.lang.String,java.lang.String) -> apply
neureka.acceleration.opencl.OpenCLPlatform$_setup -> neureka.acceleration.opencl.OpenCLPlatform$b:
    java.util.List PLATFORMS -> a
    293:293:void <clinit>() -> <clinit>
    1297:1308:java.util.List findAllPlatforms():297:308 -> <clinit>
    1297:1308:void <clinit>():293 -> <clinit>
neureka.acceleration.opencl.utility.DeviceQuery -> neureka.acceleration.opencl.utility.DeviceQuery:
    14:14:void <init>() -> <init>
    23:182:java.lang.String query() -> query
    1270:1278:java.lang.String getString(org.jocl.cl_platform_id,int):270:278 -> query
    1270:1278:java.lang.String query():38 -> query
    194:194:int getInt(org.jocl.cl_device_id,int) -> a
    207:209:int[] getInts(org.jocl.cl_device_id,int,int) -> a
    221:221:long getLong(org.jocl.cl_device_id,int) -> b
    234:236:long[] getLongs(org.jocl.cl_device_id,int,int) -> b
    249:257:java.lang.String getString(org.jocl.cl_device_id,int) -> c
    290:290:long getSize(org.jocl.cl_device_id,int) -> d
    305:324:long[] getSizes(org.jocl.cl_device_id,int,int) -> c
neureka.acceleration.opencl.utility.WeakTensorReference -> neureka.acceleration.opencl.utility.WeakTensorReference:
    int _hash -> a
    24:26:void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    30:30:int hashCode() -> hashCode
    35:35:boolean equals(java.lang.Object) -> equals
neureka.autograd.ADAgent -> neureka.autograd.ADAgent:
    neureka.autograd.ADAgent$ADAction _fad -> a
    neureka.autograd.ADAgent$ADAction _bad -> b
    java.util.function.Supplier _derivative -> c
    19:23:void <init>(java.util.function.Supplier,neureka.autograd.ADAgent$ADAction,neureka.autograd.ADAgent$ADAction) -> <init>
    26:30:void <init>(neureka.Tsr) -> <init>
    33:33:neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    38:38:neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    42:42:neureka.Tsr derivative() -> derivative
    46:46:boolean isForward() -> isForward
    51:57:java.lang.String toString() -> toString
    27:27:neureka.Tsr lambda$new$0(neureka.Tsr) -> a
neureka.autograd.ADAgent$ADAction -> neureka.autograd.ADAgent$ADAction:
    neureka.Tsr execute(neureka.autograd.GraphNode,neureka.Tsr) -> execute
neureka.autograd.GraphLock -> neureka.autograd.GraphLock:
    neureka.calculus.Function _owner -> a
    boolean _is_locked -> b
    22:31:void <init>(neureka.calculus.Function,neureka.Tsr[]) -> <init>
    37:37:boolean isLocked() -> isLocked
    45:46:void release() -> release
    53:53:java.lang.String toString() -> toString
neureka.autograd.GraphNode -> neureka.autograd.GraphNode:
    neureka.calculus.Function MUL -> a
    neureka.calculus.Function ADD -> b
    int _mode -> c
    boolean _relies_on_JIPProp -> d
    neureka.autograd.PendingError _pending_error -> e
    boolean _is_used_as_derivative -> f
    neureka.calculus.Function _function -> g
    neureka.autograd.GraphNode[] _parents -> h
    java.lang.ref.WeakReference _payload -> i
    java.util.TreeMap _targets_derivatives -> j
    neureka.autograd.GraphLock _lock -> k
    java.util.List _children -> l
    long _nid -> m
    31:31:boolean usesAD() -> usesAD
    40:40:boolean usesForwardAD() -> usesForwardAD
    49:49:boolean usesReverseAD() -> usesReverseAD
    77:77:boolean reliesOnJustInTimeProp() -> reliesOnJustInTimeProp
    87:89:neureka.autograd.PendingError getAndRemovePendingError() -> getAndRemovePendingError
    103:103:boolean isUsedAsDerivative() -> isUsedAsDerivative
    113:113:neureka.calculus.Function getFunction() -> getFunction
    122:122:neureka.autograd.GraphNode[] getParents() -> getParents
    142:142:neureka.Tsr getPayload() -> getPayload
    146:163:void _setPayload(neureka.Tsr) -> a
    169:170:void update(neureka.Tsr,neureka.Tsr) -> update
    186:186:neureka.autograd.GraphLock lock() -> lock
    195:195:java.util.List getChildren() -> getChildren
    204:204:long nid() -> nid
    215:216:void obtainLocking(neureka.autograd.GraphLock) -> obtainLocking
    222:225:void _attachChild(neureka.autograd.GraphNode) -> a
    234:234:boolean isCachable() -> isCachable
    243:243:boolean isLeave() -> isLeave
    247:251:boolean isGraphLeave() -> isGraphLeave
    258:258:boolean isVirtual() -> isVirtual
    80:281:void <init>(neureka.calculus.Function,java.lang.Object,java.util.function.Supplier) -> <init>
    284:352:void _construct(neureka.Tsr,neureka.calculus.Function,neureka.Tsr[],neureka.autograd.GraphLock) -> a
    362:381:int _modeOf(neureka.Tsr[],neureka.calculus.Function) -> a
    394:406:void backward(neureka.Tsr) -> backward
    424:448:void _backward(neureka.Tsr,java.util.Set,boolean) -> a
    460:468:void _carryPendingBackPropToGradients(java.util.Set) -> a
    484:486:void backwardJIT(neureka.Tsr) -> backwardJIT
    489:511:void _backwardJIT(neureka.Tsr,neureka.autograd.GraphNode) -> a
    523:527:void _deleteDerivativesRecursively() -> a
    535:544:int _numberOfReverseModeADChildren() -> b
    551:551:int mode() -> mode
    558:558:neureka.calculus.Function function() -> function
    566:579:void put(neureka.autograd.GraphNode,java.lang.Object) -> put
    586:587:java.lang.Object get(neureka.autograd.GraphNode) -> get
    598:599:boolean has(neureka.autograd.GraphNode) -> has
    609:609:int size() -> size
    617:621:void forEachBackward(neureka.Tsr,java.util.function.BiConsumer) -> forEachBackward
    628:632:void forEachForward(neureka.Tsr,java.util.function.BiConsumer) -> forEachForward
    639:641:void forEachDerivative(java.util.function.BiConsumer) -> forEachDerivative
    648:650:void forEachTarget(java.util.function.Consumer) -> forEachTarget
    657:659:void forEach(neureka.Tsr,java.util.function.BiConsumer) -> forEach
    666:666:boolean hasDerivatives() -> hasDerivatives
    673:678:java.lang.String type() -> type
    683:683:java.lang.String toString() -> toString
    691:699:java.lang.String toString(java.lang.String) -> toString
    715:729:java.lang.String _toString(java.lang.String,boolean) -> a
    20:20:void update(java.lang.Object,java.lang.Object) -> update
    658:658:void lambda$forEach$14(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    649:649:void lambda$forEachTarget$13(java.util.function.Consumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    630:631:void lambda$forEachForward$12(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> b
    619:620:void lambda$forEachBackward$11(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> c
    566:566:int lambda$put$10(neureka.autograd.GraphNode,neureka.autograd.GraphNode) -> a
    508:508:void lambda$_backwardJIT$9(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> a
    507:507:void lambda$_backwardJIT$8(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> b
    461:461:void lambda$_carryPendingBackPropToGradients$7(java.util.Set,neureka.autograd.GraphNode) -> a
    445:445:void lambda$_backward$6(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> a
    444:444:void lambda$_backward$5(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> b
    400:403:void lambda$backward$4(neureka.autograd.GraphNode) -> b
    397:397:void lambda$backward$3(java.util.Set,neureka.autograd.GraphNode) -> b
    336:339:void lambda$_construct$2(neureka.autograd.GraphNode,neureka.Tsr) -> a
    275:275:void lambda$new$1(java.lang.Object) -> a
    151:161:void lambda$_setPayload$0() -> c
    21:23:void <clinit>() -> <clinit>
neureka.autograd.JITProp -> neureka.autograd.JITProp:
    java.util.Set _finished -> a
    java.util.Set _pending -> b
    12:14:void <init>(java.util.Set) -> <init>
    21:23:void addPending(java.util.Set) -> addPending
    30:35:void noteFinished(neureka.autograd.GraphNode) -> noteFinished
    38:38:java.util.Set finished() -> finished
    45:53:void execute() -> execute
    60:60:boolean isDone() -> isDone
    46:51:void lambda$execute$0(neureka.autograd.GraphNode) -> a
neureka.autograd.PendingError -> neureka.autograd.PendingError:
    int _toBeReceived -> a
    neureka.Tsr _error -> b
    11:14:void <init>(neureka.Tsr,int) -> <init>
    17:21:void accumulate(neureka.Tsr) -> accumulate
    24:24:boolean isFullyAccumulated() -> isFullyAccumulated
    28:28:neureka.Tsr getAccumulatedError() -> getAccumulatedError
neureka.calculus.Function -> neureka.calculus.Function:
    neureka.calculus.environment.Cache CACHE -> CACHE
    20:20:neureka.calculus.Function create(java.lang.String) -> create
    24:24:neureka.calculus.Function create(java.lang.String,boolean) -> create
    neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    boolean doesAD() -> doesAD
    boolean isFlat() -> isFlat
    int id() -> id
    neureka.calculus.environment.OperationType type() -> type
    boolean dependsOn(int) -> dependsOn
    double activate(double) -> activate
    double activate(double[],int) -> activate
    double activate(double[]) -> activate
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    neureka.Tsr activate(neureka.Tsr) -> activate
    neureka.Tsr activate(neureka.Tsr[],int) -> activate
    neureka.Tsr activate(neureka.Tsr[]) -> activate
    neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    neureka.Tsr derive(neureka.Tsr[],int) -> derive
    java.lang.String toString() -> toString
    neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    17:17:void <clinit>() -> <clinit>
neureka.calculus.Function$Setup -> neureka.calculus.Function$Setup:
    27:27:void <init>() -> <init>
    30:30:neureka.Tsr commit(neureka.Tsr[],java.lang.String,boolean) -> commit
    34:34:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],java.lang.String,boolean) -> commit
    38:38:neureka.Tsr commit(neureka.Tsr[],neureka.calculus.Function) -> commit
    42:42:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function) -> commit
    47:75:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier) -> commit
    54:54:neureka.Tsr lambda$commit$0(neureka.Tsr) -> a
neureka.calculus.environment.Cache -> neureka.calculus.environment.Cache:
    neureka.calculus.environment.Cache _cache -> a
    java.util.Map FUNCTIONS -> b
    java.util.Map PROCESSING -> c
    15:30:void <init>() -> <init>
    18:20:neureka.calculus.environment.Cache instance() -> instance
    27:27:java.util.Map FUNCTIONS() -> FUNCTIONS
    34:36:void free(neureka.autograd.GraphLock) -> free
    40:74:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier,int,int) -> preprocess
    79:85:neureka.Tsr _get(neureka.autograd.GraphNode,int,int) -> a
    90:101:void _put(neureka.Tsr,neureka.autograd.GraphNode,int,int) -> a
    104:104:int _keyed(int) -> a
    94:94:int lambda$_put$2(java.lang.Long,java.lang.Long) -> a
    60:60:neureka.Tsr lambda$preprocess$1(neureka.Tsr) -> a
    30:30:int lambda$new$0(neureka.autograd.GraphLock,neureka.autograd.GraphLock) -> a
    13:13:void <clinit>() -> <clinit>
neureka.calculus.environment.OperationType -> neureka.calculus.environment.OperationType:
    java.util.Map _LOOKUP -> a
    java.util.ArrayList _REGISTER -> b
    int _ID -> c
    int _id -> _id
    java.lang.String _name -> _name
    java.lang.String _identifier -> _identifier
    boolean _isOperation -> _isOperation
    boolean _isIndexer -> _isIndexer
    boolean _isConvection -> _isConvection
    boolean _isCommutative -> _isCommutative
    boolean _isAssociative -> _isAssociative
    neureka.calculus.environment.Type$Activation _activation -> _activation
    neureka.calculus.environment.Type$Convolution _convolution -> _convolution
    neureka.calculus.environment.Type$Broadcast _broadcast -> _broadcast
    neureka.calculus.environment.Type$Scalarization _scalarization -> _scalarization
    neureka.calculus.environment.Type$Operation _operation -> _operation
    26:26:neureka.calculus.environment.OperationType instance(int) -> instance
    30:30:neureka.calculus.environment.OperationType instance(java.lang.String) -> instance
    35:124:void <init>(java.lang.String,java.lang.String,boolean,boolean,boolean,boolean,boolean,neureka.calculus.environment.Type$Activation,neureka.calculus.environment.Type$Scalarization,neureka.calculus.environment.Type$Convolution,neureka.calculus.environment.Type$Broadcast,neureka.calculus.environment.Type$Operation) -> <init>
    127:127:neureka.calculus.environment.OperationType[] ALL() -> ALL
    131:131:int COUNT() -> COUNT
    138:138:java.lang.String getName() -> getName
    145:145:neureka.calculus.environment.Type$Activation getActivation() -> getActivation
    150:150:boolean supportsActivation() -> supportsActivation
    157:157:neureka.calculus.environment.Type$Scalarization getScalarization() -> getScalarization
    162:162:boolean supportsScalar() -> supportsScalar
    169:169:neureka.calculus.environment.Type$Convolution getConvolution() -> getConvolution
    174:174:boolean supportsConvolution() -> supportsConvolution
    181:181:neureka.calculus.environment.Type$Broadcast getBroadcast() -> getBroadcast
    186:186:boolean supportsBroadcast() -> supportsBroadcast
    193:193:neureka.calculus.environment.Type$Operation getOperation() -> getOperation
    198:198:boolean supportsOperation() -> supportsOperation
    205:205:int id() -> id
    210:210:java.lang.String identifier() -> identifier
    216:216:boolean isOperation() -> isOperation
    221:221:boolean isIndexer() -> isIndexer
    226:226:boolean isConvection() -> isConvection
    231:231:boolean isCommutative() -> isCommutative
    237:246:boolean allowsForward(neureka.Tsr[]) -> allowsForward
    252:285:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    288:288:neureka.Tsr lambda$getADAgentOf$10(neureka.autograd.GraphNode,neureka.Tsr) -> a
    287:287:neureka.Tsr lambda$getADAgentOf$9(neureka.autograd.GraphNode,neureka.Tsr) -> b
    286:286:neureka.Tsr lambda$getADAgentOf$8() -> a
    281:281:neureka.Tsr lambda$getADAgentOf$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    280:280:neureka.Tsr lambda$getADAgentOf$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    279:279:neureka.Tsr lambda$getADAgentOf$5(neureka.Tsr) -> a
    268:268:neureka.Tsr lambda$getADAgentOf$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    267:267:neureka.Tsr lambda$getADAgentOf$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    266:266:neureka.Tsr lambda$getADAgentOf$2(neureka.Tsr) -> b
    258:258:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    257:257:neureka.Tsr lambda$getADAgentOf$0(neureka.Tsr) -> c
    21:76:void <clinit>() -> <clinit>
neureka.calculus.environment.Type -> neureka.calculus.environment.Type:
    neureka.calculus.environment.Type$Activation getActivation() -> getActivation
    boolean supportsActivation() -> supportsActivation
    neureka.calculus.environment.Type$Scalarization getScalarization() -> getScalarization
    boolean supportsScalar() -> supportsScalar
    neureka.calculus.environment.Type$Convolution getConvolution() -> getConvolution
    boolean supportsConvolution() -> supportsConvolution
    neureka.calculus.environment.Type$Broadcast getBroadcast() -> getBroadcast
    boolean supportsBroadcast() -> supportsBroadcast
    neureka.calculus.environment.Type$Operation getOperation() -> getOperation
    boolean supportsOperation() -> supportsOperation
    java.lang.String getName() -> getName
    int id() -> id
    java.lang.String identifier() -> identifier
    boolean isOperation() -> isOperation
    boolean isIndexer() -> isIndexer
    boolean isConvection() -> isConvection
    boolean isCommutative() -> isCommutative
    boolean allowsForward(neureka.Tsr[]) -> allowsForward
    neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
neureka.calculus.environment.Type$Activation -> neureka.calculus.environment.Type$Activation:
    47:48:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$Broadcast -> neureka.calculus.environment.Type$Broadcast:
    61:62:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$Convolution -> neureka.calculus.environment.Type$Convolution:
    54:55:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$Operation -> neureka.calculus.environment.Type$Operation:
    75:76:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$OperatorCreator -> neureka.calculus.environment.Type$OperatorCreator:
    neureka.calculus.environment.Type$DefaultOperator create(neureka.Tsr[],int) -> create
neureka.calculus.environment.Type$DefaultOperator -> neureka.calculus.environment.Type$DefaultOperator:
    double execute(int[],int[],int[]) -> execute
neureka.calculus.environment.Type$ScalarOperatorCreator -> neureka.calculus.environment.Type$ScalarOperatorCreator:
    neureka.calculus.environment.Type$DefaultOperator create(neureka.Tsr[],double,int) -> create
neureka.calculus.environment.Type$Scalarization -> neureka.calculus.environment.Type$Scalarization:
    68:69:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$ScalarOperatorCreator) -> <init>
neureka.calculus.environment.Type$TypeComponent -> neureka.calculus.environment.Type$TypeComponent:
    java.lang.String _operation -> _operation
    java.lang.String _deriviation -> _deriviation
    java.lang.Object _creator -> _creator
    26:30:void <init>(java.lang.String,java.lang.String,java.lang.Object) -> <init>
    32:32:java.lang.String getAsString() -> getAsString
    35:35:java.lang.String getDeriviationAsString() -> getDeriviationAsString
    38:38:java.lang.Object getCreator() -> getCreator
neureka.calculus.environment.implementations.function.Absolute -> neureka.calculus.environment.implementations.function.Absolute:
    9:27:void <init>() -> <init>
    14:18:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    18:18:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:16:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Cosinus -> neureka.calculus.environment.implementations.function.Cosinus:
    9:25:void <init>() -> <init>
    14:16:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    16:16:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    15:15:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Gaussian -> neureka.calculus.environment.implementations.function.Gaussian:
    9:37:void <init>() -> <init>
    20:24:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    25:26:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Identity -> neureka.calculus.environment.implementations.function.Identity:
    9:25:void <init>() -> <init>
    13:15:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    15:15:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    14:14:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Ligmoid -> neureka.calculus.environment.implementations.function.Ligmoid:
    9:40:void <init>() -> <init>
    30:32:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    32:32:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    31:31:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Quadratic -> neureka.calculus.environment.implementations.function.Quadratic:
    9:35:void <init>() -> <init>
    21:27:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    27:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.ReLU -> neureka.calculus.environment.implementations.function.ReLU:
    8:41:void <init>() -> <init>
    21:28:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    29:30:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sigmoid -> neureka.calculus.environment.implementations.function.Sigmoid:
    9:38:void <init>() -> <init>
    21:25:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    26:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    23:23:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sinus -> neureka.calculus.environment.implementations.function.Sinus:
    9:25:void <init>() -> <init>
    15:17:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    17:17:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:16:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Tanh -> neureka.calculus.environment.implementations.function.Tanh:
    8:31:void <init>() -> <init>
    13:20:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    21:22:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:17:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.indexer.Product -> neureka.calculus.environment.implementations.indexer.Product:
    8:35:void <init>() -> <init>
    19:24:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    25:26:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.indexer.Summation -> neureka.calculus.environment.implementations.indexer.Summation:
    8:29:void <init>() -> <init>
    19:24:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    24:24:double lambda$new$1(int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.operator.Addition -> neureka.calculus.environment.implementations.operator.Addition:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    neureka.calculus.environment.Type$Broadcast _broadcast -> b
    26:96:void <init>() -> <init>
    35:37:neureka.calculus.environment.Type$DefaultOperator lambda$new$5(neureka.Tsr[],double,int) -> a
    37:37:double lambda$new$4(int[],int[],int[]) -> a
    36:36:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:14:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    14:14:double lambda$static$1(int[],int[],int[]) -> b
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:18:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Division -> neureka.calculus.environment.implementations.operator.Division:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    26:103:void <init>() -> <init>
    37:42:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    42:42:double lambda$new$5(double,double[],neureka.Tsr[],int[],int[],int[]) -> a
    41:41:double lambda$new$4(double,int[],int[],int[]) -> a
    39:39:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:14:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    15:18:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:7:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Modulo -> neureka.calculus.environment.implementations.operator.Modulo:
    9:46:void <init>() -> <init>
    18:23:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    24:30:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    21:21:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.operator.Multiplication -> neureka.calculus.environment.implementations.operator.Multiplication:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    28:133:void <init>() -> <init>
    93:98:neureka.calculus.environment.Type$DefaultOperator lambda$new$11(neureka.Tsr[],int) -> a
    99:100:double lambda$new$10(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    96:96:double lambda$new$9(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    57:59:neureka.calculus.environment.Type$DefaultOperator lambda$new$8(neureka.Tsr[],int) -> b
    59:59:double lambda$new$7(double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    35:40:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    40:40:double lambda$new$5(double[],neureka.Tsr[],int[],int[],int[]) -> a
    39:39:double lambda$new$4(double,int[],int[],int[]) -> a
    37:37:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    14:19:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> c
    20:21:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    17:17:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> c
    12:12:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Power -> neureka.calculus.environment.implementations.operator.Power:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    33:116:void <init>() -> <init>
    42:49:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    49:49:double lambda$new$5(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    47:47:double lambda$new$4(double,double[],neureka.Tsr[],int[],int[],int[]) -> a
    44:44:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> b
    9:14:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    15:25:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    8:8:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Subtraction -> neureka.calculus.environment.implementations.operator.Subtraction:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    24:91:void <init>() -> <init>
    35:40:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    40:40:double lambda$new$5(int[],int[],int[]) -> a
    39:39:double lambda$new$4(int[],int[],int[]) -> b
    37:37:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:16:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    17:17:double lambda$static$1(int,int[],int[],int[]) -> a
    13:13:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:7:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.other.CopyLeft -> neureka.calculus.environment.implementations.other.CopyLeft:
    9:14:void <init>() -> <init>
neureka.calculus.environment.implementations.other.CopyRight -> neureka.calculus.environment.implementations.other.CopyRight:
    8:11:void <init>() -> <init>
neureka.calculus.environment.implementations.other.Randomization -> neureka.calculus.environment.implementations.other.Randomization:
    12:33:void <init>() -> <init>
    22:25:neureka.calculus.environment.Type$DefaultOperator lambda$new$1(neureka.Tsr[],double,int) -> a
    25:25:double lambda$new$0(java.util.Random,int[],int[],int[]) -> a
neureka.calculus.environment.implementations.other.Reshape -> neureka.calculus.environment.implementations.other.Reshape:
    13:18:void <init>() -> <init>
    22:25:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    28:28:neureka.Tsr lambda$getADAgentOf$2(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    27:27:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    26:26:neureka.Tsr lambda$getADAgentOf$0() -> a
neureka.calculus.factory.AbstractFunction -> neureka.calculus.factory.AbstractFunction:
    neureka.calculus.environment.OperationType _type -> a
    boolean _isFlat -> b
    boolean _doAD -> c
    java.util.ArrayList _src -> d
    30:35:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    39:39:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    44:44:boolean isFlat() -> isFlat
    49:49:boolean doesAD() -> doesAD
    54:54:int id() -> id
    59:59:neureka.calculus.environment.OperationType type() -> type
    64:96:java.lang.String toString() -> toString
    101:104:boolean dependsOn(int) -> dependsOn
    110:110:neureka.Tsr activate(neureka.Tsr) -> activate
    neureka.Tsr activate(neureka.Tsr[],int) -> activate
    neureka.Tsr activate(neureka.Tsr[]) -> activate
    neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    neureka.Tsr derive(neureka.Tsr[],int) -> derive
    128:128:double activate(double) -> activate
    double activate(double[],int) -> activate
    double activate(double[]) -> activate
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    147:147:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    159:169:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int) -> _tensor_activation
    1320:1323:neureka.acceleration.Device _device(neureka.Tsr[]):320:323 -> _tensor_activation
    1320:1323:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):159 -> _tensor_activation
    1351:1366:boolean _shareGuestDevice(neureka.Tsr[]):351:366 -> _tensor_activation
    1351:1366:neureka.acceleration.Device _device(neureka.Tsr[]):321 -> _tensor_activation
    1351:1366:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):159 -> _tensor_activation
    175:219:neureka.Tsr _execute(neureka.Tsr[],int,int,neureka.acceleration.Device) -> a
    224:297:neureka.Tsr _execution(neureka.Tsr[],int,int,neureka.acceleration.Device) -> b
    301:316:neureka.Tsr _apply(neureka.acceleration.Device,int,java.util.function.Supplier) -> a
    327:347:neureka.Tsr[] _src_acti(neureka.Tsr[],int,int,int) -> a
    371:393:double _scalar_activation(double,boolean) -> _scalar_activation
    399:419:double _scalar_activation(double[],int,int) -> _scalar_activation
    219:219:neureka.Tsr lambda$_execute$2(neureka.Tsr[],int,int,neureka.acceleration.Device) -> c
    167:167:neureka.Tsr lambda$_tensor_activation$1(neureka.Tsr[],int,int,neureka.acceleration.Device) -> d
    162:162:neureka.Tsr lambda$_tensor_activation$0(neureka.Tsr[],int,int,neureka.acceleration.Device) -> e
neureka.calculus.factory.AbstractFunction$Exec -> neureka.calculus.factory.AbstractFunction$Exec:
    423:423:void <init>() -> <init>
    429:436:double reLu(double,boolean) -> reLu
    443:446:double sigmoid(double,boolean) -> sigmoid
    453:456:double tanh(double,boolean) -> tanh
    463:464:double quadratic(double,boolean) -> quadratic
    470:471:double ligmoid(double,boolean) -> ligmoid
    477:478:double linear(double,boolean) -> linear
    484:485:double gaussian(double,boolean) -> gaussian
    491:492:double absolute(double,boolean) -> absolute
    498:499:double sinus(double,boolean) -> sinus
    505:506:double cosinus(double,boolean) -> cosinus
    512:524:double summation(double[],int,int,java.util.ArrayList) -> a
    529:551:double summation(double[],int,java.util.ArrayList) -> a
    559:578:double PI(double[],int,int,java.util.ArrayList) -> b
    584:605:double PI(double[],int,java.util.ArrayList) -> b
    615:636:double power(double[],int,int,java.util.ArrayList) -> c
    642:667:double power(double[],int,java.util.ArrayList) -> c
    674:691:double division(double[],int,int,java.util.ArrayList) -> d
    697:718:double division(double[],int,java.util.ArrayList) -> d
    725:743:double multiplication(double[],int,int,java.util.ArrayList) -> e
    749:767:double multiplication(double[],int,java.util.ArrayList) -> e
    786:794:double modulo(double[],int,int,java.util.ArrayList) -> f
    800:808:double modulo(double[],int,java.util.ArrayList) -> f
    815:831:double subtraction(double[],int,int,java.util.ArrayList) -> g
    837:853:double subtraction(double[],int,java.util.ArrayList) -> g
    860:872:double addition(double[],int,int,java.util.ArrayList) -> h
    878:890:double addition(double[],int,java.util.ArrayList) -> h
neureka.calculus.factory.assembly.FunctionBuilder -> neureka.calculus.factory.assembly.FunctionBuilder:
    10:10:void <init>() -> <init>
    19:35:neureka.calculus.Function build(neureka.calculus.environment.OperationType,int,boolean) -> build
    46:58:neureka.calculus.Function build(java.lang.String,boolean) -> build
    1067:1258:neureka.calculus.Function _build(java.lang.String,boolean):67:258 -> build
    1067:1258:neureka.calculus.Function build(java.lang.String,boolean):54 -> build
    268:275:java.util.List _rebindPairwise(java.util.List,int) -> a
neureka.calculus.factory.assembly.FunctionConstructor -> neureka.calculus.factory.assembly.FunctionConstructor:
    12:12:void <init>() -> <init>
    16:59:neureka.calculus.Function construct(int,java.util.ArrayList,boolean) -> construct
neureka.calculus.factory.assembly.FunctionConstructor$1 -> neureka.calculus.factory.assembly.FunctionConstructor$1:
    java.util.ArrayList val$sources -> a
    21:21:void <init>(int,boolean,java.util.ArrayList,boolean,java.util.ArrayList) -> <init>
    24:24:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    28:28:neureka.Tsr activate(neureka.Tsr[]) -> activate
    32:32:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    36:36:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    41:41:double activate(double[],int) -> activate
    45:45:double activate(double[]) -> activate
    49:50:double derive(double[],int,int) -> derive
    54:55:double derive(double[],int) -> derive
    28:28:neureka.Tsr lambda$activate$1(java.util.ArrayList,neureka.Tsr[]) -> a
    24:24:neureka.Tsr lambda$activate$0(java.util.ArrayList,neureka.Tsr[],int) -> a
neureka.calculus.factory.assembly.FunctionConstructor$2 -> neureka.calculus.factory.assembly.FunctionConstructor$2:
    59:59:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    62:62:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    66:66:neureka.Tsr activate(neureka.Tsr[]) -> activate
    70:70:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    74:74:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    79:79:double activate(double[],int) -> activate
    83:83:double activate(double[]) -> activate
    87:87:double derive(double[],int,int) -> derive
    91:91:double derive(double[],int) -> derive
    74:74:neureka.Tsr lambda$derive$3(neureka.Tsr[],int) -> a
    70:70:neureka.Tsr lambda$derive$2(neureka.Tsr[],int,int) -> a
    66:66:neureka.Tsr lambda$activate$1(neureka.Tsr[]) -> a
    62:62:neureka.Tsr lambda$activate$0(neureka.Tsr[],int) -> b
neureka.calculus.factory.assembly.FunctionParser -> neureka.calculus.factory.assembly.FunctionParser:
    10:10:void <init>() -> <init>
    12:18:int numberOfOperationsWithin(java.util.List) -> numberOfOperationsWithin
    22:32:java.lang.String parsedOperation(java.lang.String,int) -> parsedOperation
    36:62:java.lang.String parsedComponent(java.lang.String,int) -> parsedComponent
    66:69:boolean containsOperation(java.lang.String,java.util.List) -> containsOperation
    73:74:boolean isBasicOperation(java.lang.String) -> isBasicOperation
    78:89:java.lang.String groupBy(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> groupBy
    93:93:boolean isWeired(char) -> a
    98:102:java.lang.String removeHeadAndTail(java.lang.String) -> removeHeadAndTail
    106:153:java.lang.String cleanedHeadAndTail(java.lang.String) -> cleanedHeadAndTail
    157:207:java.lang.String unpackAndCorrect(java.lang.String) -> unpackAndCorrect
    211:222:java.lang.String assumptionBasedOn(java.lang.String) -> assumptionBasedOn
    226:241:double similarity(java.lang.String,java.lang.String) -> similarity
neureka.calculus.factory.components.FunctionConstant -> neureka.calculus.factory.components.FunctionConstant:
    double _value -> a
    8:8:void <init>() -> <init>
    12:12:double value() -> value
    17:17:boolean isFlat() -> isFlat
    22:22:boolean doesAD() -> doesAD
    27:27:int id() -> id
    32:32:neureka.calculus.environment.OperationType type() -> type
    37:37:boolean dependsOn(int) -> dependsOn
    43:56:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    62:62:double activate(double) -> activate
    67:67:double activate(double[],int) -> activate
    72:72:double activate(double[]) -> activate
    77:77:double derive(double[],int) -> derive
    82:82:double derive(double[],int,int) -> derive
    89:89:neureka.Tsr activate(neureka.Tsr) -> activate
    94:94:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    99:99:neureka.Tsr activate(neureka.Tsr[]) -> activate
    104:104:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    109:109:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    115:115:java.lang.String toString() -> toString
    121:121:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionInput -> neureka.calculus.factory.components.FunctionInput:
    int _index -> a
    10:10:void <init>() -> <init>
    15:15:boolean providesGradient() -> providesGradient
    20:20:boolean isFlat() -> isFlat
    25:25:boolean doesAD() -> doesAD
    30:30:int id() -> id
    35:35:neureka.calculus.environment.OperationType type() -> type
    40:40:boolean dependsOn(int) -> dependsOn
    47:67:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    72:82:neureka.Tsr _extract(neureka.Tsr) -> a
    89:89:double activate(double) -> activate
    94:94:double activate(double[],int) -> activate
    99:99:double activate(double[]) -> activate
    104:104:double derive(double[],int) -> derive
    109:109:double derive(double[],int,int) -> derive
    116:116:neureka.Tsr activate(neureka.Tsr) -> activate
    121:121:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    126:126:neureka.Tsr activate(neureka.Tsr[]) -> activate
    131:131:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    136:138:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    145:145:java.lang.String toString() -> toString
    149:149:int index() -> index
    154:154:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionVariable -> neureka.calculus.factory.components.FunctionVariable:
    boolean _providesGradient -> a
    9:11:void <init>() -> <init>
    14:14:boolean providesGradient() -> providesGradient
    19:19:boolean isFlat() -> isFlat
    24:24:boolean doesAD() -> doesAD
    29:29:int id() -> id
    34:34:neureka.calculus.environment.OperationType type() -> type
    39:39:boolean dependsOn(int) -> dependsOn
    45:46:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    53:53:double activate(double) -> activate
    58:58:double activate(double[],int) -> activate
    63:65:double activate(double[]) -> activate
    70:70:double derive(double[],int) -> derive
    75:76:double derive(double[],int,int) -> derive
    82:82:neureka.Tsr activate(neureka.Tsr) -> activate
    87:87:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    92:94:neureka.Tsr activate(neureka.Tsr[]) -> activate
    99:99:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    104:104:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    111:111:java.lang.String toString() -> toString
    116:116:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.GradientProvider -> neureka.calculus.factory.components.GradientProvider:
    boolean providesGradient() -> providesGradient
neureka.framing.IndexAlias -> neureka.framing.IndexAlias:
    java.util.Map _mapping -> a
    12:22:void <init>(java.util.List) -> <init>
    24:27:void <init>(int) -> <init>
    29:42:void <init>(java.util.Map,neureka.Tsr) -> <init>
    45:45:int[] get(java.util.List) -> get
    49:60:int[] get(java.lang.Object[]) -> get
    65:67:int get(java.lang.Object,java.lang.Object) -> get
    72:75:void replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    78:84:void _initializeIdxmap(java.lang.Object,int,java.lang.Object,int) -> a
    88:91:void set(java.lang.Object,java.lang.Object,int) -> set
    95:99:java.util.List keysOf(java.lang.Object) -> keysOf
    103:107:java.util.List keysOf(java.lang.Object,int) -> keysOf
    111:119:java.lang.String _fixed(java.lang.String,int) -> a
    125:187:java.lang.String toString() -> toString
    158:173:void lambda$toString$6(java.lang.Object[],int[],java.lang.StringBuilder,int[],java.lang.Object,java.lang.Object) -> a
    161:162:void lambda$toString$5(int[],java.lang.Object[],java.lang.Object,java.lang.Integer) -> a
    140:146:void lambda$toString$4(int[],int[],java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    133:133:java.lang.Boolean lambda$toString$3(int,int,java.lang.Integer) -> a
    105:105:void lambda$keysOf$2(int,java.util.List,java.lang.Object,java.lang.Integer) -> a
    97:97:void lambda$keysOf$1(java.util.List,java.lang.Object,java.lang.Integer) -> a
    33:41:void lambda$new$0(neureka.Tsr,int[],java.lang.Object,java.util.List) -> a
neureka.framing.Relation -> neureka.framing.Relation:
    neureka.Tsr _parent -> a
    java.lang.ref.WeakReference[] _children -> b
    9:9:void <init>() -> <init>
    17:36:void update(neureka.Tsr,neureka.Tsr) -> update
    40:41:neureka.framing.Relation addParent(neureka.Tsr) -> addParent
    45:55:neureka.framing.Relation addChild(neureka.Tsr) -> addChild
    59:69:neureka.framing.Relation foreachChild(java.util.function.Consumer) -> foreachChild
    73:73:boolean hasParent() -> hasParent
    77:77:boolean hasChildren() -> hasChildren
    81:81:int childCount() -> childCount
    9:9:void update(java.lang.Object,java.lang.Object) -> update
neureka.optimization.Optimizer -> neureka.optimization.Optimizer:
    void optimize(neureka.Tsr) -> optimize
neureka.optimization.implementations.ADAM -> neureka.optimization.implementations.ADAM:
neureka.optimization.implementations.Template -> neureka.optimization.implementations.Template:
    6:6:void <init>() -> <init>
    12:12:void optimize(neureka.Tsr) -> optimize
neureka.utility.DataHelper -> neureka.utility.DataHelper:
    5:5:void <init>() -> <init>
    9:9:double[] newSeededDoubleArray(java.lang.String,int) -> newSeededDoubleArray
    13:13:double[] newSeededDoubleArray(long,int) -> newSeededDoubleArray
    17:17:double[] seededDoubleArray(double[],java.lang.String) -> seededDoubleArray
    21:24:double[] seededDoubleArray(double[],long) -> seededDoubleArray
    28:28:float[] newSeededFloatArray(java.lang.String,int) -> newSeededFloatArray
    32:32:float[] newSeededFloatArray(long,int) -> newSeededFloatArray
    36:36:float[] seededFloatArray(float[],java.lang.String) -> seededFloatArray
    40:43:float[] seededFloatArray(float[],long) -> seededFloatArray
    48:51:long _longStringHash(java.lang.String) -> a
    55:58:float[] doubleToFloat(double[]) -> doubleToFloat
    62:65:double[] floatToDouble(float[]) -> floatToDouble
