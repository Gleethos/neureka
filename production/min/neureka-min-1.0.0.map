neureka.Component -> neureka.Component:
    void update(java.lang.Object,java.lang.Object) -> update
neureka.Neureka -> neureka.Neureka:
    java.util.Map _instances -> a
    java.lang.String _settings_source -> b
    java.lang.String _setup_source -> c
    neureka.Neureka$Settings _settings -> d
    neureka.Neureka$Utility _utility -> e
    27:30:void <init>() -> <init>
    33:33:neureka.Neureka instance() -> instance
    37:38:void setContext(java.lang.Thread,neureka.Neureka) -> setContext
    41:48:neureka.Neureka instance(java.lang.Thread) -> instance
    53:55:neureka.Neureka instance(groovy.lang.Closure) -> instance
    59:59:neureka.Neureka$Settings settings() -> settings
    63:65:neureka.Neureka$Settings settings(groovy.lang.Closure) -> settings
    69:69:neureka.Neureka$Utility utility() -> utility
    73:73:java.lang.String version() -> version
    77:94:void reset() -> reset
    97:97:boolean _currentThreadIsAuthorized() -> a
    24:25:void <clinit>() -> <clinit>
neureka.Neureka$Settings -> neureka.Neureka$Settings:
    neureka.Neureka$Settings$Debug _debug -> b
    neureka.Neureka$Settings$AutoDiff _autoDiff -> c
    neureka.Neureka$Settings$Indexing _indexing -> d
    neureka.Neureka$Settings$View _view -> e
    boolean _isLocked -> f
    neureka.Neureka this$0 -> a
    107:114:void <init>(neureka.Neureka) -> <init>
    117:117:neureka.Neureka$Settings$Debug debug() -> debug
    121:123:neureka.Neureka$Settings$Debug debug(groovy.lang.Closure) -> debug
    127:127:neureka.Neureka$Settings$AutoDiff autoDiff() -> autoDiff
    131:133:neureka.Neureka$Settings$AutoDiff autoDiff(groovy.lang.Closure) -> autoDiff
    137:137:neureka.Neureka$Settings$Indexing indexing() -> indexing
    141:143:neureka.Neureka$Settings$Indexing indexing(groovy.lang.Closure) -> indexing
    147:147:neureka.Neureka$Settings$View view() -> view
    151:153:neureka.Neureka$Settings$View view(groovy.lang.Closure) -> view
    157:157:boolean isLocked() -> isLocked
    161:162:void setIsLocked(boolean) -> setIsLocked
neureka.Neureka$Settings$AutoDiff -> neureka.Neureka$Settings$AutoDiff:
    boolean _retainPendingErrorForJITProp -> a
    boolean _applyGradientWhenTensorIsUsed -> b
    neureka.Neureka$Settings this$1 -> c
    194:194:void <init>(neureka.Neureka$Settings) -> <init>
    215:215:boolean retainPendingErrorForJITProp() -> retainPendingErrorForJITProp
    219:221:void setRetainPendingErrorForJITProp(boolean) -> setRetainPendingErrorForJITProp
    224:224:boolean applyGradientWhenTensorIsUsed() -> applyGradientWhenTensorIsUsed
    228:230:void setApplyGradientWhenTensorIsUsed(boolean) -> setApplyGradientWhenTensorIsUsed
neureka.Neureka$Settings$Debug -> neureka.Neureka$Settings$Debug:
    boolean _keepDerivativeTargetPayloads -> a
    neureka.Neureka$Settings this$1 -> b
    164:164:void <init>(neureka.Neureka$Settings) -> <init>
    184:184:boolean keepDerivativeTargetPayloads() -> keepDerivativeTargetPayloads
    188:190:void setKeepDerivativeTargetPayloads(boolean) -> setKeepDerivativeTargetPayloads
neureka.Neureka$Settings$Indexing -> neureka.Neureka$Settings$Indexing:
    boolean _legacyIndexing -> a
    boolean _thoroughIndexing -> b
    neureka.Neureka$Settings this$1 -> c
    234:234:void <init>(neureka.Neureka$Settings) -> <init>
    241:241:boolean legacy() -> legacy
    245:247:void setLegacy(boolean) -> setLegacy
    250:250:boolean thorough() -> thorough
    254:256:void setThorough(boolean) -> setThorough
neureka.Neureka$Settings$View -> neureka.Neureka$Settings$View:
    boolean _legacyView -> a
    neureka.Neureka$Settings this$1 -> b
    260:260:void <init>(neureka.Neureka$Settings) -> <init>
    266:266:boolean legacy() -> legacy
    270:272:void setLegacy(boolean) -> setLegacy
neureka.Neureka$Utility -> neureka.Neureka$Utility:
    278:278:void <init>() -> <init>
    288:301:java.lang.String readResource(java.lang.String) -> readResource
neureka.Tsr -> neureka.Tsr:
    neureka.acceleration.Device _CPU -> a
    int _flags -> b
    41:43:neureka.Tsr setRqsGradient(boolean) -> setRqsGradient
    47:47:boolean rqsGradient() -> rqsGradient
    51:55:void _setRqsGradient(boolean) -> _setRqsGradient
    58:80:neureka.Tsr setIsOutsourced(boolean) -> setIsOutsourced
    84:84:boolean isOutsourced() -> isOutsourced
    88:92:void _setIsOutsourced(boolean) -> _setIsOutsourced
    95:115:neureka.Tsr setIsVirtual(boolean) -> setIsVirtual
    119:119:boolean isVirtual() -> isVirtual
    123:127:void _setIsVirtual(boolean) -> _setIsVirtual
    142:145:java.lang.Object _addOrReject(java.lang.Object) -> _addOrReject
    152:152:boolean isEmpty() -> isEmpty
    156:156:boolean isUndefined() -> isUndefined
    160:161:boolean isSlice() -> isSlice
    165:166:int sliceCount() -> sliceCount
    170:171:boolean isSliceParent() -> isSliceParent
    175:175:boolean belongsToGraph() -> belongsToGraph
    179:179:boolean isLeave() -> isLeave
    183:183:boolean isBranch() -> isBranch
    193:194:neureka.acceleration.Device device() -> device
    202:202:neureka.autograd.GraphNode graphNode() -> graphNode
    210:210:neureka.framing.IndexAlias index() -> index
    217:241:neureka.Tsr _become(neureka.Tsr) -> _become
    245:258:neureka.Tsr delete() -> delete
    269:282:void _configureFromNewShape(int[]) -> _configureFromNewShape
    32:288:void <init>() -> <init>
    32:293:void <init>(java.lang.Object) -> <init>
    32:304:void <init>(java.util.List,java.lang.String) -> <init>
    32:319:void <init>(java.util.List,java.util.List) -> <init>
    32:350:void <init>(java.util.List) -> <init>
    32:354:void <init>(java.lang.Object,java.lang.Object) -> <init>
    32:357:void <init>(java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    32:360:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    32:363:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    32:366:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    32:369:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    32:372:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    32:375:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    32:378:void <init>(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> <init>
    32:382:void <init>(int[],java.lang.String) -> <init>
    385:387:void _construct(int[],java.lang.String) -> a
    390:396:int[] _intArray(java.lang.Object[]) -> a
    400:407:double[] _doubleArray(java.lang.Object[]) -> b
    32:412:void <init>(java.lang.Object[]) -> <init>
    415:470:void _construct(java.lang.Object[]) -> c
    32:474:void <init>(double) -> <init>
    32:478:void <init>(int[]) -> <init>
    481:483:void _construct(int[]) -> f
    32:487:void <init>(int[],double) -> <init>
    490:495:void _construct(int[],double) -> a
    32:499:void <init>(int[],double[]) -> <init>
    502:509:void _construct(int[],double[]) -> a
    32:516:void <init>(neureka.Tsr,java.lang.String) -> <init>
    32:520:void <init>(neureka.Tsr[],java.lang.String) -> <init>
    32:524:void <init>(neureka.Tsr[],java.lang.String,boolean) -> <init>
    527:530:void _construct(neureka.Tsr[],java.lang.String,boolean) -> a
    542:545:neureka.Tsr backward(neureka.Tsr) -> backward
    554:555:neureka.Tsr backward(double) -> backward
    559:565:void applyGradient() -> applyGradient
    570:573:neureka.Tsr T() -> T
    577:577:neureka.Tsr plus(neureka.Tsr) -> plus
    580:580:neureka.Tsr plusAssign(neureka.Tsr) -> plusAssign
    583:583:neureka.Tsr plus(java.lang.Double) -> plus
    586:586:neureka.Tsr minus(neureka.Tsr) -> minus
    589:589:neureka.Tsr minusAssign(neureka.Tsr) -> minusAssign
    592:592:neureka.Tsr negative() -> negative
    595:595:neureka.Tsr multiply(neureka.Tsr) -> multiply
    598:598:neureka.Tsr timesAssign(neureka.Tsr) -> timesAssign
    601:601:neureka.Tsr multiply(java.lang.Double) -> multiply
    604:604:neureka.Tsr div(neureka.Tsr) -> div
    607:607:neureka.Tsr div(java.lang.Double) -> div
    610:610:neureka.Tsr divAssign(neureka.Tsr) -> divAssign
    613:613:neureka.Tsr mod(neureka.Tsr) -> mod
    616:616:neureka.Tsr modAssign(neureka.Tsr) -> modAssign
    619:619:neureka.Tsr power(neureka.Tsr) -> power
    622:622:neureka.Tsr power(java.lang.Double) -> power
    625:625:neureka.Tsr xor(neureka.Tsr) -> xor
    628:628:neureka.Tsr xor(java.lang.Double) -> xor
    631:640:neureka.Tsr dot(neureka.Tsr) -> dot
    643:647:boolean isCase(neureka.Tsr) -> isCase
    650:650:boolean contains(neureka.Tsr) -> contains
    654:666:neureka.Tsr label(java.lang.String[][]) -> label
    670:672:neureka.Tsr label(java.util.List) -> label
    676:677:neureka.Tsr label(java.util.Map) -> label
    681:692:neureka.Tsr putAt(java.lang.Object,neureka.Tsr) -> putAt
    696:696:double getAt(int[]) -> getAt
    700:773:java.lang.Object getAt(java.lang.Object) -> getAt
    788:846:int _configureSubsetFromRanges(java.lang.Object[],int[],int[],int) -> a
    956:958:neureka.Tsr setValue64(double[]) -> setValue64
    962:964:neureka.Tsr setValue32(float[]) -> setValue32
    968:979:neureka.Tsr setValue(java.lang.Object) -> setValue
    983:987:java.lang.Object getValue() -> getValue
    991:993:double[] gradient64() -> gradient64
    997:999:float[] gradient32() -> gradient32
    1003:1008:neureka.Tsr addToGradient(neureka.Tsr) -> addToGradient
    1012:1019:neureka.Tsr to32() -> to32
    1023:1030:neureka.Tsr to64() -> to64
    1034:1039:double value64(int) -> value64
    1044:1053:double[] value64() -> value64
    1057:1062:float value32(int) -> value32
    1067:1075:float[] value32() -> value32
    1079:1081:neureka.Tsr setValue(double[]) -> setValue
    1091:1091:java.lang.String toString(java.lang.String) -> toString
    1095:1157:java.lang.String _toString(java.lang.String,java.lang.String) -> _toString
    1161:1173:java.lang.String _stringified(double[],boolean,int) -> a
    1177:1177:java.lang.String toString() -> toString
    1182:1198:void makeFit(neureka.Tsr[]) -> makeFit
    1151:1153:void lambda$_toString$18(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1133:1143:void lambda$_toString$17(java.util.concurrent.atomic.AtomicReference,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    1027:1027:void lambda$to64$16(java.lang.Object) -> a
    1016:1016:void lambda$to32$15(java.lang.Object) -> b
    1006:1006:void lambda$addToGradient$14(neureka.Tsr,java.lang.Object) -> a
    1004:1004:void lambda$addToGradient$13(neureka.Tsr,java.lang.Object) -> b
    644:644:void lambda$isCase$12(neureka.Tsr,boolean[],java.lang.Object) -> a
    645:646:void lambda$isCase$11(neureka.Tsr,boolean[],neureka.Tsr) -> a
    561:564:void lambda$applyGradient$10(java.lang.Object) -> c
    561:561:void lambda$applyGradient$9(java.lang.Object) -> d
    559:559:void lambda$applyGradient$8(java.lang.Object) -> e
    542:542:void lambda$backward$7(neureka.Tsr,java.lang.Object) -> c
    256:256:void lambda$delete$6(java.lang.Object) -> f
    247:250:void lambda$delete$5(java.lang.Object) -> g
    245:245:void lambda$delete$4(java.lang.Object) -> h
    103:103:void lambda$setIsVirtual$3(neureka.Tsr) -> i
    65:75:void lambda$setIsOutsourced$2(java.lang.Object) -> i
    70:70:void lambda$setIsOutsourced$1(java.lang.Object) -> j
    71:73:void lambda$setIsOutsourced$0(java.lang.Object,java.lang.Object) -> a
    20:20:int[] access$002(neureka.Tsr,int[]) -> a
    20:20:int[] access$100(neureka.Tsr) -> a
    20:20:int[] access$200(int[]) -> a
    20:20:int[] access$302(neureka.Tsr,int[]) -> b
    20:20:int[] access$400(neureka.Tsr) -> b
    20:20:int[] access$500(neureka.Tsr) -> c
    20:20:int[] access$600(int[]) -> b
    20:20:int[] access$702(neureka.Tsr,int[]) -> c
    20:20:int[] access$800(neureka.Tsr) -> d
    20:20:int[] access$900(int[]) -> c
    20:20:int[] access$1000(neureka.Tsr) -> e
    20:20:int[] access$1102(neureka.Tsr,int[]) -> d
    20:20:int[] access$1200(int[]) -> d
    20:20:int[] access$1300(neureka.Tsr) -> f
    20:20:int[] access$1402(neureka.Tsr,int[]) -> e
    20:20:int[] access$1500(int[]) -> e
    20:20:int[] access$1602(neureka.Tsr,int[]) -> f
    20:20:int[] access$1700(neureka.Tsr) -> g
    20:20:int[] access$1802(neureka.Tsr,int[]) -> g
    20:20:int[] access$1900(neureka.Tsr) -> h
    20:20:int[] access$2002(neureka.Tsr,int[]) -> h
    20:20:int[] access$2102(neureka.Tsr,int[]) -> i
    20:20:int[] access$2202(neureka.Tsr,int[]) -> j
    22:22:void <clinit>() -> <clinit>
neureka.Tsr$Create -> neureka.Tsr$Create:
    1202:1202:void <init>() -> <init>
    1205:1205:neureka.Tsr E(int[]) -> E
    1209:1209:neureka.Tsr newRandom(int[]) -> newRandom
    1213:1214:neureka.Tsr newRandom(int[],long) -> newRandom
    1218:1222:neureka.Tsr newTsrLike(neureka.Tsr,double) -> newTsrLike
    1226:1230:neureka.Tsr newTsrLike(neureka.Tsr) -> newTsrLike
    1234:1240:neureka.Tsr _newEmptyLike(neureka.Tsr) -> a
neureka.Tsr$Exec -> neureka.Tsr$Exec:
    928:928:void <init>() -> <init>
    931:947:neureka.Tsr reshaped(neureka.Tsr,int[],boolean) -> reshaped
neureka.Tsr$IO -> neureka.Tsr$IO:
    851:851:void <init>() -> <init>
    854:856:double getFrom(neureka.Tsr,int) -> getFrom
    860:861:double getFrom(neureka.Tsr,int[]) -> getFrom
    865:867:void setInto(neureka.Tsr,int,double) -> setInto
    870:872:void setInto(neureka.Tsr,int[],double) -> setInto
    875:877:void addInto(neureka.Tsr,int,double) -> addInto
    880:882:void addInto(neureka.Tsr,int[],double) -> addInto
    885:887:neureka.Tsr addInto(neureka.Tsr,neureka.Tsr) -> addInto
    891:893:void subInto(neureka.Tsr,int,double) -> subInto
    896:898:void subInto(neureka.Tsr,int[],double) -> subInto
    901:912:void subInto(neureka.Tsr,neureka.Tsr) -> subInto
    915:917:void mulInto(neureka.Tsr,int,double) -> mulInto
    920:922:void mulInto(neureka.Tsr,int[],double) -> mulInto
neureka.abstraction.AbstractComponentOwner -> neureka.abstraction.AbstractComponentOwner:
    java.util.List _components -> _components
    17:22:void <init>() -> <init>
    29:36:java.lang.Object find(java.lang.Class) -> find
    45:53:java.lang.Object remove(java.lang.Class) -> remove
    62:62:boolean has(java.lang.Class) -> has
    71:83:java.lang.Object add(java.lang.Object) -> add
    java.lang.Object _addOrReject(java.lang.Object) -> _addOrReject
    99:104:boolean forComponent(java.lang.Class,java.util.function.Consumer) -> forComponent
neureka.abstraction.AbstractNDArray -> neureka.abstraction.AbstractNDArray:
    int[] _shape -> _shape
    int[] _translation -> _translation
    int[] _idxmap -> _idxmap
    int[] _spread -> _spread
    int[] _offset -> _offset
    java.lang.Object _value -> _value
    25:25:void <init>() -> <init>
    67:67:boolean is64() -> is64
    71:71:boolean is32() -> is32
    75:75:int[] _cached(int[]) -> _cached
    107:109:int i_of_idx(int[]) -> i_of_idx
    113:113:int i_of_i(int) -> i_of_i
    117:129:int[] idx_of_i(int) -> idx_of_i
    135:135:int[] shape() -> shape
    139:139:int shape(int) -> shape
    143:143:int rank() -> rank
    147:147:int[] idxmap() -> idxmap
    151:151:int[] translation() -> translation
    155:155:int[] spread() -> spread
    159:159:int[] offset() -> offset
    163:163:int size() -> size
    29:30:void <clinit>() -> <clinit>
neureka.abstraction.AbstractNDArray$Utility -> neureka.abstraction.AbstractNDArray$Utility:
    174:174:void <init>() -> <init>
neureka.abstraction.AbstractNDArray$Utility$Indexing -> neureka.abstraction.AbstractNDArray$Utility$Indexing:
    208:208:void <init>() -> <init>
    213:216:void increment(int[],int[]) -> increment
    1220:1245:int _incrementAt(int,int[],int[]):220:245 -> increment
    1220:1245:void increment(int[],int[]):215 -> increment
    251:264:int[] newTlnOf(int[]) -> newTlnOf
    269:274:int[] rearrange(int[],int[]) -> rearrange
    279:284:int[] shpCheck(int[],neureka.Tsr) -> shpCheck
    289:295:int[] rearrange(int[],int[],int[]) -> rearrange
    300:321:int[][] makeFit(int[],int[]) -> makeFit
    326:328:int[] shpOfCon(int[],int[]) -> shpOfCon
    333:340:int[] shpOfBrc(int[],int[]) -> shpOfBrc
    345:347:int szeOfShp(int[]) -> szeOfShp
neureka.abstraction.AbstractNDArray$Utility$Stringify -> neureka.abstraction.AbstractNDArray$Utility$Stringify:
    176:176:void <init>() -> <init>
    180:194:java.lang.String formatFP(double) -> formatFP
    199:201:java.lang.String strConf(int[]) -> strConf
neureka.acceleration.AbstractDevice -> neureka.acceleration.AbstractDevice:
    java.lang.ref.Cleaner CLEANER -> a
    10:10:void <init>() -> <init>
    void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    20:21:void update(neureka.Tsr,neureka.Tsr) -> update
    25:26:neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    30:31:void _cleaning(java.lang.Object,java.lang.Runnable) -> _cleaning
    35:36:neureka.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    41:74:void _execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> _execute
    1195:1204:void _createNewDrainTensorIn(neureka.acceleration.Device,neureka.Tsr[],neureka.calculus.environment.OperationType):195:204 -> _execute
    1195:1204:void _execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int):53 -> _execute
    78:163:neureka.Tsr _execute_recursively(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> a
    170:192:void _execute_tensor_scalar(neureka.Tsr,double,neureka.calculus.environment.OperationType,int) -> _execute_tensor_scalar
    10:10:void update(java.lang.Object,java.lang.Object) -> update
    12:12:void <clinit>() -> <clinit>
neureka.acceleration.AbstractDevice$Utility -> neureka.acceleration.AbstractDevice$Utility:
    206:206:void <init>() -> <init>
    208:214:neureka.Tsr[] _subset(neureka.Tsr[],int,int,int) -> _subset
    217:219:neureka.Tsr[] _without(neureka.Tsr[],int) -> _without
    223:235:neureka.Tsr[] _offsetted(neureka.Tsr[],int) -> _offsetted
neureka.acceleration.Device -> neureka.acceleration.Device:
    13:20:neureka.acceleration.Device find(java.lang.String) -> find
    void dispose() -> dispose
    neureka.acceleration.Device get(neureka.Tsr) -> get
    neureka.acceleration.Device add(neureka.Tsr) -> add
    neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    boolean has(neureka.Tsr) -> has
    neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    neureka.acceleration.Device cleaning(neureka.Tsr,java.lang.Runnable) -> cleaning
    neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    neureka.acceleration.Device execute(neureka.Tsr[],neureka.calculus.environment.OperationType,int) -> execute
    double[] value64Of(neureka.Tsr) -> value64Of
    float[] value32Of(neureka.Tsr) -> value32Of
    java.util.Collection tensors() -> tensors
    16:16:void lambda$find$1(java.lang.String,neureka.acceleration.Device[],neureka.acceleration.opencl.OpenCLPlatform) -> a
    17:19:void lambda$find$0(java.lang.String,neureka.acceleration.Device[],neureka.acceleration.opencl.OpenCLDevice) -> a
neureka.acceleration.host.HostCPU -> neureka.acceleration.host.HostCPU:
    neureka.acceleration.host.HostCPU _instance -> a
    neureka.acceleration.host.HostCPU$NativeExecutor _executor -> b
    23:25:void <init>() -> <init>
    28:28:neureka.acceleration.host.HostCPU instance() -> instance
    32:32:neureka.acceleration.host.HostCPU$NativeExecutor getExecutor() -> getExecutor
    37:54:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    58:64:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    68:69:void dispose() -> dispose
    73:73:neureka.acceleration.Device get(neureka.Tsr) -> get
    78:78:neureka.acceleration.Device add(neureka.Tsr) -> add
    83:83:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    88:88:boolean has(neureka.Tsr) -> has
    93:93:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    98:98:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    103:103:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    108:108:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    113:113:double[] value64Of(neureka.Tsr) -> value64Of
    118:118:float[] value32Of(neureka.Tsr) -> value32Of
    123:123:java.util.Collection tensors() -> tensors
    18:19:void <clinit>() -> <clinit>
neureka.acceleration.host.HostCPU$NativeExecutor -> neureka.acceleration.host.HostCPU$NativeExecutor:
    java.util.concurrent.ThreadPoolExecutor _pool -> a
    130:132:void <init>(neureka.acceleration.host.HostCPU) -> <init>
    135:135:java.util.concurrent.ThreadPoolExecutor getPool() -> getPool
    139:147:void activate(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> activate
    150:159:void broadcast(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> broadcast
    162:171:void convolve(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> convolve
    174:182:void scalar(neureka.Tsr[],double,int,neureka.calculus.environment.OperationType) -> scalar
    187:211:void _threaded(int,neureka.acceleration.host.HostCPU$Range) -> a
    197:199:void lambda$_threaded$4(neureka.Neureka,neureka.acceleration.host.HostCPU$Range,int,int) -> a
    177:179:void lambda$scalar$3(neureka.Tsr[],neureka.calculus.environment.OperationType,double,int,int,int) -> a
    165:168:void lambda$convolve$2(neureka.Tsr[],int,neureka.calculus.environment.OperationType,int,int) -> a
    153:156:void lambda$broadcast$1(neureka.Tsr[],int,neureka.calculus.environment.OperationType,int,int) -> b
    142:144:void lambda$activate$0(neureka.Tsr[],neureka.calculus.environment.OperationType,int,int,int) -> a
neureka.acceleration.host.HostCPU$Range -> neureka.acceleration.host.HostCPU$a:
    void execute(int,int) -> execute
neureka.acceleration.host.Kernel -> neureka.acceleration.host.Kernel:
    7:7:void <init>() -> <init>
    15:150:void convolve(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$DefaultOperator) -> convolve
    158:240:void broadcast(neureka.Tsr,neureka.Tsr,neureka.Tsr,int,int,int,neureka.calculus.environment.Type$DefaultOperator) -> broadcast
    248:261:void activate(neureka.Tsr,int,int,neureka.calculus.environment.Type$DefaultOperator) -> a
neureka.acceleration.opencl.OpenCLDevice -> neureka.acceleration.opencl.OpenCLDevice:
    java.util.Set _tensors -> a
    org.jocl.cl_device_id _did -> b
    neureka.acceleration.opencl.OpenCLPlatform _platform -> c
    org.jocl.cl_command_queue _queue -> d
    38:38:org.jocl.cl_device_id CLDeviceID() -> CLDeviceID
    33:75:void <init>(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> <init>
    78:79:neureka.acceleration.opencl.OpenCLDevice instance(neureka.acceleration.opencl.OpenCLPlatform,org.jocl.cl_device_id) -> instance
    87:90:java.util.Collection tensors() -> tensors
    95:97:void dispose() -> dispose
    101:105:neureka.acceleration.Device get(neureka.Tsr) -> get
    110:111:neureka.acceleration.Device add(neureka.Tsr) -> add
    116:120:neureka.acceleration.Device add(neureka.Tsr,neureka.Tsr) -> add
    124:195:void _add(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr) -> a
    199:199:boolean has(neureka.Tsr) -> has
    203:241:void _store(neureka.Tsr,neureka.acceleration.opencl.OpenCLDevice$cl_tsr,int) -> a
    246:251:neureka.acceleration.Device rmv(neureka.Tsr) -> rmv
    265:283:neureka.acceleration.Device overwrite64(neureka.Tsr,double[]) -> overwrite64
    287:293:void _releaseEvents(neureka.Tsr[]) -> a
    296:303:org.jocl.cl_event[] _getWaitList(neureka.Tsr[]) -> b
    308:328:neureka.acceleration.Device overwrite32(neureka.Tsr,float[]) -> overwrite32
    333:338:neureka.acceleration.Device swap(neureka.Tsr,neureka.Tsr) -> swap
    343:359:double[] value64Of(neureka.Tsr) -> value64Of
    365:381:float[] value32Of(neureka.Tsr) -> value32Of
    388:464:void _enqueue(neureka.Tsr[],int,neureka.calculus.environment.OperationType) -> _enqueue
    468:494:void _enqueue(neureka.Tsr,double,int,neureka.calculus.environment.OperationType) -> _enqueue
    498:498:java.lang.String name() -> name
    502:502:java.lang.String vendor() -> vendor
    506:506:java.lang.String version() -> version
    510:519:java.lang.String type() -> type
    523:523:int maxComputeUnits() -> maxComputeUnits
    527:527:long maxWorkItemSimensions() -> maxWorkItemSimensions
    531:531:long[] maxWorkItemSizes() -> maxWorkItemSizes
    535:535:long maxWorkGroupSize() -> maxWorkGroupSize
    539:539:long maxClockFrequenzy() -> maxClockFrequenzy
    543:543:int maxAddressBits() -> maxAddressBits
    547:547:long maxMemAllocSize() -> maxMemAllocSize
    551:551:long globalMemSize() -> globalMemSize
    555:555:int errorCorrectionSupport() -> errorCorrectionSupport
    559:559:int localMemType() -> localMemType
    563:563:long localMemSize() -> localMemSize
    567:567:long maxConstantBufferSize() -> maxConstantBufferSize
    571:571:long maxConstantBufferSizeKB() -> maxConstantBufferSizeKB
    575:576:boolean queueExecIsOrdered() -> queueExecIsOrdered
    580:581:boolean queueProfilingIsEnabled() -> queueProfilingIsEnabled
    585:585:int imageSupport() -> imageSupport
    589:589:int maxReadImageArgs() -> maxReadImageArgs
    593:593:int maxWriteImageArgs() -> maxWriteImageArgs
    597:597:long singleFPConfig() -> singleFPConfig
    601:601:long image2DMaxWidth() -> image2DMaxWidth
    605:605:long image2DMaxHeight() -> image2DMaxHeight
    609:609:long image3DMaxWidth() -> image3DMaxWidth
    613:613:long image3DMaxHeight() -> image3DMaxHeight
    617:617:long image3DMaxDepth() -> image3DMaxDepth
    621:621:int prefVecWidthChar() -> prefVecWidthChar
    625:625:int prefVecWidthShort() -> prefVecWidthShort
    629:629:int prefVecWidthInt() -> prefVecWidthInt
    633:633:int prefVecWidthLong() -> prefVecWidthLong
    637:637:int prefVecWidthFloat() -> prefVecWidthFloat
    641:641:int prefVecWidthDouble() -> prefVecWidthDouble
    140:142:void lambda$_add$4(org.jocl.cl_event,org.jocl.cl_mem) -> a
    127:127:void lambda$_add$3(org.jocl.cl_mem) -> a
    103:103:void lambda$get$2(java.lang.Object) -> a
    89:89:void lambda$tensors$1(java.util.Collection,java.util.Collection) -> a
    89:89:void lambda$tensors$0(java.util.Collection,neureka.Tsr) -> a
neureka.acceleration.opencl.OpenCLDevice$DeviceQuery -> neureka.acceleration.opencl.OpenCLDevice$DeviceQuery:
    644:644:void <init>() -> <init>
    653:653:int getInt(org.jocl.cl_device_id,int) -> getInt
    665:667:int[] getInts(org.jocl.cl_device_id,int,int) -> getInts
    678:678:long getLong(org.jocl.cl_device_id,int) -> getLong
    690:692:long[] getLongs(org.jocl.cl_device_id,int,int) -> getLongs
    704:712:java.lang.String getString(org.jocl.cl_device_id,int) -> getString
    724:732:java.lang.String getString(org.jocl.cl_platform_id,int) -> getString
    743:743:long getSize(org.jocl.cl_device_id,int) -> getSize
    757:771:long[] getSizes(org.jocl.cl_device_id,int,int) -> getSizes
neureka.acceleration.opencl.OpenCLDevice$cl_config -> neureka.acceleration.opencl.OpenCLDevice$a:
    org.jocl.cl_mem data -> a
    23:23:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLDevice$cl_tsr -> neureka.acceleration.opencl.OpenCLDevice$b:
    int fp -> a
    neureka.acceleration.opencl.OpenCLDevice$cl_config config -> b
    neureka.acceleration.opencl.OpenCLDevice$cl_value value -> c
    27:29:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLDevice$cl_value -> neureka.acceleration.opencl.OpenCLDevice$c:
    org.jocl.cl_mem data -> a
    int size -> b
    org.jocl.cl_event event -> c
    17:19:void <init>() -> <init>
neureka.acceleration.opencl.OpenCLPlatform -> neureka.acceleration.opencl.OpenCLPlatform:
    org.jocl.cl_platform_id _pid -> a
    java.util.Map _id_device -> b
    org.jocl.cl_context _context -> c
    java.util.Map _kernels -> d
    java.util.Map OPERATION_TO_KERNEL_MAPPING -> e
    61:61:java.lang.String kernelNameOf(neureka.calculus.environment.OperationType) -> kernelNameOf
    65:94:void <init>(org.jocl.cl_platform_id) -> <init>
    97:101:void recompile() -> recompile
    106:170:void _compile(org.jocl.cl_device_id[]) -> a
    178:254:java.util.Map _getParsedKernelsFromTemplate(java.lang.String,java.lang.String) -> a
    258:258:org.jocl.cl_platform_id getID() -> getID
    262:264:java.util.List getDevices() -> getDevices
    269:269:boolean has(org.jocl.cl_device_id) -> has
    272:272:neureka.acceleration.opencl.OpenCLDevice get(org.jocl.cl_device_id) -> get
    275:276:void put(org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> put
    280:280:java.util.Map getKernels() -> getKernels
    284:284:org.jocl.cl_context getContext() -> getContext
    288:288:java.util.List PLATFORMS() -> PLATFORMS
    263:263:void lambda$getDevices$4(java.util.List,org.jocl.cl_device_id,neureka.acceleration.opencl.OpenCLDevice) -> a
    204:214:void lambda$_getParsedKernelsFromTemplate$3(java.lang.String[],java.lang.String,java.util.function.Function,java.util.function.Function,java.util.Map,java.lang.String,java.lang.String,java.lang.String) -> a
    198:201:java.lang.String lambda$_getParsedKernelsFromTemplate$2(java.lang.String) -> a
    184:194:java.lang.String lambda$_getParsedKernelsFromTemplate$1(java.lang.String) -> b
    137:139:void lambda$_compile$0(java.util.ArrayList,java.util.ArrayList,java.lang.String,java.lang.String) -> a
    18:58:void <clinit>() -> <clinit>
neureka.acceleration.opencl.OpenCLPlatform$Parser -> neureka.acceleration.opencl.OpenCLPlatform$a:
    void apply(java.lang.String,java.lang.String,java.lang.String) -> apply
neureka.acceleration.opencl.OpenCLPlatform$_setup -> neureka.acceleration.opencl.OpenCLPlatform$b:
    java.util.List PLATFORMS -> a
    293:293:void <clinit>() -> <clinit>
    1297:1308:java.util.List findAllPlatforms():297:308 -> <clinit>
    1297:1308:void <clinit>():293 -> <clinit>
neureka.acceleration.opencl.utility.DeviceQuery -> neureka.acceleration.opencl.utility.DeviceQuery:
    14:14:void <init>() -> <init>
    23:182:java.lang.String query() -> query
    1270:1278:java.lang.String getString(org.jocl.cl_platform_id,int):270:278 -> query
    1270:1278:java.lang.String query():38 -> query
    194:194:int getInt(org.jocl.cl_device_id,int) -> a
    207:209:int[] getInts(org.jocl.cl_device_id,int,int) -> a
    221:221:long getLong(org.jocl.cl_device_id,int) -> b
    234:236:long[] getLongs(org.jocl.cl_device_id,int,int) -> b
    249:257:java.lang.String getString(org.jocl.cl_device_id,int) -> c
    290:290:long getSize(org.jocl.cl_device_id,int) -> d
    305:324:long[] getSizes(org.jocl.cl_device_id,int,int) -> c
neureka.acceleration.opencl.utility.WeakTensorReference -> neureka.acceleration.opencl.utility.WeakTensorReference:
    int _hash -> a
    24:26:void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    30:30:int hashCode() -> hashCode
    35:35:boolean equals(java.lang.Object) -> equals
neureka.autograd.ADAgent -> neureka.autograd.ADAgent:
    neureka.autograd.ADAgent$ADAction _fad -> a
    neureka.autograd.ADAgent$ADAction _bad -> b
    java.util.function.Supplier _derivative -> c
    19:23:void <init>(java.util.function.Supplier,neureka.autograd.ADAgent$ADAction,neureka.autograd.ADAgent$ADAction) -> <init>
    26:30:void <init>(neureka.Tsr) -> <init>
    33:33:neureka.Tsr forward(neureka.autograd.GraphNode,neureka.Tsr) -> forward
    38:38:neureka.Tsr backward(neureka.autograd.GraphNode,neureka.Tsr) -> backward
    42:42:neureka.Tsr derivative() -> derivative
    46:46:boolean isForward() -> isForward
    51:57:java.lang.String toString() -> toString
    27:27:neureka.Tsr lambda$new$0(neureka.Tsr) -> a
neureka.autograd.ADAgent$ADAction -> neureka.autograd.ADAgent$ADAction:
    neureka.Tsr execute(neureka.autograd.GraphNode,neureka.Tsr) -> execute
neureka.autograd.GraphLock -> neureka.autograd.GraphLock:
    neureka.calculus.Function _owner -> a
    boolean _is_locked -> b
    22:31:void <init>(neureka.calculus.Function,neureka.Tsr[]) -> <init>
    37:37:boolean isLocked() -> isLocked
    45:46:void release() -> release
    53:53:java.lang.String toString() -> toString
neureka.autograd.GraphNode -> neureka.autograd.GraphNode:
    neureka.calculus.Function MUL -> a
    neureka.calculus.Function ADD -> b
    int _mode -> c
    boolean _relies_on_JIPProp -> d
    neureka.autograd.PendingError _pending_error -> e
    boolean _is_used_as_derivative -> f
    neureka.calculus.Function _function -> g
    neureka.autograd.GraphNode[] _parents -> h
    java.lang.ref.WeakReference _payload -> i
    java.util.TreeMap _targets_derivatives -> j
    neureka.autograd.GraphLock _lock -> k
    java.util.List _children -> l
    long _nid -> m
    31:31:boolean usesAD() -> usesAD
    40:40:boolean usesForwardAD() -> usesForwardAD
    49:49:boolean usesReverseAD() -> usesReverseAD
    77:77:boolean reliesOnJustInTimeProp() -> reliesOnJustInTimeProp
    87:89:neureka.autograd.PendingError getAndRemovePendingError() -> getAndRemovePendingError
    103:103:boolean isUsedAsDerivative() -> isUsedAsDerivative
    113:113:neureka.calculus.Function getFunction() -> getFunction
    122:122:neureka.autograd.GraphNode[] getParents() -> getParents
    142:142:neureka.Tsr getPayload() -> getPayload
    146:163:void _setPayload(neureka.Tsr) -> a
    169:170:void update(neureka.Tsr,neureka.Tsr) -> update
    186:186:neureka.autograd.GraphLock lock() -> lock
    195:195:java.util.List getChildren() -> getChildren
    204:204:long nid() -> nid
    215:216:void obtainLocking(neureka.autograd.GraphLock) -> obtainLocking
    222:225:void _attachChild(neureka.autograd.GraphNode) -> a
    234:234:boolean isCachable() -> isCachable
    243:243:boolean isLeave() -> isLeave
    247:251:boolean isGraphLeave() -> isGraphLeave
    258:258:boolean isVirtual() -> isVirtual
    80:281:void <init>(neureka.calculus.Function,java.lang.Object,java.util.function.Supplier) -> <init>
    284:352:void _construct(neureka.Tsr,neureka.calculus.Function,neureka.Tsr[],neureka.autograd.GraphLock) -> a
    362:381:int _modeOf(neureka.Tsr[],neureka.calculus.Function) -> a
    394:406:void backward(neureka.Tsr) -> backward
    424:448:void _backward(neureka.Tsr,java.util.Set,boolean) -> a
    460:468:void _carryPendingBackPropToGradients(java.util.Set) -> a
    484:486:void backwardJIT(neureka.Tsr) -> backwardJIT
    489:511:void _backwardJIT(neureka.Tsr,neureka.autograd.GraphNode) -> a
    523:527:void _deleteDerivativesRecursively() -> a
    535:544:int _numberOfReverseModeADChildren() -> b
    551:551:int mode() -> mode
    558:558:neureka.calculus.Function function() -> function
    566:579:void put(neureka.autograd.GraphNode,java.lang.Object) -> put
    586:587:java.lang.Object get(neureka.autograd.GraphNode) -> get
    598:599:boolean has(neureka.autograd.GraphNode) -> has
    609:609:int size() -> size
    617:621:void forEachBackward(neureka.Tsr,java.util.function.BiConsumer) -> forEachBackward
    628:632:void forEachForward(neureka.Tsr,java.util.function.BiConsumer) -> forEachForward
    639:641:void forEachDerivative(java.util.function.BiConsumer) -> forEachDerivative
    648:650:void forEachTarget(java.util.function.Consumer) -> forEachTarget
    657:659:void forEach(neureka.Tsr,java.util.function.BiConsumer) -> forEach
    666:666:boolean hasDerivatives() -> hasDerivatives
    673:678:java.lang.String type() -> type
    683:683:java.lang.String toString() -> toString
    691:699:java.lang.String toString(java.lang.String) -> toString
    715:729:java.lang.String _toString(java.lang.String,boolean) -> a
    20:20:void update(java.lang.Object,java.lang.Object) -> update
    658:658:void lambda$forEach$14(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    649:649:void lambda$forEachTarget$13(java.util.function.Consumer,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> a
    630:631:void lambda$forEachForward$12(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> b
    619:620:void lambda$forEachBackward$11(java.util.function.BiConsumer,neureka.Tsr,neureka.autograd.GraphNode,neureka.autograd.ADAgent) -> c
    566:566:int lambda$put$10(neureka.autograd.GraphNode,neureka.autograd.GraphNode) -> a
    508:508:void lambda$_backwardJIT$9(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> a
    507:507:void lambda$_backwardJIT$8(neureka.autograd.GraphNode,neureka.autograd.GraphNode,neureka.Tsr) -> b
    461:461:void lambda$_carryPendingBackPropToGradients$7(java.util.Set,neureka.autograd.GraphNode) -> a
    445:445:void lambda$_backward$6(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> a
    444:444:void lambda$_backward$5(java.util.Set,neureka.autograd.GraphNode,neureka.Tsr) -> b
    400:403:void lambda$backward$4(neureka.autograd.GraphNode) -> b
    397:397:void lambda$backward$3(java.util.Set,neureka.autograd.GraphNode) -> b
    336:339:void lambda$_construct$2(neureka.autograd.GraphNode,neureka.Tsr) -> a
    275:275:void lambda$new$1(java.lang.Object) -> a
    151:161:void lambda$_setPayload$0() -> c
    21:23:void <clinit>() -> <clinit>
neureka.autograd.JITProp -> neureka.autograd.JITProp:
    java.util.Set _finished -> a
    java.util.Set _pending -> b
    12:14:void <init>(java.util.Set) -> <init>
    21:23:void addPending(java.util.Set) -> addPending
    30:35:void noteFinished(neureka.autograd.GraphNode) -> noteFinished
    38:38:java.util.Set finished() -> finished
    45:53:void execute() -> execute
    60:60:boolean isDone() -> isDone
    46:51:void lambda$execute$0(neureka.autograd.GraphNode) -> a
neureka.autograd.PendingError -> neureka.autograd.PendingError:
    int _toBeReceived -> a
    neureka.Tsr _error -> b
    11:14:void <init>(neureka.Tsr,int) -> <init>
    17:21:void accumulate(neureka.Tsr) -> accumulate
    24:24:boolean isFullyAccumulated() -> isFullyAccumulated
    28:28:neureka.Tsr getAccumulatedError() -> getAccumulatedError
neureka.calculus.Function -> neureka.calculus.Function:
    neureka.calculus.environment.Cache CACHE -> CACHE
    neureka.calculus.Function X -> X
    neureka.calculus.Function PLUS -> PLUS
    neureka.calculus.Function PLUS_ASSIGN -> PLUS_ASSIGN
    neureka.calculus.Function MINUS -> MINUS
    neureka.calculus.Function MINUS_ASSIGN -> MINUS_ASSIGN
    neureka.calculus.Function DIV -> DIV
    neureka.calculus.Function DIV_ASSIGN -> DIV_ASSIGN
    neureka.calculus.Function POW -> POW
    neureka.calculus.Function POW_ASSIGN -> POW_ASSIGN
    neureka.calculus.Function MUL -> MUL
    neureka.calculus.Function MUL_ASSIGN -> MUL_ASSIGN
    neureka.calculus.Function MOD -> MOD
    neureka.calculus.Function MOD_ASSIGN -> MOD_ASSIGN
    neureka.calculus.Function NEG -> NEG
    35:35:neureka.calculus.Function create(java.lang.String) -> create
    39:39:neureka.calculus.Function create(java.lang.String,boolean) -> create
    neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    boolean doesAD() -> doesAD
    boolean isFlat() -> isFlat
    int id() -> id
    neureka.calculus.environment.OperationType type() -> type
    boolean dependsOn(int) -> dependsOn
    double activate(double) -> activate
    double activate(double[],int) -> activate
    double activate(double[]) -> activate
    double derive(double[],int,int) -> derive
    double derive(double[],int) -> derive
    neureka.Tsr activate(neureka.Tsr) -> activate
    neureka.Tsr activate(neureka.Tsr[],int) -> activate
    neureka.Tsr activate(neureka.Tsr[]) -> activate
    neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    neureka.Tsr derive(neureka.Tsr[],int) -> derive
    java.lang.String toString() -> toString
    neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    17:32:void <clinit>() -> <clinit>
neureka.calculus.Function$Setup -> neureka.calculus.Function$Setup:
    42:42:void <init>() -> <init>
    45:45:neureka.Tsr commit(neureka.Tsr[],java.lang.String,boolean) -> commit
    49:49:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],java.lang.String,boolean) -> commit
    53:53:neureka.Tsr commit(neureka.Tsr[],neureka.calculus.Function) -> commit
    57:57:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function) -> commit
    62:85:neureka.Tsr commit(neureka.Tsr,neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier) -> commit
    67:67:neureka.Tsr lambda$commit$0(neureka.Tsr) -> a
neureka.calculus.environment.Cache -> neureka.calculus.environment.Cache:
    neureka.calculus.environment.Cache _cache -> a
    java.util.Map FUNCTIONS -> b
    java.util.Map PROCESSING -> c
    15:30:void <init>() -> <init>
    18:20:neureka.calculus.environment.Cache instance() -> instance
    27:27:java.util.Map FUNCTIONS() -> FUNCTIONS
    34:36:void free(neureka.autograd.GraphLock) -> free
    40:74:neureka.Tsr preprocess(neureka.Tsr[],neureka.calculus.Function,java.util.function.Supplier,int,int) -> preprocess
    79:85:neureka.Tsr _get(neureka.autograd.GraphNode,int,int) -> a
    90:101:void _put(neureka.Tsr,neureka.autograd.GraphNode,int,int) -> a
    104:104:int _keyed(int) -> a
    94:94:int lambda$_put$2(java.lang.Long,java.lang.Long) -> a
    60:60:neureka.Tsr lambda$preprocess$1(neureka.Tsr) -> a
    30:30:int lambda$new$0(neureka.autograd.GraphLock,neureka.autograd.GraphLock) -> a
    13:13:void <clinit>() -> <clinit>
neureka.calculus.environment.OperationType -> neureka.calculus.environment.OperationType:
    java.util.Map _LOOKUP -> a
    java.util.ArrayList _REGISTER -> b
    int _ID -> c
    int _id -> _id
    java.lang.String _name -> _name
    java.lang.String _identifier -> _identifier
    boolean _isOperation -> _isOperation
    boolean _isIndexer -> _isIndexer
    boolean _isConvection -> _isConvection
    boolean _isCommutative -> _isCommutative
    boolean _isAssociative -> _isAssociative
    neureka.calculus.environment.Type$Activation _activation -> _activation
    neureka.calculus.environment.Type$Convolution _convolution -> _convolution
    neureka.calculus.environment.Type$Broadcast _broadcast -> _broadcast
    neureka.calculus.environment.Type$Scalarization _scalarization -> _scalarization
    neureka.calculus.environment.Type$Operation _operation -> _operation
    26:26:neureka.calculus.environment.OperationType instance(int) -> instance
    30:30:neureka.calculus.environment.OperationType instance(java.lang.String) -> instance
    92:124:void <init>(java.lang.String,java.lang.String,boolean,boolean,boolean,boolean,boolean,neureka.calculus.environment.Type$Activation,neureka.calculus.environment.Type$Scalarization,neureka.calculus.environment.Type$Convolution,neureka.calculus.environment.Type$Broadcast,neureka.calculus.environment.Type$Operation) -> <init>
    127:127:neureka.calculus.environment.OperationType[] ALL() -> ALL
    131:131:int COUNT() -> COUNT
    138:138:java.lang.String getName() -> getName
    145:145:neureka.calculus.environment.Type$Activation getActivation() -> getActivation
    150:150:boolean supportsActivation() -> supportsActivation
    157:157:neureka.calculus.environment.Type$Scalarization getScalarization() -> getScalarization
    162:162:boolean supportsScalar() -> supportsScalar
    169:169:neureka.calculus.environment.Type$Convolution getConvolution() -> getConvolution
    174:174:boolean supportsConvolution() -> supportsConvolution
    181:181:neureka.calculus.environment.Type$Broadcast getBroadcast() -> getBroadcast
    186:186:boolean supportsBroadcast() -> supportsBroadcast
    193:193:neureka.calculus.environment.Type$Operation getOperation() -> getOperation
    198:198:boolean supportsOperation() -> supportsOperation
    205:205:int id() -> id
    210:210:java.lang.String identifier() -> identifier
    216:216:boolean isOperation() -> isOperation
    221:221:boolean isIndexer() -> isIndexer
    226:226:boolean isConvection() -> isConvection
    231:231:boolean isCommutative() -> isCommutative
    237:246:boolean allowsForward(neureka.Tsr[]) -> allowsForward
    255:288:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    291:291:neureka.Tsr lambda$getADAgentOf$10(neureka.autograd.GraphNode,neureka.Tsr) -> a
    290:290:neureka.Tsr lambda$getADAgentOf$9(neureka.autograd.GraphNode,neureka.Tsr) -> b
    289:289:neureka.Tsr lambda$getADAgentOf$8() -> a
    284:284:neureka.Tsr lambda$getADAgentOf$7(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> a
    283:283:neureka.Tsr lambda$getADAgentOf$6(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> b
    282:282:neureka.Tsr lambda$getADAgentOf$5(neureka.Tsr) -> a
    271:271:neureka.Tsr lambda$getADAgentOf$4(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> c
    270:270:neureka.Tsr lambda$getADAgentOf$3(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> d
    269:269:neureka.Tsr lambda$getADAgentOf$2(neureka.Tsr) -> b
    261:261:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.Tsr,neureka.autograd.GraphNode,neureka.Tsr) -> e
    260:260:neureka.Tsr lambda$getADAgentOf$0(neureka.Tsr) -> c
    21:76:void <clinit>() -> <clinit>
neureka.calculus.environment.Type -> neureka.calculus.environment.Type:
    neureka.calculus.environment.Type$Activation getActivation() -> getActivation
    boolean supportsActivation() -> supportsActivation
    neureka.calculus.environment.Type$Scalarization getScalarization() -> getScalarization
    boolean supportsScalar() -> supportsScalar
    neureka.calculus.environment.Type$Convolution getConvolution() -> getConvolution
    boolean supportsConvolution() -> supportsConvolution
    neureka.calculus.environment.Type$Broadcast getBroadcast() -> getBroadcast
    boolean supportsBroadcast() -> supportsBroadcast
    neureka.calculus.environment.Type$Operation getOperation() -> getOperation
    boolean supportsOperation() -> supportsOperation
    java.lang.String getName() -> getName
    int id() -> id
    java.lang.String identifier() -> identifier
    boolean isOperation() -> isOperation
    boolean isIndexer() -> isIndexer
    boolean isConvection() -> isConvection
    boolean isCommutative() -> isCommutative
    boolean allowsForward(neureka.Tsr[]) -> allowsForward
    neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
neureka.calculus.environment.Type$Activation -> neureka.calculus.environment.Type$Activation:
    47:48:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$Broadcast -> neureka.calculus.environment.Type$Broadcast:
    61:62:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$Convolution -> neureka.calculus.environment.Type$Convolution:
    54:55:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$DefaultOperator -> neureka.calculus.environment.Type$DefaultOperator:
    double execute(int[],int[],int[]) -> execute
neureka.calculus.environment.Type$Operation -> neureka.calculus.environment.Type$Operation:
    75:76:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$OperatorCreator) -> <init>
neureka.calculus.environment.Type$OperatorCreator -> neureka.calculus.environment.Type$OperatorCreator:
    neureka.calculus.environment.Type$DefaultOperator create(neureka.Tsr[],int) -> create
neureka.calculus.environment.Type$ScalarOperatorCreator -> neureka.calculus.environment.Type$ScalarOperatorCreator:
    neureka.calculus.environment.Type$DefaultOperator create(neureka.Tsr[],double,int) -> create
neureka.calculus.environment.Type$Scalarization -> neureka.calculus.environment.Type$Scalarization:
    68:69:void <init>(java.lang.String,java.lang.String,neureka.calculus.environment.Type$ScalarOperatorCreator) -> <init>
neureka.calculus.environment.Type$TypeComponent -> neureka.calculus.environment.Type$TypeComponent:
    java.lang.String _operation -> _operation
    java.lang.String _deriviation -> _deriviation
    java.lang.Object _creator -> _creator
    26:30:void <init>(java.lang.String,java.lang.String,java.lang.Object) -> <init>
    32:32:java.lang.String getAsString() -> getAsString
    35:35:java.lang.String getDeriviationAsString() -> getDeriviationAsString
    38:38:java.lang.Object getCreator() -> getCreator
neureka.calculus.environment.implementations.function.Absolute -> neureka.calculus.environment.implementations.function.Absolute:
    9:27:void <init>() -> <init>
    14:18:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    18:18:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:16:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Cosinus -> neureka.calculus.environment.implementations.function.Cosinus:
    9:25:void <init>() -> <init>
    14:16:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    16:16:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    15:15:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Gaussian -> neureka.calculus.environment.implementations.function.Gaussian:
    9:37:void <init>() -> <init>
    20:24:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    25:26:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Identity -> neureka.calculus.environment.implementations.function.Identity:
    9:25:void <init>() -> <init>
    13:15:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    15:15:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    14:14:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Ligmoid -> neureka.calculus.environment.implementations.function.Ligmoid:
    9:40:void <init>() -> <init>
    30:32:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    32:32:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    31:31:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Quadratic -> neureka.calculus.environment.implementations.function.Quadratic:
    9:35:void <init>() -> <init>
    21:27:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    27:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.ReLU -> neureka.calculus.environment.implementations.function.ReLU:
    8:41:void <init>() -> <init>
    21:28:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    29:30:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    24:25:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sigmoid -> neureka.calculus.environment.implementations.function.Sigmoid:
    9:38:void <init>() -> <init>
    21:25:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    26:27:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    23:23:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Sinus -> neureka.calculus.environment.implementations.function.Sinus:
    9:25:void <init>() -> <init>
    15:17:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    17:17:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:16:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.function.Tanh -> neureka.calculus.environment.implementations.function.Tanh:
    8:31:void <init>() -> <init>
    13:20:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    21:22:double lambda$new$1(double[],neureka.Tsr[],int[],int[],int[]) -> a
    16:17:double lambda$new$0(double[],neureka.Tsr[],int[],int[],int[]) -> b
neureka.calculus.environment.implementations.indexer.Product -> neureka.calculus.environment.implementations.indexer.Product:
    8:35:void <init>() -> <init>
    19:24:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    25:26:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.indexer.Summation -> neureka.calculus.environment.implementations.indexer.Summation:
    8:29:void <init>() -> <init>
    19:24:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    24:24:double lambda$new$1(int[],int[],int[]) -> a
    22:22:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.operator.Addition -> neureka.calculus.environment.implementations.operator.Addition:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    neureka.calculus.environment.Type$Broadcast _broadcast -> b
    26:96:void <init>() -> <init>
    35:37:neureka.calculus.environment.Type$DefaultOperator lambda$new$5(neureka.Tsr[],double,int) -> a
    37:37:double lambda$new$4(int[],int[],int[]) -> a
    36:36:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:14:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    14:14:double lambda$static$1(int[],int[],int[]) -> b
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:18:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Division -> neureka.calculus.environment.implementations.operator.Division:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    26:103:void <init>() -> <init>
    37:42:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    42:42:double lambda$new$5(double,double[],neureka.Tsr[],int[],int[],int[]) -> a
    41:41:double lambda$new$4(double,int[],int[],int[]) -> a
    39:39:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:14:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    15:18:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:7:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Modulo -> neureka.calculus.environment.implementations.operator.Modulo:
    9:46:void <init>() -> <init>
    18:23:neureka.calculus.environment.Type$DefaultOperator lambda$new$2(neureka.Tsr[],int) -> a
    24:30:double lambda$new$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    21:21:double lambda$new$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
neureka.calculus.environment.implementations.operator.Multiplication -> neureka.calculus.environment.implementations.operator.Multiplication:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    24:129:void <init>() -> <init>
    89:94:neureka.calculus.environment.Type$DefaultOperator lambda$new$11(neureka.Tsr[],int) -> a
    95:96:double lambda$new$10(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    92:92:double lambda$new$9(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    53:55:neureka.calculus.environment.Type$DefaultOperator lambda$new$8(neureka.Tsr[],int) -> b
    55:55:double lambda$new$7(double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    31:36:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    36:36:double lambda$new$5(double[],neureka.Tsr[],int[],int[],int[]) -> a
    35:35:double lambda$new$4(double,int[],int[],int[]) -> a
    33:33:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    10:15:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> c
    16:17:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> b
    13:13:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> c
    8:8:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Power -> neureka.calculus.environment.implementations.operator.Power:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    33:116:void <init>() -> <init>
    42:49:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    49:49:double lambda$new$5(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    47:47:double lambda$new$4(double,double[],neureka.Tsr[],int[],int[],int[]) -> a
    44:44:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> b
    9:14:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    15:25:double lambda$static$1(int,double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    12:12:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    8:8:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.operator.Subtraction -> neureka.calculus.environment.implementations.operator.Subtraction:
    neureka.calculus.environment.Type$OperatorCreator _creator -> a
    24:91:void <init>() -> <init>
    35:40:neureka.calculus.environment.Type$DefaultOperator lambda$new$6(neureka.Tsr[],double,int) -> a
    40:40:double lambda$new$5(int[],int[],int[]) -> a
    39:39:double lambda$new$4(int[],int[],int[]) -> b
    37:37:double lambda$new$3(double[],neureka.Tsr[],double,int[],int[],int[]) -> a
    9:16:neureka.calculus.environment.Type$DefaultOperator lambda$static$2(neureka.Tsr[],int) -> a
    17:17:double lambda$static$1(int,int[],int[],int[]) -> a
    13:13:double lambda$static$0(double[],neureka.Tsr[],double[],int[],int[],int[]) -> a
    7:7:void <clinit>() -> <clinit>
neureka.calculus.environment.implementations.other.CopyLeft -> neureka.calculus.environment.implementations.other.CopyLeft:
    9:14:void <init>() -> <init>
neureka.calculus.environment.implementations.other.CopyRight -> neureka.calculus.environment.implementations.other.CopyRight:
    8:11:void <init>() -> <init>
neureka.calculus.environment.implementations.other.Randomization -> neureka.calculus.environment.implementations.other.Randomization:
    12:33:void <init>() -> <init>
    22:25:neureka.calculus.environment.Type$DefaultOperator lambda$new$1(neureka.Tsr[],double,int) -> a
    25:25:double lambda$new$0(java.util.Random,int[],int[],int[]) -> a
neureka.calculus.environment.implementations.other.Reshape -> neureka.calculus.environment.implementations.other.Reshape:
    13:18:void <init>() -> <init>
    22:25:neureka.autograd.ADAgent getADAgentOf(neureka.calculus.Function,neureka.Tsr[],int,boolean) -> getADAgentOf
    28:28:neureka.Tsr lambda$getADAgentOf$2(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> a
    27:27:neureka.Tsr lambda$getADAgentOf$1(neureka.calculus.Function,neureka.autograd.GraphNode,neureka.Tsr) -> b
    26:26:neureka.Tsr lambda$getADAgentOf$0() -> a
neureka.calculus.factory.AbstractFunction -> neureka.calculus.factory.AbstractFunction:
    neureka.calculus.environment.OperationType _type -> a
    boolean _isFlat -> b
    boolean _doAD -> c
    java.util.ArrayList _src -> d
    30:35:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    39:39:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    44:44:boolean isFlat() -> isFlat
    49:49:boolean doesAD() -> doesAD
    54:54:int id() -> id
    59:59:neureka.calculus.environment.OperationType type() -> type
    64:96:java.lang.String toString() -> toString
    101:104:boolean dependsOn(int) -> dependsOn
    110:110:neureka.Tsr activate(neureka.Tsr) -> activate
    116:116:double activate(double) -> activate
    123:123:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
    135:145:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int) -> _tensor_activation
    1287:1290:neureka.acceleration.Device _device(neureka.Tsr[]):287:290 -> _tensor_activation
    1287:1290:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):135 -> _tensor_activation
    1318:1333:boolean _shareGuestDevice(neureka.Tsr[]):318:333 -> _tensor_activation
    1318:1333:neureka.acceleration.Device _device(neureka.Tsr[]):288 -> _tensor_activation
    1318:1333:neureka.Tsr _tensor_activation(neureka.Tsr[],int,int):135 -> _tensor_activation
    151:191:neureka.Tsr _recursie_breakdown_execution(neureka.Tsr[],int,int,neureka.acceleration.Device) -> a
    196:269:neureka.Tsr _execution(neureka.Tsr[],int,int,neureka.acceleration.Device) -> b
    273:283:neureka.Tsr _apply(neureka.acceleration.Device,int,java.util.function.Supplier) -> a
    294:314:neureka.Tsr[] _src_acti(neureka.Tsr[],int,int,int) -> a
    338:360:double _scalar_activation(double,boolean) -> _scalar_activation
    366:386:double _scalar_activation(double[],int,int) -> _scalar_activation
    191:191:neureka.Tsr lambda$_recursie_breakdown_execution$2(neureka.Tsr[],int,int,neureka.acceleration.Device) -> c
    143:143:neureka.Tsr lambda$_tensor_activation$1(neureka.Tsr[],int,int,neureka.acceleration.Device) -> d
    138:138:neureka.Tsr lambda$_tensor_activation$0(neureka.Tsr[],int,int,neureka.acceleration.Device) -> e
neureka.calculus.factory.AbstractFunction$Exec -> neureka.calculus.factory.AbstractFunction$Exec:
    390:390:void <init>() -> <init>
    396:403:double reLu(double,boolean) -> reLu
    410:413:double sigmoid(double,boolean) -> sigmoid
    420:423:double tanh(double,boolean) -> tanh
    430:431:double quadratic(double,boolean) -> quadratic
    437:438:double ligmoid(double,boolean) -> ligmoid
    444:445:double linear(double,boolean) -> linear
    451:452:double gaussian(double,boolean) -> gaussian
    458:459:double absolute(double,boolean) -> absolute
    465:466:double sinus(double,boolean) -> sinus
    472:473:double cosinus(double,boolean) -> cosinus
    479:491:double summation(double[],int,int,java.util.ArrayList) -> a
    496:518:double summation(double[],int,java.util.ArrayList) -> a
    526:545:double PI(double[],int,int,java.util.ArrayList) -> b
    551:572:double PI(double[],int,java.util.ArrayList) -> b
    582:603:double power(double[],int,int,java.util.ArrayList) -> c
    609:634:double power(double[],int,java.util.ArrayList) -> c
    641:658:double division(double[],int,int,java.util.ArrayList) -> d
    664:685:double division(double[],int,java.util.ArrayList) -> d
    692:710:double multiplication(double[],int,int,java.util.ArrayList) -> e
    716:734:double multiplication(double[],int,java.util.ArrayList) -> e
    753:761:double modulo(double[],int,int,java.util.ArrayList) -> f
    767:775:double modulo(double[],int,java.util.ArrayList) -> f
    782:798:double subtraction(double[],int,int,java.util.ArrayList) -> g
    804:820:double subtraction(double[],int,java.util.ArrayList) -> g
    827:839:double addition(double[],int,int,java.util.ArrayList) -> h
    845:857:double addition(double[],int,java.util.ArrayList) -> h
neureka.calculus.factory.assembly.FunctionBuilder -> neureka.calculus.factory.assembly.FunctionBuilder:
    10:10:void <init>() -> <init>
    19:35:neureka.calculus.Function build(neureka.calculus.environment.OperationType,int,boolean) -> build
    46:58:neureka.calculus.Function build(java.lang.String,boolean) -> build
    1067:1258:neureka.calculus.Function _build(java.lang.String,boolean):67:258 -> build
    1067:1258:neureka.calculus.Function build(java.lang.String,boolean):54 -> build
    268:275:java.util.List _rebindPairwise(java.util.List,int) -> a
neureka.calculus.factory.assembly.FunctionConstructor -> neureka.calculus.factory.assembly.FunctionConstructor:
    12:12:void <init>() -> <init>
    16:59:neureka.calculus.Function construct(int,java.util.ArrayList,boolean) -> construct
neureka.calculus.factory.assembly.FunctionConstructor$1 -> neureka.calculus.factory.assembly.FunctionConstructor$1:
    java.util.ArrayList val$sources -> a
    21:21:void <init>(int,boolean,java.util.ArrayList,boolean,java.util.ArrayList) -> <init>
    24:24:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    28:28:neureka.Tsr activate(neureka.Tsr[]) -> activate
    32:32:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    36:36:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    41:41:double activate(double[],int) -> activate
    45:45:double activate(double[]) -> activate
    49:50:double derive(double[],int,int) -> derive
    54:55:double derive(double[],int) -> derive
    28:28:neureka.Tsr lambda$activate$1(java.util.ArrayList,neureka.Tsr[]) -> a
    24:24:neureka.Tsr lambda$activate$0(java.util.ArrayList,neureka.Tsr[],int) -> a
neureka.calculus.factory.assembly.FunctionConstructor$2 -> neureka.calculus.factory.assembly.FunctionConstructor$2:
    59:59:void <init>(int,boolean,java.util.ArrayList,boolean) -> <init>
    62:62:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    66:66:neureka.Tsr activate(neureka.Tsr[]) -> activate
    70:70:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    74:74:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    79:79:double activate(double[],int) -> activate
    83:83:double activate(double[]) -> activate
    87:87:double derive(double[],int,int) -> derive
    91:91:double derive(double[],int) -> derive
    74:74:neureka.Tsr lambda$derive$3(neureka.Tsr[],int) -> a
    70:70:neureka.Tsr lambda$derive$2(neureka.Tsr[],int,int) -> a
    66:66:neureka.Tsr lambda$activate$1(neureka.Tsr[]) -> a
    62:62:neureka.Tsr lambda$activate$0(neureka.Tsr[],int) -> b
neureka.calculus.factory.assembly.FunctionParser -> neureka.calculus.factory.assembly.FunctionParser:
    10:10:void <init>() -> <init>
    12:18:int numberOfOperationsWithin(java.util.List) -> numberOfOperationsWithin
    22:32:java.lang.String parsedOperation(java.lang.String,int) -> parsedOperation
    36:62:java.lang.String parsedComponent(java.lang.String,int) -> parsedComponent
    66:69:boolean containsOperation(java.lang.String,java.util.List) -> containsOperation
    73:74:boolean isBasicOperation(java.lang.String) -> isBasicOperation
    78:89:java.lang.String groupBy(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> groupBy
    93:93:boolean isWeired(char) -> a
    98:102:java.lang.String removeHeadAndTail(java.lang.String) -> removeHeadAndTail
    106:153:java.lang.String cleanedHeadAndTail(java.lang.String) -> cleanedHeadAndTail
    157:207:java.lang.String unpackAndCorrect(java.lang.String) -> unpackAndCorrect
    211:222:java.lang.String assumptionBasedOn(java.lang.String) -> assumptionBasedOn
    226:241:double similarity(java.lang.String,java.lang.String) -> similarity
neureka.calculus.factory.components.FunctionConstant -> neureka.calculus.factory.components.FunctionConstant:
    double _value -> a
    8:8:void <init>() -> <init>
    12:12:double value() -> value
    17:17:boolean isFlat() -> isFlat
    22:22:boolean doesAD() -> doesAD
    27:27:int id() -> id
    32:32:neureka.calculus.environment.OperationType type() -> type
    37:37:boolean dependsOn(int) -> dependsOn
    43:56:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    62:62:double activate(double) -> activate
    67:67:double activate(double[],int) -> activate
    72:72:double activate(double[]) -> activate
    77:77:double derive(double[],int) -> derive
    82:82:double derive(double[],int,int) -> derive
    89:89:neureka.Tsr activate(neureka.Tsr) -> activate
    94:94:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    99:99:neureka.Tsr activate(neureka.Tsr[]) -> activate
    104:104:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    109:109:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    115:115:java.lang.String toString() -> toString
    121:121:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionInput -> neureka.calculus.factory.components.FunctionInput:
    int _index -> a
    10:10:void <init>() -> <init>
    15:15:boolean providesGradient() -> providesGradient
    20:20:boolean isFlat() -> isFlat
    25:25:boolean doesAD() -> doesAD
    30:30:int id() -> id
    35:35:neureka.calculus.environment.OperationType type() -> type
    40:40:boolean dependsOn(int) -> dependsOn
    47:67:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    72:82:neureka.Tsr _extract(neureka.Tsr) -> a
    89:89:double activate(double) -> activate
    94:94:double activate(double[],int) -> activate
    99:99:double activate(double[]) -> activate
    104:104:double derive(double[],int) -> derive
    109:109:double derive(double[],int,int) -> derive
    116:116:neureka.Tsr activate(neureka.Tsr) -> activate
    121:121:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    126:126:neureka.Tsr activate(neureka.Tsr[]) -> activate
    131:131:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    136:138:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    145:145:java.lang.String toString() -> toString
    149:149:int index() -> index
    154:154:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.FunctionVariable -> neureka.calculus.factory.components.FunctionVariable:
    boolean _providesGradient -> a
    9:11:void <init>() -> <init>
    14:14:boolean providesGradient() -> providesGradient
    19:19:boolean isFlat() -> isFlat
    24:24:boolean doesAD() -> doesAD
    29:29:int id() -> id
    34:34:neureka.calculus.environment.OperationType type() -> type
    39:39:boolean dependsOn(int) -> dependsOn
    45:46:neureka.calculus.Function newBuild(java.lang.String) -> newBuild
    53:53:double activate(double) -> activate
    58:58:double activate(double[],int) -> activate
    63:65:double activate(double[]) -> activate
    70:70:double derive(double[],int) -> derive
    75:76:double derive(double[],int,int) -> derive
    82:82:neureka.Tsr activate(neureka.Tsr) -> activate
    87:87:neureka.Tsr activate(neureka.Tsr[],int) -> activate
    92:94:neureka.Tsr activate(neureka.Tsr[]) -> activate
    99:99:neureka.Tsr derive(neureka.Tsr[],int,int) -> derive
    104:104:neureka.Tsr derive(neureka.Tsr[],int) -> derive
    111:111:java.lang.String toString() -> toString
    116:116:neureka.autograd.ADAgent getADAgent(neureka.Tsr[],int,boolean) -> getADAgent
neureka.calculus.factory.components.GradientProvider -> neureka.calculus.factory.components.GradientProvider:
    boolean providesGradient() -> providesGradient
neureka.framing.IndexAlias -> neureka.framing.IndexAlias:
    java.util.Map _mapping -> a
    12:22:void <init>(java.util.List) -> <init>
    24:27:void <init>(int) -> <init>
    29:42:void <init>(java.util.Map,neureka.Tsr) -> <init>
    45:45:int[] get(java.util.List) -> get
    49:60:int[] get(java.lang.Object[]) -> get
    65:67:int get(java.lang.Object,java.lang.Object) -> get
    72:75:void replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    78:84:void _initializeIdxmap(java.lang.Object,int,java.lang.Object,int) -> a
    88:91:void set(java.lang.Object,java.lang.Object,int) -> set
    95:99:java.util.List keysOf(java.lang.Object) -> keysOf
    103:107:java.util.List keysOf(java.lang.Object,int) -> keysOf
    111:119:java.lang.String _fixed(java.lang.String,int) -> a
    125:187:java.lang.String toString() -> toString
    158:173:void lambda$toString$6(java.lang.Object[],int[],java.lang.StringBuilder,int[],java.lang.Object,java.lang.Object) -> a
    161:162:void lambda$toString$5(int[],java.lang.Object[],java.lang.Object,java.lang.Integer) -> a
    140:146:void lambda$toString$4(int[],int[],java.lang.StringBuilder,java.lang.Object,java.lang.Object) -> a
    133:133:java.lang.Boolean lambda$toString$3(int,int,java.lang.Integer) -> a
    105:105:void lambda$keysOf$2(int,java.util.List,java.lang.Object,java.lang.Integer) -> a
    97:97:void lambda$keysOf$1(java.util.List,java.lang.Object,java.lang.Integer) -> a
    33:41:void lambda$new$0(neureka.Tsr,int[],java.lang.Object,java.util.List) -> a
neureka.framing.Relation -> neureka.framing.Relation:
    neureka.Tsr _parent -> a
    java.lang.ref.WeakReference[] _children -> b
    9:9:void <init>() -> <init>
    17:34:void update(neureka.Tsr,neureka.Tsr) -> update
    38:39:neureka.framing.Relation addParent(neureka.Tsr) -> addParent
    43:53:neureka.framing.Relation addChild(neureka.Tsr) -> addChild
    57:67:neureka.framing.Relation foreachChild(java.util.function.Consumer) -> foreachChild
    71:71:boolean hasParent() -> hasParent
    75:75:boolean hasChildren() -> hasChildren
    79:79:int childCount() -> childCount
    9:9:void update(java.lang.Object,java.lang.Object) -> update
neureka.optimization.Optimizer -> neureka.optimization.Optimizer:
    void optimize() -> optimize
neureka.optimization.implementations.ADAM -> neureka.optimization.implementations.ADAM:
    neureka.Tsr m -> a
    neureka.Tsr v -> b
    53:54:void optimize() -> optimize
    1031:1049:void _optimize():31:49 -> optimize
    1031:1049:void optimize():53 -> optimize
neureka.optimization.implementations.Template -> neureka.optimization.implementations.Template:
    6:6:void <init>() -> <init>
neureka.utility.DataHelper -> neureka.utility.DataHelper:
    5:5:void <init>() -> <init>
    9:9:double[] newSeededDoubleArray(java.lang.String,int) -> newSeededDoubleArray
    13:13:double[] newSeededDoubleArray(long,int) -> newSeededDoubleArray
    17:17:double[] seededDoubleArray(double[],java.lang.String) -> seededDoubleArray
    21:24:double[] seededDoubleArray(double[],long) -> seededDoubleArray
    28:28:float[] newSeededFloatArray(java.lang.String,int) -> newSeededFloatArray
    32:32:float[] newSeededFloatArray(long,int) -> newSeededFloatArray
    36:36:float[] seededFloatArray(float[],java.lang.String) -> seededFloatArray
    40:43:float[] seededFloatArray(float[],long) -> seededFloatArray
    48:51:long _longStringHash(java.lang.String) -> a
    55:58:float[] doubleToFloat(double[]) -> doubleToFloat
    62:65:double[] floatToDouble(float[]) -> floatToDouble
