

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'net.sf.proguard:proguard-gradle:6.2.2'
    }
}

//-----------------------------------------------------------------

plugins {
    id 'java'
    id 'jacoco'
    id 'idea'
    id 'groovy'
    //Public deployment:
    id 'java-library'
    id 'maven-publish'
    id 'signing'
}

String PROJECT = "neureka"
String VERSION = "0.0.0"
String GROUPID = "com.github.gleethos"

//----------------------------------------------------------------------------------------------------------------------
// UTILITY LAMBDAS:
def change = { c -> new Object() {
            def between = { String a, String b -> new Object() {
                    def inFile = { String p, boolean unchanged=false ->
                        File file = new File("$rootDir" + p)
                        if(!file.exists()) return
                        String[] parts = file.text.split(a)
                        if(parts.length<2) assert false
                        String[] tails = parts[1].split(b)
                        if(!unchanged) file.write(parts[0] + a.replace("\\", "") + c(tails[0]) + b.replace("\\", "") + ((tails.length>1)?tails[1]:""))
                    }
                }
            }
        }
    }
def getBetween = {String a, String b -> new Object(){
        def inFile = { String p ->
            def result = ['']
            change({s->result[0] = s}).between(a, b).inFile(p, true)
            return result[0]
        }
    }
}
//----------------------------------------------------------------------------------------------------------------------
// SETTING VERSION IN SRC AND PRODUCTION:

change({VERSION}).between("production/neureka-", "\\.jar\\)").inFile("/README.md")
change({VERSION}).between("return \"", "\"").inFile("/src/main/resources/library_settings.groovy")

group GROUPID
version VERSION

//----------------------------------------------------------------------------------------------------------------------
// SETTING JAVA VERSION AND DEPENDENCY SRC:

sourceCompatibility = JavaVersion.VERSION_11
targetCompatibility = JavaVersion.VERSION_11

repositories {
    mavenCentral()
    jcenter { url "http://jcenter.bintray.com/" }
}

//----------------------------------------------------------------------------------------------------------------------
// LISTING DEPENDENCIES AND CONFIGURE LIBRARY-PLUGIN:

dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.12'
    compile 'org.jetbrains:annotations:16.0.2'
    compile group: 'org.jocl', name: 'jocl', version: '2.0.2'
    compile group: 'org.codehaus.groovy', name: 'groovy', version: '3.0.0-rc-3'

    api 'org.codehaus.groovy:groovy:3.0.0-rc-3'
    implementation 'org.jocl:jocl:2.0.2'
}

//----------------------------------------------------------------------------------------------------------------------
// CONFIGURING TEST REPORTING:

jacoco {
    toolVersion = "0.8.5"
    reportsDir = file("docs/coverage")
}

jacocoTestReport {
    reports {
        xml.enabled true
        csv.enabled false
    }
}
check.dependsOn jacocoTestReport

//----------------------------------------------------------------------------------------------------------------------
// DEFINE LOCAL DEPLOYMENT TASKS:
jar {
    //destinationDirectory = file("$rootDir/build/libs")
    copy {
        from "$rootDir/build/libs/neureka-"+VERSION+".jar"
        into "$rootDir/production/lib"
    }
}


task ('proguard', type: proguard.gradle.ProGuardTask) {
    verbose
    //allowaccessmodification
    injars  'build/libs/'+PROJECT+'-'+VERSION+'.jar'
    outjars 'production/min-lib/'+PROJECT+'-min-'+VERSION+'.jar'
    // Automatically handle the Java version of this build.
    if (System.getProperty('java.version').startsWith('1.')) {// Before Java 9, the runtime classes were packaged in a single jar file.
        libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
    } else {// As of Java 9, the runtime classes are packaged in modular jmod files.
        libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
    }

    // Save the obfuscation mapping to a file, so we can de-obfuscate any stack
    // traces later on.
    printmapping 'production/min/'+PROJECT+'-min-'+VERSION+'.map'
    keepparameternames
    renamesourcefileattribute 'SourceFile'
    keepattributes 'Exceptions,InnerClasses,Signature,Deprecated,SourceFile,LineNumberTable,EnclosingMethod'
    keepattributes '*Annotation*' // Preserve all annotations.

    // Preserve all public classes, and their public and protected fields and methods.
    keep 'public class * { \
        public protected *; \
    }'

    // Preserve all .class method names.
    keepclassmembernames 'class * { \
        java.lang.Class class$(java.lang.String); \
        java.lang.Class class$(java.lang.String, boolean); \
    }'

    // Preserve all native method names and the names of their classes.
    keepclasseswithmembernames includedescriptorclasses: true, 'class * { \
        native <methods>; \
    }'

    // Preserve the special static methods that are required in all enumeration classes.
    keepclassmembers allowoptimization: true, 'enum * { \
        public static **[] values(); \
        public static ** valueOf(java.lang.String); \
    }'

    // Explicitly preserve all serialization members. The Serializable interface
    // is only a marker interface, so it wouldn't save them.
    // We could comment this out if neureka library doesn't use serialization.
    // If the code contains serializable classes that have to be backward
    // compatible -> refer to the manual.

    keepclassmembers 'class * implements java.io.Serializable { \
        static final long serialVersionUID; \
        static final java.io.ObjectStreamField[] serialPersistentFields; \
        private void writeObject(java.io.ObjectOutputStream); \
        private void readObject(java.io.ObjectInputStream); \
        java.lang.Object writeReplace(); \
        java.lang.Object readResolve(); \
    }'

    // Note: library may contain more items that need to be preserved;
    // typically classes that are dynamically created using Class.forName:

    // keep 'public class com.example.MyClass'
    // keep 'public interface com.example.MyInterface'
    // keep 'public class * implements com.example.MyInterface'

    keep 'class org.jocl.** { *; }'
    keep 'interface org.jocl.** { *; }'
    keep 'class org.jetbrains.** { *; }'
    keep 'interface org.jetbrains.** { *; }'
    keep 'class groovy.lang.** { *; }'
    keep 'interface groovy.lang.** { *; }'

    //keep 'class java.lang.** { *; }'
    //dontwarn 'java.**'

    dontwarn 'org.jocl.**'
    dontwarn 'org.codehaus.**'
    dontwarn 'groovy.lang.**'
    dontwarn 'org.jetbrains.**'
}

task deploy() {
    dependsOn 'assemble'
    //dependsOn 'check'
    dependsOn 'jar'
    dependsOn 'proguard'
}

//----------------------------------------------------------------------------------------------------------------------
// CONFIGURING MAVEN DEPLOYMENT:

task sourceJar(type: Jar) {
    println "sorcejar"
    classifier "sources"
    from sourceSets.main.allJava
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    println "javadoc..."
    classifier "javadoc"
    from javadoc.destinationDir
}

/*artifacts {
    archives jar
    archives sourceJar
    archives javadocJar
}*/

signing {//372447547E38B0A909776E4DD830DAE574A07986
    //def signingKey = findProperty("signingKey")
    //def signingPassword = findProperty("signingPassword")
    //useInMemoryPgpKeys(signingKey, signingPassword)
    //useGpgCmd()
    //sign publishing.publications.mavenJava
    println "signing..."
    sign configurations.archives
    //sign publishing.publications
    println "done!"

}

publishing {
    publications {
        mavenJava(MavenPublication) {
            pom.withXml {
                def root = asNode()
                root.dependencies.removeAll { dep ->
                    dep.scope == "test"
                }
                root.children().last() + {
                    resolveStrategy = Closure.DELEGATE_FIRST
                    name PROJECT
                    description = "A platform independent tensor library written in Java."
                    url "https://gleethos.github.io/"+PROJECT+"/index.html"
                    organization {
                        name 'com.github.gleethos'
                        url 'https://github.com/Gleethos'
                    }
                    issueManagement {
                        system 'Github'
                        url 'https://github.com/Gleethos/'+PROJECT+'/issues'
                    }
                    licenses {
                        license {
                            name "MIT License"
                            url "https://raw.githubusercontent.com/Gleethos/"+PROJECT+"/master/LICENSE"
                        }
                    }
                    developers {
                        developer {
                            id "Gleethos"
                            name "Daniel Nepp"
                            email "Gleethos@gmx.at"
                        }
                    }
                    scm {
                        url 'https://github.com/Gleethos/'+PROJECT+''
                        connection 'scm:git:git://github.com/Gleethos/'+PROJECT+'.git'
                        developerConnection 'scm:git:ssh://git@github.com:Gleethos/'+PROJECT+'.git'
                    }
                }
            }

            groupId GROUPID
            artifactId PROJECT
            version VERSION

            from components.java

            // create the sign pom artifact
            //This will create the previously configured pom file on the disk, sign it and create the signed artifact.
            /*
            pom.withXml {
                def pomFile = file("${project.buildDir}/generated-pom.xml")
                writeTo(pomFile)
                def pomAscFile = signing.sign(pomFile).signatureFiles[0]
                artifact(pomAscFile) {
                    classifier = null
                    extension = 'pom.asc'
                }
            }*/ create the signed artifacts

            //artifact
            artifact(sourceJar) {
                classifier = 'sources'
            }
            artifact(javadocJar) {
                classifier = 'javadoc'
            }
            /*
            //This will iterate through the signed files generated by the signing plugin and provide the artifacts for publishing.
            project.tasks.signArchives.signatureFiles.each {
                artifact(it) {
                    def matcher = it.file =~ /-(sources|javadoc)\.jar\.asc$/
                    if (matcher.find()) {
                        classifier = matcher.group(1)
                    } else {
                        classifier = null
                    }
                    extension = 'jar.asc'
                }
            }*/

        }
    }
    repositories {
        maven {
            def releasesRepoUrl = "$projectDir/production/lib"
            def snapshotsRepoUrl = "$projectDir/production/lib"
            url = version.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
            if (version.contains("min")) url = "$projectDir/production/min-lib"
            credentials {
                println getBetween("sonatypeUsername=", "\n").inFile("/.gradle/gradle.properties")
                println getBetween("sonatypePassword=", "\n").inFile("/.gradle/gradle.properties")
                username getBetween("sonatypeUsername=", "\n").inFile("/.gradle/gradle.properties")
                password getBetween("sonatypePassword=", "\n").inFile("/.gradle/gradle.properties")
            }
        }
    }
}


// Adding the dependency to the signArchives task for the publication tasks
// -> The tasks are called publishMavenJavaPublicationToMavenLocal and publishMavenJavaPublicationToMavenRepository
// as our Maven Publication is called MavenJava.
/*
model {
   tasks.generatePomFileForMavenJavaPublication {
       destination = file("$buildDir/generated-pom.xml")
   }
   tasks.publishMavenJavaPublicationToMavenLocal {
       dependsOn project.tasks.signArchives
   }
   tasks.publishMavenJavaPublicationToMavenRepository {
       dependsOn project.tasks.signArchives
   }
}*/

javadoc {
    destinationDir = new File("$projectDir/docs/jdocs")
    if(JavaVersion.current().isJava9Compatible()) {
        options.addBooleanOption('html5', true)
    }
}

//----------------------------------------------------------------------------------------------------------------------
// CONFIGURING TEST EXECUTION:
test {
    //filter { includeTestsMatching "*" }
    minHeapSize = "1g"
    maxHeapSize = "5g"
    maxParallelForks = Math.floor(1+(Runtime.runtime.availableProcessors().intdiv(2) ?: 1)/2)
}
//----------------------------------------------------------------------------------------------------------------------
// CONFIGURING JDOC GENERATION:

task createJDocs(type: Javadoc){
    destinationDir = new File("$projectDir/docs/jdocs")
    source = "$projectDir/src/main"
    //sourceSets.main.allJava
}